#include "stdafx.hpp"
#include "propertymodule.h"
#include "proclient_svr.h"
#include "protype.h"
#include "promessage_pb.hxx.pb.h"
#include "mapmessage_pb.hxx.pb.h"
#include "sceneobj_manager.h"
#include "mapobjmanager.h"
#include "sceneobj_manager_imp.h"
#include "mapmodule.h"
#include "friendmodule.h"
#include "taskmodule.h"
#include "friendmessage_pb.hxx.pb.h"
#include "chatmodule.h"
#include "teammodule.h"
#include "stallmodule.h"
#include "mailmodule.h"
#include "creature_refresher.h"
#include "timerinterface.h"
#include "timer_define.h"
#include "repetionmodule.h"
#include "ibstoremodule.h"
#include "servermessage_in.h"
#include "message_maker.h"
#include "logservertype.h"
#include "activitymodule.h"
#include "familymodule.h"
#include "familymessage_pb.hxx.pb.h"
#include "corpsmessage_pb.hxx.pb.h"
#include "gmmessage_pb.hxx.pb.h"
#include "command.h"
#include "activitymessag_pb.hxx.pb.h"
#include "entity_searcher_imp.h"
#include "property.h"
#include "corpsmodule.h"
#include "repetionmessage_pb.hxx.pb.h"
#include "familytype.h"
#include "gmmodule.h"
#include "logmodule.h"
#include "achievemodule.h"
#include "worldmodule.h"
#include "taskmanager.h"
#include "base.h"
#include "boursemodule.h"
#include "marriagemessage_pb.hxx.pb.h"
#include "marriagemodule.h"
#include "ActivityYqs.h"
#include "ActivityYqsCfg.h"
#include <fstream>
#include "timermanager.h"
#include "globalmodule.h"
using namespace std;

#ifdef LEAK_CHK_DEBUG_NEW
#include "debug_new.h"
#endif

char CPropertyModule::sModuleName[ NAME_LENGTH ] = "Property_1";
template<> CPropertyModule* CSingleton< CPropertyModule >::spSingleton = NULL;

CEntityResultList CPropertyModule::mResultList;
CEntityResultList CPropertyModule::mSingleList;

#define ATTACK_DISTANCE_REPAIR 1			// 攻击距离补偿

#define QUERY_PLAYER_NUMBER 15				//查询附近玩家


CPropertyModule::CPropertyModule( ) : CLogicModule( sModuleName )
{ 
	if ( mShmPtr->GetInitMode() == SHM_INIT )
	{
		mRecTimer =  3000;
		mStateTimer = 300;
		mAureoleTimer = 1000;
		mDaliyRefreshTimer = 60000;
		mPkTimer = 1000;
		mBorderMapID = 0;	
		mBorderPosX = 0;
		mBorderPosY = 0;
		mRelivePosition.initailize( );	
		InitDeleteList( );
		mLastWeeklyTimer = time(0);
		mLastDaylyTimer = time(0);
	}
	else
	{
		;
	}

}

CPropertyModule::~CPropertyModule()
{

}

void CPropertyModule::OnLaunchServer( )
{

	srand( time(NULL) );

	CItemRunTime::Initialize( );

	CCreatureRefresher* pCreaturRefresher = new CCreatureRefresher;
	LK_ASSERT( pCreaturRefresher != NULL, );

	OnLoadConfig();
}

void CPropertyModule::OnLoadConfig()
{
	// 日志
	PROPERTY_LOG* tpCfg = CSceneCfgManager::GetSingletonPtr()->GetProperty_log();
	if( tpCfg != NULL )
	{
		INIT_ROLLINGFILE_LOG( tpCfg->mIdentifier, tpCfg->mDirectory, (LogLevel)tpCfg->mPriority, tpCfg->mMaxfilesize, tpCfg->mMaxbackupindex );
	}

	// 加载客户端功能控制配置
	/*mClientCtrlData.LoadFromXml("../config/data/client_ctrl/SystemParam.xml");*/
	mClientCtrlData.LoadFromXml(CSceneLogic::GetSingleton().GetConfigDataFileNamePath(CSceneLogic::GetSingletonPtr()->GetGameID(),const_cast<char*>("client_ctrl/SystemParam.xml")));
	const char* pcConfigPath = CSceneLogic::GetSingleton().GetConfigDataFileNamePath(CSceneLogic::GetSingletonPtr()->GetGameID(),const_cast<char*>("client_ctrl/SystemParam.xml"));
	CSceneServer::GetSingleton().RegisterLoadConfigCallback(pcConfigPath, CPropertyModule::LoadClientCtrlConfigCallback);
}

// 退出服务器
void CPropertyModule::OnExitServer( )
{
	CItemRunTime::Finialize( );

	// 模板释放内存
	CDataStatic::Finialize( );


	CCreatureRefresher* pRefresher = CCreatureRefresher::GetSingletonPtr();
	if( pRefresher != NULL )
		delete pRefresher;
}

// 服务器Timer
void CPropertyModule::OnTimer( unsigned int vTickCount, unsigned int vTickOffset )
{
	// 200ms一次的计时器
	if ( mStateTimer.Elapse( vTickOffset ) == true )
	{
		// 要重新计算一次时间间隔，因为mStateTimer有误差并且会累积
		static unsigned int sLastTick200 = vTickCount;
		int tTickOffset = vTickCount - sLastTick200;
		sLastTick200 = vTickCount;

		CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp;

		for( CSceneObjManagerImp::ObjMng_EntityPedal::iterator tPedalIt = pSceneneObjManagerImp->mEntityPedalPool.begin( );
			tPedalIt != pSceneneObjManagerImp->mEntityPedalPool.end( );
			++tPedalIt 
			)
		{
			CEntityPedal* tpSrcEntity = &( *tPedalIt );
			CPropertyPedal* tpProPedal = ( CPropertyPedal* )tpSrcEntity->GetProperty();
			// 陷阱触发逻辑
			if ( tpSrcEntity->IsTouch( tTickOffset ) == true )
				continue;
			// 陷阱时间到了消失
			tpProPedal->IsDisappear( tpSrcEntity, tTickOffset );
			ResultListSend( );
		}
	}

	// 3秒钟一次的计时器
	if ( mRecTimer.Elapse( vTickOffset ) == true )
	{
		int TimeNow = time( NULL );
        CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp ;
 
        for( CSceneObjManagerImp::ObjMng_EntityPlayer::iterator tPlayerIt = pSceneneObjManagerImp->mEntityPlayerPool.begin( );
                tPlayerIt != pSceneneObjManagerImp->mEntityPlayerPool.end( );
                ++tPlayerIt
            )
        {
			CEntityPlayer* tpSrcEntity = &( *tPlayerIt );
			
			// 非常重要，ontimer只处理已经在场景中的玩家
			if( tpSrcEntity->GetCommState() != CEntityPlayer::STATE_INMAP ) 
			{
				continue;
			}

			CPropertyPlayer* tpProPlayer = ( CPropertyPlayer* )tpSrcEntity->GetProperty();

            // 检查玩家处于手动解除状态的物品是否到期
            tpProPlayer->CheckItemList( TimeNow );
			
			// 回血,回蓝
			tpProPlayer->RecTimeEvent( tpSrcEntity, mRecTimer.mMaxDuration );
		
			// 回AP
			RefreshApValue( tpSrcEntity );

			// 玩家pk值刷新
			RefreshPkValue( tpSrcEntity, mRecTimer.mMaxDuration );

			//每日计数刷新
			tpSrcEntity->DailyCountRefresh( CSceneLogic::GetSingletonPtr()->GetCurrentDay() );

			// 处理关闭对话框逻辑
			tpProPlayer->LogicTimeEvent( tpSrcEntity, mRecTimer.mMaxDuration );

			ResultListSend( );
		}

		for( CSceneObjManagerImp::ObjMng_EntityPet::iterator tPetIt = pSceneneObjManagerImp->mEntityPetPool.begin( );
				tPetIt != pSceneneObjManagerImp->mEntityPetPool.end( );
				++tPetIt 
			)
		{
			CEntityPet* tpSrcEntity = &( *tPetIt );
			CPropertyPet* tpPropertyPet = ( CPropertyPet* )tpSrcEntity->GetProperty();

			// 召唤兽恢复
            tpPropertyPet->RecTimeEvent( tpSrcEntity, mRecTimer.mMaxDuration );

			// 召唤兽升级
			SummonBeastLevelUp( (CEntity*)tpSrcEntity, mRecTimer.mMaxDuration );

			ResultListSend( );
		}

		// 执行延迟刷新
		CCreatureRefresher::GetSingletonPtr()->OnTimer( vTickCount, mRecTimer.mMaxDuration );
	}

	// 60秒一次的计时器
	if( mDaliyRefreshTimer.Elapse( vTickOffset ) == true )
	{
		// 怪物定时刷新
		CCreatureRefresher::GetSingletonPtr()->OnTimeRefreshEvent();
		
		CActivityModule::GetSingletonPtr()->CheckDoubleTime( );
		CActivityModule::GetSingletonPtr()->CheckNpcTime( );
	}
}


// 新一天到来
void CPropertyModule::OnNewDayCome( )
{
	CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp;
	for( CSceneObjManagerImp::ObjMng_EntityPlayer::iterator tPlayerIt = pSceneneObjManagerImp->mEntityPlayerPool.begin( ); 
		tPlayerIt != pSceneneObjManagerImp->mEntityPlayerPool.end( ); 
		++tPlayerIt 
		)
	{
		CEntityPlayer* tpSrcEntity = &( *tPlayerIt );

		// 非常重要，ontimer只处理已经在场景中的玩家
		if( tpSrcEntity->GetCommState() != CEntityPlayer::STATE_INMAP ) 
		{
			continue;
		}	

		DaylyDispose( tpSrcEntity, true );
		CPropertyPlayer* tpPro = (CPropertyPlayer*)tpSrcEntity->GetProperty();
		tpPro->SetLastDaylyDisposTime(time(0));

		// vip 权限有效期 可以容许24小时内误差, 就在这处理		
		RefreshVip( tpSrcEntity );

		CCreatorManager::GetSingleton().RefreshPedals( );
	}
}

// 新一周到来
void CPropertyModule::OnNewWeekCome( )
{
	CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp;
	for( CSceneObjManagerImp::ObjMng_EntityPlayer::iterator tPlayerIt = pSceneneObjManagerImp->mEntityPlayerPool.begin( ); 
		tPlayerIt != pSceneneObjManagerImp->mEntityPlayerPool.end( ); 
		++ tPlayerIt
		)
	{
		CEntityPlayer* tpSrcEntity = &( *tPlayerIt );

		// 非常重要，ontimer只处理已经在场景中的玩家
		if( tpSrcEntity->GetCommState() != CEntityPlayer::STATE_INMAP ) 
		{
			continue;
		}

		WeeklyDispose( tpSrcEntity, true );
		CPropertyPlayer* tpPro = (CPropertyPlayer*)tpSrcEntity->GetProperty();
		tpPro->SetLastWeeklyDisposTime(time(0));
	}
}

// 建立场景
int CPropertyModule::OnCreateMap( unsigned short vLineID, unsigned short vMapID, unsigned short vIndex, const char* pTplName )
{
	// 读取复活点坐标
	if ( mRelivePosition.find( vMapID ) != mRelivePosition.end( ) )
		return SUCCESS;
	char stfile[56] ={0};
	::sprintf(stfile,"scenetpl/%d.xml", vMapID);
	char tTplName[ 128 ] = { 0 };
	/*::sprintf( tTplName, "../config/data/scenetpl/%d.xml", vMapID );*/
	::sprintf( tTplName, CSceneLogic::GetSingleton().GetConfigDataFileNamePath(CSceneLogic::GetSingletonPtr()->GetGameID(),stfile ));
	TiXmlDocument tTplDoc;
	tTplDoc.LoadFile( tTplName );
	TiXmlElement* tpElement = tTplDoc.FirstChildElement( );
	if ( strcmp( tpElement->Value( ), "Scene_Conf" ) != 0 )
		return ERR_UNKNOWN;

	tpElement = tpElement->FirstChildElement( );
	for( ; tpElement != NULL; tpElement = tpElement->NextSiblingElement( ) )
	{
		std::string tEleName = tpElement->Value( );
		if ( tEleName != "Map" )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] map file error", __LK_FILE__, __LINE__, __FUNCTION__ );
			//printf( "地图文件有错误!\r\n" );
			return ERR_UNKNOWN;
		}

		const char* tpMapName	= tpElement->Attribute( "MapName" );
		const char* tpMapID		= tpElement->Attribute( "MapID" );
		if ( tpMapName == NULL || tpMapID == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] map file error", __LK_FILE__, __LINE__, __FUNCTION__ );
			//printf( "地图文件有错误!\r\n" );
			return ERR_UNKNOWN;
		}

		// 如果找到指定地图，加载该地图
		if ( ::atoi( tpMapID ) == vMapID )
		{
			TiXmlElement* tpMapEle = tpElement->FirstChildElement( );
			for( ; tpMapEle != NULL; tpMapEle = tpMapEle->NextSiblingElement( ) )
			{
				std::string tEleName = tpMapEle->Value( );
				if ( tEleName == "RelivePos" )
				{
					CRelivePosition* tpRelive = ( CRelivePosition* ) CSceneObjManager::GetSingletonPtr()->CreateObject( 
						OBJTYPE_RELIVEPOSITION );			
					LK_ASSERT( tpRelive != NULL, return ERR_UNKNOWN );

					const char* tpCX	= tpMapEle->Attribute( "x" );
					const char* tpCY	= tpMapEle->Attribute( "y" );
					const char* tpLineID	= tpMapEle->Attribute( "LineID" );
					const char* tpMapID	= tpMapEle->Attribute( "MapID" );
					const char* tpBorder= tpMapEle->Attribute( "Border" );
					if ( tpCX == NULL || tpCY == NULL || tpLineID == NULL || tpMapID == NULL || tpBorder == NULL )
					{
						LOG_ERROR( "pro", "[ %s : %d ] [ %s ] map file [ %s ] error!", __LK_FILE__, __LINE__, __FUNCTION__, tpMapName );
						CSceneObjManager::GetSingletonPtr()->DestroyObject( tpRelive->get_id() );
						return ERR_UNKNOWN;
					}

					tpRelive->mPosition.mX	= ::atoi( tpCX );
					tpRelive->mPosition.mY	= ::atoi( tpCY );
					tpRelive->mLineID	= ::atoi( tpLineID );
					tpRelive->mReliveMapID	= ::atoi( tpMapID );
					tpRelive->mMapID		= vMapID;

					// 如果是边境
					if ( ::atoi( tpBorder ) == 1 )
					{
						mBorderMapID = vMapID;
						mBorderPosX = tpRelive->mPosition.mX;
						mBorderPosY = tpRelive->mPosition.mY;
					}
					mRelivePosition.insert( std::pair< int, int >( vMapID, tpRelive->get_id() ) );
				}
			}
			
			return SUCCESS;
		}
	}

	return SUCCESS;
}

// 路由消息
void CPropertyModule::OnRouterMessage( CMessage* pMessage )
{
	const CMessageHead& tHead = pMessage->msghead( );

	switch( tHead.messageid( ) )
	{
		case ID_S2S_REQUEST_LOOKPROPERTY:
			{
				OnMessageLookPropertyRouterRequest( pMessage );
				break;
			}
		case ID_S2S_RESPONSE_LOOKPROPERTY:
			{
				OnMessageLookPropertyRouterResponse( pMessage );
				break;
			}
		case ID_S2S_REQUEST_USEFLOWER:
			{
				OnMessageS2SUseFlowerRequest( pMessage );
				break;
			}
		case ID_S2S_RESPONSE_USEFLOWER:
			{
				OnMessageS2SUseFlowerResponse( pMessage );
				break;
			}
		default:
			break;
	}
}

// PK模式判定
bool CPropertyModule::EntityPKValid(	CEntity* pSrcEntity, 
										CEntity* pDesEntity, 
										CTemplateSkill* pSkillTpl, 
										bool vIsSkill
									)
{
	//return true;
	if ( pSrcEntity == NULL || pDesEntity == NULL )
	{
		return false;
	}

	if (  pDesEntity->IsPedal()
		|| pDesEntity->IsItem() 
		|| pDesEntity->IsCollect() )
	{
		return false;
	}
	if ( pDesEntity->mHasCreated == false )
	{
		return false;
	}	

	if( pDesEntity->IsBlock( ) == true )
	{
		CTemplateBlock* tpBlock = ( CTemplateBlock* )CDataStatic::SearchTpl( pDesEntity->GetNpcID( ) );
		LK_ASSERT_STR( tpBlock != NULL, return false, "Template %d", pDesEntity->GetNpcID( ) );
		if( tpBlock->mSelect == CTemplateBlock::NO_SELECT )
		{
			// 不可以被攻击的阻挡
			return false;
		}
	}

	if ( pSrcEntity->IsOgre() || pSrcEntity->IsFunNpc() )
	{
		// 怪物,功能NPC可能会使用普攻,普通时pSkillTpl有可能为空
		if ( pSkillTpl == NULL )
		{
			// 特殊处理OGRE,如果pSkillTpl为NULL,则作为特殊攻击处理
			if ( pSrcEntity->IsHostileTo( pDesEntity ) == true )
				return true;
		} 
	}	

	// 技能的pSkillTpl不能为空
	if ( pSkillTpl == NULL && vIsSkill == true )
		return false;

	// 不是技能 (召唤兽会走到这里)
	if ( pSkillTpl == NULL && vIsSkill == false )
	{
		if ( pSrcEntity->IsHostileTo( pDesEntity ) == false )
		{
			return false;
		}
		else
		{
			// 如果被攻击的是人
			if( pDesEntity->IsPlayer() || pDesEntity->IsPet() )
			{
				if ( pDesEntity->IsPlayer() )
				{
					CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pDesEntity->GetProperty();
					// 摆摊不能被攻击
					if ( tpProperty->GetServiceStatus() == SERVICE_STALL ) 
					{
						return false;
					}
				}
				// 绝对安全区判断
				CMapTpl* tpTpl = CMapTplManager::GetSingletonPtr( )->GetMapTplByID( pSrcEntity->GetMapID( ) );
				if ( ( pSrcEntity->IsPlayer() || pSrcEntity->IsPet() || pSrcEntity->IsPedal() ) && tpTpl != NULL )
				{
					if ( tpTpl->mAbsSafe == 1 )
						return false;

					CMapObject* pCurMap = pDesEntity->GetMapObject();
					if ( pCurMap == NULL )
						return false;

					// 先判断绝对安全区域
					if( pCurMap->IsAbsSafeRegion( pDesEntity->GetPos() ) || pCurMap->IsAbsSafeRegion( pSrcEntity->GetPos() ) )
						return false;

					// 如果都是同国人，再判断相对安全区
					CEntity* pSrcOwner = pSrcEntity->GetOwner();
					if( pSrcOwner->IsPlayer() && ( pSrcOwner->GetNationality() == pDesEntity->GetNationality() ) )
					{
						if( pCurMap->IsCtrSafeRegion( pDesEntity->GetPos() ) || pCurMap->IsCtrSafeRegion( pSrcOwner->GetPos() ) )
							return false;
					}

					// 如果是本国保护区
					if ( pDesEntity->IsPlayer() )
					{
						CEntityPlayer *tpDesPlayer = (CEntityPlayer*)pDesEntity;
						if ( pSrcOwner->GetNationality() != pDesEntity->GetNationality() 
							&& pDesEntity->GetNationality() == CSceneLogic::GetSingleton().GetLineID()
							&& tpDesPlayer->GetLevel() < tpTpl->mProtectLevel
							&& tpDesPlayer->GetProtectStatus() == true )
						{
							return false;
						}
					}					
				}
			}
			return true;
		}
	}

	if ( pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_ATTACK
		|| pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_CUSS
		|| pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_NORMALATTACK
		|| pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_CONTINUEDATTACK
		|| pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_CONTINUEDCUSS
		|| pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_TRIP
		)
	{			
		if ( pDesEntity->IsAlive() == false )
			return false;
		
		if ( pSrcEntity->IsHostileTo( pDesEntity ) == false )
			return false;

#ifdef _FB_
		if ( pSrcEntity->IsCharacter() && pDesEntity->IsCharacter() )
		{
			if (  ( ( CEntityCharacter* )pSrcEntity )->GetCampID() 
				==  ( ( CEntityCharacter* )pDesEntity )->GetCampID() 
				&&  ( ( CEntityCharacter* )pSrcEntity )->GetCampID() != 0 )
			{
				return false;
			}
		}
#endif

		// 挂机模式不能打人
		if ( pSrcEntity->IsPlayer() && pDesEntity->IsPlayer() )
		{
			CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pSrcEntity->GetProperty();
			if ( tpProperty->GetAutoPlayFlag() == true )
			{
				return false;
			}
		}

		// 如果被攻击的是人
		if( pDesEntity->IsPlayer() || pDesEntity->IsPet() )
		{
			if ( pDesEntity->IsPlayer() )
			{
				CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pDesEntity->GetProperty();
				// 摆摊不能被攻击
				if ( tpProperty->GetServiceStatus() == SERVICE_STALL ) 
				{
					return false;
				}
			}
			// 绝对安全区判断
			CMapTpl* tpTpl = CMapTplManager::GetSingletonPtr( )->GetMapTplByID( pSrcEntity->GetMapID( ) );
			if ( ( pSrcEntity->IsPlayer( ) || pSrcEntity->IsPet() || pSrcEntity->IsPedal() ) && tpTpl != NULL )
			{
				if ( tpTpl->mAbsSafe == 1 )
					return false;
				
				CMapObject* pCurMap = pDesEntity->GetMapObject();
				if ( pCurMap == NULL )
					return false;
				
				// 先判断绝对安全区域
				if( pCurMap->IsAbsSafeRegion( pDesEntity->GetPos() ) || pCurMap->IsAbsSafeRegion( pSrcEntity->GetPos() ) )
					return false;

				// 如果都是同国人，再判断相对安全区
				CEntity* pSrcOwner = pSrcEntity->GetOwner();
				if( pSrcOwner->IsPlayer() && ( pSrcOwner->GetNationality() == pDesEntity->GetNationality() ) )
				{
					if( pCurMap->IsCtrSafeRegion( pDesEntity->GetPos() ) || pCurMap->IsCtrSafeRegion( pSrcOwner->GetPos() ) )
						return false;
				}
				// 如果是本国保护区
				if ( pDesEntity->IsPlayer() )
				{
					CEntityPlayer *tpDesPlayer = (CEntityPlayer*)pDesEntity;
					if ( pSrcOwner->GetNationality() != pDesEntity->GetNationality() 
						&& pDesEntity->GetNationality() == CSceneLogic::GetSingleton().GetLineID()
						&& tpDesPlayer->GetLevel() < tpTpl->mProtectLevel
						&& tpDesPlayer->GetProtectStatus() == true )
					{
						return false;
					}
				}
			}
		}
	}
	else if ( pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_BLESS
			|| pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_CONTINUEDBLESS )
	{

		if ( pDesEntity->IsAlive() == false )
			return false;
#ifdef _FB_
		if ( pSrcEntity->IsCharacter() && pDesEntity->IsCharacter() )
		{
			if (  ( ( CEntityCharacter* )pSrcEntity )->GetCampID() 
				!=  ( ( CEntityCharacter* )pDesEntity )->GetCampID() 
				&&  ( ( CEntityCharacter* )pSrcEntity )->GetCampID() != 0 )
			{
				return false;
			}
		}
#endif

		if ( pSrcEntity->IsFriendlyTo( pDesEntity ) == false )
			return false;
	}
	else if ( pSkillTpl->mSkillType == CTemplateSkill::SKILLTYPE_RELIVE )
	{
		if ( pDesEntity->GetEntityType() != ENTITYTYPE_PLAYER )
			return false;

		// 新加不同阵营不能复活
		if ( pSrcEntity->GetNationality() != pDesEntity->GetNationality() )
			return false;

		if ( pSrcEntity->IsFriendlyTo( pDesEntity ) == false )
			return false;
	}	

	if ( pSrcEntity->IsCharacter() && pDesEntity->IsCharacter() )
	{
		// 如果源和目标飞行状态不同，不能使用
		if ( ((CEntityCharacter*)pSrcEntity)->CanFly() != ((CEntityCharacter*)pDesEntity)->CanFly() )
		{
			return false;
		}
	}

	return true;
}

// 实体是否同一个国家的实体
bool CPropertyModule::EntityIsNative( CEntity* pSrcEntity, CEntity* pDesEntity )
{	
	LK_ASSERT( pSrcEntity != NULL && pDesEntity != NULL, return false );

	return pSrcEntity->GetNationality( ) == pDesEntity->GetNationality( );
}

// 实体是否同一个同盟国家的实体
bool CPropertyModule::EntityIsAlly( CEntity* pSrcEntity, CEntity* pDesEntity )
{
	LK_ASSERT( pSrcEntity != NULL && pDesEntity != NULL, return false );

	return pSrcEntity->GetNationality( ) == pDesEntity->GetNationality( );
}

// 实体删除所有负面BUFF
void CPropertyModule::EntityRemoveDebuff( CEntityCharacter* pEntity )
{
	LK_ASSERT( pEntity != NULL, return );
	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();
	CBuffList *tpBuff = pProperty->GetBuffList( );
	for ( int i = ( tpBuff->mBuffNumber - 1 ); i >= 0 && ( pEntity->IsAlive() == true ); i-- )
	{
		CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mBuffID );
		if ( tpBuffTpl == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) Remove DeBuff( %d ) Error, Cannt find Buff Template",
				__LK_FILE__, __LINE__, __FUNCTION__, pEntity->GetEntityID( ), tpBuff->mBuffList[ i ].mBuffID );
			continue;
		}
		// 如果是负面BUFF
		if ( tpBuffTpl->mBuffType == CTemplateBuff::BUFF_DEC )
		{
			if ( tpBuffTpl->mBuffClear == 0 )
			{
				// 删除当前BUFF,因为是从后往前遍历,所以这里可以在循环内部删除
				int tRtn = pEntity->EntityRemoveBuff( tpBuffTpl->mTempID, tpBuff->mBuffList[ i ].mListID );
				//LOG_NOTICE( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
				if( tRtn < 0 )
				{
					LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) RemoveBuff( %d ) Error, error code is %d", __LK_FILE__,
						__LINE__, __FUNCTION__, pEntity->GetEntityID( ), tpBuffTpl->mTempID );
				}
			}
		}
	}
}

// 实体清除BUFF ( vNum表示删除BUFF数量,如果为0,表示全部删除 0表示 ) (如果vBuffType=0 则表示全清)
void CPropertyModule::EntityClearbuff( CEntityCharacter* pEntity, int vNum, int vBuffType )
{
	LK_ASSERT( pEntity != NULL, return );
	int tClearNum = vNum;
	if ( tClearNum == 0 )
		tClearNum = -1;

	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();
	CBuffList *tpBuff = pProperty->GetBuffList( );
	for ( int i = ( tpBuff->mBuffNumber - 1 ); i >= 0 && ( pEntity->IsAlive() == true ); i-- )
	{
		CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mBuffID );
		if ( tpBuffTpl == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) Remove DeBuff( %d ) Error, Cannt find Buff Template",
				__LK_FILE__, __LINE__, __FUNCTION__, pEntity->GetEntityID( ), tpBuff->mBuffList[ i ].mBuffID );
			continue;
		}
		// 如果BUFF类型相同
		if ( (tpBuffTpl->mBuffType == vBuffType) || (vBuffType == 0) )
		{
			if ( tpBuffTpl->mBuffClear == CTemplateBuff::BUFF_CANCEL )
			{
				// 删除当前BUFF,因为是从后往前遍历,所以这里可以在循环内部删除
				int tRtn = pEntity->EntityRemoveBuff( tpBuffTpl->mTempID, tpBuff->mBuffList[ i ].mListID );
				//LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
				if( tRtn < 0 )
				{
					LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) RemoveBuff( %d ) Error, error code is %d", __LK_FILE__,
						__LINE__, __FUNCTION__, pEntity->GetEntityID( ), tpBuffTpl->mTempID );
				}
				if ( tClearNum > 0 )
					tClearNum--;
			}
		}
		if ( tClearNum == 0 )
			break;
	}
}

void CPropertyModule::PlayerCloseDialog( CEntityPlayer* pPlayer )
{
	CPropertyPlayer* tpProPlayer = ( CPropertyPlayer* ) pPlayer->GetProperty();	

	tpProPlayer->SetServiceStatus( SERVICE_NONE );
	tpProPlayer->SetTalkNpcEntityID( 0 );
}

// 玩家修改快捷栏
void CPropertyModule::PlayerSetShortcut( CEntityPlayer* pPlayer, unsigned int vShortcut, unsigned int vType, unsigned int vIndex, unsigned int vLabelType, unsigned int vLabelIndex, int nParam1 )
{
	if( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is Null", __LK_FILE__, __FILE__, __FUNCTION__ );
		return;
	}
	( (CPropertyPlayer*) ( pPlayer->GetProperty() ) )->GetShortcut( )->SetShortcut( vShortcut, vType, vIndex, vLabelType, vLabelIndex, nParam1 );
}

//***************************************
// Function Name : PlayerChangeMoney
// Description 	 : vMoney-金币改变量，vPayout: true-减少, false-增加
// Input Params  :
// Output Params :
// Return Type   :
// Modified Time : 2/20/2009
//***************************************

//void CPropertyModule::PlayerChangeMoney( CEntityPlayer* pPlayer, CPropertyPlayer* pProperty, unsigned int vMoney, bool vPayout )
//{
//	if( pPlayer == NULL || pProperty == NULL )
//	{
//		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	// 金钱无变化就不发消息通知客户端
//	if ( vMoney == 0 )
//	{
//		return ;
//	}
//
//	unsigned int tOldMoney = pProperty->GetMoney( );
//	// 防止金币溢出
//	if ( vPayout == false )
//		pProperty->SetMoney( pProperty->GetMoney( ) + min( (unsigned int) ( MONEY_LIMIT - pProperty->GetMoney( ) ), (unsigned int) vMoney ) );
//
//	// 防止金币溢出
//	if ( vPayout == true )
//		pProperty->SetMoney( max( (unsigned int)0, ( unsigned int )( pProperty->GetMoney( ) - vMoney ) ) );
//	
//
//	CTaskModule::GetSingleton().OnPlayerChangeMoney( pPlayer, pProperty );
//
//	SendUpdateMoneyNotice( pPlayer, ( pProperty->GetMoney( ) - tOldMoney ), pProperty->GetMoney( ) );
//}

//***************************************
// Function Name : PlayerChangeBindMoney
// Description 	 : vMoney-绑定金钱改变量，vPayout: true-减少, false-增加
// Input Params  :
// Output Params :
// Return Type   :
// Modified Time : 2/20/2009
//***************************************

//void CPropertyModule::PlayerChangeBindMoney(CEntityPlayer* pPlayer, CPropertyPlayer* pProperty, unsigned int vMoney, bool vPayout )
//{
//	LK_ASSERT( pPlayer != NULL && pProperty != NULL, return );
//
//	// 绑定金钱没改变
//	if ( vMoney == LK_ZERO )
//	{
//		return ;
//	}
//
//	unsigned int tMoney = 0, tOldMoney = pProperty->GetBindMoney();
//	if ( vPayout == true )
//	{
//		/*tMoney = max( (unsigned int) 0, ( pProperty->GetBindMoney() - vMoney ) );*/
//		if ( vMoney <= tOldMoney )
//		{
//			tMoney = max( (unsigned int) 0, ( pProperty->GetBindMoney() - vMoney ) );
//		}
//		else
//		{
//			unsigned int tLeftMoney = vMoney - tOldMoney;
//			tMoney = 0;
//			PlayerChangeMoney( pPlayer, pProperty, tLeftMoney, true );
//		}
//	}
//	else
//	{
//		tMoney = min( (unsigned int) MONEY_LIMIT, ( pProperty->GetBindMoney() + vMoney ) );
//	}
//
//	pProperty->SetBindMoney( tMoney );
//	int tVal = pProperty->GetBindMoney() - tOldMoney;
//
//	CMessage tMessage;
//	CMessageUpdateBindMoneyNotice tPara;
//	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_BINDMONEYNOTICE );
//	tPara.set_money( tVal );
//	tPara.set_total( pProperty->GetBindMoney() );
//	tMessage.set_msgpara( (long) &tPara );
//	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
//	return ;	
//}


//***********************************
// FunctionName : PlayerChangeYuanBao
// Description  : 玩家获得元宝
// Input Params : nAmount 元宝的数量, vIsBind 原则上只能是绑定的
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************
bool CPropertyModule::PlayerChangeYuanbao(CEntityPlayer* pPlayer, int nAmount, bool vIsBind)
{
	if ( pPlayer == NULL || nAmount == 0 ) return false;

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	CYuanBao& yb = vIsBind ? tpProperty->SilverYB() : tpProperty->GoldenYB();

	if ( yb.add(nAmount) ) 
	{
		if ( vIsBind )
		{
			CSceneLogic::GetSingleton().ExecuteSql(updatesilveryb, 0, 0, pPlayer->GetCharID( ), SQL_NONE, UPDATE,
					"update UMS_ROLE set charged_silver_yb = charged_silver_yb + %d ,"
					"silver_yb = silver_yb + %d where role_id = %d",
					nAmount,  nAmount, pPlayer->GetCharID());
		}else
		{
			CSceneLogic::GetSingleton().ExecuteSql(updatesilveryb, 0, 0, pPlayer->GetCharID( ), SQL_NONE, UPDATE,
					"update UMS_ACCOUNT set charged_golden_yb = charged_golden_yb + %d ,"
					"golden_yb = golden_yb + %d where role_id = %d",
					nAmount,  nAmount, pPlayer->GetCharID());
		}

		CMessageUserChargeNotice  tNoticeMsg;

		tNoticeMsg.set_subjectid( vIsBind ? CYuanBao::em_silver_yuanbao : CYuanBao::em_golden_yuanbao );
		tNoticeMsg.set_amount( nAmount);

		CMessage tMsg;
		tMsg.set_msgpara((uint32_t) &tNoticeMsg);
		pbmsg_sethead(&tMsg, ID_S2C_NOTIFY_USERCHARGE, 0, 0, 0, 0, 0, 0);
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsg);

		return true;
	}

	return false;
}

//***********************************
// FunctionName : PlayerChangeMoney 
// Description  : 玩家获得金钱 ( 如果是扣绑定金，如果绑定的不够，不足的部分直接扣非绑定金 )
// Input Params : vMoney:金钱改变量，vPayout:支出还是收入,vIsBind:是否支持绑定金钱
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************

int CPropertyModule::PlayerChangeMoney( CEntityPlayer* pPlayer, int vMoney, bool vPayout, bool vIsBind )
{
	LK_ASSERT( pPlayer != NULL, return ERR_INVALID_PARAMETER );
	LK_ASSERT_STR( vMoney >= 0, return ERR_INVALID_PARAMETER, "ChangeMoney Is Negative %d", vMoney );

	if ( vMoney == LK_ZERO )
	{
		// 没有发生变化,直接返回
		return SUCCESS;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	int tOldMoney = tpProperty->GetMoney();
	int tOldBindMoney = tpProperty->GetBindMoney();
	int tChangeMoney = ( vPayout == true ) ? ( -1 * vMoney ) : vMoney;
	int tRtn = SUCCESS;

	
	// 不支持绑定金钱
	if ( vIsBind == false )
	{
		tChangeMoney += tOldMoney;
		if( tChangeMoney < 0 )
		{
			return ERR_NO_ENOUGH_MEMORY;
		}
		tChangeMoney = std::min( MONEY_LIMIT, tChangeMoney );
		tpProperty->SetMoney( tChangeMoney );
		SendUpdateMoneyNotice( pPlayer, tChangeMoney - tOldMoney, tpProperty->GetMoney() );
	}
	// 支持绑定金钱
	else
	{
		tChangeMoney += tOldBindMoney;
		if( tChangeMoney < 0 )
		{
			// 绑定金不够， 支付非绑定金
			tRtn = PlayerChangeMoney( pPlayer, -1 * tChangeMoney, true, false );
			if( tRtn == SUCCESS )
			{
				extern int g_exMoney ;
				g_exMoney = tChangeMoney;	

				tChangeMoney = 0;
			}
			else
			{
				return ERR_NO_ENOUGH_MEMORY;
			}
		}
		tChangeMoney = std::min( MONEY_LIMIT, tChangeMoney );
		tpProperty->SetBindMoney( tChangeMoney );
		SendUpdateBindMoneyNotice( pPlayer, tChangeMoney - tOldBindMoney, tpProperty->GetBindMoney( ) );
	}

	return SUCCESS;;
}



//************************************
// Method:    PlayerThrowMoney
// FullName:  CPropertyModule::PlayerThrowMoney
// Access:    public 
// Returns:   void
// Qualifier: 目前暂时没有扔钱需求
// Parameter: CEntityPlayer * pPlayer
// Parameter: int vMoney
//************************************
//void CPropertyModule::PlayerThrowMoney( CEntityPlayer* pPlayer, int vMoney )
//{
//	if( pPlayer == NULL )
//	{
//		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
//	vMoney = std::min( pProperty->GetMoney( ), vMoney );
//	if ( vMoney == 0 )
//	{
//		// 金币不够了
//		SendProErrorNotice( pPlayer, ERROR_THROW_OUTOFMONEY );
//		return;
//	}
//
//	CMoneyCreator tCreator( vMoney, 5, pPlayer->GetPosX( ), pPlayer->GetPosY( ), 0, 0 );
//
//	unsigned int tEntityID = 0;
//	bool tBool = CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(),
//														pPlayer->GetMapID(),
//														pPlayer->GetMapIndex(),
//														&tCreator,
//														tEntityID );
//	if ( tBool == true )
//	{
//		if ( PlayerChangeMoney( pPlayer, vMoney, true, false ) == SUCCESS)
//		{
//			LogEventLostMoneyByThrowMoney(pPlayer, CYuanBao::em_unbind_money, vMoney);
//		}
//	}
//}

// 处理由于道具失去造成的任务状态变化
void CPropertyModule::OnTaskRemoveItem( CEntityPlayer* pPlayer, unsigned int vItemID, unsigned short vNumber )
{
	if( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CTaskModule::GetSingleton().OnTaskRemoveItem( pPlayer, vItemID, vNumber );
}

//***********************************
// FunctionName : PlayerThrowItem 
// Description  : 玩家销毁物品，不再掉地上。
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************
void CPropertyModule::PlayerDestroyItem( CEntityPlayer* pPlayer, int vItemIndex, int vNumber )
{
	LK_ASSERT( pPlayer != NULL, return );
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	CItemObject *tpItemObj = pProperty->GetBaggage( )->GetItemObjPtr( vItemIndex );
	
	// 判断有没有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	


	// 删除道具时，道具不存在
	if ( tpItemObj == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_REMOVEITEM_ITEMNOTEXIST );
		return;
	}

	// 删除道具时，道具被锁定了
	if ( tpItemObj->GetLockStatus() != LOCKTYPE_NONE )
	{
		SendProErrorNotice( pPlayer, ERROR_REMOVEITEM_ITEMLOCKED );
		return;
	}

	// 如果处于手动绑定解除状态则检查绑定解除时间
	if ( IfItemBindFree( tpItemObj ) == 1 )
	{	
		CheckItemBindFreeTime( tpItemObj );	
	}
	// 删除道具时候，道具被绑定了
	if ( tpItemObj->GetBindStatus() != ITEM_BINDSTATUS_FREE )
	{
		// 发送通知，绑定的物品不能被丢弃
		SendProErrorNotice( ( CEntityPlayer* )pPlayer , ITEM_THROW_BINDED  );
		return;
	}


	uint64_t ullGUID = tpItemObj->GetGUID();
	int nItemID = tpItemObj->GetItemID();

	// 发送删除道具
	SendRemoveItemNotice( pPlayer, POS_BAGGAGE, vItemIndex, vNumber );

	CSceneLogic::GetSingleton().LogValuableEquip(pPlayer->GetCharID(), tpItemObj);

	// 这里会删除物品
	pProperty->GetBaggage( )->RemoveItem( vItemIndex, vNumber );

	// 记录丢物品日志
	LogEventLostItemByDestroyItem(pPlayer, ullGUID, nItemID, vNumber);

	// 处理道具失去后，任务状态变化
	OnTaskRemoveItem( pPlayer, tpItemObj->GetItemID(), vNumber );

}



//************************************
// Method:    PlayerThrowItem
// FullName:  CPropertyModule::PlayerThrowItem
// Access:    public 
// Returns:   void
// Qualifier: 玩家丢弃物品(目前只有非主动的丢弃，如被杀死后的爆装备)
// Parameter: CEntityPlayer * pPlayer
// Parameter: int vItemIndex
// Parameter: int vNumber
//************************************
void CPropertyModule::PlayerThrowItem( CEntityPlayer* pPlayer, int vItemIndex, int vNumber  )
{
	LK_ASSERT( pPlayer != NULL, return );

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	CItemObject *tpItemObj = pProperty->GetBaggage( )->GetItemObjPtr( vItemIndex ) ;

	// 删除道具时，道具不存在
	if ( tpItemObj == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_REMOVEITEM_ITEMNOTEXIST );
		return;
	}

	// 删除道具时，道具被锁定了
	if ( tpItemObj->GetLockStatus() != LOCKTYPE_NONE )
	{
		SendProErrorNotice( pPlayer, ERROR_REMOVEITEM_ITEMLOCKED );
		return;
	}

	// 如果处于手动绑定解除状态则检查绑定解除时间
	if ( IfItemBindFree( tpItemObj ) == 1 )
	{	
		CheckItemBindFreeTime( tpItemObj );	
	}

	// 删除道具时候，道具被绑定了
	if ( tpItemObj->GetBindStatus() != ITEM_BINDSTATUS_FREE )
	{
		// 发送通知，绑定的物品不能被丢弃
		SendProErrorNotice( ( CEntityPlayer* )pPlayer , ITEM_THROW_BINDED  );
		return;
	}

	int tCharID[ TEAMNUM ] = { 0 };
	CItemObject* tpThrowItem = pProperty->GetBaggage( )->EraseItem( vItemIndex, vNumber );


	CItemCreator tCreator( tpThrowItem->GetItemID(), 1, pPlayer->GetPosX( ), pPlayer->GetPosY( ), tCharID, tpThrowItem );

	unsigned int tEntityNpcID = 0;
	CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(),
											pPlayer->GetMapID(),
											pPlayer->GetMapIndex(),
											&tCreator,
											tEntityNpcID );

	// 记录丢物品日志
	LogEventLostItemByThrowItem(pPlayer, tpThrowItem->GetGUID(), tpThrowItem->GetItemID(), vNumber);

	// 发送删除道具
	SendRemoveItemNotice( pPlayer, POS_BAGGAGE, vItemIndex, vNumber );

	// 处理道具失去后，任务状态变化
	OnTaskRemoveItem( pPlayer, tpThrowItem->GetItemID(), vNumber );
}


//***********************************
// FunctionName : 玩家出售道具 (NPC交易) 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************

void CPropertyModule::PlayerSellItem( CEntityPlayer* pPlayer, int vEntityID, int vItemIndex, int vNumber )
{
	if( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

	
	CEntityFuncNpc* tpDesEntity = dynamic_cast<CEntityFuncNpc*>( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		vEntityID ) );	
	
	CProperty* tpDesProperty = ( tpDesEntity != NULL ) ? tpDesEntity->GetProperty( ) : NULL;
	if ( tpDesProperty == NULL )
		return;

	// 验证距离
	if ( pPlayer->IsWithinDistance( tpDesEntity, MAX_NPC_TALK_GIRD ) == false )
	{
		return ;
	}

	// 如果谈话目标不是NPC
	if ( tpDesProperty->GetEntityType( ) != ENTITYTYPE_FUNCNPC )
	{
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_TARGETINVALID );
		return;
	}
	
	// 个数大于零
	if ( vNumber <= LK_ZERO )
	{
		return ;
	}	

	CTemplateNpc* tpNpcTpl = (CTemplateNpc*) CDataStatic::SearchTpl( tpDesProperty->GetPropertyTempID( ) );
	if ( tpNpcTpl == NULL )
	{
		LOG_ERROR( "pro", "NPC=%d data not found", tpDesProperty->GetPropertyTempID( ) );
		return;
	}

	CTemplateSellTable* tpSellTable = (CTemplateSellTable*) CDataStatic::SearchTpl( tpNpcTpl->mSellServiceID );
	if ( tpSellTable == NULL )
	{
		// NPC没有商店服务
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_TARGETINVALID );
		return;
	}

	// 防止缓冲区溢出
	// TODO:添加对背包的索引判断
	if ( !pProperty->GetBaggage( )->CheckIndexValid( vItemIndex ) )
	{
		return;
	}
	/*if ( vItemIndex < 0 || vItemIndex >= (int)pProperty->GetBaggage( )->mReleaseIndex )
		return;*/

	CItemObject* tpItem = pProperty->GetBaggage( )->GetItemObjPtr( vItemIndex );
	if ( tpItem == NULL )
	{
		LOG_ERROR( "pro", "player (entity:%d charid:%d charname:%s) index %d dosn't have data",
			pPlayer->GetEntityID(), pPlayer->GetCharID(), pPlayer->GetCharNameShow(), vItemIndex );
		return;
	}
	
	CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpItem->GetItemID() );
	if ( tpTplItem == NULL )
	{
		LOG_ERROR( "pro", "can't find item %d in template", tpItem->GetItemID() );
		return;
	}

	//TODO: 判断包裹中的道具数量是不是真有那么多
	if( (int)(tpItem->GetItemNum()) < vNumber || tpTplItem->mPileLimit < vNumber )
	{
		LOG_FATAL( "pro", "[%s:%d] player %s:%d sell item %d, index %d invalid number %d while only has %d ", __FUNCTION__, __LINE__,
			pPlayer->GetCharNameShow(), pPlayer->GetCharID(), tpItem->GetItemID(), vItemIndex, vNumber, tpItem->GetItemNum() );
		return;
	}

	// 不能卖店
	if ( ( tpTplItem->mProcessType & CTplItem::PROCESSTYPE_CANSALE ) != CTplItem::PROCESSTYPE_CANSALE )
	{
		return;
	}

	if ( tpItem->GetLockStatus() != LOCKTYPE_NONE )
	{
		LOG_ERROR( "pro", " [%s:%d] player %s:%d sell item %d, num %d, index %d but item is locked ",__FUNCTION__, __LINE__, 
			pPlayer->GetCharNameShow(), pPlayer->GetCharID(),
			tpItem->GetItemID(), vNumber, vItemIndex );
		return;
	}

	// check pk state of entity
	
	int tSalePrice = tpTplItem->mPriceSale;
	
	CTemplateLevelMoneyLmt* tpMoneyTable = (CTemplateLevelMoneyLmt*)CDataStatic::GetTemp(TEMP_MONEYLMT_CFG);
	LK_ASSERT( tpMoneyTable!=NULL, return );
	LK_ASSERT( pPlayer->GetLevel() >= 0 && pPlayer->GetLevel() < TMP_MAX_GRADE, return );

	// 检查包裹金钱是否溢出
	if ( tpTplItem->mSaleBindMoney != LK_NOTBIND )
	{
		unsigned int tMoney = (unsigned int)(pProperty->GetBindMoney() + tSalePrice * vNumber);
		if ( tMoney > MONEY_LIMIT || tMoney > tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mBagBindMoneyLmt )
		{
			SendProErrorNotice( pPlayer, ERR_BAG_BIND_MONEY_UPLMT );
			return ;
		}
	}
	else
	{
		unsigned int tMoney = (unsigned int)( pProperty->GetMoney() + tSalePrice * vNumber );
		if ( tMoney > MONEY_LIMIT || tMoney > tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mBagMoneyLmt )
		{
			SendProErrorNotice( pPlayer, ERR_BAG_MONEY_UPLMT );
			return ;
		}
	}	

	// 如果处于手动绑定解除状态则检查绑定解除时间
	if ( IfItemBindFree( tpItem ) == 1 )
	{	
		int FreeResult = CheckItemBindFreeTime( tpItem );
		if ( FreeResult != 1 )
		{
			return;			
		}			
	}	
	if ( ( tpItem->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) != 0 )
	{ 
		// 发送由于装备绑定物品不能卖出的通知
	    SendProErrorNotice( pPlayer, ITEM_SELL_BINDED );
		return;
	}

	// 如果卖掉的物品是坐骑,则处理下马逻辑
	if ( tpTplItem->mItemType == CTplItem::ITEM_HORSE )
	{
		if ( pProperty->GetHorseTempID( ) == tpItem->GetItemID() )
		{
			CTplItemHorse* pTplHorse = (CTplItemHorse*)tpTplItem;
			pProperty->OffHorse( pTplHorse->mSpeedBuff );
			SendRideHorseNotice( pPlayer, tpItem->GetItemID(), 0 );
		}
	}

	// 处理包裹道具
	int tItemID = tpItem->GetItemID();

	// 将包裹中道具擦除，克隆一个内存保留
	tpItem = pProperty->GetBaggage( )->EraseItem( vItemIndex, vNumber );

	// 记录物品消耗
	if ( tpItem != NULL )
	{
		LogEventLostItemBySell2Npc( pPlayer, tpItem->GetGUID(), tpItem->GetItemID(), vNumber,
				tpDesProperty->GetPropertyTempID(), CYuanBao::em_bind_money, tSalePrice);

		CSceneLogic::GetSingleton().LogValuableEquip(pPlayer->GetCharID(), tpItem);
	}

	// 记录非堆叠的人民币物品消耗; 如果是回购, 则记录会有问题
	LogIbItemUsed(pPlayer, tpItem);

	// 发送出售成功消息
	CMessage tMessage;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_SELLITEM );
	CMessageSellItemResponse tPara;
	PBItemObject* tpObj = tPara.mutable_item();
	tpItem->GetItemBinaryBuffer2( tpObj, vNumber );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage ); 

	// 发送删除道具
	SendRemoveItemNotice( pPlayer, POS_BAGGAGE, vItemIndex, vNumber );

	// 处理道具失去后的逻辑
	OnTaskRemoveItem( pPlayer, tItemID, vNumber );	

	// 这里处理防沉迷
	/*if ( pPlayer->GetFcmStatus() == em_none_rate )
	{
		tSalePrice = 0;
	}
	else if ( pPlayer->GetFcmStatus() == em_half_rate )
	{
		tSalePrice = tSalePrice * 0.5;
	}*/

	// 是否支持绑定金钱
	if ( tpTplItem->mSaleBindMoney != LK_NOTBIND )
	{
		//PlayerChangeBindMoney( pPlayer, pProperty, tpTplItem->mPriceSale * vNumber, false );
		if (PlayerChangeMoney( pPlayer, ( tSalePrice * vNumber ), false, true ) == SUCCESS)
		{
			LogEventGetMoneyBySell2NPC(pPlayer, CYuanBao::em_bind_money, ( tSalePrice * vNumber ), 
				tpItem->GetItemID(), vNumber, tpItem->GetGUID());
		}
	}
	else
	{
		//PlayerChangeMoney( pPlayer, pProperty, tpTplItem->mPriceSale * vNumber, false );
		if (PlayerChangeMoney( pPlayer, ( tSalePrice * vNumber ), false, false ) == SUCCESS)
		{
			LogEventGetMoneyBySell2NPC(pPlayer, CYuanBao::em_unbind_money, ( tSalePrice * vNumber ), 
				tpItem->GetItemID(), vNumber, tpItem->GetGUID());
		}
	}	

	// 添加出售道具记录，购回时用
	SaleItem tSaleItem;
	tSaleItem.mItemID = tpItem->get_id();
	tSaleItem.mNumber = vNumber;
	tSaleItem.mPrice = tSalePrice;

	if ( pProperty->GetSaleItem( )->size() == ITEM_BUYBACK_MAX )
	{
		// 如果已满20个道具，删除第一个
		SaleItem* tpSale = (SaleItem*) &( * (pProperty->GetSaleItem( )->begin()) );
		if ( tpSale == NULL )
		{
			return ;
		}
		CItemObject* tpSaleItem = ( CItemObject* )CSceneObjManager::GetSingletonPtr()->GetObject( tpSale->mItemID );
		if ( tpSaleItem != NULL )
		{
			if (tpSaleItem->GetValidTimerID() != INVALID_OBJ_ID )
			{
				pPlayer->GetTimerReciver()->ClearTimer(tpSaleItem->GetValidTimerID() );
			}
			CSceneObjManager::GetSingletonPtr()->DestroyObject( tpSaleItem->get_id( ) );
		}
		pProperty->GetSaleItem( )->erase( pProperty->GetSaleItem( )->begin( ) );
		pProperty->GetSaleItem( )->push_back( tSaleItem );
	}	
	else
	{
		pProperty->GetSaleItem( )->push_back( tSaleItem );
	}	

	// refresh buy back item list
	CMessage tMsgSale;
	CMessageObtainSaleItem tParaSale;
	tMsgSale.mutable_msghead()->set_messageid( ID_C2S_REQUEST_SALEITEM );
	tParaSale.set_entityid( pPlayer->GetEntityID() );
	tMsgSale.set_msgpara( (long) &tParaSale );
	OnMessageObtainSaleItemString( pPlayer, &tMsgSale );

	LOG_NOTICE( "trade", "[%s : %d] Entity %s Sell item (%d,%d) to NPC. ", __LK_FILE__, __LINE__ ,
		pPlayer->GetCharNameShow(), tpItem->GetItemID(), vNumber ); 
}


// ***************************************************************
//  Function: 	PlayerPurchase   
//  Description:玩家购买道具( 策划规则：可叠加道具一次最大买一摞；不可叠加道具一次买一个 )
//  Date: 		08/31/2008
// 
// ***************************************************************
void CPropertyModule::PlayerPurchase( CEntityPlayer* pPlayer, int vEntityID, int vPageIndex, int vItemIndex, int vNumber, int nNpcID )
{
	if( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	//int tNpcEntityID = pProperty->GetTalkNpcEntityID();
	
	// 检查有没有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}


//	CEntity* tpDesEntity = CSceneLogic::GetSingleton().GetEntity( nNpcID );
	CEntity* tpDesEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( nNpcID ) );
	if ( tpDesEntity == NULL )
		return ;

	if( !pPlayer->IsWithinDistance( tpDesEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), nNpcID, __FUNCTION__ );
		return;
	}
	
	CProperty* tpDesProperty = tpDesEntity->GetProperty();

	// 如果谈话目标不是NPC
	if ( tpDesProperty->GetEntityType( ) != ENTITYTYPE_FUNCNPC )
	{
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_TARGETINVALID );
		return;
	}

	CTemplateNpc* tpNpcTpl = (CTemplateNpc*) CDataStatic::SearchTpl( tpDesProperty->GetPropertyTempID( ) );
	if ( tpNpcTpl == NULL )
	{
		LOG_ERROR( "pro", "NPC=%d data not found", tpDesProperty->GetPropertyTempID( ) );
		return;
	}

	CTemplateSellTable* tpSellTable = (CTemplateSellTable*) CDataStatic::SearchTpl( tpNpcTpl->mSellServiceID );
	if ( tpSellTable == NULL )
	{
		// NPC没有商店服务
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_TARGETINVALID );
		return;
	}

	// 防止缓冲区溢出
	if ( vPageIndex < 0 || vPageIndex >= SHOP_PAGEINDEX_MAX )
	{
		return ;
	}

	if ( vItemIndex < 0 || vItemIndex >= SHOP_ITEMINDEX_MAX )
	{
		return ;
	}

	// 判断金币够不够
	int tItemID = tpSellTable->mItem[ vPageIndex ].mItemID[ vItemIndex ];
	CTplItem* tpItem = (CTplItem*) CDataStatic::SearchTpl( tItemID );
	if ( tpItem == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] ITEM=%d not found", __FUNCTION__, __LINE__, tItemID );
		return;
	}
	
	// 是否家族出售表
	if ( tpSellTable->mSellTableType == CTemplateSellTable::SELLTABLETYPE_FAMILYMONEYNEEDED || 
			tpSellTable->mSellTableType == CTemplateSellTable::SELLTABLETYPE_FAMILYWAR )
	{
		CFamilyModule::GetSingleton().BuyFamilyItem( pPlayer, tpItem->mTempID, vNumber, tpNpcTpl->mTempID );
		return;
	}

	// 是否军团出售表
	else if( tpSellTable->mSellTableType == CTemplateSellTable::SELLTABLETYPE_CORPSMONEYNEEDED ||
				tpSellTable->mSellTableType == CTemplateSellTable::SELLTABLETYPE_CORPSWAR )
	{
		CCorpsModule::GetSingleton().BuyCorpsItem( pPlayer, tpItem->mTempID, vNumber, tpNpcTpl->mTempID,  tpSellTable->mWarCityMapID );
		return;
	}

	// 判断物品的叠加规则 / 叠加上限
	if( tpItem->mItemType == CTplItem::ITEM_WEAPON || tpItem->mItemType == CTplItem::ITEM_ARMOR )
	{	
		// 不可叠加物品只能一次买一个
		if( vNumber != 1 )
		{
			LOG_ERROR( "pro", "player purchase item, and the item can't be lap over, but the number is %d", vNumber );
			
			return;
		}
	}
	else
	{
		// 可叠加物品一次最大买一摞
		if( vNumber > tpItem->mPileLimit )
		{
			LOG_ERROR( "pro", "player purchase item, and the item could be lap over, and the upper lap is %d, but the number is %d. too much ", tpItem->mPileLimit, vNumber );
		
			return ;
		}
	}	  
	

	// check pk state of entity
	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		LOG_ERROR( "pro", "pk value config template error.[%s:%d]", __LK_FILE__, __LINE__ );
		return ;
	}	

	int tPurchasePrice = tpItem->mPricePurchase;
	EPKStatus tPkStatus = pProperty->GetTplPKState();
	if ( tPkStatus == PKSTATUS_ROSINESS )
	{
		tPurchasePrice = (int) ( tpItem->mPricePurchase * (float) ( 1 + ( tpTable->mPriceChange[ 0 ] / SERVER_PERCENT_FLOAT ) ) );
	}
	else if ( tPkStatus == PKSTATUS_RED )
	{
		tPurchasePrice = (int) ( tpItem->mPricePurchase * (float) ( 1 + ( tpTable->mPriceChange[ 1 ] / SERVER_PERCENT_FLOAT ) ) );
	}
	else if ( tPkStatus == PKSTATUS_CARMINE )
	{
		tPurchasePrice = (int) ( tpItem->mPricePurchase * (float) ( 1 + ( tpTable->mPriceChange[ 2 ] / SERVER_PERCENT_FLOAT ) ) );
	}
	else if ( tPkStatus == PKSTATUS_PKTOPLIMIT )
	{
		LOG_INFO( "pro", "arrive top pk value, not able to purchase.[%s:%d]", __LK_FILE__, __LINE__ );
		return ;
	}	

	if ( tpItem->mPurchaseBindMoney != LK_NOTBIND )
	{
		if ( pProperty->IsMoneyEnough( true, ( tPurchasePrice * vNumber ) ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFMONEY );
			return ;
		}		
	}
	else
	{
		if ( pProperty->IsMoneyEnough( false, ( tPurchasePrice * vNumber ) ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFMONEY );
			return ;
		}
	}
	

	CItemObject * pInsItemPile = PlayerInsertItem( pPlayer, tItemID, vNumber);
	if ( pInsItemPile == NULL) return; 

	LogEventGetItemByNpcShop(pPlayer, pInsItemPile->GetGUID(), tItemID, vNumber, 
			tpItem->mPurchaseBindMoney != LK_NOTBIND ? CYuanBao::em_bind_money : CYuanBao::em_unbind_money,
			tPurchasePrice, tpNpcTpl->mTempID); 

	// 如果添加道具成功，那么处理金币减少逻辑
	if ( tpItem->mPurchaseBindMoney != LK_NOTBIND )
	{
		// 绑定金钱足够买道具
		//PlayerChangeBindMoney( pPlayer, pProperty, tpItem->mPricePurchase * vNumber, true );
		if (PlayerChangeMoney( pPlayer, ( tPurchasePrice * vNumber ), true, true ) == SUCCESS)
		{
			LogEventLostMoneyByBuy4NPC(pPlayer, CYuanBao::em_bind_money, ( tPurchasePrice * vNumber ), 
					tItemID, vNumber, pInsItemPile->GetGUID());
		}
	}	
	else
	{
		if (PlayerChangeMoney( pPlayer, ( tPurchasePrice * vNumber ), true, false ) == SUCCESS)
		{
			LogEventLostMoneyByBuy4NPC(pPlayer, CYuanBao::em_unbind_money, ( tPurchasePrice * vNumber ), 
					tItemID, vNumber, pInsItemPile->GetGUID());
		}
	}

	LOG_DEBUG( "trade", "[%s : %d] player %s purchase item (%d,%d) to NPC.", __LK_FILE__, __LINE__
		, pPlayer->GetCharNameShow(), tItemID, vNumber ); 
}

//***********************************
// FunctionName : PlayerClickStorage 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************
int CPropertyModule::PlayerClickStorage( CEntityPlayer* pPlayer, unsigned int vEntityID )
{	
	LK_ASSERT( pPlayer != NULL, return -1 )
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	pProperty->SetServiceStatus( SERVICE_STORAGE );

	// 是否没有给玩家发送过仓库信息
	if( pProperty->GetStorageStatus() != STORAGE_STATUS_INITIALIZED )
	{
		CMessage				tMessage;
		CMessageNotifyStorItem	tMsgNotifyStorageInfo;
		
		tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_STORAGEITEM );
		tMessage.set_msgpara( (uint32)& tMsgNotifyStorageInfo );

		PBItemBox* tpPBStorage = tMsgNotifyStorageInfo.mutable_storage();
		pProperty->GetStorage()->GetTlvBuffer2( tpPBStorage, 0, pProperty->GetStorage()->GetReleaseIndex() ); 
		
		// 金钱独立到外面了
		tMsgNotifyStorageInfo.set_stormoney( pProperty->GetStorageMoney() );
		tMsgNotifyStorageInfo.set_storbindmoney( pProperty->GetStorageBindMoney() );

		// 仓库可能会分包发送，如果数量太大的话, 不常有
		//if( tMsgNotifyStorageInfo.storage().itemobjects_size() > MAX_STORAGEITEM )
		//{
		//	int ItemNum = 0;
		//	// 这里效率稍低，但是代码整洁容易出错， 另外仓库不是关键路径，允许低效
		//	PBItemBox tStorageForExchange( tMsgNotifyStorageInfo.storage() ) ;
		//	tMsgNotifyStorageInfo.mutable_storage()->Clear();
		//	for ( int i = 0; i <  pProperty->GetStorage()->GetKitBagIndex(); ++i )
		//	{
		//		int tKitBagID = pProperty->GetStorage()->GetKitBagIDByIndex( i );
		//		PBItemObject* pItemKitbag = tMsgNotifyStorageInfo.mutable_storage()->add_kitbag(  );
		//		pItemKitbag->set_itemid( tKitBagID );
		//	}					
		//	tMsgNotifyStorageInfo.mutable_storage()->set_stormoney( pProperty->GetStorage()->GetMoney() );
		//	tMsgNotifyStorageInfo.mutable_storage()->set_storbindmoney( pProperty->GetStorage()->GetBindMoney() );
		//	for( int i = 0; i < tStorageForExchange.itemobjects_size(); i++ )
		//	{
		//		PBItemObject* tpPBItemObj = tMsgNotifyStorageInfo.mutable_storage()->add_itemobjects( );
		//		LK_ASSERT( tpPBItemObj != NULL, return ERR_UNKNOWN);
		//		tpPBItemObj->CopyFrom( tStorageForExchange.itemobjects(i));

		//		// 达到单次发送上限，或者已经到结尾了还没塞满单个包，都发送消息
		//		if( ++ItemNum >= MAX_STORAGEITEM-1 || i == tStorageForExchange.itemobjects_size() - 1 )
		//		{
		//			CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &tMessage );	
		//			tMsgNotifyStorageInfo.Clear();
		//			ItemNum = 0;
		//		}
		//	}
		//}
		//else
		//{
		// 不分包发送	
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &tMessage );	
		//}

		// 设置发送过仓库标志位
		pProperty->SetStorageStatus( STORAGE_STATUS_INITIALIZED );
	}
	
	// 发送仓库背包
	for ( int i = 0; i < pProperty->GetStorage()->GetKitBagIndex(); ++i )
	{
		if ( pProperty->GetStorage()->GetKitBagItemByIndex( i ) == NULL  )
		{
			continue;
		}

		CMessage tMsgHead;
		CMessageOpenKitBagResponse tMsgOpenStorKitBag;	 
		tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_OPENKITBAG );
		tMsgHead.set_msgpara( (int)&tMsgOpenStorKitBag );						
		// if( !( pProperty->GetStorage()->GetKitBagStatus() & ( 1 << i ) ) )
		if( pProperty->GetStorage()->GetKitBagStatus() == 0 )
		{
			pProperty->GetStorage()->GetItemInBag( BAGTYPE_KITBAG, i, *tMsgOpenStorKitBag.mutable_itembox() );
		}		
		tMsgOpenStorKitBag.set_desslot( SLOT_STORKITBAG );
		tMsgOpenStorKitBag.set_kitbagindex( i );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
		// pProperty->GetStorage()->SetKitBagStatus( ( 1 << i ) | pProperty->GetStorage()->GetKitBagStatus() );	  		
	}
	pProperty->GetStorage()->SetKitBagStatus( 1 );

	return SUCCESS;
}

int CPropertyModule::PlayerClickMail( CEntityPlayer* pPlayer, unsigned int vEntityID )
{

	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	
	pProperty->SetServiceStatus( SERVICE_MAIL );

	return SUCCESS;
}

// 与NPC谈话,进入商店服务 (NPC交易)
int CPropertyModule::PlayerClickShop( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_SHOP );

	return SUCCESS;
}

int CPropertyModule::PlayerClickUpg( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_UPG );

	return SUCCESS;
}

int CPropertyModule::PlayerClickTele( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_TELE );

	return SUCCESS;
}

// 玩家点击回城服务
int CPropertyModule::PlayerClickTown( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_TOWN );

	return SUCCESS;
}

int CPropertyModule::PlayerClickBind( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return  -1 )
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_BIND );

	return SUCCESS;
}


int CPropertyModule::PlayerClickWelfare( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 ) 
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	
	// 检查等级
	if( pPlayer->GetLevel() < WELFARE_LEVLE_NEED )
	{
		return ERR_ACTIVITY_LEVELLOW;
	}	 
	
	// 检查是否已经处于答题状态
	int Result = 0;		   
	CAnswerStatus *tpAnswer = ( CAnswerStatus * )CSceneObjManager::GetSingleton().GetObject( pProperty->GetAnswerStatusObjID() );
	LK_ASSERT( tpAnswer != NULL, return ERR_ACTIVITY_HASANSWERED )		
	if ( tpAnswer->GetAppType() != APPTYPE_NULL && tpAnswer->GetAppType() != APPTYPE_NPC )
	{
		// 发送错误提示
		return ERR_ACTIVITY_INANSWERSTATUS;
	}	
	
	// 已经答题的话发送错误码
	if ( pProperty->GetWelfareStatus() == 1 )
	{
		return ERR_ACTIVITY_HASANSWERED;
	}		   
		
	// 还没有答题
	if ( pProperty->GetWelfareStatus() == 0 )
	{
		Result = 1;
		tpAnswer->SetAppType( APPTYPE_NPC ); 
		pProperty->SetServiceStatus( SERVICE_WELFARE );		
	}	 
			
	return SUCCESS;
}

int CPropertyModule::PlayerClickChange( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
		CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_CHANGE );

	return SUCCESS;
}

int CPropertyModule::PlayerClickJudge( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
		CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_JUDGE );

	return SUCCESS;
}

int CPropertyModule::PlayerClickExchange( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
		CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_EXCHANGE );

	return SUCCESS;
}

int CPropertyModule::PlayerClickHonor( CEntityPlayer* pPlayer, unsigned int vEntityID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
		CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_HONOR );

	return SUCCESS;
}

void CPropertyModule::PlayerClickNpc( CEntityPlayer* pPlayer, int vEntityID )
{
	if( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property IS NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	//TODO: 客户端不再发什么CloseDialog消息，服务器也不再判断谈话npc什么的，每次重新刷新talknpcid和servicestatus
	//// 如果玩家已经有谈话对象(并且新的谈话对象不是老的对象)，不能再谈话
	//if ( (pProperty->GetTalkNpcEntityID( ) != 0) && (pProperty->GetTalkNpcEntityID( ) != (unsigned int )vEntityID) )
	//{
	//	SendProErrorNotice( pPlayer, ERROR_CLICKNPC_STATEINVALID );
	//	return;
	//}		

//	CEntity* tpEntity = CSceneLogic::GetSingleton( ).GetEntity( vEntityID );
	CEntity* tpEntity = dynamic_cast<CEntity*>(CSceneObjManager::GetSingletonPtr( )->GetObject( vEntityID ));
	if ( tpEntity == NULL )
		return;

	//if ( !pPlayer->GetPos( ).LimitDistance( tpEntity->GetPos( ), 15 ) )
	if( pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) == false )
	{
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFRANGE );
		return;
	}

	// if click object is NPC
	if ( tpEntity->IsFunNpc() || tpEntity->IsOgre() )
	{
		CEntityNpc *pNpc = (CEntityNpc*)tpEntity;
		if( IS_REPETION_LINE_ID( pNpc->GetLineID( ) ) == false 
			&& IS_BATTLE_LINE_ID( pNpc->GetLineID( ) ) == false 
			&& pNpc->GetLineID( ) != pPlayer->GetNationality( ) )
		{
			// 如果与外国玩家中立或敌对，不能操作
			if ( ( pNpc->GetPKType( ) & NEUTRAL_WITH_FC ) == NEUTRAL_WITH_FC || ( pNpc->GetPKType( ) & ENEMY_WITH_FC ) == ENEMY_WITH_FC )
				return;
		}

		pProperty->SetTalkNpcEntityID( vEntityID );
		CTaskModule::GetSingleton().OnPlayerClickNpc( pPlayer, vEntityID );

		// 活动NPC的处理, 通过服务处理
		// OnClickActivityNpc(pPlayer, pNpc);
		SendClickNpcResponse( pPlayer, vEntityID );

		return;
	}

	if( tpEntity->GetEntityType( ) == ENTITYTYPE_BOX )
	{
		PlayerClickStoreBox( pPlayer, ( CEntityBox* )tpEntity );	
		return;
	}

}

// player click storebox
void CPropertyModule::PlayerClickStoreBox( CEntityPlayer* vpPlayer, CEntityBox* vpBox )
{
	if ( vpPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )vpPlayer->GetProperty();
	// 检查读秒时间
	if ( tpProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_BOX, vpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
#ifdef _DEBUG_
		//TODO: 外网错误太多，只好改成DEBUG等级
		LOG_ERROR( "pro","wrong progresstime when click box, roleid:%d", vpPlayer->GetCharID() );
#endif
		return;
	}
	
	CTemplateBox* tpTemplate = ( CTemplateBox* )CDataStatic::SearchTpl( vpBox->GetProperty( )->GetPropertyTempID( ) );
	LK_ASSERT_STR( tpTemplate != NULL, return, "TemplateID( %d ) Can'nt find ",
		vpBox->GetProperty( )->GetPropertyTempID( ) );

	if( vpBox->GetAliveStatus( ) == ALIVE_DIE )
	{
		// Box Is Opened
		return;
	}

	if( vpPlayer->GetAliveStatus( ) == ALIVE_DIE )
	{
		//Player Is Die Cannt Open Box
		return;
	}

	if ( vpBox->GetOwnercharID() != 0 && vpBox->GetOwnercharID() != (int)vpPlayer->GetCharID() )
	{
		// 宝箱不属于这个人
		SendProErrorNotice( vpPlayer, ERROR_CLICKNPC_BOXOWNER_ERR );
		return;
	}

#ifdef _FB_
	bool  nLimit = CRepetionModule::GetSingleton().PlayerOpenBoxLimited(vpPlayer);
	if ( nLimit )
	{
		SendProErrorNotice( vpPlayer, ERROR_CLICKNPC_BOXOWNER_ERR );
		return;
	}
#endif

    // 摇钱树活动拾取宝箱
    COgreCreator* pCreator = ( COgreCreator*)CSceneObjManager::GetSingletonPtr()->GetObject( vpBox->GetCreatorID() );
    bool lbYqsIsStart       = CActivityYqs::GetSingleton().mbIsStarted;
    int  liYqsSettlePhase   = CActivityYqs::GetSingleton().GetSettlePhase();
    if ( lbYqsIsStart == true && liYqsSettlePhase != -1 && pCreator!=NULL )
    {
        int liStoreBoxIndex = pCreator->GetIndex();

        int  liYqsLevel         = CActivityYqs::GetSingleton().moYaoQianShuCampInfo.miLevel;
        bool lbIsYqsStoreBox    = CActivityYqsCfg::GetSingleton().IsStoreBox( liYqsLevel, liStoreBoxIndex );
        if ( lbIsYqsStoreBox == true )
        {
            int liRetForPickStoreBox = vpPlayer->moYaoQianShu.PickStoreBox( vpPlayer->GetCharID(), vpBox->GetNpcID() );
            if ( liRetForPickStoreBox != 1 )
            {
                SendProErrorNotice( vpPlayer, ERROR_CLICKNPC_BOXHASPICKED );
                return;
            }
        }
        else
        {
            LOG_DEBUG( "YaoQianShu","[ %s:%d ][ %s ] the box is not for yqs!", __LK_FILE__, __LINE__, __FUNCTION__ );
        }
    }

	unsigned int i = 0;
	unsigned int tProbabilityMax = 0;
	int tProbability = 0;
	bool tIsSelect = false;
	
	for( i = 0; i < ARRAY_CNT( tpTemplate->mClick ); i++ )
	{
		if( tpTemplate->mClick[ i ].mProbability == 0 )
		{
			break;
		}

		tProbabilityMax += ( unsigned int )( tpTemplate->mClick[ i ].mProbability );
	}

	LK_ASSERT_STR( tProbabilityMax != 0, return, "Template %d", vpBox->GetProperty( )->GetPropertyTempID( ) );

	int tSRand = CSceneServer::GetSingletonPtr( )->GetLastTickCount( );
	tProbability = ( ( tSRand << 7 ) - tSRand ) % ( tProbabilityMax );

	for( i = 0; i < ARRAY_CNT( tpTemplate->mClick ); i++ )
	{
		if( tpTemplate->mClick[ i ].mProbability == 0 )
		{
			break;
		}

		if( tProbability < tpTemplate->mClick[ i ].mProbability )
		{
			tIsSelect = true;
			break;
		}
		
		tProbability -= tpTemplate->mClick[ i ].mProbability;
	}


	if( tIsSelect == false )
	{
		LOG_ERROR( "default", "[ %s : %d ][ %s ] Cannt Get The Proability( %d : %u ), tempid %d", __LK_FILE__, 
			__LINE__, __FUNCTION__, ( ( tSRand << 7 ) - tSRand ) % ( tProbabilityMax + 1 ), tProbabilityMax, 
			vpBox->GetNpcID( ) ); 
		return;
	}

	
	switch( tpTemplate->mClick[ i ].mEvent )
	{
		// storebox drop item
		case CTemplateBox::EVENT_DROPITEM:
			{
				vpBox->EntityDie( vpPlayer, false );
			}
			break;
		case CTemplateBox::EVENT_MACHINERY:
			{
				vpBox->MachinerySpring( vpBox, vpPlayer );
			}
			break;
        case CTemplateBox::EVENT_PICKFORYQS:
            {
				// 修改：只有摇钱树活动开启才能捡
				if (CActivityModule::GetSingleton().GetActivityStateByID(HELPID_YAOQIANSHU) == ACTIVITYSTATE_STARTED)
				{
					int liCreateID      = vpBox->GetCreatorID();
					vpBox->EntityDie( vpPlayer, false );

					int nTimerOtherInfo = MESSAGE_PROPERTY;
					CTimerMng::GetSingleton().SetTimer( liCreateID, TIMER_STOREBOXRELIVE, 1000, 1, &nTimerOtherInfo );
					//vpBox->GetTimerReciver()->SetTimer( vpBox->get_id(), TIMER_STOREBOXRELIVE, 2000, 1, nTimerOtherInfo );
				}
			}
			break;
		case CTemplateBox::EVENT_PICKFORCORPSBOSS:
			{
				vpBox->ChangeNpcByLevel(vpPlayer->GetLevel());
				vpBox->EntityDie( vpPlayer, false );
			}
			break;
		default:
			break;
	}

}

// 玩家拾取道具
void CPropertyModule::PlayerPickItem( CEntityPlayer* pPlayer, int vEntityID )
{
	if( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property IS NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( vEntityID ) );
	if ( tpEntity == NULL )
	{
		SendPickItemResponse( pPlayer, vEntityID );
		return;
	}

	if( tpEntity->IsDrop() == false )
	{
		return;	
	}

	// 如果已经死了，不能捡东西
	if ( pPlayer->IsAlive( ) == false )
	{
		return;
	}

	// 如果距离不够不能捡
	//if ( tpEntity->GetPos( ).LimitDistance( pPlayer->GetPos( ), PICKRANGE ) == false || tpEntity->GetMapID() != pPlayer->GetMapID() )
	if( tpEntity->IsWithinDistance( pPlayer, PICKRANGE ) == false ) 
		return;

	// 如果道具已经消失，退出
	if ( tpEntity->GetAliveStatus( ) == ALIVE_DIE )
	{
		return;
	}

	if ( tpEntity->GetEntityType() == ENTITYTYPE_ITEM || tpEntity->GetEntityType() == ENTITYTYPE_MONEY )
	{
		CEntityDrop* tpNpc = (CEntityDrop*) tpEntity;


		if ( tpNpc->GetEntityType() == ENTITYTYPE_ITEM )
		{
			CPropertyItem* tpItemProperty = ( CPropertyItem* )tpNpc->GetProperty();
			if( tpItemProperty == NULL )
				return;
			// 如果该玩家有权利获得该道具
			if ( tpItemProperty->IsOwner( pPlayer->GetCharID() ) || tpItemProperty->HasOwner() == false )
			{
				if ( tpItemProperty->GetItemID( ) == 0 )
				{
					int tItemID = tpNpc->GetNpcID( );

					CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tItemID, 1, false, tpItemProperty->GetLevel());
					if ( pInsItemPile )
					{
						// Log
						LogEventGetItemByPickup(pPlayer, pInsItemPile->GetGUID(), tItemID, 1, 
								pPlayer->GetPosX(), pPlayer->GetPosY(), tpItemProperty->GetLevel());

						CSceneLogic::GetSingleton( ).DestroyEntity( tpNpc, 0 );
						SendPickItemNotify( pPlayer, tItemID );
					}

				}
				else
				{
					CItemObject* tpItemObj = ( CItemObject* )CSceneObjManager::GetSingletonPtr()->GetObject( tpItemProperty->GetItemID( ) );
					if( tpItemObj == NULL )
					{
						LOG_ERROR( "pro", "[ %s : %d ][ %s ]Pick Item Object( %d ) Cannt find", __LK_FILE__, __LINE__,
								__FUNCTION__, tpItemProperty->GetItemID( ) );
						return;
					}			

					uint64_t ullGUID = tpItemObj->GetGUID();
					int nItemNum = tpItemObj->GetItemNum();

					CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tpItemObj );
					if ( pInsItemPile )
					{
						// 如果是拾取绑定物品则绑定物品
						if ( GetItemObjBindStatus( tpItemObj ) == ITEM_BINDSTATUS_FREE )
						{
							BindItem( pPlayer , tpItemObj , ITEM_BINDWAY_BYPICKUP );
						}

						// Log 
						LogEventGetItemByPickup(pPlayer, ullGUID, tpItemObj->GetItemID(), nItemNum, 
								pPlayer->GetPosX(), pPlayer->GetPosY(), 0);

						CSceneLogic::GetSingleton( ).DestroyEntity( tpNpc, 0 );
					}
				}
			}
			else
			{
				SendProErrorNotice( pPlayer, ERROR_PICK_CANNOT );
			}
			// 这里暂时先不做了,同队的玩家都能捡
		}
		else if ( tpNpc->GetEntityType() == ENTITYTYPE_MONEY )
		{
			CPropertyMoney* tpProperty = ( CPropertyMoney* )tpEntity->GetProperty();
			if( tpProperty == NULL )
			{
				LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) Cannt find CProperty", __LK_FILE__, __LINE__, 
						__FUNCTION__, tpEntity->GetEntityID( ) );
				return;
			}
			if (PlayerChangeMoney( pPlayer, tpProperty->GetMoney( ), false, false ) == SUCCESS)
			{
				LogEventGetMoneyByPickup(pPlayer, CYuanBao::em_unbind_money, tpProperty->GetMoney( ));
			}

			// 销毁道具
			CSceneLogic::GetSingleton( ).DestroyEntity( tpNpc, 0 );
		}
	}
}

void CPropertyModule::PlayerObtainMoney( CEntityPlayer* pEntity, int vInitMoney, int vDeltaMoney, int* pMemberList, int vMemberCount, int vLevel )
{
	if( pEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();

	int tMoney = vDeltaMoney == 0 ? vInitMoney : vInitMoney + rand( ) % vDeltaMoney;

	unsigned int tTotalLevel = pProperty->GetLevel( );		// 队伍中的等级和
	unsigned int tMaxLevel	 = pProperty->GetLevel( );		// 队伍中的最大等级
	CPropertyPlayer*		tpMemberProperty[ TEAMNUM ]	= { NULL };//{ pProperty, NULL, NULL, NULL, NULL, NULL };	
	CEntityPlayer*	tpMemberEntity[ TEAMNUM ]		= { NULL };//{ pEntity, NULL, NULL, NULL, NULL, NULL };
	// 如果玩家在队伍中
	if ( pMemberList != NULL )
	{
		for ( int i = 0; i < vMemberCount; i ++ )
		{
			CEntityPlayer* tpEntity = (CEntityPlayer*) CSceneLogic::GetSingleton().GetPlayerByCharID( pMemberList[ i ] );
			if( tpEntity == NULL )
				continue;

			CPropertyPlayer* tpProperty = (CPropertyPlayer*) tpEntity->GetProperty();


			// 如果该成员超过的分配距离，那么不参与分配计算
			//if ( tpEntity != NULL && tpEntity->GetPos( ).LimitDistance( pEntity->GetPos( ), TEAM_VALID_DISTANCE ) == false )
			if( tpEntity->IsWithinDistance( pEntity, TEAM_VALID_DISTANCE ) == false )
				continue;

			tpMemberProperty[ i ]	= tpProperty;
			tpMemberEntity[ i ]		= tpEntity;	

			if ( tpProperty == pProperty )
				continue;

			tTotalLevel += tpProperty->GetLevel( );
			if ( tMaxLevel < tpProperty->GetLevel( ) )
				tMaxLevel = tpProperty->GetLevel( );
		}		
	}
	
	// 不管有没有队伍，所有的成员都在tpMemberProperty这个数组中，就算没有队伍，该数组就一项成员
	for ( int i = 0; i < TEAMNUM && tpMemberProperty[ i ] != NULL && tpMemberEntity[ i ] != NULL; i ++ )
	{
		int tMoneyFinal = (int) ( tMoney * tpMemberProperty[ i ]->GetLevel( ) / (float) tTotalLevel );
		if ( tMoneyFinal != 0 )
		{
			if (PlayerChangeMoney( tpMemberEntity[ i ], tMoneyFinal, false, false ) == 0)
			{
				//TODO:				
			}
		}
	}
}

//***********************************
// FunctionName : PlayerObtainExp 
// Description  : 获得经验
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/26/2009]
//***********************************

int CPropertyModule::PlayerObtainExp( CEntityPlayer* pEntity, int vExp, int vReason /* = EXPREASON_TASK */, int* pMemberList /* = NULL */, int vMemberCount /* = 1 */, int vLevel /* = 0 */, CEntity* pNPCEntity /* = NULL */ )
{
	LK_ASSERT( pEntity != NULL, return  0);

	CTemplateLevelExp* tpLevelExp = (CTemplateLevelExp*) CDataStatic::GetTemp( TEMP_LEVELEXP );
	if ( tpLevelExp == NULL )
	{
		return 0;
	}

	if ( vReason == EXPREASON_OGRE )
	{
		// 经验倍率,只有打怪受到限制
		vExp = (int)( (double)(vExp) * (double)( CSceneCfgManager::GetSingleton().GetProperty_cfg()->mExp_award / SERVER_PERCENT_FLOAT ) );
	}
	else if( vReason == EXPREASON_TASK )
	{
		// 经验倍率,只有任务受到限制
		vExp = (int)( (double)(vExp) * (double)( CSceneCfgManager::GetSingleton().GetProperty_cfg()->mExp_task / SERVER_PERCENT_FLOAT ) );
	}

	// 如果有家族设置荣耀增长所需要的经验值
	if ( pEntity->GetFamilyID() > 0 )
	{
		CMemberInfo *tpMemberInfo = CFamilyModule::GetSingleton().GetFamilyMemberInfo( pEntity );
		if ( tpMemberInfo != NULL )
		{
			tpMemberInfo->mExpGloryNeeded += vExp;
		}
		//pEntity->SetExpGloryNeeded( pEntity->GetExpGloryNeeded() + vExp );
	}	

	// 如果传入的 pMemberList 为空 则默认为entity本身
	int tCharID=pEntity->GetCharID();
	if ( pMemberList == NULL && vMemberCount == 1 )
	{
		pMemberList=&tCharID;
	}
	
	unsigned int tTotalLevel = 0;				// 队伍中的等级和
	float tPunish	= 1.0f;						// 默认没有惩罚

	CEntityPlayer*	tpMemberEntity[ TEAMNUM ]		= { NULL };

	// 如果玩家在队伍中
	int tCount = 0;
	if ( pMemberList != NULL )
	{		
		for ( int i = 0; i < vMemberCount && i < TEAMNUM; i ++ )
		{
			CEntityPlayer* tpEntity = (CEntityPlayer*) CSceneLogic::GetSingleton().GetPlayerByCharID( pMemberList[ i ] );
			if ( tpEntity == NULL )
			{
				continue;
			}

			// 已获得经验的人为中心
			if( pNPCEntity != NULL && tpEntity->IsWithinDistance( pNPCEntity, TEAM_VALID_DISTANCE ) == false )
			{
				continue;
			}

			if ( tpEntity->IsAlive() == false )
			{
				continue;
			}

			tpMemberEntity[ tCount ]	= tpEntity;	
			tCount++;

			// 自己跳过
			//if ( pEntity == tpEntity )
			//	continue;

			CPropertyPlayer* tpProperty = (CPropertyPlayer*) tpEntity->GetProperty();
			tTotalLevel += tpProperty->GetLevel( );
		}
		
	}

	int tMWExp = vExp;  // 法宝获得经验 先存下来 等会要单独做衰减	
	int tExpFinal = 0;

	// 不管有没有队伍，所有的成员都在tpMemberProperty这个数组中，就算没有队伍，该数组就一项成员
	for ( int i = 0; i < tCount && i < TEAMNUM; i ++ )
	{
		CEntityPlayer* tpTeamPlayer = tpMemberEntity[ i ];
		CPropertyPlayer* tpProPlayer = (CPropertyPlayer*)tpTeamPlayer->GetProperty();
		float fBaseAddRate = 0.0f;
		int nTimes = 1;
#ifdef _FB_
		fBaseAddRate = 0.01;
		nTimes = tCount;
#else
		fBaseAddRate = 0.05;
		nTimes = 1;
#endif
		
		float fTeamRate = ( 1 + fBaseAddRate * ( tCount - 1 ) ) * ( tpProPlayer->GetLevel( ) + 10.0 ) / ( (float) tTotalLevel + 10 * tCount ) * nTimes;
		tExpFinal = (int) ( vExp *  fTeamRate);
		// 如果等级大于零，那么需要考虑等级差
		if ( vLevel > 0 )
		{
			int tLevelDelta = tpProPlayer->GetLevel( ) - vLevel;

			if ( tLevelDelta < 0 )
				tLevelDelta *= -1;

			// 修正过的经验惩罚
			if ( tLevelDelta <= 3 )
				tPunish = 1.0;
			else if ( tLevelDelta > 3 && tLevelDelta <= 18 )
				tPunish = 1.0 - ( tLevelDelta - 3 ) * 0.06;
			else if ( tLevelDelta > 18 )
				tPunish = 0.1;

			// 计算等级差的惩罚
			tExpFinal = (int) ( tExpFinal * tPunish );
		}
		tExpFinal = std::max( tExpFinal, 1 );

		// 根据原始经验获得离线经验
		int tOffLineExp = 0;
		if ( vReason == EXPREASON_OGRE || vReason == EXPREASON_TASK )
		{
			tOffLineExp = tpProPlayer->GetExpTimeInfo()->GetExpByRate( tExpFinal );
			if ( tpProPlayer->GetStateParam( STATE_INCOFFLINEEXP ).mInState == true )
			{
				tOffLineExp *= ( SERVER_PERCENT_INT + tpProPlayer->GetStateParam( STATE_INCOFFLINEEXP ).mParames1 ) / SERVER_PERCENT_FLOAT;
			}
		}

		// 如果玩家有双倍经验BUFF,并且打怪获得经验
		if ( vReason == EXPREASON_OGRE )
		{
			float tDoubleExp = SERVER_PERCENT_INT;
			//优先活动双倍，然后才会是个人领双
			if ( tpProPlayer->IsActivityDouble() )
			{
				tDoubleExp += tpProPlayer->GetActivityState();
			}else if ( tpProPlayer->UnFreezeDouble() )
			{
				tDoubleExp += SERVER_PERCENT_INT;
			}

			if ( tpProPlayer->GetStateParam( STATE_INCEXP ).mInState == true )
				tDoubleExp += tpProPlayer->GetStateParam( STATE_INCEXP ).mParames1;

			// 先乘会越界
//			tExpFinal = tExpFinal * ( tDoubleExp / SERVER_PERCENT_INT );
			tExpFinal = tExpFinal * ( tDoubleExp / SERVER_PERCENT_FLOAT );			
			PlayerObtainTalentExp( tpTeamPlayer, tExpFinal / CSceneCfgManager::GetSingleton().GetProperty_cfg()->mTalentexp );
			
			// 修炼经验丹获取经验
			AddExpToExpContainer( tpTeamPlayer, tExpFinal );
		} 		
		
		// 这里处理防沉迷
		if ( tpTeamPlayer->GetFcmStatus() == em_none_rate )
		{
			continue;
		}
		else if ( tpTeamPlayer->GetFcmStatus() == em_half_rate )
		{
			tExpFinal = tExpFinal * 0.5;
		}
		bool tLevelUp = false;

		// 如果是打怪获得 还要考虑法宝
		if ( vReason == EXPREASON_OGRE )
		{
			CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpProPlayer->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
			if ( tpMW != NULL )
			{
				// 策划最新要求：法宝获得经验基础值 用法宝的等级再衰减一遍
				int tLevelDelta = tpMW->GetMWLevel() - vLevel;
				tPunish	= 1.0f;	
				// 修正过的经验惩罚
				if ( tLevelDelta <= 3 )
					tPunish = 1.0;
				else if ( tLevelDelta > 3 && tLevelDelta <= 18 )
					tPunish = 1.0 - ( tLevelDelta - 3 ) * 0.06;
				else if ( tLevelDelta > 18 )
					tPunish = 0.1;

				// 计算等级差的惩罚
				tMWExp = (int) ( tMWExp * tPunish );

				if ( tpProPlayer->GetAssignExpScl() > 0 && tpProPlayer->GetLevel( ) < MAX_GRADE ) // 只有小于MAX_GRADE才予以分配
				{
					tMWExp += (int)((double)tExpFinal*tpProPlayer->GetAssignExpScl()/100); // 加上玩家额外分配的
				}

				if ( 0 == OnMagicWeaponObtainExp( tpTeamPlayer, tMWExp ) ) // 给法宝加经验成功 扣除玩家的
				{
					// 要把玩家获得的经验减去法宝分配走的
					tExpFinal -= (int)((double)tExpFinal*tpProPlayer->GetAssignExpScl()/100);
				}
			}
		}


		if ( tpProPlayer->GetLevel( ) >= MAX_GRADE || tExpFinal <= 0 )
			continue;

		tpProPlayer->SetExp( tpProPlayer->GetExp( ) + tExpFinal + tOffLineExp );

		if ( tOffLineExp != 0 )
		{
			LogEventGetExpByOffLine( tpTeamPlayer, tExpFinal, tOffLineExp, tpProPlayer->GetExpTimeInfo()->GetExpFromOffLine() );
		}

		if ( vReason == EXPREASON_OGRE && pNPCEntity != NULL)
		{			
			LogEventGetExpByEntityDie( tpTeamPlayer, vExp, tExpFinal, vMemberCount, pNPCEntity ? pNPCEntity->GetNpcID() : 0);			
		}
		
		// 升的级数
		int tUpLevel = 0;

		while ( tpProPlayer->GetExp( ) >= tpLevelExp->mLevelExp[ tpProPlayer->GetLevel( ) ] && tpProPlayer->GetLevel( ) < MAX_GRADE )
		{
			tpProPlayer->SetExp( tpProPlayer->GetExp( ) - tpLevelExp->mLevelExp[ tpProPlayer->GetLevel( ) ] );
			tpProPlayer->LevelUp( );
			tLevelUp = true; 
			tUpLevel++;

			if (tpProPlayer->GetLevel( ) == MAX_GRADE )
				tpProPlayer->SetExp( 0 );

/*			tpTeamPlayer->GetExp()	= tpProPlayer->GetExp( );
			tpTeamPlayer->GetLevel()	= tpProPlayer->GetLevel( );			*/	
		}

		if ( tLevelUp == true )
		{
			OnPlayerLevelUp( tpTeamPlayer, tUpLevel );
		}

		//// 把消息发送给得到经验的玩家
		if ( tExpFinal > 0 )
		{
			SendObtainExpNotice( tpTeamPlayer, tExpFinal, tpProPlayer->GetExp( ), 
				GetResultList( )->GetListID(), tLevelUp, tOffLineExp, tpProPlayer->GetExpTimeInfo()->GetExpFromOffLine() );
			ResultListSend( );
		}		

		// 只有超过一定数值的经验才记录或者升级时记录一次，否则logserver日志量太大了
		if( (tExpFinal >= 2000) || tLevelUp )
		{
			// 记录玩家获得经验到日志服务器
			/*
			CSceneLogic::GetSingleton( ).Send2Log( 
					BuildObtainExpLogMessage( tpTeamPlayer, tExpFinal, vReason ), 
					(int)EIHANDLE_ONE, tpTeamPlayer->GetCharID() );
			*/
		}
	}

	return tExpFinal;
}

int CPropertyModule::CloseAureole( CEntityCharacter* pEntity )
{
	int						tSkillTempID = 0;
	int						j = 0;
	int						i = 0;
	CEntityCharacter* 		tpEntityList[ FUNC_LIMIT ] = { NULL };

	CTemplateAureoleSkill* 	tpSkill = NULL;
	int tEntityCount = 0;

	if( pEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return 0;
	}

	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();

	if( pProperty->GetStateParam( STATE_AUREOLE ).mInState == false )
	{
		// pProperty not open aureole
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) not open aureole", __LK_FILE__, __LINE__, __FUNCTION__,
				pEntity->GetEntityID( ) );
		return -1;
	}

	tSkillTempID = pProperty->GetStateParam( STATE_AUREOLE ).mParames1;

	tpSkill = ( CTemplateAureoleSkill* )CDataStatic::SearchTpl( tSkillTempID );
	if( tpSkill == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) Opened Aureole Skill( %d ) Cann't find", __LK_FILE__, __LINE__,
				__FUNCTION__, pEntity->GetEntityID( ), tSkillTempID );
		goto CALL_BACK;
	}

	for ( int i = 0; i < TEAMNUM; i++ )
	{
		CEntityCharacter* tpEntity = pEntity->GetAureoEntity( i );
		if ( tpEntity == NULL )
			break;

		tpEntityList[ tEntityCount ] = tpEntity;
		tEntityCount++;
	}
	
	// 光环影响实体由客户端上报
	//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体
	//CMapModule::GetSingletonPtr()->GetRangeEntity(
	//		pEntity->GetLineID(),
	//		pEntity->GetMapID(),
	//		pEntity->GetMapIndex(),
	//		CTemplateNormalSkill::RANGE_SELFCIRCLE,
	//		tpSkill->mAureoleDistance,
	//		0,
	//		pEntity,
	//		tpEntityList,
	//		&tEntityCount
	//		);

	for( i = 0; i < tEntityCount; i++ )
	{
		if( tpEntityList[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) UseSkill( %d : %d ), Call "
					"Map_GetRangeEntity tResult count error index %d is NULL", __LK_FILE__, __LINE__,
					__FUNCTION__, pEntity->GetEntityID( ), tpSkill->mSkillID, tpSkill->mSkillLevel, i );
			break;
		}

		CPropertyCharacter* tpProperty = ( CPropertyCharacter* )tpEntityList[ i ]->GetProperty();
		if( tpProperty == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ] Entity( %d ) UseSkill %d Level %d, Cannt find"
					"Entity( %d ) property", __LK_FILE__, __LINE__, __FUNCTION__,pEntity->GetEntityID( ),
					tpSkill->mSkillID, tpSkill->mSkillLevel, tpEntityList[ i ]->GetEntityID( ) );
			continue;
		}

		// 这段循环内删除BUFF有问题,应该反向遍历,否者不可在循环内删除
		for( j = 0; j < (int)ARRAY_CNT( tpSkill->mAureoleType ); j++ )
		{
			for ( int k = 0; k < tEntityCount && k < (int)sizeof( tpEntityList ); k++ )
			{
				tpEntityList[ i ]->EntityRemoveBuff( tpSkill->mAureoleType[ j ].mBuffID ); 
				LogEventLostBuffByCloseAureole(( CEntityPlayer * )tpEntityList[ i ],tpSkill->mAureoleType[ j ].mBuffID );  // 关闭光环失去
				LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
			}
		}
	} 

	pEntity->ClearAureoEntityList();

	pProperty->DetachState( STATE_AUREOLE, 0, SKILL ); 

CALL_BACK:
	LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Entity( %d ) Close Aureole( %d ) End", __LK_FILE__, __LINE__, __FUNCTION__,
			pEntity->GetEntityID( ), tSkillTempID );

	return 0;
}

bool AureoleAllSelect( CEntity* pSrcEntity, CEntity* pDesEntity, int vParame )
{
	if( pSrcEntity->GetEntityID( ) == pDesEntity->GetEntityID( ) )
		return false;
	return true;
}

int CPropertyModule::UseAureoleSkill( CEntityCharacter* pEntity, CTemplateAureoleSkill* pAureoleSkill, CEntityCharacter** vEntityList, int vEntityListNum )
{
	int i = 0;
	CTemplateBuff* tpBuffTpl = NULL;

	if( pEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Or Property Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return 0;
	}

	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();

	if( pProperty->GetStateParam( STATE_AUREOLE ).mInState == true )
	{
		return -1;
	}

	LOG_DEBUG( "pro", "[ %s : %d ][ %d ]Entity( %d ) Fitout Open Aureole( TempID is %d ) Begin", __LK_FILE__, __LINE__, 
			__FUNCTION__, pEntity->GetEntityID( ), pAureoleSkill->mTempID );

	// TODO: 现在只有对小队作用的光环,暂时不支持负面光环
	CEntityCharacter* tpEntityList[ TEAMNUM ] = { NULL };
	int tEntityCount = 0;
	if ( vEntityList == NULL || vEntityListNum <= 0 )
		return 0;
	
	pEntity->ClearAureoEntityList();

	for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
	{
		if ( vEntityList[ i ] == NULL )
			continue;

		if ( vEntityList[ i ]->GetEntityType() != ENTITYTYPE_PLAYER )
			continue;

		CEntityPlayer* tpPlayer = (CEntityPlayer*) vEntityList[ i ];
		if ( tpPlayer->IsTeamTo( pEntity ) == false )
			continue;

		if ( pEntity->IsWithinDistance( tpPlayer, pAureoleSkill->mAureoleDistance ) == false )
			continue;

		pEntity->AddAureoEntityList( vEntityList[ i ] );
		tpEntityList[ tEntityCount ] = vEntityList[ i ];
		tEntityCount++;

		if ( tEntityCount >= TEAMNUM )
			break;
	}
	
	for( i = 0; i < (int)ARRAY_CNT( pAureoleSkill->mAureoleType ); i++ )
	{
		if( pAureoleSkill->mAureoleType[ i ].mAureoleArea == CTemplateAureoleSkill::AUREOLE_NONE )
		{
			continue;
		}
		tpBuffTpl = ( CTemplateBuff* )CDataStatic::SearchTpl( pAureoleSkill->mAureoleType[ i ].mBuffID );
		if( tpBuffTpl == NULL )
		{
			LOG_DEBUG( "pro", "[ %d : %s ][ %d ]Entity( %d ) Fiout Open Aureole, cannt find buff( TempID is %d, index"
					" is %d )", __LK_FILE__, __LINE__, __FUNCTION__, pEntity->GetEntityID( ), 
					pAureoleSkill->mAureoleType[ i ].mBuffID, i );
			continue;
		}
		
		for ( int j = 0; j < tEntityCount && j < (int)ARRAY_CNT( tpEntityList ); j++ )
		{
			
			tpEntityList[ j ]->EntityInsertBuff( pEntity, tpBuffTpl );
			int tBuffID = pAureoleSkill->mAureoleType[ i ].mBuffID;
			LogEventGetBuffByPlayer(( CEntityPlayer * )tpEntityList[ j ],tBuffID,tpBuffTpl->mLastTime,pAureoleSkill->mSkillID,(( CEntityPlayer * )pEntity)->GetCharID() ) ;
		}
				
	}			

	LOG_DEBUG( "pro", "[ %s : %d ][ %d ]Entity( %d ) Fitout Open Aureole( TempID is %d ) End", __LK_FILE__, __LINE__, 
			__FUNCTION__, pEntity->GetEntityID( ), pAureoleSkill->mTempID );

	pProperty->AttachState( STATE_AUREOLE, pAureoleSkill->mTempID, pAureoleSkill->mIncessaryTime, 0, SKILL );

	LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Entity( %d ) Opened Aureole( TempID is %d )", __LK_FILE__, __LINE__, 
			__FUNCTION__, pEntity->GetEntityID( ), pAureoleSkill->mTempID );

	return 0;
}

//void CPropertyModule::GetEntityList( vector< CFuncResult >& rResultList, vector< CEntity* >& rEntityList )
//{
//	for ( size_t i = 0; i < rResultList.size( ); i ++ )
//	{
//		bool tEntityExist = false;
//		for ( size_t j = 0; j < rEntityList.size( ); j ++ )
//		{
//			if ( rEntityList[ j ]->GetEntityID( ) == rResultList[ i ].GetEntityID( ) )
//			{
//				tEntityExist = true;
//				break;
//			}
//		}
//
//		if ( tEntityExist == false )
//		{
//			CEntity* tpEntity = CSceneLogic::GetSingleton( ).GetEntity( rResultList[ i ].GetEntityID( ) );
//			if ( tpEntity == NULL )
//			{
//				LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] tpEntity is NULL tpEntityID is %d", __LK_FILE__, __LINE__, __FUNCTION__, rResultList[ i ].GetEntityID( ) );
//				continue;
//			}
//			if ( rEntityList.size( ) < FUNC_LIMIT )
//				rEntityList.push_back( tpEntity );
//		}
//	}
//}

bool CPropertyModule::SkillWeaponValid( CPropertyPlayer* pSrcProperty, CTemplateSkill* pSkill )
{
	// 判断技能攻击方式
	int tWeaponType = 0;
	CItemObject* tpWeapon = pSrcProperty->GetEquipment( )->GetItemObjPtr( EQUIPMENT_WEAPON );
	if ( tpWeapon == NULL )
		return false;

	CTemplateWeapon* tpWeaponTpl = ( CTemplateWeapon* ) CDataStatic::SearchTpl( tpWeapon->GetItemID() );
	if ( tpWeaponTpl == NULL )
		return false;     	
	tWeaponType = tpWeaponTpl->mWeaponType;
	// 如果技能需求武器不满足要求
	if ( pSkill->mRequireWeapon != CTemplateWeapon::WEAPON_UNLIMIT && tWeaponType != CTemplateWeapon::WEAPON_UNLIMIT && 
			pSkill->mRequireWeapon != tWeaponType )
		return false;

	return true;
}


// 装备是否可用
bool CPropertyModule::EquipmentAvailable( CEntity* pEntity ,int EptPart )
{
	if ( pEntity == NULL )
	{
		// error
		return false;
	}
	if ( pEntity->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		// error
		return false;
	}

	CPropertyPlayer *tpProperty =( CPropertyPlayer * ) pEntity->GetProperty();

	if ( tpProperty == NULL )
	{
		// error 
		return false;
	}

	CEquipment	* tpEquipment = tpProperty->GetEquipment( );
	if ( tpEquipment == NULL )
	{
		return false;
	}
	CItemEquipment * pItemObjPtr = ( CItemEquipment * )tpEquipment->GetItemObjPtr( EptPart );
	if ( pItemObjPtr == NULL )
	{
		return false;
	}
	// 装备是否损坏
	if ( pItemObjPtr->GetDurability( )  == 0  )
	{
		return false;
	}	
	return true;

}

// 进行一次攻击或者被攻击后减少玩家的装备耐久度
void CPropertyModule::EquipmentDurability( CEntity *pEntity, int  IsAttacker , int EntityType )
{	    

	if( pEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}	

	if ( pEntity->GetEntityType( ) != ENTITYTYPE_PLAYER )
	{
		//LOG_DEBUG( "pro", "[ %s : %d ][ %s ]CEntity  Is Not Player", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	} 
		
	// EntityType 表示交互类型 1表示玩家和npc之间的交互 0表示玩家之间的交互 
	if( ( ( CEntityPlayer* )pEntity )->IsHandle( UN_HANDLE_DURA ) == false )
	{
		return;
	}

	CItemEquipment* pItemObjPtr = NULL ;							// 装备指针
	CMessage tMessageHead;											// 消息头
	CMessageNotifyEqptDurability  MsgDurability;					// 耐久度改变的通知消息


	CPropertyPlayer *pProperty   = ( CPropertyPlayer * ) pEntity->GetProperty( );		// 获取人物属性		
	bool bIfNeedRefresh			 = false;							// 是否需要刷新装备带来的人物属性	
	int bIfHardinessReduced		 = 0;								// 装备耐久是否降低
	CEquipment* tpEquipment = pProperty->GetEquipment( );			// 物品装备

	// 攻击者
	if ( IsAttacker == 1 )
	{
		/*  攻击方的装备耐久度的变化   */
		// 获取人物装备的武器信息			
		int tEquipPart[ MAXEQUIPMENTINDEX ] = { EQUIPMENT_WEAPON, EQUIPMENT_CUFFLEFT,  EQUIPMENT_CUFFRIGHT };
		int tEquipPartNum = 3;
		
		for ( int i = 0; i < tEquipPartNum; ++i )
		{
			pItemObjPtr = ( CItemEquipment * )tpEquipment->GetItemObjPtr( tEquipPart[i] );
			if ( pItemObjPtr != NULL )
			{
				bIfHardinessReduced = pItemObjPtr->ReduceDurability( EntityType );
				if ( bIfHardinessReduced == 1 )
				{			
					if ( bIfNeedRefresh == false && pItemObjPtr->GetDurability() == 0 )
					{
						bIfNeedRefresh = true;
					}

					MsgDurability.add_eqptindex( tEquipPart[i] );
					MsgDurability.add_eqptdurability( pItemObjPtr->GetDurability() );				
				}
			}
		}				
	}	

	// 被攻击者	
	if( IsAttacker == 0 )
	{   
		/*  被攻击方的装备耐久度的变化   */             
		// 获取人物装备的护头信息
		int tEquipPart[ MAXEQUIPMENTINDEX ] = { EQUIPMENT_HEAD, EQUIPMENT_CHEST,  EQUIPMENT_LEG, EQUIPMENT_CHARMLEFT, EQUIPMENT_CHARMRIGHT, EQUIPMENT_BALL, EQUIPMENT_CLOAK, EQUIPMENT_SASH };
		int tEquipPartNum = 8;
		
		for ( int i = 0; i < tEquipPartNum; ++i )
		{
			pItemObjPtr = ( CItemEquipment * )tpEquipment->GetItemObjPtr( tEquipPart[i] );
			if ( pItemObjPtr != NULL )
			{
				bIfHardinessReduced = pItemObjPtr->ReduceDurability( EntityType );
				if ( bIfHardinessReduced == 1 )
				{			
					if ( bIfNeedRefresh == false && pItemObjPtr->GetDurability() == 0 )
					{
						bIfNeedRefresh = true;
					}	
					MsgDurability.add_eqptindex( tEquipPart[i] );
					MsgDurability.add_eqptdurability( pItemObjPtr->GetDurability()  );				
				}
			}		
		}			
	}
	
	// 刷新玩家属性
	if ( bIfNeedRefresh == true )
	{	
		pProperty->Refresh();
		((CEntityPlayer*)pEntity)->NotifyPropertyRefresh( );
		// 把玩家MP和HP值的改变情况广播出去
		CMessageEntityRefreshNotice FreshMsg;
		CreateMessageEntityRefreshNotice( &tMessageHead, &FreshMsg, pEntity->GetEntityID(), pProperty->GetCurHP( ),  
			pProperty->GetCurMP( ), pProperty->GetMaxHP( ),  pProperty->GetMaxMP( ) );
		CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tMessageHead );
	}
	/*发送装备耐久度的更新消息给攻击方*/ 
	if( MsgDurability.eqptindex_size() > 0 )
	{			
		MsgDurability.set_isinpackage( 0 );	
		tMessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS  );
		tMessageHead.set_msgpara( ( int )&MsgDurability );			
		CSceneLogic::GetSingletonPtr()->Send2Player( ( CEntityPlayer * )pEntity, &tMessageHead );
	}	 	
	return;
}

void CPropertyModule::ChangeDurabilityOnDeath( CEntity* pEntity )
{
	CItemEquipment *tpItemEquipment = NULL ;              // 装备指针
	CEquipment     *tpEquipment = NULL;                  // 装备包裹指针
	CPropertyPlayer *tpProperty = NULL;                  // 人物属性指针
	CMessage MessageHead;
	CMessageNotifyEqptDurability DurabilityMessage;
	int  EptNum =0;
	int IfDurabilityChanged = 0 ;
	bool IfNeedRefresh = false;
	if ( pEntity == NULL )
	{
		return;
	}
	if ( pEntity->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		return ;
	}

	if( ( ( CEntityPlayer* )pEntity )->IsHandle( UN_HANDLE_DURA ) == false )
	{
		return;
	}

	tpProperty = ( CPropertyPlayer * ) pEntity->GetProperty();
	if ( tpProperty == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] CPropertyPlayer of EntityID:%d does not exist", __LK_FILE__,__LINE__,__FUNCTION__ , pEntity->GetEntityID() );
		return ;
	}

	tpEquipment = tpProperty->GetEquipment( );

	if ( tpEquipment == NULL )
	{
		return;
	} 
	EptNum = 0;
	for ( int i = 0;i < MAXEQUIPMENTINDEX;i++ )
	{
		tpItemEquipment = ( CItemEquipment * )tpEquipment->GetItemObjPtr( i );
		if ( tpItemEquipment != NULL )
		{  			
			IfDurabilityChanged = tpItemEquipment ->ReduceDurability( 1,0 );
			if ( IfDurabilityChanged == 1 )
			{
				if (  IfNeedRefresh == false && tpItemEquipment->GetDurability() == 0 )
				{
					IfNeedRefresh = true;	
				}				
				DurabilityMessage.add_eqptdurability( tpItemEquipment->GetDurability()  );
				DurabilityMessage.add_eqptindex( i );				
				EptNum ++;
			}
		}
	}
	if ( EptNum > 0 )
	{
		if( IfNeedRefresh == true )
		{
			tpProperty->Refresh();
			((CEntityPlayer*)pEntity)->NotifyPropertyRefresh( );
			// 把玩家MP和HP值的改变情况广播出去
			CMessageEntityRefreshNotice FreshMsg;
			CreateMessageEntityRefreshNotice( &MessageHead, &FreshMsg, pEntity->GetEntityID(), tpProperty->GetCurHP( ),  
					tpProperty->GetCurMP( ), tpProperty->GetMaxHP( ),  tpProperty->GetMaxMP( ) );
			CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &MessageHead );
		}
		DurabilityMessage.set_isinpackage( 0 );
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS );
		MessageHead.set_msgpara( (int)&DurabilityMessage );
		CSceneLogic::GetSingletonPtr()->Send2Player( pEntity , &MessageHead );
	}
	return ;
}

// 修理玩家的装备
void CPropertyModule::OnMessageMendEquipment( CEntityPlayer *pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return  )	
	CMessageMendEquipment *tpMessage = ( CMessageMendEquipment * )pMessage->msgpara();
	LK_ASSERT( tpMessage != NULL, return )
	
	// 判断npc的服务和距离
	CEntityNpc* tpEntity = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMessage->entityid() ) );
	LK_ASSERT( tpEntity != NULL, return )
	if ( tpEntity->GetEntityType() != ENTITYTYPE_FUNCNPC )
	{
		return;
	}

	// 服务判断
	CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
	CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
	LK_ASSERT( tpTmpNpc != NULL, return )
	if ( tpTmpNpc->mSellServiceID == 0 )
	{
		return;
	}
	
	// 距离判断
	if ( pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) == false )
	{
		return;
	}
	
	CPropertyPlayer  *tpProperty    = ( CPropertyPlayer  * ) pPlayer->GetProperty();
	int IfMendAllEupt = 0;
	if ( tpProperty == NULL )
	{
		return;
	}

	IfMendAllEupt = tpMessage->isallequipment( );   
	if ( IfMendAllEupt == 1 )
	{
		MendAllEquipment( pPlayer );
		return;
	}
	if ( IfMendAllEupt == 0 )
	{
		MendSigleEquipment( pPlayer, tpMessage->isinpackage(), tpMessage->index() );
	}
	return;
}

// 修理玩家身上所有装备
bool CPropertyModule::MendAllEquipment( CEntityPlayer *pPlayer )
{ 		
	if( pPlayer == NULL )
	{
		LOG_ERROR(" propertymodule ", "[%s,%d][%s] NULL CEntityPlayer  ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return false;
	}
	if ( pPlayer->GetEntityType() != ENTITYTYPE_PLAYER  )
	{
		return false;
	}
	CMessageNotifyEqptDurability  MsgPackageItem;
	CMessageNotifyEqptDurability  MsgBodyItem ;
	CMessaegMendEquipmentCallBack MsgCallBack;		
	CEquipment *pEuipment = NULL ;						  // 玩家身上的装备包裹
	CItemEquipment *tpItemEquipment = NULL ;              // 装备指针
	CPropertyPlayer *pSrcProperty  = NULL;	
	int		 MendMoney = 0;                                    // 总共需要修理的金钱总数
	int      ItemMendMoney = 0;
	bool	 IfNeedRefresh = false;	  
	pSrcProperty = ( CPropertyPlayer * ) pPlayer->GetProperty(); 
	if( pSrcProperty == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s]  CEntityPlayer of EntityID:%d does not exist!",__LK_FILE__,__LINE__,__FUNCTION__, pPlayer->GetEntityID() ) ;
		return false;
	} 
	pEuipment = pSrcProperty->GetEquipment( ); 
	if ( pEuipment == NULL )
	{
		return false;
	}

	// 检查玩家身上的装备
	for ( int i = 0; i < MAXEQUIPMENTINDEX ; i++ )
	{		
		tpItemEquipment = ( CItemEquipment *)pEuipment->GetItemObjPtr( i );
		if ( tpItemEquipment == NULL )
		{
			continue;
		} 		
		if ( IfNeedRefresh == false && tpItemEquipment->GetDurability() == 0 )
		{
			IfNeedRefresh = true;
		}
		ItemMendMoney = tpItemEquipment->GetMendMoney( );	
		if( ItemMendMoney > 0 ||  tpItemEquipment->GetLostDurability() > 0  )
		{ 
			// 将需要修改的道具索引添加到消息中
			MendMoney += ItemMendMoney;				
			MsgBodyItem.add_eqptindex( i ) ;
		}		 
	}		

	// 检查包裹中的装备
	int vBagCount = ( int )pSrcProperty->GetBaggage( )->mReleaseIndex;

	CItemBoxToolkit tBoxToolkit(pSrcProperty->GetBaggage( ));
	for ( int i = 0 ; i < vBagCount; i++ )
	{
		ItemMendMoney = tBoxToolkit.GetEquipMendMoney( i );
		if( ItemMendMoney >= 0 )
		{
			MendMoney += ItemMendMoney;					
			MsgPackageItem.add_eqptindex( i );
		}
		
	}
	
	// 检查包裹背包的物品
	for ( int i = 0; i < pSrcProperty->GetBaggage()->GetKitBagIndex(); ++i )
	{
		int tBeginIndex = -1;
		int tEndIndex	= -1;
		int tRet = pSrcProperty->GetBaggage()->GetKitBagIndexRange( BAGTYPE_KITBAG, i, tBeginIndex, tEndIndex );
		if ( tRet != SUCCESS )
		{
			continue;
		}
		
		for ( int j = tBeginIndex; j <= tEndIndex; ++j )
		{
			ItemMendMoney = tBoxToolkit.GetEquipMendMoney( j  );
			if( ItemMendMoney >= 0 )
			{
				MendMoney += ItemMendMoney;					
				MsgPackageItem.add_eqptindex( j  );
			}					
		}
	}
	
	if( MendMoney == 0 && MsgPackageItem.eqptindex_size() == 0 && MsgBodyItem.eqptindex_size() == 0 )
	{
		// 装备不需要修理				
		SendProErrorNotice( pPlayer, EUIPMENT_MENDNOTNEED );	
		return false;
	}
	
	// 判断身上金钱(金币+绑定金钱)是否大于修理费   
	CTemplateBeginner *tpBeginner = ( CTemplateBeginner * )CDataStatic::spBeginner;
	LK_ASSERT( tpBeginner != NULL, return false );	
	unsigned int tBaggageMoney = ( unsigned int )pSrcProperty->GetMoney(); 
	if ( tpBeginner->mCanMendUseBindMoney == 0 )
	{											
		tBaggageMoney +=  pSrcProperty->GetBindMoney();
	} 
	if ( (unsigned int)MendMoney > tBaggageMoney )
	{
		// 金钱不够
		SendProErrorNotice( pPlayer , EUIPMENT_MONEYNOTENOUGH );
		return false;
	}	  

	// 更新玩家身上装备耐久度消息
	if (  MsgBodyItem.eqptindex_size() > 0 )
	{		
		// 重置装备耐久度，将装备耐久度的更新值添加到消息中
		for ( int i = 0 ; i < MsgBodyItem.eqptindex_size() ; i++ )
		{	

			tpItemEquipment = ( CItemEquipment *)pEuipment->GetItemObjPtr( MsgBodyItem.eqptindex( i ) );		
			MsgBodyItem.add_eqptdurability(  tpItemEquipment->ResetDurability() );
		}
		CMessage                     MessageHead;			
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS );
		MsgBodyItem.set_isinpackage( 0 );
		MessageHead.set_msgpara( ( int ) &MsgBodyItem );
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer , &MessageHead );
	}

	// 更新包裹中装备耐久度消息
	if ( MsgPackageItem.eqptindex_size() > 0 )
	{
		for ( int i = 0; i < MsgPackageItem.eqptindex_size(); i++ )
		{
			tpItemEquipment = ( CItemEquipment * )pSrcProperty->GetBaggage( )->GetItemObjPtr( MsgPackageItem.eqptindex( i ) );
			MsgPackageItem.add_eqptdurability(  tpItemEquipment->ResetDurability());
		}
		CMessage    MessageHead;
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS );	
		MsgPackageItem.set_isinpackage( 1 ); 
		MessageHead.set_msgpara( (int)&MsgPackageItem ); 
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer,&MessageHead );
	}	
	// 刷新玩家的人物属性
	if ( IfNeedRefresh == true )
	{
		CMessage        MsgHead; 		
		pSrcProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		CMessageEntityRefreshNotice FreshMsg;
		CreateMessageEntityRefreshNotice( &MsgHead, &FreshMsg, pPlayer->GetEntityID(), pSrcProperty->GetCurHP( ), pSrcProperty->GetCurMP( ), pSrcProperty->GetMaxHP( ),  pSrcProperty->GetMaxMP( ) );
		CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &MsgHead );
	}					
		
	// 发送操作结果		
	SendProErrorNotice( pPlayer, EUIPMENT_SUCCESS ); 
	  	
	// 扣除修理金钱
	int tBindMoney = 0;
	int tMoneyCharge = 0;
	if ( tpBeginner->mCanMendUseBindMoney == 0 )
	{
		tBindMoney = MendMoney>pSrcProperty->GetBindMoney()?pSrcProperty->GetBindMoney():MendMoney;				
	}
	tMoneyCharge = MendMoney - tBindMoney; 									
	if (PlayerChangeMoney( pPlayer, tBindMoney, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByRepairAll(pPlayer, CYuanBao::em_bind_money, tBindMoney);
	}
	
	if ( tMoneyCharge > 0 && PlayerChangeMoney( pPlayer, tMoneyCharge, true, false) == SUCCESS)
	{
		LogEventLostMoneyByRepairAll(pPlayer, CYuanBao::em_unbind_money, tMoneyCharge);
	}
	return true;
}

// 修理单个装备
void CPropertyModule::MendSigleEquipment( CEntityPlayer *pPlayer , int IsInPackage, int Index )
{
	CEquipment *tpBodyEuipment = NULL ;     // 身上装备列表
	CItemObject * tpObject = NULL;                                       
	CTplItem    * tpTplItem = NULL;
	CItemEquipment *tpItemEquipment = NULL;
	int             MendMoney = 0;
	CMessage    MessageHead;
	CMessageNotifyEqptDurability NotifyDurability;
	CMessaegMendEquipmentCallBack MsgCallBack;
	CPropertyPlayer* pSrcProperty ;
	bool IfNeedRefresh = false;
	
	// 获取是否能够使用绑定金钱的模板数据
	CTemplateBeginner *tpBeginner = ( CTemplateBeginner * )CDataStatic::spBeginner;
	LK_ASSERT( tpBeginner != NULL, return );
	if( pPlayer == NULL )
	{
		return;
	}
	if ( pPlayer->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		return;
	}
	pSrcProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	if ( pSrcProperty == NULL )
	{
		return;
	}
	tpBodyEuipment    = pSrcProperty->GetEquipment( );
	// 修理的道具在包裹中
	if ( IsInPackage == 1 )
	{	  
		tpObject = pSrcProperty->GetBaggage( )->GetItemObjPtr( Index );
		if( tpObject == NULL )
		{
			return;
		}
		if ( tpObject->GetLockStatus() != LOCKTYPE_NONE )
		{
			return;
		}

		tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpObject->GetItemID() );
		if ( tpTplItem == NULL )
		{
			LOG_ERROR( "pro","[%s,%d][%s]  Item ( ItemID:%d )does not exist in template  ",__LK_FILE__,__LINE__,__FUNCTION__,tpObject->GetItemID() );
			return;
		}
		if ( !tpTplItem->IsEquipable() )
		{
			LOG_ERROR( "pro","[%s,%d][%s] Item Can Not Be Equiped %d",__LK_FILE__,__LINE__,__FUNCTION__, tpTplItem->mTempID );
			return;
		}
		tpItemEquipment = ( CItemEquipment * )tpObject;
		MendMoney = tpItemEquipment->GetMendMoney( );
		if( MendMoney == 0 &&  tpItemEquipment->GetLostDurability() == 0 )
		{
			// 不需要修理消息
			SendProErrorNotice( pPlayer , EUIPMENT_MENDNOTNEED );
			return;
		}		

		if( MendMoney > 0 || tpItemEquipment->GetLostDurability() > 0 )
		{ 

			unsigned int tBaggageMoney = ( unsigned int )pSrcProperty->GetMoney(); 
			if ( tpBeginner->mCanMendUseBindMoney == 0 )
			{											
				tBaggageMoney +=  pSrcProperty->GetBindMoney();
			}
			
			if ( (unsigned int)MendMoney > tBaggageMoney )
			{
				// 金钱不够
				SendProErrorNotice( pPlayer , EUIPMENT_MONEYNOTENOUGH );
				return;
			}	  
			
			// 重置装备耐久度，发送装备更新的消息			
			MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS );
			NotifyDurability.set_isinpackage( 1 );
			NotifyDurability.add_eqptindex ( Index );
			NotifyDurability.add_eqptdurability( tpItemEquipment->ResetDurability( ) );
			MessageHead.set_msgpara( (int)&NotifyDurability );
			CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead ); 
			SendProErrorNotice( pPlayer , EUIPMENT_SUCCESS );  
		}  		
	}

	// 在身上
	else if ( IsInPackage == 0 )
	{
		tpItemEquipment = ( CItemEquipment *)tpBodyEuipment->GetItemObjPtr( Index );
		if ( tpItemEquipment == NULL )
		{
			return;
		}
		if ( tpItemEquipment->GetDurability() == 0 )
		{
			IfNeedRefresh = true;
		}
		MendMoney = tpItemEquipment->GetMendMoney();
		if ( MendMoney == -1 )
		{
			LOG_ERROR(" propertymodule ","CPropertyModule::MendAllEquipment Error");
			return;
		}
		if (  MendMoney == 0 && tpItemEquipment->GetLostDurability() == 0 )
		{
			SendProErrorNotice( pPlayer , EUIPMENT_MENDNOTNEED );
			return;
		}
		if ( MendMoney > 0 || tpItemEquipment->GetLostDurability() > 0 )
		{
			unsigned int tBaggageMoney = ( unsigned int )pSrcProperty->GetMoney(); 
			if ( tpBeginner->mCanMendUseBindMoney == 0 )
			{											
				tBaggageMoney +=  pSrcProperty->GetBindMoney();
			}  
			if ( (unsigned int)MendMoney > tBaggageMoney )
			{
				// 金钱不够
				SendProErrorNotice( pPlayer , EUIPMENT_MONEYNOTENOUGH );
				return;
			}	  
			
			// 更新装备的耐久度
			NotifyDurability.set_isinpackage( 0 );
			NotifyDurability.add_eqptindex ( Index );
			NotifyDurability.add_eqptdurability ( tpItemEquipment->ResetDurability() );
			MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS );
			MessageHead.set_msgpara( (int)&NotifyDurability );			
			CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer,&MessageHead ); 

			// 刷新任务属性
			if ( IfNeedRefresh == true )
			{
				pSrcProperty->Refresh( );
				pPlayer->NotifyPropertyRefresh( );
				CMessageEntityRefreshNotice FreshMsg;
				CreateMessageEntityRefreshNotice( &MessageHead, &FreshMsg, pPlayer->GetEntityID(), pSrcProperty->GetCurHP( ), pSrcProperty->GetCurMP( ), pSrcProperty->GetMaxHP( ),  pSrcProperty->GetMaxMP( ) );
				CMapModule::GetSingletonPtr()->MessageBroadCast(  pPlayer, &MessageHead );
			} 
			// 发送修理成功的消息
			SendProErrorNotice( pPlayer , EUIPMENT_SUCCESS );
		}
				 
	}	
	
	int tBindMoney = 0;
	int tMoneyCharge = 0;
	if ( tpBeginner->mCanMendUseBindMoney == 0 )
	{
		tBindMoney = MendMoney>pSrcProperty->GetBindMoney()?pSrcProperty->GetBindMoney():MendMoney;				
	}
	tMoneyCharge = MendMoney - tBindMoney; 									

	if (PlayerChangeMoney( pPlayer, tBindMoney, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByRepairOne(pPlayer, CYuanBao::em_bind_money, tBindMoney, tpItemEquipment->GetItemID(), tpItemEquipment->GetGUID());
	}

	if (PlayerChangeMoney( pPlayer, tMoneyCharge, true, false ) == SUCCESS)
	{
		LogEventLostMoneyByRepairOne(pPlayer, CYuanBao::em_unbind_money, tMoneyCharge, tpItemEquipment->GetItemID(), tpItemEquipment->GetGUID());
	}
}


// 扣除玩家邮件物品

void CPropertyModule::RemoveMailItem( CEntityPlayer * tpPlayer, int PackageIndex, int ItemNum )
{
	if ( tpPlayer == NULL )
	{
		// error
		return;
	}	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) tpPlayer->GetProperty();
	CItemObject *tpItemObj = pProperty->GetBaggage( )->GetItemObjPtr( PackageIndex );
	if ( tpItemObj == NULL )
	{
		// error
		return;
	}
	if ( ItemNum < 0 )
	{
		// error
		return;
	}

	if ( ItemNum > (int)tpItemObj->GetItemNum() )
	{
		// error
		return;
	}
	if ( ItemNum < (int)tpItemObj->GetItemNum() )
	{
		uint64_t ullGUID = tpItemObj->GetGUID();
		int  nItemID = tpItemObj->GetItemID();
		tpPlayer->SetExchange(true);
		if (PlayerRemoveItem( tpPlayer, PackageIndex , ItemNum) == 0)
		{
			//TODO: 
			LogEventLostItemBySendMail(tpPlayer, ullGUID, nItemID, ItemNum, 0, 0);
		}
		tpPlayer->SetExchange(false);

		return;
	}

	pProperty->GetBaggage( )->SetIndexNull( PackageIndex );
	return;	
}



// 计算伤害后处理, 守护, 魔法盾等, 处理实体调血，计算伤害统计
void CPropertyModule::EntityDamaged(	CEntityCharacter* pSrcEntity, 
										CEntityCharacter* pDesEntity, 
										int vDamage, 
										EResultType vResultType,
										int vSkillType
		)
{	
	int tDesDamage	= vDamage;
	int tShieldDamage	= 0;
	bool tMagicShield	= true;
	if( pDesEntity == NULL )
	{
		return;
	}

	if( pDesEntity->IsAlive() == false )
	{
		return;
	}

	CPropertyCharacter* pDesProperty = (CPropertyCharacter*) pDesEntity->GetProperty();
	CPropertyCharacter* pSrcProperty = NULL;

	// 重置战斗计时器
	if( pSrcEntity != NULL )
	{
		if( pSrcEntity->GetAliveStatus( ) == ALIVE_NORMAL )
		{
			pSrcEntity->SetAliveStatus( ALIVE_BATTLE );
			pSrcEntity->AddFunResult( 0, FUNC_BATTLE, RESULT_NORMAL );
		}
	}

	if( pDesEntity->GetAliveStatus( ) == ALIVE_NORMAL )
	{
		pDesEntity->SetAliveStatus( ALIVE_BATTLE );
		pDesEntity->AddFunResult( 0, FUNC_BATTLE, RESULT_NORMAL );

		// 清空伤害列表
		//pDesProperty->mDamageList.ClearDamage( );
	}

	// 普通攻击闪避
	if ( vResultType == RESULT_NORMALDUCK )
	{
		pDesEntity->AddFunResult( ( ( pSrcEntity == NULL ) ? 0 : pSrcEntity->GetEntityID() ), FUNC_NONE, RESULT_NORMALDUCK );
		return;
	}

	// 计算PK,只在正常攻击和暴击时计算pk
	if ( ( vResultType == RESULT_NORMAL || vResultType == RESULT_DEATHHIT ) && vDamage > 0 )
	{
		ProcessPKValueOnAttack( pSrcEntity, pDesEntity );
	}

	// immunity damage
	if ( pDesProperty->GetStateParam( STATE_IMMUNITYDAMAGE ).mInState == true )
	{
		pDesEntity->AddFunResult( ( ( pSrcEntity == NULL ) ? 0 : pSrcEntity->GetEntityID() ), FUNC_NONE, RESULT_IMMUNITY );
		return;
	}

	if ( pDesProperty->GetStateParam( STATE_DECALLDAMAGEPER ).mInState == true )
	{
		// 降低所有伤害的百分比
		if ( tDesDamage > 1 )
		{
			tDesDamage = std::max( (int)( tDesDamage * ( ( SERVER_PERCENT_INT - pDesProperty->GetStateParam( STATE_DECALLDAMAGEPER ).mParames1 ) / SERVER_PERCENT_FLOAT ) ), 1 );
		} 
	}

	// 伤害对BUFF的相关处理
	BuffByDamage( pSrcEntity, pDesEntity, vResultType, vSkillType, vDamage, tDesDamage, tShieldDamage, tMagicShield );

	// 装备反弹伤害
	if ( pDesEntity->IsPlayer() )
	{
		CPropertyPlayer *tpProPlayer = (CPropertyPlayer*)pDesProperty;
		int tReflect = tpProPlayer->GetEquipment()->GetPerNumber( CTemplateProperty::PROPERTYFUNC_REFLECT ) +
					   tpProPlayer->GetEquipment()->GetSuitPer( CTemplateProperty::PROPERTYFUNC_REFLECT ); 	
		// 如果是反弹伤害，就不再反弹处理
		if ( tReflect > 0 && vResultType != RESULT_REBOUND )
		{
			EntityDamaged( pDesEntity, pSrcEntity, (int) ( vDamage * tReflect / SERVER_PERCENT_FLOAT ), RESULT_REBOUND );
		}
	}

	if( tDesDamage == 0 )
		return;
		
	// 受到伤害大于0，打断进度条
	if ( pDesEntity->IsPlayer() == true )
	{
		StopProgress( ( CEntityPlayer * )pDesEntity );
	}	

	// TODO: 如果是陷阱造成伤害,则把原实体替换为陷阱释放者
	if ( pSrcEntity != NULL )
	{
		if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PEDAL )
		{
			CEntity* tpOwner = pSrcEntity->GetOwner();
			if ( tpOwner != NULL && tpOwner->IsCharacter() )
			{
				CPropertyCharacter* tpOwnerCharacter = (CPropertyCharacter*) tpOwner->GetProperty();
				if ( tpOwnerCharacter != NULL )
				{
					pSrcEntity = ( CEntityCharacter* )tpOwner;
					pSrcProperty = tpOwnerCharacter;
					ProcessPKValueOnAttack( pSrcEntity, pDesEntity );
				}
			}
		}
	}

	// 如果其中是NPC被伤害了，那么要通知NPC模块处理NPC策略
	if ( pSrcEntity != NULL && pDesEntity->GetEntityType( ) != ENTITYTYPE_PLAYER )
	{
		// 通知NPC模块，NPC被攻击了
		CNpcModule::GetSingleton().OnAttacked( pSrcEntity, pDesEntity, ( ( vDamage > 0 ) ? vDamage : 1 ) );

		// 把NPC加入人的伤害列表
		EntityInsertDamageList( pDesEntity, pSrcEntity );
	}

	// 如果没有第一次伤害实体，那么可以认为这次伤害为第一次伤害
	if( pSrcEntity != NULL && ( pDesEntity->GetEntityType() == ENTITYTYPE_FUNCNPC || pDesEntity->GetEntityType() == ENTITYTYPE_OGRE )  )
	{
		CPropertyNPC* tpProNpc = ( CPropertyNPC* )pDesProperty;
		if ( tpProNpc->GetFirstEntityID( ) == 0 )
		{
			// 记录HP百分比
			tpProNpc->SetLastHPPer( pDesProperty->GetHPPercent( ) );
			// 记录伤害源实体ID
			tpProNpc->SetFirstEntityID( pSrcEntity->GetEntityID( ) );
		}
	}

	// 计算伤害逻辑
	if ( vResultType == RESULT_NORMAL || vResultType == RESULT_DEATHHIT || vResultType ==  RESULT_PROTECTED 
			|| vResultType == RESULT_REBOUND )
	{
		// 计算伤害统计
		EntityInsertDamageList( pSrcEntity, pDesEntity, std::min( (int)pDesProperty->GetCurHP( ), tDesDamage ) );

		int tFinalDamage = tDesDamage;
		tFinalDamage = pDesEntity->ExpendHP( tFinalDamage, pSrcEntity == NULL ? 0 : pSrcEntity->GetEntityID(), vResultType );

		// 偷取HP,MP
		if ( pSrcEntity != NULL )
		{
			pSrcEntity->StealHP( tFinalDamage );
			pSrcEntity->StealMP( tFinalDamage );
		}
	}	

	if ( ( pDesProperty->GetCurHP( ) <= 0 ) && ( pDesEntity->IsAlive( ) == true ) )
	{
		PERF_FUNC( "EntityDie", pDesEntity->EntityDie( pSrcEntity ) );
	}
}

// 攻击技能效果作用于目标
void CPropertyModule::EntityBuffSkill( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, int* pBuffList, int nBuffNum, int vDamage, int vSkillType )
{
	if ( pSrcEntity == NULL || pDesEntity == NULL || pBuffList == NULL )
		return;

	// 是否有负面buff
	bool bIsDecBuff = false;

	// 计算技能添加Buff
	for ( int i = 0; i < nBuffNum; i ++ )
	{
		CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( pBuffList[ i ] );
		if ( tpBuffTpl == NULL )
			continue;

		// 计算该Buff是否需要激活, 激活条件仅为某技能ID是否已经学会
		//if ( pConList[ i ] != 0 && tpSkill->GetSkillObjectByID( pConList[ i ] ) == NULL )
		//	continue;

		// 如果有一个buff为负面buff
		if ( tpBuffTpl->mBuffType == CTemplateBuff::BUFF_DEC )
		{
			bIsDecBuff = true;
		}

		// 给自己作用的BUFF
		if ( i == 4 )
		{
			pSrcEntity->EntityInsertBuff( pSrcEntity, tpBuffTpl, vSkillType, vDamage );
			int pTime = tpBuffTpl->mLastTime/1000;
			if (pTime > 60)
			{
				LogEventGetBuffByPlayer((CEntityPlayer *)pSrcEntity,pBuffList[ i ],pTime,vSkillType,( (CEntityPlayer * )pSrcEntity)->GetCharID() );  // 技能
			}


		}
		// 给小队作用的BUFF
		else if ( i == 5 )
		{
			if ( pSrcEntity->IsPlayer() == false )
				continue;

			CEntityPlayer* tMemberList[ TEAMNUM ] = { NULL };
			int tRtn = 0, tCount = 0;
			tRtn = CTeamModule::GetSingleton().OnGetMemberList( (CEntityPlayer*)pSrcEntity, tMemberList, ARRAY_CNT( tMemberList ), tCount );
			if ( tRtn < 0 )
			{
				continue;
			}			
			for ( int i = 0; i < tCount; i ++ )
			{
				CEntity* tpMember = (CEntity*) tMemberList[ i ];
				if ( tpMember == NULL )
					continue;

				// 只有在指定范围内的队员才能作用
				if ( tpMember->IsWithinDistance( pSrcEntity, 20 ) == true )
				{
					( (CEntityCharacter*) tpMember )->EntityInsertBuff( pSrcEntity, tpBuffTpl, vSkillType, vDamage );
					int pTime = tpBuffTpl->mLastTime/1000;
					if (pTime >= 60)
					{
						LogEventGetBuffByPlayer((CEntityPlayer *)tpMember,pBuffList[ 5 ],pTime,vSkillType,((CEntityPlayer *)pSrcEntity)->GetCharID() );
					}

				}
			}
		}
		// 给目标作用的BUFF
		else
		{
			pDesEntity->EntityInsertBuff( pSrcEntity, tpBuffTpl, vSkillType, vDamage );
			int pTime = tpBuffTpl->mLastTime/1000;
			if (pTime >= 60)
			{
				LogEventGetBuffByPlayer((CEntityPlayer *)pDesEntity,pBuffList[ i ],pTime,vSkillType,((CEntityPlayer *)pSrcEntity)->GetCharID() );
			}
			
		}
	}

	// 如果有一个是负面buff
	if ( bIsDecBuff )
	{
		// 降低被攻击方的装备耐久度
		EquipmentDurability( pDesEntity , 0 , 1 ); 

		ProcessPKValueOnAttack( pSrcEntity, pDesEntity );
		
		if ( pDesEntity->IsPlayer() )
		{
			StopProgress( ( CEntityPlayer * )pDesEntity );
		}
	}		
}

// 单个实体受到技能攻击
void CPropertyModule::EntityAttackSkill( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vSkillType, int vDamageRate )
{
	// 如果目标不存在
	if ( pDesEntity == NULL || pSrcEntity == NULL || pNormalSkill == NULL )
	{
		SendProErrorNotice( pSrcEntity, ERROR_USESKILL_TARGETNOTFOUND );
		return;
	}

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	CPropertyCharacter* pDesProperty = (CPropertyCharacter*) pDesEntity->GetProperty();

	// 如果目标已经死亡
	if ( pDesEntity->IsAlive() == false )
	{
		return;
	}

	// 被攻击(作用)
	pDesEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
		pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );


	// 计算命中
	int tSkillHitrate	= pSrcProperty->GetNormalHitRate() + pNormalSkill->mSkillHitrate;
	int tDuckValue		= CPropertyFormula::GetNormalDuck( pDesProperty );
	int tIgnoreValue	= CPropertyFormula::GetIgnoreDuck( pSrcProperty );
	
	
	int tHitrate	= CPropertyFormula::GetHitrate( pSrcProperty->GetLevel( ), pDesProperty->GetLevel( ), tSkillHitrate ) * SERVER_PERCENT_FLOAT;
	tHitrate		= std::min( 9999, tHitrate );
	tHitrate		= std::max( 1, tHitrate );

	int tDuckrate	= CPropertyFormula::GetDuckRate( pSrcProperty->GetLevel( ), tDuckValue, tIgnoreValue ) * SERVER_PERCENT_FLOAT;
	tDuckrate		= std::min( 3000, tDuckrate );
	tDuckrate		+= pDesProperty->GetDuckRate( ); 	
	tDuckrate		= std::max( 1, tDuckrate );

	if ( RAND(10000) > tHitrate )
	{  		
		pDesEntity->AddFunResult( ( ( pSrcEntity == NULL ) ? 0 : pSrcEntity->GetEntityID() ), FUNC_NONE, RESULT_SKILLDUCK );
		// 通知NPC模块，NPC被攻击了
		if ( pDesEntity->GetEntityType() == ENTITYTYPE_OGRE || pDesEntity->GetEntityType() == ENTITYTYPE_FUNCNPC)
		{
			CNpcModule::GetSingleton().OnAttacked( pSrcEntity, pDesEntity, 1 );
		}
		return;
	}
	if ( RAND(10000) < tDuckrate )
	{  		
		pDesEntity->AddFunResult( ( ( pSrcEntity == NULL ) ? 0 : pSrcEntity->GetEntityID() ), FUNC_NONE, RESULT_SKILLDUCK );
		// 通知NPC模块，NPC被攻击了
		if ( pDesEntity->GetEntityType() == ENTITYTYPE_OGRE || pDesEntity->GetEntityType() == ENTITYTYPE_FUNCNPC)
		{
			CNpcModule::GetSingleton().OnAttacked( pSrcEntity, pDesEntity, 1 );
		}
		return;
	}
	// 被攻击方被击中,耐久度降低
	if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PLAYER )
	{
		EquipmentDurability( pDesEntity , 0 , 0 ); 
	}
	else
	{
		EquipmentDurability( pDesEntity, 0 , 1 );
	}		
	
	// 计算目标无敌状态
	// 如果被攻击方是NPC, 并且NPC处于超人状态，直接抵抗
	if ( pDesEntity->GetEntityType() != ENTITYTYPE_PLAYER && ( (CEntityNpc*) pDesEntity )->GetSuperState( ) == true)
	{
		pDesEntity->AddFunResult( ( ( pSrcEntity == NULL ) ? 0 : pSrcEntity->GetEntityID() ), FUNC_NONE, RESULT_IMMUNITY );
		return;
	}

	int tDamage			= 0;
	int tBuffDamage = 0;
	EResultType tResultType		= RESULT_NORMAL;

	if ( pSrcProperty->GetEntityType( ) == ENTITYTYPE_PLAYER )
	{
		// 改武器类型为技能类型
		// 得到技能攻击类型, 如果是物理攻击
		if ( pNormalSkill->mDamageType == ATTACKTYPE_PHYSICS )
		{
			tDamage = CPropertyFormula::GetPSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			tBuffDamage = CPropertyFormula::GetPAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
		}

		// 得到技能攻击类型, 如果是法术攻击
		else if ( pNormalSkill->mDamageType == ATTACKTYPE_MAGIC )
		{
			tDamage = CPropertyFormula::GetMSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			tBuffDamage = CPropertyFormula::GetMAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
		}

		// 如果是通用的，潜规则取最大
		else if ( pNormalSkill->mDamageType == ATTACKTYPE_NORMAL )
		{
			int tPDamage = CPropertyFormula::GetPSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			int tMDamage = CPropertyFormula::GetMSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			tDamage = max( tPDamage, tMDamage );
			int tPBuffDamage = CPropertyFormula::GetPAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
			int tMBuffDamage = CPropertyFormula::GetMAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
			tBuffDamage = max( tPBuffDamage, tMBuffDamage );
		}

		((CPropertyPlayer*)pSrcProperty)->InsertSelfBuff( pDesEntity, CTemplateProperty::PROPERTYFUNC_HITSKILL );

		if ( tResultType == RESULT_DEATHHIT )
		{
			((CPropertyPlayer*)pSrcProperty)->InsertSelfBuff( pDesEntity, CTemplateProperty::PROPERTYFUNC_DEATHSKILL );
		}
	}
	else if( pSrcEntity->GetEntityType( ) == ENTITYTYPE_PET ) 
	{			

		CEntityPet* tpPet = ( CEntityPet* ) pSrcEntity;

		CTemplateSummonBeast* tpPetTpl = (CTemplateSummonBeast*) CDataStatic::SearchTpl( tpPet->GetNpcID( ) );
		if ( tpPetTpl == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] can't find pet %d", __LK_FILE__, __LINE__, __FUNCTION__ , tpPet->GetNpcID( ));
			return;
		}

		if ( tpPetTpl->mPetData[ tpPet->GetCurLevel( ) ].mAttackType == CTemplateSummonBeast::EM_ATTACK_TYPE_MGC )
		{
			tDamage = CPropertyFormula::GetMSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			tBuffDamage = CPropertyFormula::GetMAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
		}

		if ( tpPetTpl->mPetData[ tpPet->GetCurLevel( ) ].mAttackType == CTemplateSummonBeast::EM_ATTACK_TYPE_PHY )
		{
			tDamage = CPropertyFormula::GetPSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			tBuffDamage = CPropertyFormula::GetPAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
		}
	}
	else
	{
		int tNpcID = 0;
		if( pSrcEntity->IsOgre() || pSrcEntity->IsFunNpc() )
		{
			tNpcID = pSrcEntity->GetNpcID( );
		}
		else
		{
			return;
		}

		CEntityNpc* pSrcNpc = ( CEntityNpc* )pSrcEntity;

		CTemplateOgre *tplNpc = (CTemplateOgre*)CDataStatic::SearchTpl( pSrcNpc->GetNpcID( ) );
		if ( tplNpc == NULL )
			return;
		// 得到技能攻击类型, 如果是物理攻击
		if ( tplNpc->mOgreType == ATTACKTYPE_PHYSICS )
		{
			tDamage = CPropertyFormula::GetPSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType );
			tBuffDamage = CPropertyFormula::GetPAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
		}

		// 得到技能攻击类型, 如果是法术攻击
		if ( tplNpc->mOgreType == ATTACKTYPE_MAGIC )
		{
			tDamage = CPropertyFormula::GetMSkillAttack( pSrcEntity, pDesEntity, pNormalSkill, tResultType ); 
			tBuffDamage = CPropertyFormula::GetMAttackValue( pSrcProperty, (pNormalSkill->mIsMagicWeaponSkill==1) );
		}
	}

	if ( pDesEntity->IsPlayer( ) )
	{
		((CPropertyPlayer*)pDesProperty)->InsertSelfBuff( pSrcEntity, CTemplateProperty::PROPERTYFUNC_BEHITSKILL );
		CPropertyPlayer* tpPro = (CPropertyPlayer*)pDesEntity->GetProperty();
		if (tpPro->GetHorseState() != 0 )
		{
			CTplItemHorse* tpTplHorse = (CTplItemHorse*)CDataStatic::SearchTpl( tpPro->GetHorseTempID());
			if ( tpTplHorse == NULL )
			{
				LOG_ERROR("pro", "can't find horse?? in %s:%d. tempid=%d", __LK_FILE__, __LINE__, tpPro->GetHorseTempID() );
			}
			else
			{
				CTemplateBuff *tpBuff = (CTemplateBuff*)CDataStatic::SearchTpl( tpTplHorse->mSpeedBuff );
				bool tOffHorse = true;
				if ( tpBuff != NULL )
				{
					for ( unsigned int i = 0; i < ARRAY_CNT(tpBuff->mBuff); i++ )
					{
						if ( tpBuff->mBuff[ i ].mBuffFunc == CTemplateBuff::BUFFFUNC_FLY )
						{
							tOffHorse = false;
							break;
						}
					}
				}
				// 计算概率 看该不该下马
				if ( tOffHorse == true )
				{
					if ( RAND(SERVER_PERCENT_INT) < tpTplHorse->mOffHorseProb )
					{
						tpPro->OffHorse( tpTplHorse->mSpeedBuff );
						SendRideHorseNotice( pDesEntity, tpTplHorse->mTempID, 0 );
						// 下马后要上BUFF
						InsertBuff( pDesEntity, tpTplHorse->mOffBuffID );
					}
				}				
			}
		}
	}
	
	// 处理伤害递减
	if ( vDamageRate != SERVER_PERCENT_FLOAT )
	{
		tDamage = (int) ( tDamage * ( vDamageRate / SERVER_PERCENT_FLOAT ) );
	}

	// 记日志
	if ( pSrcEntity->IsPlayer() && pDesEntity->IsPlayer() )
	{
		if ( ( tResultType == RESULT_NORMAL && tDamage >= EM_DAMAGE_NORMAL_MAX ) ||
			 ( tResultType == RESULT_DEATHHIT && tDamage >= EM_DAMAGE_DEATH_MAX ) || 
			 ( tResultType == RESULT_NORMAL && tDamage <= EM_DAMAGE_NORMAL_MIN ) ||
			 ( tResultType == RESULT_DEATHHIT && tDamage <= EM_DAMAGE_DEATH_MIN ) )
		{
			LogRoleDamage( (CEntityPlayer*)pSrcEntity, (CEntityPlayer*)pDesEntity, pNormalSkill->mSkillID, tDamage, tResultType );
		}
	}

	// 目标实体受到伤害
	PERF_FUNC( "EntityDamage", EntityDamaged( pSrcEntity, pDesEntity, tDamage, tResultType, vSkillType ) );

	if ( pSrcProperty->GetCurHP( ) <= 0 )
	{
		return;
	}

	if ( pDesProperty->GetCurHP( ) <= 0 )
	{
		return;
	}
	
	// BUFF作用于实体
	PERF_FUNC( "EntityBuffSkill", EntityBuffSkill( pSrcEntity, pDesEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), tBuffDamage, vSkillType ));

		
	return ;
}

// 释放技能
void CPropertyModule::FireSkill(	CEntityCharacter* pSrcEntity, 
									CEntityCharacter* pDesEntity, 
									CTemplateSkill* pSkill,
									CEntityCharacter** vEntityList,
									int vEntityListNum,
									bool bIsMagicWeapon
								)
{
	// vEntityList 有可能为空,这里不需要判断,在后面用的时候判断
	LK_ASSERT( pSrcEntity != NULL && pDesEntity != NULL && pSkill != NULL, return );
	//EResultType	tResultType	= RESULT_NORMAL;

	// 判断法宝技能
	if ( bIsMagicWeapon )
	{
		if ( !pSrcEntity->IsPlayer() )
		{
			LOG_ERROR("pro", "error ! MWSkill not from player! entitytype=%d", pSrcEntity->GetEntityType() );
			return;
		}
		if ( pSkill->mIsMagicWeaponSkill == 0 )
		{
			LOG_ERROR("pro", "error ! not MWSkill! skillid=%d",pSkill->mTempID );
			return;
		}
	}

	// 使用技能,对BUFF的相关处理
	CheckBuffEntityUseSkill( pSrcEntity, pDesEntity );

	// TODO: 服务器不做延迟,所有延迟由客户端处理

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	//CPropertyCharacter* pDesProperty = (CPropertyCharacter*) pDesEntity->GetProperty();

	// 装备耐久度
	bool bIfSrcDurReduced = false;   // true表示减少，false表示不用减少
	bool bEntityType      = true;    // 交互类型，false表示玩家之间的交互，true表示玩家和npc之间的交互  

	// 如果被攻击方是NPC, 并且NPC处于超人状态，直接抵抗
	if ( pDesEntity->IsPlayer() == false && ( (CEntityNpc*) pDesEntity )->GetSuperState( ) == true )
	{
		pDesEntity->AddFunResult( pSrcEntity->GetEntityID(), FUNC_NONE, RESULT_IMMUNITY );
		return;
	}
	if( pSkill == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ] Skill( %d : %d )  not found", __LK_FILE__, __LINE__, __FUNCTION__,
			pSkill->mSkillID, pSkill->mSkillLevel );
		return;
	}

	CTemplateNormalSkill* tpNormalSkill = (CTemplateNormalSkill*) pSkill;

	switch( pSkill->mSkillType )
	{
		// 自身祝福类技能
	case CTemplateSkill::SKILLTYPE_SELFBLESS:
		{	
			ActionSelfBless( pSrcEntity, tpNormalSkill, 0, pSkill->mSkillType, bIfSrcDurReduced, bEntityType );
		}
		break;
		// 可见范围内友方祝福
	case CTemplateSkill::SKILLTYPE_1PFRIENDINBLESS:
		{	
			ActionSeenBless( pSrcEntity, tpNormalSkill, 0, pSkill->mSkillType, bIfSrcDurReduced, bEntityType );
		}
		break;
		// 攻击类技能
	case CTemplateSkill::SKILLTYPE_ATTACK:
		{					
			if ( tpNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_SINGLE )
			{
				// 如果只能对单体使用
				ActionAttackSingle( pSrcEntity, pDesEntity, tpNormalSkill, pSkill->mSkillType, bIfSrcDurReduced, bEntityType );
			}
			else
			{
				// 如果是对范围使用
				ActionAttackRange( pSrcEntity, pDesEntity, tpNormalSkill, pSkill->mSkillType, bIfSrcDurReduced, bEntityType, vEntityList, vEntityListNum );
			}
		}
		break;
		// 诅咒类
	case CTemplateSkill::SKILLTYPE_CUSS:
		
		// 祝福类
	case CTemplateSkill::SKILLTYPE_BLESS:
		{
			// 减少攻击方的装备耐久度
			bIfSrcDurReduced = true;
			if ( pDesEntity->IsPlayer( ) )
			{
				bEntityType = false;
			}
			int tDamage = 0;
			if ( pSrcEntity->IsPlayer( ) )
			{
				// 把武器类型改为技能类型
				// 得到技能攻击类型, 如果是物理攻击
				if ( pSkill->mDamageType == ATTACKTYPE_PHYSICS )
				{
					tDamage = CPropertyFormula::GetPAttackValue( pSrcProperty,(pSkill->mIsMagicWeaponSkill==1) );
				}

				// 得到技能攻击类型, 如果是法术攻击
				else if ( pSkill->mDamageType == ATTACKTYPE_MAGIC )
				{
					tDamage = CPropertyFormula::GetMAttackValue( pSrcProperty, (pSkill->mIsMagicWeaponSkill==1) );
				}

				// 如果是通用的，潜规则取最大
				// 得到技能攻击类型, 如果是法术攻击
				else if ( pSkill->mDamageType == ATTACKTYPE_NORMAL )
				{
					int tPDamage = CPropertyFormula::GetPAttackValue( pSrcProperty,(pSkill->mIsMagicWeaponSkill==1) );
					int tMDamage = CPropertyFormula::GetMAttackValue( pSrcProperty, (pSkill->mIsMagicWeaponSkill==1) );
					tDamage = max( tPDamage, tMDamage );
				}
			}

			// 如果只能对单体使用
			if ( tpNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_SINGLE ||
				tpNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_PLAYER)
			{
				ActionCussOrBlessSingle( pSrcEntity, pDesEntity, tpNormalSkill, tDamage, pSkill->mSkillType );
			}
			else
			{
				ActionCussOrBlessRange( pSrcEntity, pDesEntity, tpNormalSkill, tDamage, pSkill->mSkillType, bEntityType, vEntityList, vEntityListNum );
			}
		}
		break;
		// 小队祝福类
	case CTemplateSkill::SKILLTYPE_TEAMBLESS:
		{
			ActionTeamBless( pDesEntity, tpNormalSkill, 0, pSkill->mSkillType, bIfSrcDurReduced, bEntityType );
		}
		break;
		// 陷阱类
	case CTemplateSkill::SKILLTYPE_TRIP:
		{
			ActionTrip( pSrcEntity, pSkill, bIfSrcDurReduced );
		}
		break;
		// 宠物祝福类
	case CTemplateSkill::SKILLTYPE_PETBLESS:
		{
			ActionPetBless( pSrcEntity, tpNormalSkill, 0, pSkill->mSkillType, bIfSrcDurReduced );
		}
		break;
		// 被动技能类
	case CTemplateSkill::SKILLTYPE_PASSIVITY:
		break;
		// 复活技能类
	case CTemplateSkill::SKILLTYPE_RELIVE:
		{					
			ActionRelive( pSrcEntity, pDesEntity, tpNormalSkill, 0, pSkill->mSkillType, bIfSrcDurReduced );
		}
		break;
		// 传送类
	case CTemplateSkill::SKILLTYPE_TELEPORT:
	case CTemplateSkill::SKILLTYPE_PETTELEPORT:
		{
			ActionTeleport( pSrcEntity, pDesEntity, tpNormalSkill, 0, pSkill->mSkillType, bIfSrcDurReduced );
		}
		break;
		// 召唤类
	case CTemplateSkill::SKILLTYPE_SUMMON:
		{					
			ActionSummon( pSrcEntity, tpNormalSkill, bIfSrcDurReduced );
		}
		break;
		// 光环类
	case CTemplateSkill::SKILLTYPE_AUREOLE:
		{		
			ActionAureole( pSrcEntity, pSkill, bIfSrcDurReduced, vEntityList, vEntityListNum );
		}
		break;
		// 持续攻击类
	case CTemplateSkill::SKILLTYPE_CONTINUEDATTACK:
		{
			ActionContinuedAttackRange( pSrcEntity, pDesEntity, tpNormalSkill, vEntityList, vEntityListNum );
		}
		break;
		// 持续祝福类
	case CTemplateSkill::SKILLTYPE_CONTINUEDBLESS:
		// 持续诅咒类
	case CTemplateSkill::SKILLTYPE_CONTINUEDCUSS:
		{
			ActionContinuedCussOrBlessRange( pSrcEntity, pDesEntity, tpNormalSkill, vEntityList, vEntityListNum );
		}
		break;
	case CTemplateSkill::SKILLTYPE_TRANSFORM:
		{
			ActionCussOrBlessSingle( pSrcEntity, pDesEntity, tpNormalSkill, 0, pSkill->mSkillType );
		}
		break;
	case CTemplateSkill::SKILLTYPE_SUMMONNPC:
		{
			CCreator *tpCreator = CCreatorManager::GetSingleton().GetCreator( tpNormalSkill->mSummonIndex );
			if ( tpCreator->mHasOgre != 0 )
				break;
			unsigned int tEntityID = 0;
			CMapModule::GetSingleton().CreateNpc( pSrcEntity->GetLineID(), pSrcEntity->GetMapID(), pSrcEntity->GetMapIndex(), tpCreator, tEntityID );
		}
		break;
	default:
		break;
	}

	if ( bIfSrcDurReduced == true )
	{
		if ( bEntityType == true )
		{	
			// 玩家与怪物交互
			EquipmentDurability( pSrcEntity , 1 , 1 );
		}
		else
		{	
			// 玩家与玩家交互
			EquipmentDurability( pSrcEntity , 1 , 0 );
		}		 	
	}
}

int CPropertyModule::PlayerRemoveItemByID( CEntityPlayer* pPlayer, 
		unsigned int vItemID, unsigned int vItemNumber, bool &vBind, uint64_t* pullGuID, int vType )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();

	// 将道具扔掉
	CTplItem* tpItem = (CTplItem*) CDataStatic::SearchTpl( vItemID );
	if ( tpItem == NULL ) return -1;

	bool tIsTask = false;
	CItemBox* tpBag = NULL;

	// 如果是任务道具
	if ( IS_TASK_ITEM( tpItem ) )
	{
		tIsTask = true;
		tpBag = pProperty->GetTaskBaggage( );
	}
	else
	{
		tpBag = pProperty->GetBaggage( );
	}

	if (tpBag == NULL) return -1;

	for ( unsigned int i = 0; i < tpBag->mReleaseIndex; i ++ )
	{
		CItemObject* tpItemObj = tpBag->GetItemObjPtr( i );
		if ( tpItemObj != NULL && tpItemObj->IsSameItemGroup( vItemID, vType) )
		{
			int tThrowNumber = std::min( vItemNumber, tpItemObj->GetItemNum() );
			PlayerRemoveItem( pPlayer, i, tThrowNumber, pullGuID, tIsTask );
			vItemNumber -= tThrowNumber;		
			if ( ( tpItemObj->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
			{
				vBind = true;
			}
		}

		if ( vItemNumber == 0 )
			return vItemNumber;
	}
	
	// TODO::如果不是任务物品则搜索包裹背包
	if ( !IS_TASK_ITEM( tpItem ) )
	{
		for ( int i = 0; i < tpBag->GetKitBagIndex(); ++i )
		{
			int tBeginIndex = 0;
			int tEndIndex	= 0;
			int tRet = tpBag->GetKitBagIndexRange( BAGTYPE_KITBAG, i, tBeginIndex, tEndIndex );
			if ( tRet != SUCCESS )
			{
				continue;
			}

			for ( int j = tBeginIndex; j <= tEndIndex; ++j )
			{
				CItemObject* tpItemObj = tpBag->GetItemObjPtr( j );
				if ( tpItemObj != NULL && tpItemObj->IsSameItemGroup( vItemID, vType) )
				{
					int tThrowNumber = std::min( vItemNumber, tpItemObj->GetItemNum() );
					PlayerRemoveItem( pPlayer, j, tThrowNumber, pullGuID, tIsTask );
					vItemNumber -= tThrowNumber;
					if ( ( tpItemObj->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
					{
						vBind = true;
					}
				}
				if ( vItemNumber == 0 )
					break;
			}
		}
	}
	return vItemNumber;
}

int CPropertyModule::PlayerRemoveItem( CEntityPlayer* pPlayer, 
		unsigned int vItemIndex, int vItemNumber, uint64_t* pullGuID, bool vIsTask)
{
	LK_ASSERT( pPlayer != NULL, return -1 ) 	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	// 将道具扔掉
	CItemObject* tpThrowItem = NULL;

	if ( vIsTask )
	{
		tpThrowItem = pProperty->GetTaskBaggage( )->EraseItem( vItemIndex, vItemNumber );
	}else
	{
		tpThrowItem = pProperty->GetBaggage( )->EraseItem( vItemIndex, vItemNumber );
	}

	if ( tpThrowItem == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d]can't find item , index %d", __FUNCTION__, __LINE__, vItemIndex );
		return -1;
	}

	if ( vIsTask )
	{
		// 发送删除任务道具
		SendRemoveItemNotice( pPlayer, POS_TASK_BAGGAGE, vItemIndex, tpThrowItem->GetItemNum() );
	}
	else
	{
		// 发送删除道具
		SendRemoveItemNotice( pPlayer, POS_BAGGAGE, vItemIndex, tpThrowItem->GetItemNum() );
	}

	// 处理道具失去后，任务状态变化
	OnTaskRemoveItem( pPlayer, tpThrowItem->GetItemID(), tpThrowItem->GetItemNum() );

	// 记录非堆叠的人民币物品消耗 
	LogIbItemUsed(pPlayer, tpThrowItem);
	CSceneLogic::GetSingleton().LogValuableEquip(pPlayer->GetCharID(), tpThrowItem);

	if ( pullGuID != NULL)
	{
		*pullGuID = tpThrowItem->GetGUID();
	}

	// 干掉timer
	if ( tpThrowItem->GetValidTimerID() != INVALID_OBJ_ID)
	{
		pPlayer->GetTimerReciver()->ClearTimer(tpThrowItem->GetValidTimerID());
	}
	CSceneObjManager::GetSingletonPtr( )->DestroyObject( tpThrowItem->get_id() );

	return 0;
}

// 时效限制的物品在失效后销毁前发送
// 有次数限制的物品在最后一次使用后销毁前发送`
// 普通物品如果销毁则发使用消息
void CPropertyModule::LogIbItemUsed( CEntityPlayer* pPlayer, CItemObject * tpThrowItem)
{
	if ( tpThrowItem == NULL || pPlayer == NULL) return;

	// 如果是交易的物品
	if ( pPlayer->IsExchange()) return;

	// 如果没有交易流水号
	if ( tpThrowItem->GetPurchaseID() == 0) return; 

	// 记录物品消耗
	CTplItem* pTplItem = (CTplItem*) CDataStatic::SearchTpl( tpThrowItem->GetItemID() );

	// 可堆叠的物品不用发送使用消息
	if ( pTplItem != NULL && pTplItem->mPileLimit == 1)
	{

		// 直接写数据库, 由loginserver定期从数据库中取出来，向erating发送
		CSceneLogic::GetSingletonPtr()->ExecuteSql( 
			ibitemused, 0, 0, pPlayer->GetCharID(), SQL_NONE, INSERT, 
			"INSERT INTO GMS_IBITEM_USED_LOCKED ( account_id, role_id, purchase_id, gender_id, metier_id, role_level, use_time, game_id)"
			"VALUES ( %d, %d, %lld, %d, %d, %d, %d, %d )", 
			pPlayer->GetAccountID(), pPlayer->GetCharID(), tpThrowItem->GetPurchaseID(),
			pPlayer->GetSex(), pPlayer->GetMetier(), pPlayer->GetLevel(), time(0), pPlayer->GetGameID());
	}
}

//
//************************************
// Method:    UseSkill
// FullName:  CPropertyModule::UseSkill
// Access:    public 
// Returns:   void
// Qualifier:  使用技能，如果怪物有了技能列表，需要调整.
// Parameter: CEntityCharacter * pSrcEntity
// Parameter: CEntityCharacter * pDesEntity
// Parameter: unsigned short vSkillID
// Parameter: unsigned short vSkillLevel
// Parameter: int vListID
// Parameter: unsigned int vIndex
// Parameter: CEntityCharacter * * vEntityList
// Parameter: int vEntityListNum
//************************************
bool CPropertyModule::UseSkill( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, unsigned short vSkillID, unsigned short vSkillLevel, int vListID, unsigned int vIndex, CEntityCharacter** vEntityList, int vEntityListNum, bool bIsMagicWeapon, bool bUseByItem )
{
	LK_ASSERT ( pSrcEntity != NULL , return false );
	
	if ( vSkillID == 0 || vIndex >= MAX_SKILL_NUM )
	{
		LOG_ERROR( "pro", "[%s:%d] skill id %d or skill index %d wrong", __FUNCTION__, __LINE__, vSkillID, vIndex );
		return false;
	}

	// 如果源被沉默，那么不能使用
	if ( pSrcEntity->GetAttackable() == false ) 
	{
		if ( pSrcEntity->IsPlayer() && bUseByItem == false )
		{
			SendProErrorNotice( pSrcEntity, ERROR_USESKILL_SILENCE );
		}
		return false;
	}	

	// 技能所有的结果集和影响实体列表,都放在下面这个类中
	pSrcEntity->InitFunResult( vListID );

	//TODO: 不考虑玩家装备对技能等级的影响【注意】，等以后有了，直接修改技能等级
	unsigned short tSkillLevel = vSkillLevel;

	CTemplateSkill* tpSkill = NULL;
	CSkillObject* tpSkillObj = NULL;
	CSkillObject tSkillObj = CSkillObject( vSkillID, vSkillLevel );

	// 玩家全走技能
	if( pSrcEntity->IsPlayer() )
	{
		CPropertyPlayer* tpSrcPlayer = ( CPropertyPlayer* )pSrcEntity->GetProperty();
		// 如果是法宝技能，而且法宝在当前地图不允许携带，则不让用
		if (bIsMagicWeapon)
		{
			CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpSrcPlayer->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
			if (tpMW == NULL)
			{
				return false;
			}
			CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl( tpMW->GetItemID() );
			if ( tpItemMW == NULL )
			{
				return false;
			}
			// 限制持有判断
			bool bOK= true;
			if (tpItemMW->mLmtMapID[0] != 0 )// 要限制持有
			{
				bOK = false;
				for (int i = 0; i < (int)ARRAY_CNT(tpItemMW->mLmtMapID); ++i )
				{
					if ( tpItemMW->mLmtMapID[i] == 0 )
						break;
					if ( pSrcEntity->GetMapID() == tpItemMW->mLmtMapID[i] ) // 当前地图可以持有
					{
						bOK = true;
						break;
					}
				}
			}

			if (tpItemMW->mLmtUseMapID[0] != 0 )// 要限制使用
			{
				bOK = false;
				for (int i = 0; i < (int)ARRAY_CNT(tpItemMW->mLmtUseMapID); ++i )
				{
					if ( tpItemMW->mLmtUseMapID[i] == 0 )
						break;
					if ( pSrcEntity->GetMapID() == tpItemMW->mLmtUseMapID[i] ) // 当前地图可以持使用
					{
						bOK = true;
						break;
					}
				}
			}

			if ( !bOK )
			{
				SendProErrorNotice( pSrcEntity, ERROR_USESKILL_MW_DISALLOW_MAP );
				return false;
			}
		}

		if ( bIsMagicWeapon )
		{
			tpSkillObj = tpSrcPlayer->GetSkillObjectBySkillIDInMagicWeapon( vSkillID ); // 是法宝技能
		}
		else if ( bUseByItem )
		{
			tpSkillObj = &tSkillObj;
		}
		else
		{
			tpSkillObj = tpSrcPlayer->GetSkillObjectByIndex( vIndex );
		}
		LK_ASSERT( tpSkillObj != NULL, return false);
		// 如果用索引查到的技能ID和发来的不一致，可能是装备增加的技能
		// 改用ID再查一次
		if ( tpSkillObj->GetSkillID( ) != vSkillID && !bIsMagicWeapon )
		{
			tpSkillObj = tpSrcPlayer->GetSkillObjectByID( vSkillID );
		}				
		LK_ASSERT( tpSkillObj != NULL, return false);
		tpSkill = tpSkillObj->GetSkillTpl( );
		LK_ASSERT( tpSkill != NULL, return false );

		int nResult = ((CEntityPlayer*)pSrcEntity)->CanUseSkill( tpSkillObj, bIsMagicWeapon );
		if( nResult != SUCCESS )
		{
			SendProErrorNotice( pSrcEntity, nResult );
			return false;
		}

	}
	else 
	{
		// 没有等级按1级算
		tSkillLevel = (tSkillLevel != 0) ? tSkillLevel : 1 ;
		tpSkill = (CTemplateSkill*) CDataStatic::SearchSkill( vSkillID, tSkillLevel );
		if ( tpSkill == NULL )
		{
			return false;
		}
	}

	// 如果是自身祝福，小队祝福，目标都转为自己
	if ( tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_SELFBLESS 
		|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_TEAMBLESS
		|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_1PFRIENDINBLESS
		|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_TRIP )
	{
		pDesEntity = pSrcEntity;
	}
	else if ( tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_RELIVE )
	{
		LK_ASSERT( pDesEntity != NULL, return false );
		CTemplateNormalSkill* tpNormalSkill = (CTemplateNormalSkill*) tpSkill;
		// 新加不同阵营不能复活
		if ( pSrcEntity->GetNationality() != pDesEntity->GetNationality() || pSrcEntity->IsFriendlyTo( pDesEntity ) == false )
		{
			SendProErrorNotice( pSrcEntity, ERROR_USESKILL_ERRDEST );
			return false;
		}

		// 判断距离是否满足
		if ( pSrcEntity->IsWithinDistance( pDesEntity, tpNormalSkill->mMinDistance + ATTACK_DISTANCE_REPAIR ) == false )
		{
			SendProErrorNotice( pSrcEntity, ERROR_USESKILL_ERRDEST );
			return false;
		}
	}
	// 如果是攻击类,诅咒类,祝福类技能
	else if ( tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_ATTACK 
			|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_BLESS
			|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_CUSS )
	{

		CTemplateNormalSkill* tpNormalSkill = (CTemplateNormalSkill*) tpSkill;
		// 如果只能对单体使用
		if ( tpNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_SINGLE 
			|| tpNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_PLAYER )
		{
			LK_ASSERT( pDesEntity != NULL, return false );
			
			// 判断目标是否死亡
			if( pDesEntity->IsAlive( ) == false )
			{
				SendProErrorNotice( pSrcEntity, ERROR_USESKILL_TARGETDIE );
				return false;
			}

			bool vPKValid = EntityPKValid( pSrcEntity, pDesEntity, tpNormalSkill );

			// 判断技能PK模式是否满足
			if ( vPKValid == false )
			{
				SendProErrorNotice( pSrcEntity, ERROR_USESKILL_PKPROTECT );
				return false;
			}

			// 判断距离是否满足
			if ( pSrcEntity->IsWithinDistance( pDesEntity, tpNormalSkill->mMinDistance + ATTACK_DISTANCE_REPAIR ) == false )
			{
				pDesEntity->AddFunResult( pSrcEntity->GetEntityID(), FUNC_NONE, RESULT_NORMALDUCK );
				
				if( pSrcEntity->IsPlayer() )
					SendSyncPosNotice( pSrcEntity, pDesEntity->GetEntityID( ), pDesEntity->GetPosX( ), pDesEntity->GetPosY( ) );
				return false;
			}

			if ( tpNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_PLAYER )
			{
				if ( ! pDesEntity->IsPlayer() )
				{
					SendProErrorNotice( pSrcEntity, ERROR_USESKILL_TARGETINVALID );
					return false;
				}
			}
		}
	}
	// 如果是持续性作用技能
	else if ( tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_CONTINUEDATTACK
		|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_CONTINUEDBLESS
		|| tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_CONTINUEDCUSS )
	{
		// 技能开始作用 //TODOMW 没处理法宝？
		tpSkillObj->StartContinueSkill();
	}	
	else if ( tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_TRANSFORM )
	{
		LK_ASSERT( pDesEntity != NULL, return false );
		if ( pDesEntity->CanBeTransformed() == false )
		{
			SendProErrorNotice( pSrcEntity, ERROR_USESKILL_SRCRESIST );
			return false;
		}

		// 判断目标实体等级是否满足要求
		if( tpSkill->mTargetLevel > 0 && pDesEntity->GetLevel() > tpSkill->mTargetLevel )
		{
			SendProErrorNotice( pSrcEntity, ERROR_USESKILL_TARGETLEVELHIGH );
			return false;
		}
	}

	LK_ASSERT( pDesEntity != NULL, return false );	
	
	// 【TODO】 必须先发攻击/被攻击，否则客户端无法同步
	// 攻击 & 被攻击消息（ 会触发客户端施法者技能CD )
	pSrcEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACK, bUseByItem ? RESULT_USEBYITEM : RESULT_NONE, true, 
		pDesEntity->GetEntityID( ), tpSkill->mSkillID, tpSkill->mSkillLevel, pDesEntity->GetPosX( ), pDesEntity->GetPosY( ) ); 

	if ( pSrcEntity->IsPlayer() == true )
	{
		CEntityPlayer* tpPlayer = (CEntityPlayer*)pSrcEntity;
		
		// 计算技能冷却
		tpPlayer->DoSkillCoolDown( tpSkillObj, bIsMagicWeapon );
		
		// 打断正在进行的npc服务
		tpPlayer->InterruptNpcService();

		// 计算技能消耗	
		PERF_FUNC( "DoSkillCost", tpPlayer->DoSkillCost( tpSkill, bIsMagicWeapon ));
	
		CPropertyPlayer* tpPlayerProperty = (CPropertyPlayer*) tpPlayer->GetProperty();
		if ( !bIsMagicWeapon )
		{
			// 战斗中重置回血/回蓝计时器			
			tpPlayerProperty->SetRefreshTimer( REFRESHTIME );
		}
		tpPlayer->RefreshCDGroup( tpSkill->mCDGroup, ARRAY_CNT( tpSkill->mCDGroup ) );
	}
	// 如果是召唤兽，这里先发送一个，用于通知客户端listid. 用于客户端同步
	else if( pSrcEntity->IsPet() == true )
	{
		ResultListSend( );
		pSrcEntity->InitFunResult( );
	}

	// 如果是变身技能，交换源和目标
	if ( tpSkill->mSkillType == CTemplateSkill::SKILLTYPE_TRANSFORM )
	{
		CEntityCharacter* tpChar = pDesEntity;
		pDesEntity = pSrcEntity;
		pSrcEntity = tpChar;
	}

	FireSkill( pSrcEntity, pDesEntity, tpSkill, vEntityList, vEntityListNum, bIsMagicWeapon );
	
	// 如果是法宝技能 要刷新法宝属性  因为可能消耗了法宝的MP等
	// 先这么写吧，法宝技能不能有变身
	if ( bIsMagicWeapon )
	{
		if ( pSrcEntity->IsPlayer() )
			NotifyRefreshMagicWeaponProperty( (CEntityPlayer*)pSrcEntity, -1 );
	}

	// 发送技能使用结果
	PERF_FUNC( "UseSkill_ResultListSend",  ResultListSend( ) );

	//[注意] 该函数一定要放在最下面调用，在技能处理结束后,处理销毁实体的流程
	ClearDeleteList( );

	return true;
}

// 卸下道具
void CPropertyModule::UnEquipItem( CEntityPlayer* pEntity, unsigned short vPart, unsigned int& vIndex, bool bDestroy )
{
	LK_ASSERT( pEntity != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();
	CItemObject* tpSrcItem = pProperty->GetEquipment()->GetItemObjPtr( vPart );
	int nItemID = 0;   
	
	
	// ly修改：如果是-1 而且不是destroy 则非法
	if ( vIndex == (unsigned int)~0 )
	{
		if (!bDestroy)
		{
			return;	
		}
		else // 寻找包裹空格(包满 可能会找不到 so直接干掉)
		{
			vIndex = pProperty->GetBaggage()->Space();
		}
	}
	
	// 先得到物品的ID  后面任务用
	if ( tpSrcItem != NULL )
		nItemID = tpSrcItem->GetItemID();

	int tRet = pProperty->UnEquip( vPart, vIndex );
	if ( tRet == SUCCESS )
	{
		// 如果是法宝 要干掉定时器
		if ( vPart == EQUIPMENT_MAGICWEAPON )
		{
			CItemMagicWeapon* pObjMW = (CItemMagicWeapon*)tpSrcItem;
			pObjMW->OnEndMagicWeapon( (CEntityPlayer*)pEntity );
			// 法宝技能需要超时
			pObjMW->OnStopSkillCD( (CEntityPlayer*)pEntity );
		}

		int tnInvalidTime = 0;
		CItemObject* tpNowItem = pProperty->GetEquipment()->GetItemObjPtr( vPart );
		if ( tpNowItem != NULL)
		{
			CTemplateEquipment* tpEquip = (CTemplateEquipment*) CDataStatic::SearchTpl( tpNowItem->GetItemID() );	
			LK_ASSERT( tpEquip!=NULL, return );
			// 如果有 有效时间，而且是装备后开启 检查 如果还没有过期时间 则赋值&通知
			if ( tpEquip->mValidTime > 0 && tpEquip->mValidType == VALIDTYPE_EQUIP && tpNowItem->GetInvalidTime() == 0 )
			{
				SetItemValidTime(( CEntityPlayer * )pEntity , (CTplItem*)tpEquip, tpNowItem );
				tnInvalidTime = tpNowItem->GetInvalidTime();
			}
		}

		// 刷新属性，保证不会超过最大值
		
		// 刷新一次
		pProperty->Refresh( );
		((CEntityPlayer*)pEntity)->NotifyPropertyRefresh( );

		
		//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体
		CMessage tPlayerChange;
		CMessagePlayerChangeEquipNotice tMessage;
		bool vBool = false;
		CItemMagicWeapon* tpMW = (CItemMagicWeapon*)pProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
		int tMWID = 0;
		int tMWQLID = 0;
		if ( tpMW != NULL && tpMW->IsOvertimed() == false )
		{
			tMWID = tpMW->GetItemID();
			tMWQLID = tpMW->GetCurQL();
		}
		CItemEquipment* tpFashion = (CItemEquipment*)pProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_FASHION );
		int tFashionID = 0;
		if ( tpFashion != NULL && tpFashion->IsOvertimed() == false )
		{
			tFashionID = tpFashion->GetItemID();
		}
		
		CItemEquipment *tpMarriageEquip = ( CItemEquipment * )pProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_MARRY );
		int tMarriageEquipID = 0;
		if ( tpMarriageEquip != NULL && tpMarriageEquip->IsOvertimed() == false )
		{
			tMarriageEquipID = tpMarriageEquip->GetItemID();
		}
		int tWeaponLevel = 0, tChestLevel = 0, tWeaponJewel = 0, tChestJewel = 0;
		pProperty->GetEquipment()->GetLightPoint( tWeaponLevel, tChestLevel, tWeaponJewel, tChestJewel );
		vBool = CreateMessagePlayerChangeEquipNotice(
				&tPlayerChange,
				&tMessage,
				pEntity->GetEntityID(),
				vPart,
				0,
				pProperty->GetCurHP( ),
				pProperty->GetCurMP( ),
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( ),
				tWeaponLevel,tChestLevel,tWeaponJewel,tChestJewel,
				tMWID,
				tFashionID,
				tMarriageEquipID,
				tMWQLID
				);
		if ( vBool == true )
		{

			//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体		
			CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tPlayerChange, false, true );
		}

		unsigned int tNewSpeed = CPropertyFormula::GetRunSpeed( pProperty );

		if ( pProperty->GetCurSpeed( ) != tNewSpeed )
		{
			CMessage tPlayerChange;
			CMessageSpeedChangedNotify tMessage;
			bool vBool = false;
			vBool = pProperty->CreateMessageNotifySpeedChanged( &tPlayerChange, &tMessage, pEntity->GetEntityID( ), 
					tNewSpeed );
			if ( vBool == true )
			{
				CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tPlayerChange );
			}
			pProperty->SetCurSpeed( tNewSpeed );
		}

		//// 发送卸下装备的通知
		//if ( vIndex == (unsigned int)~0 )
		SendUnEquipItemNotice( pEntity, vPart, vIndex, SUCCESS );

		// 如果要通知开始计时 则通知
		if (tnInvalidTime>0)
		{
			NotifyClientStartTimer( (CEntityPlayer*) pEntity, POS_EQUIPMENT, vPart, tnInvalidTime );
		}

		// 计算卸下道具后,任务状态的变化
		if (nItemID != 0)
			OnTaskRemoveItem( (CEntityPlayer*) pEntity, nItemID, 1 );
	}
	else
	{
		// 发送卸下装备的错误通知		
		SendUnEquipItemNotice( pEntity, vPart, vIndex, tRet );
	}
}

// 装备道具
void CPropertyModule::EquipItem( CEntityPlayer* pEntity, unsigned int vSrcIndex, unsigned int vDesIndex )
{
	LK_ASSERT( pEntity != NULL, return )	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	
	
	
	CItemObject* tpItem = pProperty->GetBaggage( )->GetItemObjPtr( vSrcIndex );
	LK_ASSERT( tpItem != NULL, return );

	CItemObject* tpOldItem = pProperty->GetEquipment( )->GetItemObjPtr( vDesIndex );
	int tOldItemObjID = INVALID_OBJ_ID;
	if ( tpOldItem != NULL )
		tOldItemObjID = tpOldItem->get_id();		
	

	//int tOldSpeed = CPropertyFormula::GetRunSpeed( pProperty );
	int tRet = pProperty->Equip( vSrcIndex, vDesIndex );
	if ( tRet == SUCCESS )
	{
		CTemplateEquipment* tpEquip = (CTemplateEquipment*) CDataStatic::SearchTpl( tpItem->GetItemID() );	
		LK_ASSERT( tpEquip!=NULL, return );
		// 如果是法宝 要开启定时器
		if ( tpEquip->mEquipType == CTemplateEquipment::PART_MAGICWEAPON )
		{
			CItemMagicWeapon* pObjMW = (CItemMagicWeapon*)tpItem;
			pObjMW->OnStartMagicWeapon( (CEntityPlayer*)pEntity );
			pObjMW->OnStartSkillCD((CEntityPlayer*)pEntity);
			// 如果原来的位置上已经有法宝了 要停止定时器等
			if ( tOldItemObjID != INVALID_OBJ_ID )
			{
				CItemMagicWeapon* pOldMW = (CItemMagicWeapon*)CSceneObjManager::GetSingletonPtr()->GetObject( tOldItemObjID );
				if ( pOldMW != NULL )
				{ 
					pOldMW->OnEndMagicWeapon( (CEntityPlayer*)pEntity );
					pOldMW->OnStopSkillCD((CEntityPlayer*)pEntity);
				}
			}
		}

		// 如果是装备绑定，则绑定装备
		if ( GetItemObjBindStatus( tpItem ) == ITEM_BINDSTATUS_FREE )
		{
			BindItem( ( CEntityPlayer * )pEntity , tpItem , ITEM_BINDWAY_BYEQUIP );	
		}       

		// 如果有 有效时间，而且是装备后开启
		bool bIsNotifyTimer = false;
		if ( tpEquip->mValidTime > 0 && tpEquip->mValidType == VALIDTYPE_EQUIP )
		{
			SetItemValidTime(( CEntityPlayer * )pEntity , (CTplItem*)tpEquip, tpItem );
			bIsNotifyTimer = true;
		}

		// 刷新属性，保证不会超过最大值
		pProperty->Refresh( );
		((CEntityPlayer*)pEntity)->NotifyPropertyRefresh( );

		
		int tPart = vDesIndex;
		if ( tpEquip->mEquipType == CTemplateEquipment::PART_WEAPON )	tPart = EQUIPMENT_WEAPON;
		if ( tpEquip->mEquipType == CTemplateEquipment::PART_CHEST )	tPart = EQUIPMENT_CHEST;
		if ( tpEquip->mEquipType == CTemplateEquipment::PART_FASHION )	tPart = EQUIPMENT_FASHION;
		if ( tpEquip->mEquipType == CTemplateEquipment::PART_MAGICWEAPON )	tPart = EQUIPMENT_MAGICWEAPON;

		//// 通知看到自己的客户端自己的装备改变了
		//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体

		CMessage tPlayerChange;
		CMessagePlayerChangeEquipNotice tMessage;
		bool vBool = false;
		CItemMagicWeapon* tpMW = (CItemMagicWeapon*)pProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
		int tMWID = 0;
		int tMWQLID = 0;
		if ( tpMW != NULL && tpMW->IsOvertimed() == false )
		{
			tMWID = tpMW->GetItemID();
			tMWQLID = tpMW->GetCurQL();
		}
		CItemEquipment* tpFashion = (CItemEquipment*)pProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_FASHION );
		int tFashionID = 0;
		if ( tpFashion != NULL && tpFashion->IsOvertimed() == false )
		{
			tFashionID = tpFashion->GetItemID();
		}
		CItemEquipment* tpMarriageEquip = ( CItemEquipment * )pProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_MARRY );
		int tMarriageEquipID = 0;
		if ( tpMarriageEquip != NULL && tpMarriageEquip->IsOvertimed() == false )
		{
			tMarriageEquipID = tpMarriageEquip->GetItemID();			
		}
		int tWeaponLevel = 0, tChestLevel = 0, tWeaponJewel = 0, tChestJewel = 0;
		pProperty->GetEquipment()->GetLightPoint( tWeaponLevel, tChestLevel, tWeaponJewel, tChestJewel );
		vBool = CreateMessagePlayerChangeEquipNotice(
				&tPlayerChange,
				&tMessage,
				pEntity->GetEntityID(),
				tPart,
				( tpItem == NULL ? 0 : tpItem->GetItemID() ),
				pProperty->GetCurHP( ),
				pProperty->GetCurMP( ),
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( ),
				tWeaponLevel,tChestLevel,tWeaponJewel,tChestJewel,
				tMWID,
				tFashionID,
				tMarriageEquipID,
				tMWQLID
				);
		if ( vBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tPlayerChange, false, true );
		}

		unsigned int tNewSpeed = CPropertyFormula::GetRunSpeed( pProperty );

		if ( pProperty->GetCurSpeed( ) != tNewSpeed )
		{
			CMessage tPlayerChange;
			CMessageSpeedChangedNotify tMessage;
			bool vBool = false;
			vBool = pProperty->CreateMessageNotifySpeedChanged( &tPlayerChange, &tMessage, pEntity->GetEntityID( ), 
					tNewSpeed );
			if ( vBool == true )
			{
				// 通知看到自己的客户端自己的速度改变了
				//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体
				CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tPlayerChange );
			}
			pProperty->SetCurSpeed( tNewSpeed );
		}

		//// 发送获得装备道具的通知
		SendEquipItemNotice( pEntity, vSrcIndex, SUCCESS, vDesIndex );

		// 如果要通知开始计时 则通知
		if (bIsNotifyTimer)
		{
			NotifyClientStartTimer( (CEntityPlayer*) pEntity, POS_EQUIPMENT, vDesIndex, tpItem->GetInvalidTime() );
		}

		// 计算装备道具后,任务状态的变化
		OnTaskRemoveItem( (CEntityPlayer*) pEntity, tpItem->GetItemID(), 1 );
	}
	else
	{
		//// 发送获得装备道具的错误通知		
		SendEquipItemNotice( pEntity, vSrcIndex, tRet, vDesIndex  );
	}
}

// 移动道具
void CPropertyModule::MoveItem( CEntityPlayer* pEntity, unsigned short vSrcIndex, unsigned char vSrcSlot, unsigned short vDesIndex, unsigned char vDesSlot, unsigned short vNumber )
{
	if ( pEntity == NULL )
	{
		LOG_ERROR("pro","[%s,%d][%s] CEntity or CPropertyPlayer is null!  ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	CPropertyPlayer* pProperty = (CPropertyPlayer*) tpPlayer->GetProperty();	
	
	// 如果是从仓库取物要进行密码验证
	if ( ( vSrcSlot == SLOT_STORAGE || vSrcSlot == SLOT_STORKITBAG )
		 && vDesSlot != SLOT_STORAGE && vDesSlot != SLOT_STORKITBAG )
	{
		int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
		if ( tPwdCheckRet != SUCCESS )
		{			
			SendMoveItemNotice( pEntity, vSrcIndex, vDesIndex, 0, vSrcSlot, vDesSlot, tPwdCheckRet, 0, 0 );
			return;
		}	
	}
	
	// 如果和仓库有关,那么需要判断是否处于仓库服务状态
	if ( vSrcSlot == SLOT_STORAGE || vDesSlot == SLOT_STORAGE )
	{
		
		if ( pProperty->GetServiceStatus( ) != SERVICE_STORAGE )
		{
			// 发送获得道具的错误通知			
			SendMoveItemNotice( pEntity, vSrcIndex, vDesIndex, 0, vSrcSlot, vDesSlot, ERROR_MOVEITEM_NOTSERVICE, 0, 0 );
			return;
		}	
	}
	
	// 如果和仓库有关,那么需要判断是否处于仓库服务状态
	if ( vSrcSlot == SLOT_STORKITBAG || vDesSlot == SLOT_STORKITBAG  )
	{
		if ( pProperty->GetServiceStatus( ) != SERVICE_STORAGE )
		{
			// 发送获得道具的错误通知			
			SendMoveItemNotice( pEntity, vSrcIndex, vDesIndex, 0, vSrcSlot, vDesSlot, ERROR_MOVEITEM_NOTSERVICE, 0, 0 );
			return;
		}

	}
	
	
	int tMoveNum = 0;
	int tRet = pProperty->MoveItem( vSrcIndex, vSrcSlot, vDesIndex, vDesSlot, vNumber, tMoveNum );
	if ( tRet == ERROR_MOVEITEM_SUCCESS )
	{	
		int tSrcNum = 0;
		int tDesNum = 0;		
		if ( vSrcSlot == SLOT_BAGGAGE || vSrcSlot == SLOT_BAGGAGEKITBAG )
		{
			CItemObject *tpSrcItem = pProperty->GetBaggage()->GetItemObjPtr( vSrcIndex );
			if ( tpSrcItem != NULL )
			{
				tSrcNum = tpSrcItem->GetItemNum();
			}
		}
		else
		{
			CItemObject *tpSrcItem = pProperty->GetStorage()->GetItemObjPtr( vSrcIndex );
			if ( tpSrcItem != NULL )
			{
				tSrcNum = tpSrcItem->GetItemNum();
			}
		}
		
		if ( vDesSlot == SLOT_BAGGAGE || vDesSlot == SLOT_BAGGAGEKITBAG )
		{
			CItemObject *tpDesItemObj = pProperty->GetBaggage()->GetItemObjPtr( vDesIndex );
			if ( tpDesItemObj != NULL )
			{
				tDesNum = tpDesItemObj->GetItemNum();
			}
		}
		else
		{
			CItemObject *tpDesItemObj = pProperty->GetStorage()->GetItemObjPtr( vDesIndex );
			if ( tpDesItemObj != NULL )
			{
				tDesNum = tpDesItemObj->GetItemNum();
			}
		}
		if(  vSrcSlot == SLOT_BAGGAGE && vDesSlot == SLOT_STORAGE )
		{
			CItemObject *tpItemObj = ( CItemObject * )pProperty->GetStorage( )->GetItemObjPtr( vDesIndex ); 
			if ( tpItemObj == NULL )
			{
				return;
			}
			CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
			if ( tpTplItem == NULL )
			{
				return;
			}
			// 如果移动的是物品,则处理下马逻辑 
			if ( tpTplItem->mItemType == CTplItem::ITEM_HORSE )
			{
				if ( pProperty->GetHorseTempID( ) == tpItemObj->GetItemID() )
				{
					CTplItemHorse* pTplHorse = (CTplItemHorse*)tpTplItem;
					pProperty->OffHorse( pTplHorse->mSpeedBuff );
					SendRideHorseNotice( ( CEntityPlayer * )pEntity, tpItemObj->GetItemID(), 0 );
				}
			}		
		}
		// 发送获得道具的通知
		SendMoveItemNotice( pEntity, vSrcIndex, vDesIndex, tMoveNum, vSrcSlot, vDesSlot, SUCCESS, tSrcNum, tDesNum );
		
		// 判断任务
		int nItemID = 0;
		if ( vDesSlot == SLOT_STORAGE )
		{
			CItemObject *tpItemObj = ( CItemObject * )pProperty->GetStorage( )->GetItemObjPtr( vDesIndex ); 
			if ( tpItemObj == NULL )
			{
				return;
			}
			nItemID = tpItemObj->GetItemID();
		}
		else if( vDesSlot == SLOT_BAGGAGE )
		{
			CItemObject *tpItemObj = ( CItemObject * )pProperty->GetBaggage( )->GetItemObjPtr( vDesIndex ); 
			if ( tpItemObj == NULL )
			{
				return;
			}
			nItemID = tpItemObj->GetItemID();
		}
		if ( nItemID != 0 )
		{
			CTaskModule::GetSingleton().FireEvent( (CEntityPlayer*)pEntity, EVENT_ITEMCHANGE, nItemID );
		}
	}
	else
	{
		//// 发送获得道具的错误通知
		/*if ( tRet == ERROR_MOVEITEM_ITEMNOTEXIST || tRet == ERROR_MOVEITEM_SRCINVALID || tRet == ERROR_MOVEITEM_DESINVALID )
		{
			char Buffer[200] = { 0 };
			sprintf( Buffer, " src index ( %d ), des index(%d), Errcode( %d )  ", vSrcIndex, vDesIndex, tRet );			
			CChatModule::GetSingleton().ChatOnChannelCommon( (CEntityPlayer*)pEntity, CHANNEL_COMMON, Buffer );
		}*/		
		SendMoveItemNotice( pEntity, vSrcIndex, vDesIndex, tMoveNum, vSrcSlot, vDesSlot, tRet, 0, 0 );
	}
}

// 使用道具
void CPropertyModule::UseItem( CEntityPlayer* pEntity, int tPos, unsigned short vIndex, unsigned int vParam )
{
	LK_ASSERT( ( pEntity != NULL ) && "Parames Error", return );
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	

	int IfItemNeedBind = false;						// 是否需要绑定检查
	CItemObject* tpSrcItem;
	if ( tPos == POS_EQUIPMENT )
	{
		LK_ASSERT( vIndex < EQUIP_LIMIT, return );
		tpSrcItem = pProperty->GetEquipment( )->GetItemObjPtr( vIndex );
	}
	else if( tPos == POS_BAGGAGE )
	{
		// TODO:添加背包索引的检查
		LK_ASSERT( ( pProperty->GetBaggage( )->CheckIndexValid( vIndex ) ), return );
		tpSrcItem = pProperty->GetBaggage( )->GetItemObjPtr( vIndex );
	}		

	if( tpSrcItem == NULL )
	{
		LOG_DEBUG( "default", "[ %s : %d ][ %s ] Err : Entity( %d  ) Index( %d ) Is NULL", __LK_FILE__, __LINE__,
			__FUNCTION__, pEntity->GetEntityID( ), vIndex );
		return;
	}
//	LK_ASSERT_STR( tpSrcItem != NULL, return, "Entity( %d  ) Index( %d ) Is NULL", 
//			pEntity->GetEntityID( ), vIndex );

	// 如果锁定，不能使用
	if ( tpSrcItem->GetLockStatus() != LOCKTYPE_NONE )
	{
		if ( tpSrcItem->GetLockStatus() != LOCKTYPE_LOCKCANUSE )
		{
			SendUseItemResponse( (CEntityPlayer*)pEntity, ERROR_ITEMLOCKED, tPos, vIndex, 0 );
			return;
		}
	}

	if ( pEntity->IsAlive( ) == false )
	{
		SendUseItemResponse( (CEntityPlayer*)pEntity, ERROR_SRCDEAD, tPos, vIndex, 0 );
		return;
	}

	int tRet = SUCCESS;
	int tRemainHP = 0, tRemainMP = 0, tRemainAP = 0, tUsedTimes = 0;
	CTplItem *tpItem = (CTplItem *)CDataStatic::SearchTpl( tpSrcItem->GetItemID() );
	if ( tpItem == NULL )
		return;	

	bool tLimit = false;
	// 如果限制了地图,不能使用
	for ( int i = 0; i < (int)ARRAY_CNT(tpItem->mLmtUseMapID); i++ )
	{
		if ( tpItem->mLmtUseMapID[ i ] == 0 )
		{
			break;
		}
		if ( tpItem->mLmtUseMapID[ i ] == pEntity->GetMapID() )
		{
			tLimit = false;
			break;
		}
		else
		{
			tLimit = true;
		}
	}

	if ( tLimit == true )
	{
		SendUseItemResponse( (CEntityPlayer*)pEntity, ERROR_NOTUSEMAP, tPos, vIndex, 0 );
		return;
	}

	// 如果是能刷新库任务的
	if ( ( tpItem->mProcessType & CTplItem::PROCESSTYPE_ISREFRESHTASK ) == CTplItem::PROCESSTYPE_ISREFRESHTASK )
	{
		if (!CTaskModule::GetSingleton().OnRefreshStorageTask( (CEntityPlayer*)pEntity )) // 刷新失败
		{
			return;
		}
	}

	// 如果组CD未到
	CEntityPlayer* pPlayer = (CEntityPlayer*)pEntity;
	tRet = pPlayer->CheckCDGroup( tpItem->mCDGroup, ARRAY_CNT( tpItem->mCDGroup ) );
	if ( tRet != SUCCESS )
	{
		SendUseItemResponse( (CEntityPlayer*)pEntity, tRet, tPos, vIndex, 0 );
		return;
	}

	// 增加使用次数判断
	if ( tpItem->mCountType != 0 )
	{
		CTemplateCountTable *tpCountTable = (CTemplateCountTable*)CDataStatic::GetTemp( TEMP_COUNT );
		if ( tpCountTable == NULL || ( tpItem->mCountType >= (int) ARRAY_CNT(tpCountTable->mCountData) ) )
		{
			SendUseItemResponse( (CEntityPlayer*)pEntity, ERROR_ITEM_OVER_TIME, tPos, vIndex, 0 );
			return;
		}
		int tKey = CPersonalTimesMgr::MakeKey((enTimeMgrType)tpItem->mCountType, 0);
		int tTimes = pProperty->GetTimesMgr()->GetTimes(tKey);
		
		if ( pProperty->IsVip() ) 
		{
			if ( tTimes >= tpCountTable->mCountData[ tpItem->mCountType ].mVipTime )
			{
				SendUseItemResponse( (CEntityPlayer*)pEntity, ERROR_ITEM_OVER_TIME, tPos, vIndex, 0 );
				return;
			}		
		}
		else
		{
			if ( tTimes >= tpCountTable->mCountData[ tpItem->mCountType ].mCountTime )
			{
				SendUseItemResponse( (CEntityPlayer*)pEntity, ERROR_ITEM_OVER_TIME, tPos, vIndex, 0 );
				return;
			}
		}
	}

	switch( tpItem->mItemType )
	{
		// 如果是药品
	case CTplItem::ITEM_PHYSIC:
		{
			tRet = OnUsePhysics( pEntity, tpItem, tpSrcItem, vIndex, tRemainHP, tRemainMP, tRemainAP );
			IfItemNeedBind = true;
		}
		break;
		// 如果是传送道具
	case CTplItem::ITEM_TELEPORT:
		{
			// 检查当前地图是否支持使用传送道具
			CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( pEntity->GetMapID() );
			if ( tpMapTpl == NULL )
			{
				break;
			}
			if ( tpMapTpl->mTeleItem == false  )
			{
				tRet = ERROR_ITEM_NOTEVENT;
				break;
			}

			CTplItemTeleport *tpTelePort = (CTplItemTeleport *)tpItem;
			// 随即传送
			if ( tpTelePort->mMapID == 1 )
			{
				tRet = OnUseRandomTP( pEntity, vIndex );
				IfItemNeedBind = true;
			}
			// 入口传送
			if ( tpTelePort->mMapID == 2 )
			{

			}
			// 记忆传送
			if ( tpTelePort->mMapID == 3 )
			{
				tRet = OnUseRemberTP( pEntity, vIndex );
				IfItemNeedBind = true;
			}
		}
		break;
		// 如果是回城
	case CTplItem::ITEM_RETURN:
		{
			// 检查当前地图是否支持使用传送道具
			CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( pEntity->GetMapID() );
			if ( tpMapTpl == NULL )
			{
				break;
			}
			if ( tpMapTpl->mTeleItem == false  )
			{
				tRet = ERROR_ITEM_NOTEVENT;
				break;
			}
			tRet = OnUseTownTP( pEntity, vIndex );
			IfItemNeedBind = true;
		}
		break;
		// 如果是坐骑道具
	case CTplItem::ITEM_HORSE:
		{
			CMapTpl *tpTpl = CMapTplManager::GetSingletonPtr( )->GetMapTplByID( pEntity->GetMapID( ) );
			if( tpTpl != NULL )
			{
				bool bHorseCheck = true;
				if ( tpTpl->mBasRide == false && ( tpItem->mProcessType & CTplItem::PROCESSTYPE_ISRMBITEM ) != CTplItem::PROCESSTYPE_ISRMBITEM ) 
				{					
					bHorseCheck = false;
				}
				else if ( tpTpl->mAdvRide == false && ( tpItem->mProcessType & CTplItem::PROCESSTYPE_ISRMBITEM ) == CTplItem::PROCESSTYPE_ISRMBITEM ) 
				{
					bHorseCheck = false;
				}
				
				if ( bHorseCheck == false )
				{
					CMapObject *tpMapObj = CMapObjManager::GetSingleton().GetMapObject( pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetMapIndex() );
					if ( tpMapObj == NULL )
					{
						tRet = ERROR_CANNOTRIDE;
						break;
					}

					// 地宫不能用
					if ( tpMapObj->IsGroundMap() != true || pProperty->IsVip() == false )
					{
						tRet = ERROR_CANNOTRIDE;
						break;
					}					
				}
			}
			tRet = OnUseHorse( pEntity, tpItem, tpSrcItem );
			if ( tRet == SUCCESS )
			{
				int tHorseRet = pProperty->RideHorse( tpItem->mTempID );
				if ( tHorseRet == 0 || tHorseRet == 1 )
				{
					CTplItemHorse* tpTplHorse = (CTplItemHorse*)tpItem;
					CEntityCharacter* pPlayer = (CEntityCharacter*)pEntity;
					if ( tHorseRet == 1 )
					{
						// 骑马进度条验证
						CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );
						CTplItemHorse *tpHorse = (CTplItemHorse *)tpItem;

						if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_HORSE, ( (CEntityPlayer *)pEntity )->GetClientInfo()->mNetSpeed, false, tpHorse->mUsingTime ) == false )
						{
#ifdef _DEBUG_
							//TODO: 外网错误太多，只好改成DEBUG等级
							LOG_ERROR( "pro","wrong progresstime when ride horse, roleid:%d", ( (CEntityPlayer *)pEntity )->GetCharID() );
#endif
							tRet = -1;
							return;
						}
						
						// 上坐骑BUFF						
						CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( tpTplHorse->mSpeedBuff );
						LK_ASSERT( tpBuffTpl != NULL, return );
						if ( tpTpl->mFlyRide == false )
						{
							for ( unsigned int i = 0; i < ARRAY_CNT(tpBuffTpl->mBuff); i++ )
							{
								if ( tpBuffTpl->mBuff[ i ].mBuffFunc == CTemplateBuff::BUFFFUNC_FLY )
								{
									tRet = ERROR_CANNOTRIDE;
									break;
								}
							}
						}	
						if ( tRet != SUCCESS )
						{
							break;
						}
						if ( pProperty->IsVip() == false &&  ((int)(pProperty->GetCurAP()) < tpTplHorse->mInitAP ) )
						{
							tRet = ERROR_RIDENOAP;
							break;
						}
						pPlayer->InitFunResult( );
						if ( pPlayer->EntityInsertBuff( pPlayer, tpBuffTpl ) != SUCCESS )
						{
							tRet = ERROR_CANNOTRIDE;
							break;
						}
						if ( pProperty->IsVip() == false )
						{
							int tAp = pProperty->GetCurAP();
							pProperty->SetCurAP( std::max( 0, tAp - tpTplHorse->mInitAP ) );
							pPlayer->AddFunResult( pPlayer->GetEntityID(), FUNC_DECAP, RESULT_NORMAL, true, tpTplHorse->mInitAP, pProperty->GetCurAP(), pProperty->GetMaxAP() );
						}						
						ResultListSend( );
					}
					//else if( tHorseRet == 0 ) 【下坐骑统一在OffHorse那里处理 因为有很多地方需要调用下坐骑】
					//{
					//	// 下马
					//	pPlayer->InitFunResult( );
					//	pPlayer->EntityRemoveBuff( tpTplHorse->mSpeedBuff );
					//	ResultListSend( );
					//}
					// 广播坐骑的消息
					SendRideHorseNotice( pEntity, tpItem->mTempID, tHorseRet );
					IfItemNeedBind = true;
				}
				else
				{
					tRet = tHorseRet;
				}
			}			
		}
		break;
		// 门派返回卷
	case CTplItem::ITEM_RETURNPAPER:
		{
			// 检查当前地图是否支持使用传送道具
			CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( pEntity->GetMapID() );
			if ( tpMapTpl == NULL )
			{
				break;
			}
			if ( tpMapTpl->mTeleItem == false  )
			{
				tRet = ERROR_ITEM_NOTEVENT;
				break;
			}
			tRet = OnUseReturnPaper( pEntity, tpItem, vIndex );
		}
		break;
		// 传送符
	case CTplItem::ITEM_TELESYMBOL:
		{
			// 检查当前地图是否支持使用传送道具
			CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( pEntity->GetMapID() );
			if ( tpMapTpl == NULL )
			{
				break;
			}
			if ( tpMapTpl->mTeleItem == false  )
			{
				tRet = ERROR_ITEM_NOTEVENT;
				break;
			}
			tRet = OnUseTeleSymbol( pEntity, tpItem, vIndex, vParam, tUsedTimes );
		}
		break;
		// 指定炉石
	case CTplItem::ITEM_STOVE:
		{
			// 检查当前地图是否支持使用传送道具
			CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( pEntity->GetMapID() );
			if ( tpMapTpl == NULL )
			{
				break;
			}
			if ( tpMapTpl->mTeleItem == false  )
			{
				tRet = ERROR_ITEM_NOTEVENT;
				break;
			}
			tRet = OnUseStove( pEntity, tpItem, tpSrcItem, vIndex );
		}
		break;
		// 藏宝图
	case CTplItem::ITEM_MINEMAP:
		{
			tRet = OnUseMineMap( pEntity, tpItem, vIndex );
		}
		break;
		// 召唤类物品
	case CTplItem::ITEM_CALL:
		{
			tRet = OnUseItemCall( pEntity, tpItem, vIndex );
		}
		break;
		// 技能类物品
	case CTplItem::ITEM_SKILL:
		{
			tRet = OnUseItemSkill( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_CARD:
		{
			tRet = OnUseCard( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_GIFTBAG:  // 礼包
		{
			tRet = OnUseGiftBag( pEntity, tpItem, vIndex, vParam );
		}
		break;
	case  CTplItem::ITEM_LIFESKILLSCROLL:
		{
			tRet = OnUseLifeSkillScroll( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_FUNCITEM:  // 功能性物品
		{
			tRet = OnUseFuncItem( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_REDPAPER:
		{
			 tRet = OnUseRedPaper( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_VIP:
		{
			tRet = OnUseVipItem( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_CLEAN:
		{
			tRet = OnUseCleanItem( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_LEAGUEBAG:
		{
			tRet = OnUseLeagueBagItem( pEntity, tpItem, vIndex );
		}
		break;
	case CTplItem::ITEM_BLACKPILLS:
		{
			tRet = OnUseBlackPills( pEntity, tpItem, vIndex );			
		}
		break;
	case CTplItem::ITEM_EXPPILLS:
		{
		
			tRet = OnUseExpPills( pEntity, tpItem, vIndex );			
		}
		break;
	
	default:
		{
			// 如果能够使用技能
			if ( tpItem->mSkillID > 0 )
			{
				
				CEntityCharacter *pDesEntity = dynamic_cast< CEntityCharacter * >( CSceneLogic::GetSingletonPtr( )->GetEntity( vParam ) );
				
				// 检查是否可以使用的结婚装备
				tRet = CheckMarriageEquipmentValid( pPlayer, tpItem, tpSrcItem, pDesEntity );
				if ( tRet == SUCCESS )
				{
					CTemplateSkill *tplSkill = (CTemplateSkill*)CDataStatic::SearchTpl( tpItem->mSkillID );
					if ( tplSkill != NULL )
					{
						bool tUsed = UseSkill( (CEntityCharacter*)pEntity, pDesEntity, tplSkill->mSkillID, tplSkill->mSkillLevel, 0, 0, NULL, 0, false, true );
						if ( tUsed == true && tpItem->mDisappear == 0 )
						{
							uint64_t ullGUID = tpSrcItem->GetGUID();
							int nItemID = tpSrcItem->GetItemID();
							if ( PlayerRemoveItem( (CEntityPlayer*)pEntity, vIndex, 1 ) == 0)
							{
								LogEventLostItemByUse((CEntityPlayer*)pEntity, ullGUID, nItemID, 1);
							}
						}
					}							
				}			
			}
			else
			{
				tRet = ERROR_WRONGTYPE;
			}			
		}
		break;
	}

	if ( tRet == SUCCESS )
	{
		((CEntityPlayer*)pEntity)->RefreshCDGroup( tpItem->mCDGroup, ARRAY_CNT( tpItem->mCDGroup ) );

		if ( tpItem->mCountType != 0 )
		{
			int tKey = CPersonalTimesMgr::MakeKey((enTimeMgrType)tpItem->mCountType, 0);
			pProperty->GetTimesMgr()->Tick(tKey);
		}
	}

	if ( IfItemNeedBind == true )
	{
		if ( GetItemObjBindStatus( tpSrcItem ) == ITEM_BINDSTATUS_FREE )
		{
			int tBindRet = BindItem( ( CEntityPlayer * )pEntity, tpSrcItem , ITEM_BINDWAY_BYUSE );
			if ( tBindRet == ITEM_BINDRESULT_SUCESS )
			{
				SendItemBindedNotice( ( CEntityPlayer * )pEntity, vIndex, SLOT_BAGGAGE );	
			}			 
		}			
	}

	// 如果有 有效时间，而且是使用后开启
	if ( tpItem->mValidTime > 0 && tpItem->mValidType == VALIDTYPE_USE )
	{
		SetItemValidTime((CEntityPlayer*)pEntity, tpItem, tpSrcItem );
		NotifyClientStartTimer( pPlayer, (EPosType)tPos, vIndex, tpSrcItem->GetInvalidTime() );
	}

	if ( tpItem->mItemType == CTplItem::ITEM_TELESYMBOL )
	{
		SendUseItemResponse( (CEntityPlayer*)pEntity, tRet, tPos, vIndex, tpSrcItem->GetItemID(), tUsedTimes, tRemainMP, tRemainAP );
	}
	else
	{
		SendUseItemResponse( (CEntityPlayer*)pEntity, tRet, tPos, vIndex, tpSrcItem->GetItemID(), tRemainHP, tRemainMP, tRemainAP );
	}	
}

// 使用任务道具

void CPropertyModule::UseTaskItem( CEntityPlayer* pEntity, unsigned short vIndex )
{
	LK_ASSERT( pEntity != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();
	LK_ASSERT ( vIndex < pProperty->GetTaskBaggage( )->mReleaseIndex, return; )
		

	LK_ASSERT( pEntity->GetEntityType() == ENTITYTYPE_PLAYER , return );

	CItemObject* pItemObj = pProperty->GetTaskBaggage( )->GetItemObjPtr( vIndex );
	LK_ASSERT( pItemObj != NULL, return );
	if ( pEntity->IsAlive( ) == false )
	{
		//// 发送获得道具的错误通知
		SendProErrorNotice( pEntity, ERROR_SRCDEAD );
	}	

	CTplItem* tpItem = ( CTplItem* ) CDataStatic::SearchTpl( pItemObj->GetItemID() );
	if ( tpItem == NULL )
	{
		SendProErrorNotice( (CEntityPlayer*)pEntity, ERROR_ITEM_DATANOTEXIST );
		return ;
	}
	
	int tRet = -1;
	switch( tpItem->mItemType )
	{
	case CTplItem::ITEM_TOKEN: // 惩妖令牌
		{
			tRet = OnUseToken( pEntity, tpItem, vIndex );
			break;
		}
	case CTplItem::ITEM_CALL: // 召唤类物品
		{
			tRet = OnUseItemCall( pEntity, tpItem, vIndex );
			break;
		}
	case CTplItem::ITEM_TASK:
	case CTplItem::ITEM_SPECIAL_TASK:
		{
			int tItemID = 0;
			tRet = CTaskModule::GetSingleton().UseTaskItem( (CEntityPlayer*)pEntity, vIndex, tItemID );
			break;
		}
	default:
		{
			LOG_ERROR("pro", "task bag has invilid item : id=%d", tpItem->mTempID );
			return;
		}
	}
	SendUseItemResponse( (CEntityPlayer*)pEntity, tRet, POS_TASK_BAGGAGE, vIndex, tpItem->mTempID );
}


// 获得道具时处理
void CPropertyModule::OnTaskObtainItem( CEntityPlayer* pPlayer, unsigned int vItemID, unsigned short vNumber )
{
	CTaskModule::GetSingleton().OnTaskObtainItem( pPlayer, vItemID, vNumber );
}

// 获得一个已经存在道具
CItemObject*  CPropertyModule::PlayerInsertItem( CEntityPlayer* pEntity, CItemObject* tpItemObj, bool bIsCalledFromTask, bool bBind )
{
	if ( tpItemObj == NULL || pEntity == NULL )
	{
		LOG_ERROR( "pro", "Input Params is none,[%s : %d]", __LK_FILE__, __LINE__ );
		return NULL;
	}

	CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpItemObj->GetItemID() );

	if ( tpTplItem == NULL )
	{
		SendProErrorNotice( pEntity, ERROR_ITEM_DATANOTEXIST );
		return NULL;
	}
	
	// 如果已经过期，不可插入 直接销毁
	if ( tpTplItem->mInvilidDate != 0 && tpTplItem->mInvilidDate <= GetYYYYMMDD( time(NULL) ) )
	{
		SendProErrorNotice( pEntity, ERROR_INVILID_ITEM );
		CSceneObjManager::GetSingletonPtr()->DestroyObject( tpItemObj->get_id() );
		return NULL;
	}

	//	绑定状态判断
	if ( bBind  == true )
	{
		if ( !( tpItemObj->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{				
			SetEquipBindTime( tpItemObj );
		}
		tpItemObj->SetBindStatus( tpItemObj->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
	}

	// 如果是拾取绑定则绑定该物品
	if ( GetItemObjBindStatus( tpItemObj ) == ITEM_BINDSTATUS_FREE )
	{
		BindItem( pEntity , tpItemObj , ITEM_BINDWAY_BYPICKUP );
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();
	CMessage tMessage;	
	
	int tPos = POS_NULL;
	int tIndex[ BOX_LIMIT ] = { 0 };
	int tNumber[ BOX_LIMIT ] = { 0 };
	int tLen = 0;
	int tRet = pProperty->InsertBaggageItem( tpItemObj, tPos, tIndex, tNumber, tLen );		
	bool vBool = false;	
	//int tItemID		= tpItemObj->mItemID;
	//int tItemNumber	= tpItemObj->mNumber;	

	CItemObject* pLastInsertedItem = NULL;
	// 添加到包裹中
	if ( tRet == ERROR_INSERTITEM_SUCCESS )
	{	  
		if ( IS_TASK_ITEM( tpTplItem) )
		{
			pLastInsertedItem = pProperty->GetTaskBaggage()->GetItemObjPtr( tIndex[tLen-1] );
		}else
		{
			pLastInsertedItem = pProperty->GetBaggage()->GetItemObjPtr( tIndex[tLen-1] );
		} 
		
		// 如果是有时间限制 而且是进包就开始
		if ( tpTplItem->mValidTime > 0 && tpTplItem->mValidType == VALIDTYPE_GET )
		{
			SetItemValidTime(pEntity, tpTplItem, tpItemObj);
		}
		
		// 如果不可堆叠
		if ( tpTplItem->mPileLimit == 1 )
		{
			CMessageInsertEquipNotify tMessageNotice;
			vBool = CreateMessageInsertEquipNotice( &tMessage, &tMessageNotice, tpItemObj, tPos, tIndex[0] );
			if ( vBool == true )
			{
				CSceneLogic::GetSingleton( ).Send2Player( pEntity, &tMessage );
			}
		}
		else
		{
			CMessageInsertItemNotify tMessageNotice;
			vBool = CreateMessageInsertItemNotice( &tMessage, &tMessageNotice, 
						tPos, tpItemObj->GetItemID(), tIndex, tNumber, tLen, tpItemObj->GetBindStatus() );

			if ( vBool == true )
			{
				CSceneLogic::GetSingleton( ).Send2Player( pEntity, &tMessage );
			}
		}  

		AfterInsertedItem(pEntity, tpTplItem, tpItemObj, bIsCalledFromTask);

		// 删除物品，如果插入后个数为0
		if ( tpItemObj->GetItemNum() == 0 )
		{
			CSceneObjManager::GetSingletonPtr()->DestroyObject( tpItemObj->get_id() );
		}
	}
	else
	{
		//// 发送获得道具的错误通知
		SendProErrorNotice( pEntity, tRet );
	}

	return pLastInsertedItem;
}



// 生产装备
// vType1	生产物品的类型，武器，防具，药品
// vType2	生产类型细化，武器为武器类型，防具为防具位置
// vType3	生产类型细化，防具为防具效果
// vLevel	生产物品的等级，药品为药品类别
// vRank	生产材料的等级
void CPropertyModule::PlayerProduceEquip( CEntityPlayer* pPlayer, unsigned short vType1, unsigned short vType2, unsigned short vType3, unsigned short vLevel, unsigned short vRank, int vType  )
{
	LK_ASSERT( pPlayer != NULL, return  );

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查安全密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	
	// 如果数值类型错误
	if ( vType1 > PHYSICS_DEXP || vRank > 4 )
	{
		LOG_ERROR( "pro", "[%s:%d] vType1 %d, vRank %d, prolevel %d", __LK_FILE__, __LINE__, vType1, vRank, pProperty->GetProLevel( ) );
		return;	
	}

	// 以Rank来标志是生产装备还是生产药品
	if ( vRank > 0 )
	{

		// 如果生产等级不足
		if ( pProperty->GetProLevel( ) < vLevel )
		{
			pProperty->GetProduce( )->Clear( );
			SendProErrorNotice( pPlayer, ERROR_PROLOWLEVEL );
			return;
		}		

		// 如果数值类型错误
		if ( vType1 > EQUIP_BELT || vRank > 4 )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOTYPE );
			return;
		}
		if ( vLevel > EQUIP_LEVEL_END )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOTYPE );
			return;
		}

		// 如果背包满了
		if ( pProperty->GetBaggage( )->Space( ) == (unsigned int)~0 )
		{
			//// 发送生产道具的错误通知
			pProperty->GetProduce( )->Clear( );
			SendProErrorNotice( pPlayer, ERROR_PRONOSPACE );
			return;
		}

		int tTplID = CDataStatic::GetProEquip( vType1, vType2, vLevel, vRank, vType3 );
		if ( tTplID == 0 )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOMATERIAL );
			return;
		}
		CTemplateProEquip *tpEquip = (CTemplateProEquip*)CDataStatic::SearchTpl( tTplID );
		if ( tpEquip == NULL )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOMATERIAL );
			return;
		}	

		// 如果钱不够(绑定钱+非绑定钱)
		unsigned int tBaggageMoney = ( unsigned int ) (pProperty->GetBindMoney() + pProperty->GetMoney());
		if ( tBaggageMoney < (unsigned int)tpEquip->mMoney )
		{
			pProperty->GetProduce( )->Clear( );
			SendProErrorNotice( pPlayer, ERROR_PRONOMONEY );
			return;
		}

		if( pProperty->GetBaggage( )->HasItem( tpEquip->mMaterialID, tpEquip->mMaterialNum, vType ) == false )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOMATERIAL );
			return;
		}

		int tRan1,tRan2,tID1,tID2,tID3;
		if ( tpEquip->mItemRan1 > tpEquip->mItemRan2 )
		{
			if ( tpEquip->mItemRan3 > tpEquip->mItemRan1 )
			{
				tRan1 = tpEquip->mItemRan1;
				tRan2 = tpEquip->mItemRan2;
				tID1 = tpEquip->mItemID1;
				tID2 = tpEquip->mItemID2;
				tID3 = tpEquip->mItemID3;
			}
			if ( tpEquip->mItemRan1 >= tpEquip->mItemRan3 && tpEquip->mItemRan3 >= tpEquip->mItemRan2 )
			{
				tRan1 = tpEquip->mItemRan3;
				tRan2 = tpEquip->mItemRan2;
				tID1 = tpEquip->mItemID3;
				tID2 = tpEquip->mItemID2;
				tID3 = tpEquip->mItemID1;
			}
			if ( tpEquip->mItemRan2 > tpEquip->mItemRan3 )
			{
				tRan1 = tpEquip->mItemRan2;
				tRan2 = tpEquip->mItemRan3;
				tID1 = tpEquip->mItemID2;
				tID2 = tpEquip->mItemID3;
				tID3 = tpEquip->mItemID1;
			}
		}
		else
		{
			if ( tpEquip->mItemRan3 > tpEquip->mItemRan2 )
			{
				tRan1 = tpEquip->mItemRan2;
				tRan2 = tpEquip->mItemRan1;
				tID1 = tpEquip->mItemID2;
				tID2 = tpEquip->mItemID1;
				tID3 = tpEquip->mItemID3;
			}
			if ( tpEquip->mItemRan2 >= tpEquip->mItemRan3 && tpEquip->mItemRan3 >= tpEquip->mItemRan1 )
			{
				tRan1 = tpEquip->mItemRan3;
				tRan2 = tpEquip->mItemRan1;
				tID1 = tpEquip->mItemID3;
				tID2 = tpEquip->mItemID1;
				tID3 = tpEquip->mItemID2;
			}
			if ( tpEquip->mItemRan1 > tpEquip->mItemRan3 )
			{
				tRan1 = tpEquip->mItemRan1;
				tRan2 = tpEquip->mItemRan3;
				tID1 = tpEquip->mItemID1;
				tID2 = tpEquip->mItemID3;
				tID3 = tpEquip->mItemID2;
			}
		}
		int tItemID = 0;
		int tRan = RAND(10000);
		if ( tRan < tRan1 )
		{
			tItemID = tID1;
			if ( tRan < tRan2 )
			{
				tItemID = tID2;
			}
		}
		else
		{
			tItemID = tID3;
		}

		CTplItem *pTplItem = (CTplItem*)CDataStatic::SearchTpl( tItemID );
		if ( tItemID == 0 || pTplItem == NULL)
		{
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOPRODUCE );
			return;
		}	

		bool tBind = vType == BIND_NO ? false : true; 
		// 先扣除物品
		CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tItemID, 1, false, 0, pPlayer->GetCharName(), tBind ); 
		if ( pInsItemPile != NULL)
		{
			// Log
			LogEventGetItemByProduce( pPlayer, pInsItemPile->GetGUID(), tItemID, 1, tpEquip->mMaterialID, tpEquip->mMaterialNum );
		}else
		{
			pProperty->GetProduce( )->Clear( );
			return;
		}

		uint64_t ullGUID = 0;
		if (PlayerRemoveItemByID( pPlayer, tpEquip->mMaterialID, tpEquip->mMaterialNum, tBind, &ullGUID, vType ) == 0)
		{
			LogEventLostItemByProduce( pPlayer, ullGUID, 
					tpEquip->mMaterialID, tpEquip->mMaterialNum, tItemID, pInsItemPile->GetGUID());
		}

		if ( PlayerChangeMoney( pPlayer, tpEquip->mMoney, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByProduceEquip(pPlayer, CYuanBao::em_bind_money, tpEquip->mMoney, tItemID, pInsItemPile->GetGUID());
		}

		pProperty->GetProduce( )->mNumber--;
		pProperty->SetProExp( pProperty->GetProExp( ) + tpEquip->mExp );
		CTemplateProExp *tProExp = (CTemplateProExp*)CDataStatic::GetTemp( TEMP_PROEXP );
		if ( tProExp == NULL )
		{
			return;
		}
		int nLevelUp = 0;
		while ( pProperty->GetProExp( ) >= tProExp->mLevelExp[ pProperty->GetProLevel( ) ] )
		{
			pProperty->SetProExp( pProperty->GetProExp( ) - tProExp->mLevelExp[ pProperty->GetProLevel( ) ] );
			if ( ( pProperty->GetProLevel( ) + 1 ) > MAXPROLEVEL )
			{
				pProperty->SetProExp( 0 );
				break;
			}
			pProperty->SetProLevel( pProperty->GetProLevel( ) + 1 );
			nLevelUp ++;
		} 
		SendProExpNotice( pPlayer, pProperty->GetProLevel( ), pProperty->GetProExp( ) );
		if ( nLevelUp > 0)
		{
			SendProErrorNotice( pPlayer, EEROR_PROLEVELUP );
			LogEventPlayerProduceLevelUp(pPlayer, nLevelUp);
		}

		// log
		LogEventGetProExpByProduce(pPlayer, pInsItemPile, tpEquip->mExp);
	}

	else
	{

		if ( vLevel > 0 && (int)pProperty->GetProLevel( ) < ( ( vLevel - 1 ) * 3 ) )
		{
			pProperty->GetProduce( )->Clear( );
			SendProErrorNotice( pPlayer, ERROR_PROLOWLEVEL );
			return;
		}

		// 如果数值类型错误
		if ( vType1 > PHYSICS_DEXP || vLevel > 4 )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOTYPE );
			return;
		}	

		int tTplID = CDataStatic::GetProPhy( vType1, vLevel );
		if ( tTplID == 0 )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOMATERIAL );
			return;
		}
		CTemplateProPhysics *tpPhys = (CTemplateProPhysics*)CDataStatic::SearchTpl( tTplID );
		if ( tpPhys == NULL )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOMATERIAL );
			return;
		}

		// 如果钱不够
		unsigned int tBaggageMoney = ( unsigned int ) ( pProperty->GetMoney() + pProperty->GetBindMoney() );
		if ( tBaggageMoney < ( unsigned int )tpPhys->mMoney )
		{
			pProperty->GetProduce( )->Clear( );
			SendProErrorNotice( pPlayer, ERROR_PRONOMONEY );
			return;
		}

		if( pProperty->GetBaggage( )->HasItem( tpPhys->mMaterialID, tpPhys->mMaterialNum ) == false )
		{
			pProperty->GetProduce( )->Clear( );
			//// 发送生产道具的错误通知
			SendProErrorNotice( pPlayer, ERROR_PRONOMATERIAL );
			return;
		}

		// 如果背包满了
		if ( pProperty->GetBaggage( )->Space( tpPhys->mItemID, 1 ) == false )
		{
			pProperty->GetProduce( )->Clear( );
			SendProErrorNotice( pPlayer, ERROR_PRONOSPACE );
			return;
		}

		uint64_t ullGUID = 0;
		CItemObject * pInsItemPile = NULL;
		bool tBind = false;

		if (PlayerRemoveItemByID( pPlayer, tpPhys->mMaterialID, tpPhys->mMaterialNum, tBind, &ullGUID ) == 0) 
		{
			pInsItemPile = PlayerInsertItem( pPlayer, tpPhys->mItemID, 1); 
			if ( pInsItemPile != NULL)
			{
				LogEventGetItemByProduce( pPlayer, pInsItemPile->GetGUID(), tpPhys->mItemID, 1, 
						tpPhys->mMaterialID, tpPhys->mMaterialNum);

				if (PlayerChangeMoney( pPlayer, tpPhys->mMoney, true, true ) == SUCCESS)
				{
					LogEventLostMoneyByProducePhys(pPlayer, CYuanBao::em_bind_money, tpPhys->mMoney, tpPhys->mItemID, pInsItemPile->GetGUID());	
				}
			}

			LogEventLostItemByProduce( pPlayer, ullGUID, 
					tpPhys->mMaterialID, tpPhys->mMaterialNum, tpPhys->mItemID, pInsItemPile->GetGUID());

		}


		pProperty->GetProduce( )->mNumber--;	
		pProperty->SetProExp( pProperty->GetProExp( ) + tpPhys->mExp );
		CTemplateProExp *tProExp = (CTemplateProExp*)CDataStatic::GetTemp( TEMP_PROEXP );
		if ( tProExp == NULL )
		{
			LOG_ERROR( "pro", "GetTemp() failed.[%s : %d]", __LK_FILE__, __LINE__ );
			return ;
		}
		
		int nLevelUp = 0;
		while ( pProperty->GetProExp( ) >= tProExp->mLevelExp[ pProperty->GetProLevel( ) ] )
		{
			pProperty->SetProExp( pProperty->GetProExp( ) - tProExp->mLevelExp[ pProperty->GetProLevel( ) ] );
			if ( ( pProperty->GetProLevel( ) + 1 ) > MAXPROLEVEL )
			{
				pProperty->SetProExp( 0 );
				break;
			}
			pProperty->SetProLevel( pProperty->GetProLevel( ) + 1 );
			nLevelUp ++;			
		}
		SendProExpNotice( pPlayer, pProperty->GetProLevel( ), pProperty->GetProExp( ) );

		if ( nLevelUp > 0)
		{
			SendProErrorNotice( pPlayer, EEROR_PROLEVELUP );
			LogEventPlayerProduceLevelUp(pPlayer, nLevelUp);
		}

		// log
		LogEventGetProExpByProduce(pPlayer, pInsItemPile, tpPhys->mExp);
	}

	SendProFinNotice( pPlayer, 0, pProperty->GetProduce( )->mNumber );
}

// 玩家升级道具
// vIndex1	装备的位置
// vIndex2	宝石的位置
// vIndex3	苻的位置
void CPropertyModule::PlayerUpItem( CEntityPlayer* pPlayer, int vIndex1, int vIndex2, int *vIndex3, int vType, int nNpcEntityID )
{
	LK_ASSERT( pPlayer != NULL, return );
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

	CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( nNpcEntityID ) );
	if( pNpc == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find obj %d", __LK_FILE__, __FUNCTION__, __LINE__, nNpcEntityID );
		return ;
	}
	if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), nNpcEntityID, __FUNCTION__ );
		return;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mUpgService == 0 )
	{
		return;
	}

	if ( pProperty->GetServiceStatus( ) != SERVICE_UPG )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	if ( ( vType == UPG_PROPERTY && ( tpNpc->mUpgService & 0x01 ) != 0x01 ) ||
		 ( vType == UPG_RESDEF && ( tpNpc->mUpgService & 0x02 ) != 0x02 ) ||
		 ( vType == UPG_RESATT && ( tpNpc->mUpgService & 0x04 ) != 0x04 ) )
	{
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	unsigned short tResult = UPG_SUCCESS;

	// 防止缓冲区溢出
	// TODO:添加对背包索引的判断(包括背包有效期的判断)
	/*if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex 
		|| vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex 
		|| ( vIndex3 != - 1 && vIndex3 >= (int)pProperty->GetBaggage( )->mReleaseIndex ) )*/
	if( ( !pProperty->GetBaggage( )->CheckIndexValid( vIndex1 ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) ) )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}
	for ( int i = 0; i < UPG_ITEM_NUM; i++ )
	{
		if ( vIndex3[ i ] != -1 && ( !pProperty->GetBaggage()->CheckIndexValid( vIndex3[ i ] ) ) )
		{
			SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
			SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
			return;
		}
	}
	if ( vType < UPG_PROPERTY || vType > UPG_RESATT )
	{
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}	
	
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendProErrorNotice( pPlayer, ERROR_UPGEQUIPBINDBYITEM );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}		   	
	
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID());
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}
	// 如果第一件不是装备或者第二件不是升级道具或者第三件不是保底或者运气
	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR&& tpItem1->mItemType != CTplItem::ITEM_MAGICWEAPON ) || tpItem2->mItemType != CTplItem::ITEM_EQUIPUPG )
	{

		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}	

	CTemplateEquipment *tpEquip = (CTemplateEquipment*)tpItem1;	
	CItemEquipment *tEquip = (CItemEquipment*)tItem1;
	uint64_t ullGUIDOfItem1 = tItem1->GetGUID();
	uint64_t ullGUIDOfItem2 = tItem2->GetGUID();

	// 如果不能升级
	if ( ( vType == UPG_PROPERTY && tpEquip->mCanUpgrade != 0 )   ||
		 ( vType == UPG_RESDEF && tpEquip->mCanDefUpgrade != 0 )  ||
		 ( vType == UPG_RESATT && tpEquip->mCanAttUpgrade != 0 ) )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}
	// 如果装备等级高于精炼石等级
	CTplItemEquipUpg *tpUpg = (CTplItemEquipUpg*)tpItem2;
	if ( tpUpg->mType != vType || tpEquip->mLevelRequire > tpUpg->mMaxLevel )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	// 精炼石的类型要和装备/法宝的类型匹配
	if ( ( ( tpItem1->mItemType == CTplItem::ITEM_WEAPON || tpItem1->mItemType == CTplItem::ITEM_ARMOR ) && tpUpg->mUpType != CTplItemEquipUpg::UPTYPE_EQUIT )
		|| ( ( tpItem1->mItemType == CTplItem::ITEM_MAGICWEAPON ) && tpUpg->mUpType != CTplItemEquipUpg::UPTYPE_MW )  )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	bool tBind = false;
	if ( ( tItem2->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
	{
		tBind = true;
	}

	int tLuck = 0;
	int tRemain = 0;
	int tUpg = 0;
	//int tRand = RAND( 10000 );
	//int tLowRan = 0;
	//int tHighRan = 0;
	/*for ( unsigned int i = 0; i < ARRAY_CNT( tpUpg->mLuck ); i++ )
	{
		tLowRan		+= ( i == 0 ) ? 0 : tpUpg->mLuck[ i - 1 ];
		tHighRan	+= tpUpg->mLuck[ i ];
		if ( tRand >= tLowRan && tRand < tHighRan )
		{
			tUpg = i;
			break;
		}
	}*/

	CItemObject* tItem3[ UPG_ITEM_NUM ] = { NULL };
	CTplItem* tpItem3 = NULL;

	// 只有本体属性升级可以使用保底强运
	if ( vType == UPG_PROPERTY )
	{
		for ( int i = 0; i < UPG_ITEM_NUM; i++ )
		{
			if ( vIndex3[ i ] == -1 )
			{
				break;
			}
			for ( int j = 0; j < i; j++ )
			{
				if ( vIndex3[ j ] == vIndex3[ i ] )
				{
					SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
					SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
					return;
				}
			}
			tItem3[ i ] = pProperty->GetBaggage( )->GetItemObjPtr( vIndex3[ i ] );
			if ( tItem3[ i ] == NULL )
				return;
			tpItem3 = (CTplItem*)CDataStatic::SearchTpl( tItem3[ i ]->GetItemID() );
			if ( tpItem3 == NULL )
				return;
			if( tpItem3->mItemType != CTplItem::ITEM_UPGLUCK && tpItem3->mItemType != CTplItem::ITEM_UPGLEAST )
			{
				//// 发送升级道具的错误通知
				SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
				SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
				return;
			}

			if ( tpItem3->mItemType == CTplItem::ITEM_UPGLUCK )
			{
				CTplUpgLuck *tplLuck = (CTplUpgLuck*)tpItem3;
				tLuck += tplLuck->mIncLuck1;
				// 如果不是指定等级的必升石，不能升级
				if ( tplLuck->mLevel != 0 && tplLuck->mLevel != ( tEquip->GetLevel() + 1 ) )
				{
					//// 发送升级道具的错误通知
					SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
					SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
					return;
				}
				/*int tRand = RAND( 10000 );
				int tLowRan = 0;
				int tHighRan = 0;
				for ( unsigned int i = 0; i < ARRAY_CNT( tplLuck->mIncLuck3 ); i++ )
				{
					tLowRan		+= ( i == 0 ) ? 0 : tplLuck->mIncLuck3[ i - 1 ];
					tHighRan	+= tplLuck->mIncLuck3[ i ];
					if ( tRand >= tLowRan && tRand < tHighRan )
					{
						tUpg = i;
						break;
					}
				}*/
			}
			else if ( tpItem3->mItemType == CTplItem::ITEM_UPGLEAST )
			{
				CTplUpgLeast *tplLeast = (CTplUpgLeast*)tpItem3;
				if ( tplLeast->mType != 0 )
				{
					SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
					SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
					return;
				}
				tRemain = tplLeast->mIncLuck2;
			}	

			if ( ( tItem3[ i ]->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
			{
				tBind = true;
			}
		}		
	}

	if ( tLuck != 0 && tRemain != 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	// 乾坤八卦石等不能和神炼石共存
	if ( ( tLuck != 0 || tRemain != 0 ) && tpUpg->mFail != 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	CTemplateEquipUpg *tUpgList = (CTemplateEquipUpg*)CDataStatic::GetTemp( TEMP_UPGRADE );
	if ( tUpgList == NULL )
	{
		LOG_ERROR( "pro", "GetTemp() failed.Type:TEMP_UPGRADE.[%s : %d]", __LK_FILE__, __LINE__ );
		return ;
	}
	
	
	// 借用临时变量记录属性等级
	int nLevelValue = 0;
	// int *pLevel = &nLevelValue;
	
	unsigned int tFee = 0;
	if ( vType == UPG_PROPERTY )
	{
		nLevelValue =  tEquip->GetLevel() ;
		tFee = tpEquip->mUpgCharge;
	}
	else if ( vType == UPG_RESDEF )
	{
		nLevelValue =  tEquip->GetDefLevel();
		tFee = tpEquip->mDefUpgCharge;
	}
	else if ( vType == UPG_RESATT )
	{
		nLevelValue = tEquip->GetAttLevel() ;
		tFee = tpEquip->mAttUpgCharge;
	}
	else
	{
		LOG_ERROR( "pro", "Wrong Upg Type[%s : %d]", __LK_FILE__, __LINE__ );
		return ;
	}

	int nPrevLevel = nLevelValue;
	// 如果金钱不足
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < tFee )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGNOTYPE );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	// 如果达到改造上限
	if ( ( nLevelValue >= ITEMUPLIMIT && vType == UPG_PROPERTY ) || ( nLevelValue >= ITEMRESLIMIT && ( vType == UPG_RESDEF || vType == UPG_RESATT ) ) )
	{
		//// 发送升级道具的错误通知
		SendProErrorNotice( pPlayer, ERROR_UPGLIMIT );
		SendUpgEquipNotice( pPlayer, UPG_STOP, vType, vIndex1 );
		return;
	}

	int tSuccess = 0;
	if ( tpUpg->mFail != 0 )
	{
		tSuccess = tUpgList->mEquipUpg[ vType ][ nLevelValue ].mExtSuccess;
	}
	else
	{
		tSuccess = tUpgList->mEquipUpg[ vType ][ nLevelValue ].mSuccess;
	}
	// 如果成功升级
	if ( RAND( 100000000 ) < tSuccess + tLuck * SERVER_PERCENT_INT )
	{	
		// 等级增加
		(nLevelValue)++;
		nLevelValue += tUpg;		
		if ( nLevelValue > ITEMUPLIMIT && vType == UPG_PROPERTY )
		{
			nLevelValue = ITEMUPLIMIT;
		}
		if ( nLevelValue > ITEMRESLIMIT && ( vType == UPG_RESDEF || vType == UPG_RESATT ) )
		{
			nLevelValue = ITEMRESLIMIT;
		}
		tResult = UPG_SUCCESS;

		// 
	}
	// 如果失败
	else if ( tpUpg->mFail != 0 )
	{
		tResult = UPG_REMAIN;
	}
	else
	{	
		// 记录装备升级失败次数
		pProperty->SetUpFailNum( pProperty->GetUpFailNum() +1 );
		// 如果装备消失
		if ( RAND( 10000 ) < tUpgList->mEquipUpg[ vType ][ nLevelValue ].mFail )
		{
			if ( PlayerRemoveItem( pPlayer, vIndex1, 1 ) == 0);
			{
				LogEventLostItemByUpgrade(pPlayer, ullGUIDOfItem1, tpItem1->mTempID, 1, UPG_FAIL, 0, 0);
			}

			tResult = UPG_FAIL;
		}
		else
		{
			// 如果等级<2或者有保底符,装备保留,改造次数+1
			if ( tRemain > 0 )
			{
				// 等级减少
				if ( nLevelValue > 0 )
				{
					(nLevelValue)--;
				}
				tResult = UPG_REMAIN;
			}
			else
			{
				if ( tUpgList->mEquipUpg[ vType ][ nLevelValue ].mResult != -1 )
				{
					nLevelValue = tUpgList->mEquipUpg[ vType ][ nLevelValue ].mResult;
					tResult = UPG_DOWN;
				}				
				else
				{
					if (PlayerRemoveItem( pPlayer, vIndex1, 1 ) == 0)
					{
						LogEventLostItemByUpgrade(pPlayer, ullGUIDOfItem1, tpItem1->mTempID, 1, UPG_FAIL, 0, 0);
					}

					tResult = UPG_FAIL;
				}
			}
		}		
	}


	// 把临时变量的值反填
	if ( vType == UPG_PROPERTY )
	{
		tEquip->SetLevel( nLevelValue ) ;
	}
	else if ( vType == UPG_RESDEF )
	{
		 tEquip->SetDefLevel( nLevelValue);
	}
	else if ( vType == UPG_RESATT )
	{
		tEquip->SetAttLevel( nLevelValue ) ;
	}
	else
	{
		// 前面已经判断过了，这里就打个错误
		LOG_ERROR( "pro", "Wrong Upg Type[%s : %d]", __LK_FILE__, __LINE__ );
	}

	// 成功与否, 宝石和符都会消失	
	if (PlayerRemoveItem( pPlayer, vIndex2, 1) == 0)
	{
		LogEventLostItemByUpgrade(pPlayer, ullGUIDOfItem2, tpItem2->mTempID, 1, tResult, tpItem1->mTempID, ullGUIDOfItem1);
	}

	for ( int i = 0; i < UPG_ITEM_NUM; i++ )
	{
		if ( tItem3[ i ] == NULL )
		{
			continue;
		}
		uint64_t ullGUIDOfItem3 = tItem3[ i ]->GetGUID();
		int nItemID3 = tItem3[ i ]->GetItemID();
		if(PlayerRemoveItem( pPlayer, vIndex3[ i ], 1 ) == 0)
		{
			LogEventLostItemByUpgrade(pPlayer, ullGUIDOfItem3, nItemID3, 1, tResult, tpItem1->mTempID, ullGUIDOfItem1);
		}
	}

	if (PlayerChangeMoney( pPlayer, tFee, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByUpgradeEquip(pPlayer, CYuanBao::em_bind_money, tFee, tpItem1->mTempID, ullGUIDOfItem1);
	}

	int nSubType = 0;
	if ( vType == UPG_PROPERTY )
	{
		if ( tResult == UPG_SUCCESS )
		{
			if ( tEquip->GetLevel() >= NOTICE_UPG_FIRST && tEquip->GetLevel() < NOTICE_UPG_SECOND )
			{
				SendUpgAndJewNotice( pPlayer, UPG_NOTICE, NOTICE_UPG_FIRST, tEquip );
			}
			else if ( tEquip->GetLevel() >= NOTICE_UPG_SECOND && tEquip->GetLevel() < NOTICE_UPG_THIRD )
			{
				SendUpgAndJewNotice( pPlayer, UPG_NOTICE, NOTICE_UPG_SECOND, tEquip );
			}
			else if ( tEquip->GetLevel() >= NOTICE_UPG_THIRD )
			{
				SendUpgAndJewNotice( pPlayer, UPG_NOTICE, NOTICE_UPG_THIRD, tEquip );
			}
		}
		SendUpgEquipNotice( pPlayer, tResult, vType, vIndex1, tEquip->GetLevel() );
	}
	else if ( vType == UPG_RESDEF )
	{
		nSubType = tEquip->GetResDef();
		SendUpgEquipNotice( pPlayer, tResult, vType, vIndex1, tEquip->GetDefLevel() );
	}
	else if ( vType == UPG_RESATT )
	{
		nSubType = tEquip->GetResAtt();
		SendUpgEquipNotice( pPlayer, tResult, vType, vIndex1, tEquip->GetAttLevel() );
	}
	

	if ( tBind == true && ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
	{
		if ( !( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{			
			SetEquipBindTime( tItem1 );
		}
		tItem1->SetBindStatus( tItem1->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, vIndex1, tItem1->GetBindStatus( ) );
	}

	LogEventItemLevelUpAction(pPlayer, tpItem1->mTempID, ullGUIDOfItem1, vType, nSubType, 
			nLevelValue, nPrevLevel, tpItem2 ? tpItem2->mTempID : 0, tItem1->GetBindStatus());

	return;
}

// 玩家镶嵌符文
void CPropertyModule::PlayerInsertRune( CEntityPlayer* pPlayer, int vIndex1, int vIndex2 )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 防止缓冲区溢出
	// TODO:包括对背包索引的检查
	if ( (!pProperty->GetBaggage()->CheckIndexValid( vIndex1 )) || ( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) ) )	
	// if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex || vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送镶嵌符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		//// 发送镶嵌符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		//// 发送镶嵌符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}
	// 如果第一件不是装备或者第二件不是符文
	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR ) || tpItem2->mItemType != CTplItem::ITEM_RUNE )
	{
		//// 发送镶嵌符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}
	CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
	CTplItemRune *tpRune = (CTplItemRune*)tpItem2;
	CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem1;

	if ( tplEquip->mEquipType > CTemplateEquipment::PART_SASH )
	{
		SendProErrorNotice( pPlayer, ERROR_CANNOTINSERT );
		return;
	}

	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tpRune->mInsertCharge )
	{
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}
	
	// 查看是否手动绑定
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendProErrorNotice( pPlayer, ERROR_RUNEEQUIPBINDEDBYITEM );
		return;
	}

	tpEquip->SetSlotSpell( tpRune->mTempID );
	SendInsertRuneNotice( pPlayer, 0 );
	if ( ( tItem2->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED
		&& ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
	{	
		if ( !( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{				
			SetEquipBindTime( tItem1 );
		}		
		tItem1->SetBindStatus( tItem1->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, vIndex1, tItem1->GetBindStatus( ) );
	}

	if (PlayerChangeMoney( pPlayer, tpRune->mInsertCharge, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByInsertRune(pPlayer, CYuanBao::em_bind_money, tpRune->mInsertCharge, tpEquip->GetItemID(), tpEquip->GetGUID());
	}

	uint64_t ullGUIDOfItem1 = tItem1->GetGUID();
	uint64_t ullGUIDOfItem2 = tItem2->GetGUID();
	int nItem1ID = tItem1->GetItemID();
	int nItem2ID = tItem2->GetItemID();

	if ( PlayerRemoveItem( pPlayer, vIndex2, 1 ) == 0)
	{
		LogEventLostItemByInsSlot(pPlayer, ullGUIDOfItem2, nItem2ID, 1, nItem1ID, ullGUIDOfItem1);
	}

	// 记录装备符文镶嵌
	LogEventItemRunneAction(pPlayer, nItem1ID, ullGUIDOfItem1, nItem2ID, tItem1->GetBindStatus() );

	return;
}

// 玩家镶嵌宝石
void CPropertyModule::PlayerInsertJewel( CEntityPlayer* pPlayer, int vIndex0, int *vIndex )
{
	LK_ASSERT( pPlayer != NULL && vIndex != NULL,  return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 防止缓冲区溢出
	// TODO:包括背包的索引检查
	if ( !pProperty->GetBaggage()->CheckIndexValid( vIndex0 ) )	
	// if ( vIndex0 < 0 || vIndex0 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送镶嵌宝石的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
		return;
	}
	CItemObject *tItem0 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex0 );
	if ( tItem0 == NULL )
	{
		//// 发送镶嵌宝石的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
		return;
	}	
	
	if ( (tItem0->GetBindStatus() & ITEM_BINDSTATUS_BYITEM) || ( tItem0->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELEUIQPBINDEDBYITEM );
		return;
	}
	
	CTplItem *tpItem0 = (CTplItem*)CDataStatic::SearchTpl( tItem0->GetItemID() );
	if ( tpItem0 == NULL )
	{
		/// 发送镶嵌宝石的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
		return;
	}
	// 如果第一件不是装备
	if ( tpItem0->mItemType != CTplItem::ITEM_WEAPON && tpItem0->mItemType != CTplItem::ITEM_ARMOR )
	{
		//// 发送镶嵌宝石的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
		return;
	}
	CItemEquipment *tpEquip = (CItemEquipment*)tItem0;
	CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem0;

	CItemObject *tItem[ JEWELNUM ] = { NULL };
	CTplItem *tpItem[ JEWELNUM ] = { NULL };
	for ( int i = 0; i < JEWELNUM; i++ )
	{
		if ( vIndex[ i ] == -1 )
			continue;
		tItem[ i ] = pProperty->GetBaggage( )->GetItemObjPtr( vIndex[ i ] );
		if ( tItem[ i ] == NULL )
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
			return;
		}
		tpItem[ i ] = (CTplItem*)CDataStatic::SearchTpl( tItem[ i ]->GetItemID() );
		if ( tpItem[ i ] == NULL )
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
			return;
		}
		if ( tpItem[ i ]->mItemType != CTplItem::ITEM_JEWEL )
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
			return;
		}
		if ( tpEquip->GetSlotProperty(i) == 0 )
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
			return;
		}
		// 延迟时可能镶在已有的宝石上,增加判断
		if ( tpEquip->GetSlotValue(i) != 0 )
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
			return;
		}
		CTplItemJewel *tpJewel = (CTplItemJewel*)tpItem[ i ];
		if ( 
			(( tplEquip->mEquipType == CTemplateEquipment::PART_RING )	&& ( ( tpJewel->mPos & CTplItemJewel::POS_RING ) == 0 ) )	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_CUFF )	&& ( ( tpJewel->mPos & CTplItemJewel::POS_CUFF ) == 0 ) )	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_WEAPON )&&( ( tpJewel->mPos & CTplItemJewel::POS_WEAPON ) == 0 ) ) 	||		
			(( tplEquip->mEquipType == CTemplateEquipment::PART_CHEST ) &&( ( tpJewel->mPos & CTplItemJewel::POS_CHEST ) == 0 )	)	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_LEG )	&&( ( tpJewel->mPos & CTplItemJewel::POS_LEG )	== 0 ) ) 	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_HEAD )	&&( ( tpJewel->mPos & CTplItemJewel::POS_HEAD )	== 0 ) ) 	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_NECK )	&&( ( tpJewel->mPos & CTplItemJewel::POS_NECK )	== 0 ) )	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_SASH )	&&( ( tpJewel->mPos & CTplItemJewel::POS_SASH )	== 0 ) )	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_CHARM )	&&( ( tpJewel->mPos & CTplItemJewel::POS_CHARM ) == 0 ) )	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_BALL )	&&( ( tpJewel->mPos & CTplItemJewel::POS_BALL )	== 0 ) )	||
			(( tplEquip->mEquipType == CTemplateEquipment::PART_CLOAK )	&&( ( tpJewel->mPos & CTplItemJewel::POS_CLOAK ) == 0 ) )	
			)
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELWRONGSLOT );
			return;
		}
		if ( tplEquip->mLevelRequire < tpJewel->mTypeID )
		{
			//// 发送镶嵌宝石的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
			return;
		}
		// 改叠加之后需要判断
		for( int j = 0; j < i; j++ )
		{
			if ( vIndex[ j ] == vIndex[ i ] )
			{
				SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
				return;
			}
		}
	}

	// 预先镶嵌一下，检查唯一性
	int tUnique[ JEWELNUM ] = { 0 };
	for ( int i = 0; i < JEWELNUM; i ++ )
	{
		CTplItemJewel *tpJewel = NULL;
		if ( vIndex[ i ] == -1 )
		{
			tpJewel = (CTplItemJewel*)CDataStatic::SearchTpl( tpEquip->GetSlotValue(i) );			
		}
		else
		{
			tpJewel = (CTplItemJewel*)tpItem[ i ];
		}	
		if ( tpJewel != NULL )
		{
			if ( tpJewel->mUnique != 0 )
			{
				tUnique[ i ] = tpJewel->mUnique;
				for( int j = 0; j < i; j++ )
				{
					if ( tUnique[ j ] == tUnique[ i ] )
					{
						SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
						return;
					}
				}
			}
		}		
	}

	bool tBind = false;
	unsigned int tFee = 0;
	for ( int i = 0; i < JEWELNUM; i ++ )
	{
		if ( vIndex[ i ] == -1 )
			continue;
		CTplItemJewel *tpJewel = (CTplItemJewel*)tpItem[ i ];
		tpEquip->SetSlotValue( i, tpJewel->mTempID );
		if ( tItem[ i ]->GetBindStatus() != ITEM_BINDSTATUS_FREE )
		{
			tBind = true;
		}
		tFee += tpJewel->mInsertCharge;
	}
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < tFee )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
		return;
	}

	SendInsertJewelNotice( pPlayer, SUCCESS, tBind );
	if (PlayerChangeMoney( pPlayer, tFee, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByInsertJewel(pPlayer, CYuanBao::em_bind_money, tFee, tpEquip->GetItemID(), tpEquip->GetGUID());
	}
	if ( tBind == true && ( tItem0->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
	{
		if ( !( tpEquip->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{				
			SetEquipBindTime( tpEquip );
		}	
		tpEquip->SetBindStatus( tpEquip->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, vIndex0, tpEquip->GetBindStatus( ) );
	}

	for ( int i = 0; i < JEWELNUM; i++ )
	{
		if ( tpItem[ i ] == NULL )
			continue; 
		
		uint64_t ullGUID = 0;
		int nItemID = tpItem[i]->mTempID;
		int nItem0ID = tItem0->GetItemID();
		uint64_t ullGUID0 = tItem0->GetGUID();

		if (PlayerRemoveItem( pPlayer, vIndex[ i ], 1 , &ullGUID) == 0)
		{
			LogEventLostItemByInsSlot(pPlayer, ullGUID, nItemID, 1, nItem0ID, ullGUID0);
			LogEventItemJewelAction(pPlayer, nItem0ID, ullGUID0, nItemID, tpEquip->GetBindStatus());
		}
	}	
	return;
}

// 玩家打开装备插槽
void CPropertyModule::PlayerOpenSlot( CEntityPlayer* pPlayer, int vIndex1, int vIndex2 )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 防止缓冲区溢出
	// TODO:包括背包的索引检查
	if ( ( !pProperty->GetBaggage()->CheckIndexValid( vIndex1 ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) ) )	
	// if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex || vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	
	// 查看装备是否滴血
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendProErrorNotice( pPlayer, ERROR_OPENSLOT_EQUIPBINDEDBYITEM );
		return;
	}
	
	// 如果第一件不是装备或者第二件不是元气蛋
	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR ) || tpItem2->mItemType != CTplItem::ITEM_YUANEGG )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem1;
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tplEquip->mOpenCharge )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
	CItemYuanEgg *tpYuanEgg = (CItemYuanEgg*)tItem2;
	CTemplateOpenSlot *tSlotTable = (CTemplateOpenSlot*)CDataStatic::GetTemp( TEMP_OPENSLOT );
	if ( tSlotTable == NULL )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	CTplItemYuanEgg *tplEgg = (CTplItemYuanEgg*)tpItem2;
	int tNeedLevel = tSlotTable->mSlotLevel[ tpEquip->GetSlotNumber() ];
	unsigned int tNeedNumber = tSlotTable->mSlotNumber[ tpEquip->GetSlotNumber() ];
	// 如果蛋的等级不够
	if ( tplEgg->mLevel != tNeedLevel )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	if ( tplEgg->mMaxEquip < tplEquip->mLevelRequire )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}
	// 如果蛋的数量不够
	if ( tpYuanEgg->GetItemNum() < tNeedNumber )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}

	// 如果槽没有这么多
	if ( tpEquip->GetSlotNumber() + 1 > (int)tpEquip->GetMaxSlotNumber() )
	{
		//// 发送打开插槽的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
		return;
	}

	int nFrom = tpEquip->GetSlotNumber();

	tpEquip->SetSlotProperty( tpEquip->GetSlotNumber(), 1 );
	tpEquip->SetSlotNumber( tpEquip->GetSlotNumber() + 1 );

	if (PlayerChangeMoney( pPlayer, tplEquip->mOpenCharge, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByOpenSlot(pPlayer, CYuanBao::em_bind_money, tplEquip->mOpenCharge, tpEquip->GetItemID(), tpEquip->GetGUID());
	}
	if ( ( tItem2->GetBindStatus( ) &  ITEM_BINDSTATUS_BINDED ) ==  ITEM_BINDSTATUS_BINDED
		&& ( tpEquip->GetBindStatus( ) &  ITEM_BINDSTATUS_BINDED ) == 0 )
	{
		if ( !( tpEquip->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{				
			SetEquipBindTime( tpEquip );
		}	
		tpEquip->SetBindStatus( tpEquip->GetBindStatus( ) |  ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, vIndex1, tpEquip->GetBindStatus( ) );
	}

	uint64_t ullGUID2 = tItem2->GetGUID();
	int nItemID2 = tItem2->GetItemID();
	int nItemID1 = tItem1->GetItemID();
	uint64_t ullGUID1 = tItem1->GetGUID();

	if (PlayerRemoveItem( pPlayer, vIndex2, tNeedNumber) == 0)
	{
		LogEventLostItemByOpenSlot(pPlayer, ullGUID2, nItemID2, tNeedNumber, nItemID1, ullGUID1 );
	}

	SendOpenSlotNotice( pPlayer, vIndex1, vIndex2, tpYuanEgg->GetItemNum() - tNeedNumber );	

	// 记录开槽前后
	LogEventItemSlotAction(pPlayer, nItemID1, ullGUID1, nFrom, tpEquip->GetSlotNumber(), nItemID2, tpEquip->GetBindStatus());

	return;
}

// 元气虫吃装备
void CPropertyModule::PlayerEatEquip( CEntityPlayer* pPlayer, int vIndex0, int *vIndex )
{
	LK_ASSERT( pPlayer != NULL && vIndex != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 防止缓冲区溢出
	// TODO:检查背包的索引
	if( !pProperty->GetBaggage()->CheckIndexValid( vIndex0, true ) )
	//if ( vIndex0 < 0 || vIndex0 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送吃装备的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
		return;
	}
	CItemObject *tItem0 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex0 );
	if ( tItem0 == NULL )
	{
		//// 发送吃装备的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
		return;
	}	
	CTplItem *tpItem0 = (CTplItem*)CDataStatic::SearchTpl( tItem0->GetItemID() );
	if ( tpItem0 == NULL )
	{
		//// 发送吃装备的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
		return;
	}
	// 如果第一件不是元气虫
	if ( tpItem0->mItemType != CTplItem::ITEM_YUANBUG )
	{
		//// 发送吃装备的错误通知
		SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
		return;
	}

	CItemYuanBug *tpBug = (CItemYuanBug*)tItem0;
	CTplItemYuanBug *tplBug = (CTplItemYuanBug*)tpItem0;
	CItemObject *tItem[ YUANNUM ] = { NULL };
	CTplItem *tpItem[ YUANNUM ] = { NULL };
	int tYuan = 0;
	for ( int i = 0; i < YUANNUM; i++ )
	{
		if ( vIndex[ i ] == -1 )
			continue;
		tItem[ i ] = pProperty->GetBaggage( )->GetItemObjPtr( vIndex[ i ] );
		if ( tItem[ i ] == NULL )
		{
			//// 发送吃装备的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
			return;
		}
		
		if ( ( tItem[i]->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem[i]->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
		{
			SendProErrorNotice( pPlayer, ERROR_EQUIPBINDEDBYITEM );
			return;	
		}
		tpItem[ i ] = (CTplItem*)CDataStatic::SearchTpl( tItem[ i ]->GetItemID() );
		if ( tpItem[ i ] == NULL )
		{
			//// 发送吃装备的错误通知
			SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
			return;
		}
		if ( tpItem[ i ]->mEatType != tplBug->mYuanType )
		{
			SendProErrorNotice( pPlayer, ERROR_EATWRONGTYPE );
			return;
		}
		//if ( tpItem[ i ]->mItemType != CTplItem::ITEM_WEAPON && tpItem[ i ]->mItemType != CTplItem::ITEM_ARMOR )
		//{
		//	//// 发送吃装备的错误通知
		//	SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
		//	return;
		//}
		if ( IfItemBindedByItem( tItem[i] ) || IfItemBindFree( tItem[i] ) )
		{
			// 装备不能被吃掉
			SendProErrorNotice( pPlayer,  ITEM_EATEQUIP_BINDED );
			return;
		}

		for ( int j = 0; j < i; j++ )
		{
			if ( vIndex[ j ] == vIndex[ i ] )
			{
				SendProErrorNotice( pPlayer,  ERROR_JEWELEATFAIL );
				return;
			}
		}

		//CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem[ i ];
		tYuan += tpItem[ i ]->mEatValue * tItem[ i ]->GetItemNum( );
	}


	SendEatEquipNotice( pPlayer, vIndex0, tYuan );
	
	tpBug->SetCurrent( tpBug->GetCurrent() + tYuan );
	// 如果达到元气上限，转化为元气蛋
	if ( tpBug->GetCurrent() >= tplBug->mYuan )
	{
		uint64_t ullGUID0 = tItem0->GetGUID();
		int nItemID0 = tItem0->GetItemID();
		//int nYuandID = CSceneCfgManager::GetSingleton().GetProperty_cfg()->mYuan_id;
		int nYuandID = tplBug->mEggID;

		if ( PlayerRemoveItem( pPlayer, vIndex0, 1) ==0)
		{
			CItemObject * pInsItemPile = PlayerInsertItem( pPlayer, nYuandID, 1);
			if ( pInsItemPile )
			{
				// 记录获得
				LogEventGetItemByYQC(pPlayer, pInsItemPile->GetGUID(), nYuandID, 1, nItemID0, ullGUID0);

				// 记录失去
				LogEventLostItemByEat(pPlayer, ullGUID0, nItemID0, 1, nYuandID, pInsItemPile->GetGUID()); 
			}
		}
	}

	for ( int i = 0; i < YUANNUM; i++ )
	{
		if ( tpItem[ i ] == NULL )
			continue; 

		uint64_t ullGUID = tItem[i]->GetGUID();
		int nItemID = tItem[i]->GetItemID();

		CSceneLogic::GetSingleton().LogValuableEquip(pPlayer->GetCharID(), tItem[i]);
		if ( PlayerRemoveItem( pPlayer, vIndex[ i ], tItem[ i ]->GetItemNum( ) ) == 0)
		{
			LogEventLostItemByEat(pPlayer, ullGUID, nItemID, 1, tItem0->GetItemID(), tItem0->GetGUID());
		}
	}

	return;
}

// 物品合成
void CPropertyModule::PlayerComposeItem( CEntityPlayer* pPlayer, int vIndex )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 防止缓冲区溢出
	// TODO:背包索引的检查
	if( !pProperty->GetBaggage()->CheckIndexValid( vIndex ) )
	// if ( vIndex < 0 || vIndex >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送合成的错误通知
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
		return;
	}
	CItemObject *tItem = pProperty->GetBaggage( )->GetItemObjPtr( vIndex );
	if ( tItem == NULL )
	{
		//// 发送合成的错误通知
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
		return;
	}	
	CTplItem *tpItem = (CTplItem*)CDataStatic::SearchTpl( tItem->GetItemID() );
	if ( tpItem == NULL )
	{
		//// 发送合成的错误通知
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
		return;
	}

	// 真灵道具不能走物品合成，要走聚灵的合成逻辑
	if (tpItem->mItemType == CTplItem::ITEM_SPIRIT_CASTING)
	{
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
		return;
	}

	unsigned int tNeedNum = 0;
	int tComID = 0;
	int tComNum = 0;

	CTemplateCompose *tpCompose = (CTemplateCompose*)CDataStatic::SearchTpl( tpItem->mCompID );
	// 如果不是材料或元气蛋
	if ( tpCompose == NULL )
	{
		//// 发送合成的错误通知
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
		return;
	}
	tNeedNum = tpCompose->mMaterialNum;
	tComID = tpCompose->mItemID;
	tComNum = tpCompose->mItemNum;

	// 如果数量错误
	if ( tItem->GetItemNum() < tNeedNum || tNeedNum == 0 )
	{
		//// 发送合成的错误通知
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
		return;
	}

	int tDesNum = 0, tSrcNum = 0;// 合成的道具的数量，剩余材料的数量
	int tProNum = tItem->GetItemNum()/tNeedNum;		// 生成的组数
	tDesNum = tProNum * tComNum;
	tSrcNum = tItem->GetItemNum()%tNeedNum;

	bool tBind = ( tItem->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED ? true : false;
	CItemObject * pInsItemPile = PlayerInsertItem( pPlayer, tComID, tDesNum, false, 0, NULL, tBind );
	if ( pInsItemPile != NULL)
	{
		// LOG 
		LogEventGetItemByCompose(pPlayer, pInsItemPile->GetGUID(), tComID, tDesNum, tItem->GetItemID(), tItem->GetItemNum()-tSrcNum);

		uint64_t ullGUID = tItem->GetGUID();
		int nItemID = tItem->GetItemID();
		int nNumber = tItem->GetItemNum()-tSrcNum;

		if ( PlayerRemoveItem( pPlayer, vIndex, tItem->GetItemNum()-tSrcNum, &ullGUID) == 0)
		{
			LogEventLostItemByCompose ( pPlayer, ullGUID, nItemID, nNumber, tComID, tComNum, pInsItemPile->GetGUID() );
		}

		SendComoseNotice( pPlayer, vIndex, tComID, tDesNum, tSrcNum );
	}

	return;
}

// 玩家修改职业
void CPropertyModule::PlayerChangeMetier( CEntityPlayer* pEntity, unsigned short vMetierID )
{
	LK_ASSERT( pEntity != NULL && vMetierID <= METIER_NOVICE, return );
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();

	unsigned int tOldHP		= pProperty->GetCurHP( );
	unsigned int tOldMP		= pProperty->GetCurMP( );

	unsigned int tOldMaxHP	= pProperty->GetMaxHP( );
	unsigned int tOldMaxMP	= pProperty->GetMaxMP( );

	// 转职一定成功
	pProperty->ChangeMetier( vMetierID );
	pEntity->SetMetier( vMetierID );

	// 通知任务模块 多调一次
	// CTaskModule::GetSingleton().FireEvent( pEntity, EVENT_METIERCHANGE, vMetierID );

	CMessage tChangeMetier;
	CMessageChangeMetierNotice tMessage;
	bool vBool = false;
	vBool = CreateMessageChangeMetierNotice(
			&tChangeMetier,
			&tMessage,
			pEntity->GetEntityID( ),
			vMetierID
			);

	if ( vBool == true )
	{	
		CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tChangeMetier, false, true );

		// 刷新身上任务
		CTaskModule::GetSingleton().FireEvent( (CEntityPlayer*)pEntity, EVENT_METIERCHANGE );
	}

	// 修改职业的时候,任务根据职业自带一个普通攻击技能

	int tGenerIDList[ 3 ] = { 0, 0, 0 };
	int tColList[ 3 ] = { 0, 0, 0 };
	int tRowList[ 3 ] = { 0, 0, 0 };
	unsigned int tSkillIDList[ 3 ] = { 0, 0, 0 };
	int tIndex[ 3 ] = { 0, 0, 0 };
	int tCount = 0;
	StudySkillByChangeMetier( pProperty, vMetierID, tGenerIDList, tColList, tRowList, tCount, 3, tSkillIDList, tIndex );

	// 刷新属性，保证不会超过最大值
	pProperty->Refresh( );
	pEntity->NotifyPropertyRefresh( );

	// 发送学习技能的消息
	SendStudySkillResponse( pEntity, tGenerIDList, tColList, tRowList, tCount, tSkillIDList, tIndex );

	// 判断属性是否需要更新
	unsigned int tNewHP = pProperty->GetCurHP( );
	unsigned int tNewMP = pProperty->GetCurMP( );

	unsigned int tNewMaxHP = pProperty->GetMaxHP( );
	unsigned int tNewMaxMP = pProperty->GetMaxMP( );

	// 如果生命或者法力发生改变，通知看到我的人，属性改变
	if ( tNewHP != tOldHP || tNewMP != tOldMP || tNewMaxHP != tOldMaxHP || tNewMaxMP != tOldMaxMP )
	{

		LOG_NOTICE( "pro", "[ %s : %d ] [ %s ] player %s change metier to %d", 
			__LK_FILE__, __LINE__, __FUNCTION__, pEntity->GetCharNameShow(), vMetierID  );
		CMessage tEntityRefresh;
		CMessageEntityRefreshNotice tMessage;
		bool vBool = false;
		vBool = CreateMessageEntityRefreshNotice(
				&tEntityRefresh,
				&tMessage,
				pEntity->GetEntityID( ),
				tNewHP,
				tNewMP,
				tNewMaxHP,
				tNewMaxMP
				);
		if ( vBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tEntityRefresh );
		}
	}		
	
	// 玩家信息改变通知网关(如果需要的话)
	CCommandSendPlayerDirtyDataToGate tSendToGate( pEntity->GetEntityID() );
	tSendToGate.OnEventTrigger( CCommandSendPlayerDirtyDataToGate::DIRTYDATA_METIER );

}

// 获得一个全新的道具
CItemObject* CPropertyModule::PlayerInsertItem( CEntityPlayer* pEntity, 
		unsigned int vItemID, unsigned int vNumber, bool bIsCalledFromTask, int nLevel, const char* szMadeByName, bool bBind, int nInvalidTime ) 
{
	LK_ASSERT( pEntity != NULL, return NULL );	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	

	CTemplate* tpTemplate = (CTemplate*) CDataStatic::SearchTpl( vItemID );	
	if( tpTemplate == NULL )
	{
		SendProErrorNotice( pEntity, ERROR_ITEM_DATANOTEXIST );
		return NULL;
	}

	// 判断物品是不是道具类型
	if( tpTemplate->mTemplateType != EM_TEMPTYPE_ITEM )
	{
		LOG_ERROR( "pro", "[%s:%d] item %d is not itemtype", __FUNCTION__, __LINE__, vItemID );
		SendProErrorNotice( pEntity, ERROR_ITEM_DATANOTEXIST );
		return NULL;
	}

	CTplItem* tpTplItem = (CTplItem*)tpTemplate;

	// 如果已经过期，不可插入
	if ( tpTplItem->mInvilidDate != 0 && tpTplItem->mInvilidDate <= GetYYYYMMDD( time(NULL) ) )
	{
		SendProErrorNotice( pEntity, ERROR_INVILID_ITEM );
		return NULL;
	}

	// 如果是特殊任务道具，而且玩家已经有了
	if ( tpTplItem->mItemType == CTplItem::ITEM_SPECIAL_TASK && pProperty->BaggageHasItem(vItemID) > 0 )
	{
		SendProErrorNotice( pEntity, ERROR_SPECIAL_TASK_ITEM_ERROR );
		return NULL;
	}

	CItemObject* tpItemObj = NULL;

	// 直接从对象池上创建对象
	int nCreateResult = CreateItem( tpTplItem, vNumber, nLevel, &tpItemObj);

	// 如果创建失败
	if ( nCreateResult != 0)
	{
		SendProErrorNotice( pEntity, nCreateResult );
		return NULL;
	}

	if ( tpItemObj == NULL)
	{
		SendProErrorNotice( pEntity, ERROR_ITEM_DATANOTEXIST );
		return NULL;
	}

	// 如果是外部指定的到期时间
	if ( nInvalidTime != 0 )
	{
		tpItemObj->SetInvalidTime(nInvalidTime);
		StartItemValidTimer(pEntity, tpItemObj);
	}
	// 如果是有时间限制 而且是进包就开始
	else if ( tpTplItem->mValidTime > 0 && tpTplItem->mValidType == VALIDTYPE_GET )
	{
		SetItemValidTime( pEntity, tpTplItem, tpItemObj);
	}

	// 个性化物品
	PersonalizeItem(pEntity, tpTplItem, tpItemObj, szMadeByName);

	// 插入物品, 要么全部成功，要么全部失败;不会出现插入不完整的情况
	CItemObject* pLastInsertedItem = PlayerInsertItem( pEntity, tpItemObj, bIsCalledFromTask, bBind );
	if ( pLastInsertedItem )
	{
		// 如果插入完的道具数目为0,删除, 此处不能用pLastInsertedItem来判断，这个是插入到包裹的对象
		if ( tpItemObj->GetItemNum() == 0 )
		{
			CSceneObjManager::GetSingletonPtr( )->DestroyObject( tpItemObj->get_id() );
		}
	}else
	{
		CSceneObjManager::GetSingletonPtr( )->DestroyObject( tpItemObj->get_id() );
	}

	return pLastInsertedItem;
}

//
// 创建标准物品
//
int CPropertyModule::CreateItem(CTplItem* tpItem,  uint32_t vNumber, int vLevel, CItemObject** ppItemObj)
{
	if ( tpItem == NULL )
	{
		return ERROR_ITEM_DATANOTEXIST;
	}
	
	CItemObject* tpItemObj = NULL;
	uint32_t vItemID = tpItem->mTempID;

	switch ( tpItem->mItemType )
	{
		case CTplItem::ITEM_PHYSIC:
		{
			CTplItemPhysic *tplPhysic = (CTplItemPhysic*)tpItem;
			tpItemObj = (CItemObject*)  CSceneObjManager::GetSingletonPtr( )->CreateObject( OBJTYPE_ITEM_PHYSIC );
			LK_ASSERT( tpItemObj != NULL && "Create ItemEquimpment failed in PlayerInsertItem()" , return ERROR_OBJECT_USEDUP );
			CItemPhysic *tpPhysic = (CItemPhysic*)tpItemObj;
			tpPhysic->SetItemID( vItemID );
			tpPhysic->SetItemNum( vNumber );

			tpPhysic->SetRemainHP( tplPhysic->mHPValue );
			tpPhysic->SetRemainMP( tplPhysic->mMPValue );
			tpPhysic->SetRemainAP( tplPhysic->mApValue );

			break;
		}

		case CTplItem::ITEM_WEAPON:
		case CTplItem::ITEM_ARMOR:
		{
			tpItemObj = (CItemObject*)  CSceneObjManager::GetSingletonPtr( )->CreateObject ( OBJTYPE_ITEM_EQUIPMENT );
			LK_ASSERT( tpItemObj != NULL && "Create ItemEquimpment failed in PlayerInsertItem()" , return ERROR_OBJECT_USEDUP );

			CItemEquipment *tpEquip = (CItemEquipment*)tpItemObj;
			tpEquip->Initialize( );
			tpItemObj->SetItemID( vItemID );
			tpItemObj->SetItemNum( 1 );	
			int tLevel = 0;
			if ( vLevel > 0 && vLevel <= ITEMUPLIMIT )
			{
				CTemplateDropLevel *tpDropLevel = (CTemplateDropLevel*)CDataStatic::GetTemp( TEMP_DROPLEVEL );

				if ( tpDropLevel != NULL )
				{
					int	tRand		= RAND(SERVER_PERCENT_INT);
					int	tLowRan		= 0;
					int	tHighRan	= 0;				
					for ( int i = 0; i < ITEMUPLIMIT + 1; i++ )
					{
						tLowRan		+= ( i == 0 ) ? 0 : tpDropLevel->mRan[ vLevel ][ i - 1 ];
						tHighRan	+= tpDropLevel->mRan[ vLevel ][ i ];
						if ( tRand >= tLowRan && tRand < tHighRan )
						{
							tLevel = i;
							break;
						}
					}
				}

			}
			else if ( vLevel > ITEMUPLIMIT )
			{
				tLevel = std::min( vLevel - ITEMUPLIMIT, ITEMUPLIMIT );
			}

			tpEquip->SetLevel( tLevel );
			tpEquip->GetPropertyFromTpl( vItemID );

			break;
		}

		case CTplItem::ITEM_MAGICWEAPON:
		{
			// CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)tpItem;
			tpItemObj = (CItemObject*)  CSceneObjManager::GetSingletonPtr( )->CreateObject ( OBJTYPE_ITEM_MAGICWEAPON );
			LK_ASSERT( tpItemObj != NULL && "Create OBJTYPE_ITEM_MAGICWEAPON failed in PlayerInsertItem()" , return ERROR_OBJECT_USEDUP );

			CItemMagicWeapon *tpMW = (CItemMagicWeapon*)tpItemObj;
			tpMW->Initialize2( );
			tpMW->SetItemID( vItemID );
			tpMW->SetItemNum( 1 );	

			// 从模板赋值
			tpMW->SetupFromTemplate();

			break;
		}

		case CTplItem::ITEM_TASK: 
		case CTplItem::ITEM_SPECIAL_TASK:
		{
			tpItemObj = CItemRunTime::Clone( vItemID, vNumber );

			break;
		}

		case CTplItem::ITEM_MINEMAP:
		{
			tpItemObj = CItemRunTime::Clone( vItemID, vNumber );
			if ( tpItemObj != NULL)
			{
				SetItemPosRandom< CTplMineMap, CItemMineMap >( (CTplMineMap*) tpItem, (CItemMineMap*) tpItemObj);
			}

			break;
		}

		case CTplItem::ITEM_TOKEN:
		{
			tpItemObj = CItemRunTime::Clone( vItemID, vNumber );
			if ( tpItemObj != NULL)
			{
				SetItemPosRandom< CTplToken, CItemToken >( (CTplToken*) tpItem, (CItemToken*) tpItemObj);
			}

			break;
		}
		
		case CTplItem::ITEM_BLACKPILLS:
		{
			CTplItemBlackPills * tpTplBlackPills = ( CTplItemBlackPills * ) tpItem;
			tpItemObj = CItemRunTime::Clone( vItemID, vNumber );;
			LK_ASSERT( tpItemObj != NULL, return ERROR_OBJECT_USEDUP );
			CItemBlackPills *tpBlackPills = ( CItemBlackPills * )tpItemObj;
			tpBlackPills->SetItemNum( vNumber );
			tpBlackPills->SetItemID( vItemID );
			tpBlackPills->SetLeftTime( tpTplBlackPills->mExchangeTime*60 );
			break;			
		}

		default:
		{
			tpItemObj = CItemRunTime::Clone( vItemID, vNumber );
		}
	}

	if ( tpItemObj == NULL ) 
	{
		return ERROR_ITEM_DATANOTEXIST;
	}else
	{
		tpItemObj->SetGUID();
	}

	*ppItemObj = tpItemObj;

	return 0;
}


// 插入道具后的操作
void  CPropertyModule::AfterInsertedItem(CEntityPlayer* pEntity, CTplItem* pTplItem, CItemObject* tpItemObj, bool bIsCalledFromTask)
{
	LK_ASSERT(tpItemObj != NULL && pTplItem != NULL && pEntity != NULL, return);

	switch (pTplItem->mItemType)
	{
		// 如果是卡片，激活客户端
		case CTplItem::ITEM_CARD :
		{
			CTplItemCard *tplCard = (CTplItemCard*)pTplItem;
			CPropertyPlayer * pProperty = (CPropertyPlayer *) pEntity->GetProperty();
			CPropertyPlayer::CardList::iterator it = pProperty->mActiveCardList.find( tplCard->mTempID );
			if ( it == pProperty->mActiveCardList.end() )
			{
				CPropertyPlayer::CardList::_Pairib tPair = pProperty->mOwnCardList.insert( tplCard->mTempID );
				if ( tPair.second == true )
				{
					SendActiveCardNotice( pEntity, tplCard->mType, tplCard->mPos, tpItemObj->GetItemID() );
				}
			}

			break;
		}

		// 如果是任务道具, 设置转换Timer
		case CTplItem::ITEM_TASK: 
		case CTplItem::ITEM_SPECIAL_TASK:
		{
			CTplItemTask* pTplItemTask = (CTplItemTask*)pTplItem;
			if ( pTplItemTask->mChangeTime > 0 )
			{
				// 自定义的otherinfo分别是 原物品的模板ID 要换成的物品的模板ID
				int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, tpItemObj->GetItemID(), pTplItemTask->mChangeItem, pTplItemTask->mFailTaskID};
				pEntity->GetTimerReciver()->SetTimer( 
						pEntity->get_id(), TIMER_ITEMCHANGE, 1000*pTplItemTask->mChangeTime, 4, nTimerOtherInfo );
			}

			break;
		}
	}

	// 如果不是从任务模块调用过来的, 则调用任务模块响应
	if (!bIsCalledFromTask )
	{
		OnTaskObtainItem( pEntity, tpItemObj->GetItemID(), tpItemObj->GetItemNum() );
	}
}

// 个性化物品
int CPropertyModule::PersonalizeItem(CEntityPlayer* pEntity, CTplItem* tpItem , CItemObject* tpItemObj, const char* szMadeByName)
{
	LK_ASSERT(pEntity != NULL && tpItem != NULL && tpItemObj != NULL, return -1);
	switch (tpItem->mItemType)
	{
		case CTplItem::ITEM_WEAPON:
		case CTplItem::ITEM_ARMOR:
		{
			CItemEquipment *tpEquip = (CItemEquipment*)tpItemObj;
			if ( szMadeByName != NULL )
			{
				tpEquip->SetNameLength( std::min( (unsigned char)strlen(szMadeByName), tpEquip->GetMaxNameLength() ) );
				tpEquip->SetName( szMadeByName );
			}

			break;
		}

		case CTplItem::ITEM_MAGICWEAPON:
		{
			// 类型转换
			//CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)tpItem;
			CItemMagicWeapon *tpMW = (CItemMagicWeapon*)tpItemObj;

			tpMW->SetupSkillFromTemplate( pEntity );

			break;
		}

		default:
		{
			break;
		}
	}

	return 0;
}


// 玩家重置一点属性点
void CPropertyModule::ResetSingleSP( CEntityPlayer* pEntity, unsigned short vGenerID, unsigned char vCol, unsigned char vRow )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();

	unsigned int tOldHP		= pProperty->GetCurHP( );
	unsigned int tOldMP		= pProperty->GetCurMP( );
	int tRet = pProperty->ResetSingleSP( vGenerID, vCol, vRow );
	if ( tRet == ERROR_RESETSSP_SUCCESS )
	{
		// 刷新属性，保证不会超过最大值
		pProperty->Refresh( );
		pEntity->NotifyPropertyRefresh( );

		// 判断属性是否需要更新
		unsigned int tNewHP = pProperty->GetCurHP( );
		unsigned int tNewMP = pProperty->GetCurMP( );

		// 如果生命或者法力发生改变，通知看到我的人，属性改变
		if ( tNewHP != tOldHP || tNewMP != tOldMP )
		{
			LOG_NOTICE( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
			CMessage tEntityRefresh;
			CMessageEntityRefreshNotice tMessage;
			bool vBool = false;
			vBool = CreateMessageEntityRefreshNotice(
					&tEntityRefresh,
					&tMessage,
					pEntity->GetEntityID( ),
					tNewHP,
					tNewMP,
					pProperty->GetMaxHP( ),
					pProperty->GetMaxMP( )
					);
			if ( vBool == true )
			{
				CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tEntityRefresh );
			}
		}

		SendResetSSPResponse( pEntity, vGenerID, vCol, vRow );
	}
	else
	{

		SendProErrorNotice( pEntity, tRet );
	}
}

// 玩家重置所有技能点
void CPropertyModule::ResetAllSP( CEntityPlayer* pEntity )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();
	
	LOG_DEBUG( "pro", "[ %s : %d : %s ] ResetAllSP index( %d : %d ) SPNum( %d : %d )!", __LK_FILE__, __LINE__, __FUNCTION__,
		( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetsp_index ), pProperty->GetLastResetSPIndex(), 
		( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetsp_num ), pProperty->GetResetSPNum() );

	//// 洗点限制判断
	//if ( ( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetsp_index ) == pProperty->GetLastResetSPIndex() )
	//{
	//	// 本次活动已经洗过点
	//	if ( pProperty->GetResetSPNum() >= ( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetsp_num ) )
	//	{
	//		// 已经达到本次活动洗点次数上限
	//		SendResetASPResponse( pEntity, ERROR_RESETASP_MAXNUM );
	//		return;
	//	}

	//	// 没到上限,则洗点次数加1
	//	pProperty->SetResetSPNum( pProperty->GetResetSPNum() + 1 );
	//}
	//else
	//{
	//	// 本次活动没有洗过点,重置洗点次数和活动INDEX
	//	pProperty->SetResetSPNum( 1 );
	//	pProperty->SetLastResetSPIndex( ( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetsp_index ) );
	//}
	//
	unsigned int tOldHP		= pProperty->GetCurHP();
	unsigned int tOldMP		= pProperty->GetCurHP();
	unsigned int tOldMaxHP	= pProperty->GetMaxHP();
	unsigned int tOldMaxMP	= pProperty->GetMaxMP();

	int tRet = pProperty->ResetAllSP( );
	if ( tRet == ERROR_RESETASP_SUCCESS )
	{
		// 客户端根据洗技能点成功的消息,清空所有技能
		SendResetASPResponse( pEntity, ERROR_RESETASP_SUCCESS );

		// 修改职业的时候,任务根据职业自带一个普通攻击技能
		int tGenerIDList[ 3 ] = { 0, 0, 0 };
		int tColList[ 3 ] = { 0, 0, 0 };
		int tRowList[ 3 ] = { 0, 0, 0 };
		unsigned int tSkillIDList[ 3 ] = { 0, 0, 0 };
		int tIndex[ 3 ] = { 0, 0, 0 };
		int tCount = 0;
		StudySkillByChangeMetier( pProperty, pEntity->GetMetier(), tGenerIDList, tColList, tRowList, tCount, 3, tSkillIDList, tIndex );

		// 发送学习技能的消息
		SendStudySkillResponse( pEntity, tGenerIDList, tColList, tRowList, tCount, tSkillIDList, tIndex );

		// 刷新属性，保证不会超过最大值
		pProperty->Refresh( );
		pEntity->NotifyPropertyRefresh( );

		// 判断属性是否需要更新
		unsigned int tNewHP = pProperty->GetCurHP( );
		unsigned int tNewMP = pProperty->GetCurMP( );

		unsigned int tNewMaxHP = pProperty->GetMaxHP( );
		unsigned int tNewMaxMP = pProperty->GetMaxMP( );

		// 如果生命或者法力发生改变，通知看到我的人，属性改变
		if ( tNewHP != tOldHP || tNewMP != tOldMP || tNewMaxHP != tOldMaxHP || tNewMaxMP != tOldMaxMP )
		{
			CMessage tEntityRefresh;
			CMessageEntityRefreshNotice tMessage;
			bool vBool = false;
			vBool = CreateMessageEntityRefreshNotice(
				&tEntityRefresh,
				&tMessage,
				pEntity->GetEntityID( ),
				tNewHP,
				tNewMP,
				tNewMaxHP,
				tNewMaxMP
				);
			if ( vBool == true )
			{
				CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tEntityRefresh );
			}
		}
	}
	else
	{
		SendResetASPResponse( pEntity, ERROR_RESETASP_FAILED );
	}
}

// 玩家重置所有属性点
void CPropertyModule::ResetAllPP( CEntityPlayer* pEntity )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();

	LOG_DEBUG( "pro", "[ %s : %d : %s ] ResetAllPP index( %d : %d ) SPNum( %d : %d )!", __LK_FILE__, __LINE__, __FUNCTION__,
		( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetpp_index ), pProperty->GetLastResetPPIndex(), 
		( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetpp_num ), pProperty->GetResetPPNum() );

	//// 洗点限制判断
	//if ( ( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetpp_index ) == pProperty->GetLastResetPPIndex() )
	//{
	//	// 本次活动已经洗过点
	//	if ( pProperty->GetResetPPNum() >= ( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetpp_num ) )
	//	{
	//		// 已经达到本次活动洗点次数上限
	//		SendResetAPPResponse( pEntity, ERROR_RESETAPP_MAXNUM );
	//		return;
	//	}

	//	// 没到上限,则洗点次数加1
	//	pProperty->SetResetPPNum( pProperty->GetResetPPNum() + 1 );
	//}
	//else
	//{
	//	// 本次活动没有洗过点,重置洗点次数和活动INDEX
	//	pProperty->SetResetPPNum( 1 );
	//	pProperty->SetLastResetPPIndex( ( (int) CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mResetpp_index ) );
	//}
	//
	unsigned int tOldHP		= pProperty->GetCurHP( );
	unsigned int tOldMP		= pProperty->GetCurMP( );
	int tRet = pProperty->ResetAllPP( );
	if ( tRet == ERROR_RESETAPP_SUCCESS )
	{
		// 刷新属性，保证不会超过最大值
		pProperty->Refresh( );
		pEntity->NotifyPropertyRefresh( );

		// 判断属性是否需要更新
		unsigned int tNewHP = pProperty->GetCurHP( );
		unsigned int tNewMP = pProperty->GetCurMP( );

		// 如果生命或者法力发生改变，通知看到我的人，属性改变
		if ( tNewHP != tOldHP || tNewMP != tOldMP )
		{
			LOG_NOTICE( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
			CMessage tEntityRefresh;
			CMessageEntityRefreshNotice tMessage;
			bool vBool = false;
			vBool = CreateMessageEntityRefreshNotice(
					&tEntityRefresh,
					&tMessage,
					pEntity->GetEntityID( ),
					tNewHP,
					tNewMP,
					pProperty->GetMaxHP( ),
					pProperty->GetMaxMP( )
					);
			if ( vBool == true )
			{	
				CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tEntityRefresh );
			}
		}


		SendResetAPPResponse( pEntity, ERROR_RESETAPP_SUCCESS );
	}
	else
	{
		
		SendResetAPPResponse( pEntity, ERROR_RESETAPP_FAILED );
	}
}

// 玩家重置所有属性点
int CPropertyModule::ResetAllTalent( CEntityPlayer* pEntity, int vStep )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();

	unsigned int tOldHP		= pProperty->GetCurHP( );
	unsigned int tOldMP		= pProperty->GetCurMP( );
	int tRet = pProperty->ResetAllTalent( vStep );
	if ( tRet == ERROR_RESETTALENT_SUCCESS )
	{
		// 刷新属性，保证不会超过最大值
		pProperty->Refresh( );
		pEntity->NotifyPropertyRefresh( );

		// 判断属性是否需要更新
		unsigned int tNewHP = pProperty->GetCurHP( );
		unsigned int tNewMP = pProperty->GetCurMP( );

		// 如果生命或者法力发生改变，通知看到我的人，属性改变
		if ( tNewHP != tOldHP || tNewMP != tOldMP )
		{
			LOG_NOTICE( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
			CMessage tEntityRefresh;
			CMessageEntityRefreshNotice tMessage;
			bool vBool = false;
			vBool = CreateMessageEntityRefreshNotice(
				&tEntityRefresh,
				&tMessage,
				pEntity->GetEntityID( ),
				tNewHP,
				tNewMP,
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( )
				);
			if ( vBool == true )
			{	
				CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tEntityRefresh );
			}
		}
		SendResetTalentResponse( pEntity, tRet, pProperty->GetTalentStep( ), pProperty->GetTalentPoint( ) );
	}	
	return tRet;
}


int CPropertyModule::ClickSP( CEntityPlayer* pEntity, unsigned short vGenerID, unsigned char vCol, unsigned char vRow, unsigned int& vSkillID, int& vIndex, int& vMoney, int& vBindMoney )
{
	// TODO: 暂时注释,等待客户端联调
	LK_ASSERT( pEntity != NULL, return ERROR_CLICKSP_NONEPLAYER );
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();
	
	int tRet = pProperty->ClickSkillPoint( vGenerID, vCol, vRow, vSkillID, vIndex, vMoney, vBindMoney );

	return tRet;
}

// 玩家获得修为值
void CPropertyModule::PlayerObtainTalentExp( CEntityPlayer* pEntity, int vExp )
{
	LK_ASSERT( pEntity != NULL, return );

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	
	LK_ASSERT( pProperty->GetTalentStep( ) < TOTAL_TALENT_STAGE, return );
	CTemplateTalent *tpTalent = (CTemplateTalent*)CDataStatic::GetTemp( TEMP_TALENT );
	LK_ASSERT( tpTalent != NULL, return );
	LK_ASSERT( (unsigned int)(pProperty->GetTalentLevel( )) < ARRAY_CNT(tpTalent->mExp), return );
	// 如果已经加满了造化点，不能再获得修为值
	//if ( pProperty->GetTalentStudy( ) >= tpTalent->mStep[ pProperty->GetTalentStep( ) ].mMaxPoint )
	//	return;
	int tTempExp = pProperty->GetTalentExp( ) + vExp;
	int tOldPoint = pProperty->GetTalentPoint( );
	// 如果修为值满了，兑换造化点
	if ( tTempExp >= tpTalent->mExp[ pProperty->GetTalentLevel( ) ] )
	{	
		int tTempPoint = pProperty->GetTalentPoint( );
		//int tPoint = std::min( tpTalent->mStep[ pProperty->GetTalentStep( ) ].mMaxPoint - pProperty->GetTalentStudy( ), pProperty->GetTalentPoint( ) + tTempExp / tpTalent->mExp[ pProperty->GetTalentLevel( ) ]  );
		if ( tpTalent->mExp[ pProperty->GetTalentLevel( ) ] == 0 )
		{
			return;
		}
		int tPoint = pProperty->GetTalentPoint( ) + tTempExp / tpTalent->mExp[ pProperty->GetTalentLevel( ) ];
		pProperty->SetTalentPoint( tPoint );
		pProperty->SetTalentExp( tTempExp - ( tPoint - tTempPoint ) * tpTalent->mExp[ pProperty->GetTalentLevel( ) ] );
		pProperty->SetTalentLevel( pProperty->GetTalentLevel( ) + pProperty->GetTalentPoint( ) - tOldPoint );
	}
	else
	{
		pProperty->SetTalentExp( tTempExp );
	}

	LogEventGetTalentByDefault(pEntity, vExp);

	SendTalentChangeNotify( pEntity, pProperty->GetTalentExp( ), pProperty->GetTalentPoint( ), vExp, pProperty->GetTalentLevel( ) );
	return;
}

// 玩家点击造化点
int CPropertyModule::PlayerClickTalentPoint( CEntityPlayer* pEntity, int vRow, int vCol )
{
	LK_ASSERT( pEntity != NULL, return ERROR_CLICKTALENTFAILED );

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	
	LK_ASSERT( pProperty->GetTalentStep( ) < TOTAL_TALENT_STAGE, return ERROR_CLICKTALENTFAILED );
	CTemplateTalent *tpTalent = (CTemplateTalent*)CDataStatic::GetTemp( TEMP_TALENT );
	LK_ASSERT( tpTalent != NULL, return ERROR_CLICKTALENTFAILED );

	// 如果已经加满，不能再加
	if ( pProperty->GetTalentStudy( ) >= tpTalent->mStep[ pProperty->GetTalentStep( ) ].mMaxPoint )
		return ERROR_CLICKTALENT_MAX;
	// 技能消耗是否满足
	if ( pProperty->GetTalentPoint( ) <= 0 )
		return ERROR_CLICKTALENT_NOPOINT;
	CTemplateSkillTree* tpSkillTree = (CTemplateSkillTree*) CDataStatic::SearchTpl( tpTalent->mStep[ pProperty->GetTalentStep( ) ].mSkillTree );
	if ( tpSkillTree == NULL )
		return ERROR_CLICKTALENTFAILED;

	if ( vCol >= (int)ARRAY_CNT( tpSkillTree->mLayerNode ) || vRow >= (int)ARRAY_CNT( tpSkillTree->mLayerNode[ 0 ] )  )
		return ERROR_CLICKTALENTFAILED;

	CSkillTreeNode* tpNode = &tpSkillTree->mLayerNode[ vCol ][ vRow ];
	// 检查技能等级是否满足需求
	if ( (int)pProperty->GetLevel( ) < tpNode->mLevel )
		return ERROR_CLICKTALENTFAILED;

	// 检查前导系系列投入需求
	//if ( tpNode->mNeedGenerID != 0 )
	//{
	//	// 如果投入不够， 返回
	//	if ( pProperty->mTalentSkill.GetGenerPoint( tpNode->mNeedGenerID ) < tpNode->mNeedGenerPoint )
	//		return ERROR_CLICKTALENTFAILED;
	//}

	// 检查前导技能需求
	if ( tpNode->mNeedSkillID != 0 )
	{
		CSkillObject* tpSkill = pProperty->mTalentSkill.GetSkillObjectByID( tpNode->mNeedSkillID );
		// 如果指定需要的技能没有，如果不能配备该技能点
		if ( tpSkill == NULL )
			return ERROR_CLICKTALENTFAILED;

		// 如果指定需要的技能存在，但是技能的投入不够，那么也不能配置技能点
		if ( tpSkill->GetSkillLevel() - tpSkill->GetIncLevel() < (unsigned int)tpNode->mNeedSkillPoint )
			return ERROR_CLICKTALENTFAILED;
	}

	// 检查金钱是否足够	
	CSkillObject* tpSkill2 = pProperty->mTalentSkill.GetSkillObjectByID( tpSkillTree->mLayerNode[ vCol ][ vRow ].mSkillID );	
	CTemplateSkill* tpSkillTpl = NULL;
	// 技能找不到有几种情况,1技能还未学习,2技能找不到
	if ( tpSkill2 != NULL )
	{
		// 如果已经学到最大等级
		if ( (unsigned int)(tpSkillTree->mLayerNode[ vCol ][ vRow ].mMaxLevel) <= tpSkill2->GetSkillLevel() - tpSkill2->GetIncLevel( ) )
		{
			return ERROR_CLICKTALENTFAILED;
		}
		tpSkillTpl = (CTemplateSkill*) CDataStatic::SearchSkill( tpSkill2->GetSkillID(), ( tpSkill2->GetSkillLevel() - tpSkill2->GetIncLevel( ) + 1 ) );
	}
	else
	{
		// 还没学习就找出第一次的技能模板
		tpSkillTpl = (CTemplateSkill*) CDataStatic::SearchSkill( tpSkillTree->mLayerNode[ vCol ][ vRow ].mSkillID, 1 );		
	}

	if ( tpSkillTpl == NULL )
	{
		return ERROR_CLICKTALENTFAILED;
	}
	if ( pProperty->IsMoneyEnough( true, tpSkillTpl->mStudyGold ) == false )
	{
		return ERROR_CLICKTALENT_NOMONEY;
	}

	// 等级判断
	if ( (int)pProperty->GetLevel( ) < tpSkillTpl->mStudySkillLevel )
		return ERROR_CLICKTALENTFAILED;	

	// 检查技能是否增加
	if ( pProperty->mTalentSkill.InsertSkill( tpNode->mSkillID, tpNode->mMaxLevel ) == false )
		return ERROR_CLICKTALENTFAILED;

	// 消耗技能点
	pProperty->SetTalentPoint( pProperty->GetTalentPoint( ) - 1 );
	pProperty->SetTalentStudy( pProperty->GetTalentStudy( ) + 1 );

	// 消耗金钱
	if (PlayerChangeMoney( pEntity, tpSkillTpl->mStudyGold, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByStudyTalent(pEntity, CYuanBao::em_bind_money, tpSkillTpl->mStudyGold, 
				pProperty->GetTalentPoint(), pProperty->GetTalentStudy());	
	}

	// 如果加满了这一小阶的造化点，自动升到下一小阶，如果当前大阶结束，则不升
	if ( pProperty->GetTalentStudy( ) >= tpTalent->mStep[ pProperty->GetTalentStep( ) ].mMaxPoint )
	{
		int tCurrentStage = tpTalent->mStep[ pProperty->GetTalentStep( ) ].mStageID;
		int tNextStage = tpTalent->mStep[ tpTalent->mStep[ pProperty->GetTalentStep( ) ].mNext[ 0 ] ].mStageID;
		if ( tCurrentStage == tNextStage )
		{
			pProperty->SetTalentStep( tpTalent->mStep[ pProperty->GetTalentStep( ) ].mNext[ 0 ] );
			// 把上一阶累计的修为值转化为这一阶的造化点
			//pProperty->SetTalentPoint( pProperty->GetTalentExp( ) / tpTalent->mStep[ pProperty->GetTalentStep( ) ].mExp + 1 );
			//pProperty->SetTalentExp( pProperty->GetTalentExp( ) % tpTalent->mStep[ pProperty->GetTalentStep( ) ].mExp );
			pProperty->SetTalentStudy( 0 );
			// 修改为不清技能
			//pProperty->mTalentSkill.Clean( );
			
			LogEventPlayerTalentLevelUp(pEntity, tCurrentStage, pProperty->GetTalentStep()); 
		}		
	}
	pProperty->Refresh( );
	pEntity->NotifyPropertyRefresh( );
	return SUCCESS;
}

// 玩家造化进阶
int CPropertyModule::PlayerIncreaseTalent( CEntityPlayer* pEntity, int vStep )
{
	LK_ASSERT( pEntity != NULL, return ERROR_INCREASETALENTFAILED );

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	
	LK_ASSERT( pProperty->GetTalentStep( ) < TOTAL_TALENT_STAGE, return ERROR_INCREASETALENTFAILED );
	CTemplateTalent *tpTalent = (CTemplateTalent*)CDataStatic::GetTemp( TEMP_TALENT );
	LK_ASSERT( tpTalent != NULL, return ERROR_INCREASETALENTFAILED );

	// 如果当前阶没有加满，不能进阶
	if ( pProperty->GetTalentStudy( ) < tpTalent->mStep[ pProperty->GetTalentStep( ) ].mMaxPoint )
	{
		return ERROR_INCREASETALENTFAILED;
	}
	for( unsigned int i = 0; i < ARRAY_CNT( tpTalent->mStep[ pProperty->GetTalentStep( ) ].mNext ); i++ )
	{
		// 如果进阶，清空修为值，造化点置为1
		if ( vStep == tpTalent->mStep[ pProperty->GetTalentStep( ) ].mNext[ i ] && vStep != 0 )
		{
			pProperty->SetTalentStep( tpTalent->mStep[ pProperty->GetTalentStep( ) ].mNext[ i ] );
			//pProperty->SetTalentPoint( 1 );
			pProperty->SetTalentStudy( 0 );
			//pProperty->SetTalentExp( 0 );
			//pProperty->mTalentSkill.Clean( );
			
			LogEventPlayerTalentLevelUp(pEntity, 
					tpTalent->mStep[ pProperty->GetTalentStep( ) ].mStageID, pProperty->GetTalentStep()); 

			return SUCCESS;
		}
	}

	return ERROR_INCREASETALENTFAILED;
}

// 玩家获得某类才华值
int CPropertyModule::PlayerObtainWizardValue( CEntityPlayer* pEntity, int vType, int vValue )
{
	LK_ASSERT( pEntity != NULL, return ERROR_ADDWIZARD_UNKNOWN );
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();	
	CTemplateWizardTable *tpWizard = (CTemplateWizardTable*)CDataStatic::GetTemp( TEMP_WIZARD );
	LK_ASSERT( tpWizard != NULL, return ERROR_ADDWIZARD_UNKNOWN );

	pProperty->mWizard.AddValue( vType, vValue );

	pEntity->InitFunResult( );
	pEntity->AddFunResult( 0, FUNC_WIZARD, RESULT_NORMAL, false, vType, 
		pProperty->mWizard.GetWizardValue( vType ), pProperty->mWizard.GetWizardPoint( vType ), 
		pProperty->mWizard.GetWizardIncrease( WIZARD_COMMON ) );
	
	ResultListSend( );
	return SUCCESS;
}

// 玩家用功勋兑换才华值
void CPropertyModule::PlayerChangeHonorToWizard( CEntityPlayer* pPlayer, int vHonor, int vType )
{
	if ( pPlayer == NULL )
		return;
	CPropertyPlayer *pProperty = (CPropertyPlayer*)pPlayer->GetProperty( );
	if ( pProperty == NULL )
		return;
	CEntityNpc *pNpc = (CEntityNpc*)CSceneObjManager::GetSingletonPtr()->GetObject( pProperty->GetTalkNpcEntityID( ) );
	if( pNpc == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find obj %d", __LK_FILE__, __FUNCTION__, __LINE__,  pProperty->GetTalkNpcEntityID( ) );
		return ;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mHonorService == 0 )
	{
		return;
	}

	if ( pProperty->GetServiceStatus( ) != SERVICE_HONOR )
	{
		return;
	}
	// 修改为-功勋不能兑换经验
	if ( vHonor <= 0 || vHonor > pProperty->GetHonor( ) )
		return;
	CTemplateHonorToExp *tpHonor = (CTemplateHonorToExp*)CDataStatic::GetTemp( TEMP_HONORTOEXP );
	if ( tpHonor == NULL )
		return;
	int tLevel = pProperty->mWizard.GetWizardPoint( vType );
	int tValue = tpHonor->mWizard[ tLevel > 0 ? tLevel : 0 ];

	if ( PlayerObtainWizardValue( pPlayer, vType, tValue ) == SUCCESS )
	{
		pProperty->SetHonor( pProperty->GetHonor( ) - vHonor );
		SendObtainHonorNotice( pPlayer, -1 * vHonor );
	}	
}

// 内部超时消息
void CPropertyModule::OnTimeoutMessage( CMessage* pMessage )
{
	CTimerItem* pTimerItem = (CTimerItem*) pMessage->msgpara();

	switch( pTimerItem->mTimerMark )
	{
		case TIMER_SKLL_COOLDOWN:
			{
				OnTimeoutMessageSkillCoolDown( pMessage );
				break;
			}
		case TIMER_ENTITY_DISAPPER:
			{
				OnTimeoutMessageEntityDisappear( pMessage );
				break;
			}
		case TIMER_ENTITY_CLEAR:
			{
				OnTimeoutMessageEntityClear( pMessage );
				break;
			}
		case TIMER_ENTITY_RELIVE:
			{
				OnTimeoutMessageEntityRelive( pMessage );
				break;
			}
        case TIMER_STOREBOXRELIVE:
            {
                OnTimeoutMessageEntityRelive2( pMessage );
                break;
            }
		case TIMER_ENTITY_PROTECT:
			{
				OnTimeoutMessageEntityProtectTimeOver( pMessage );
				break;
			}
		case TIMER_ENTITY_ALIVE_REFRESH:
			{
				OnTimeoutMessageEntityAliveRefresh( pMessage );
				break;
			}
		case TIMER_REDSTONE_PROTECT:
			{
				OnTimeoutMessageEndRedstoneProtect( pMessage );
				break;
			}
		case TIMER_REDSTONE_CLEAR:
			{
				OnTimeOutMessageRedStoneClear( pMessage );
				break;
			}
		case TIMER_REDSTONE_EXPMAGIC:
			{
				OnTimeOutMessageFireRedStoneMagic( pMessage );
				break;
			}
		case TIMER_DIPLOID_TIME:
			{
				OnTimeoutMessageDiploidTime( pMessage );
				break;
			}
		case TIMER_REDSTONE_PRECESSTIMEOUT:
			{
				OnTimeOutMessageRedstoneProcess( pMessage );
				break;
			}
		//case TIMER_KILLNPC_WITHHIDE_TIMEOUT:
		//	{
		//		OnTimeoutMessageKillEntityWithHide( pMessage );
		//		break;
		//	}
		case TIMER_ASSIGNMENT:
			{
				OnTimeOutMessageAssignment( pMessage );
			}
			break;
		case TIMER_YELLOWNAME:
			{
				OnTimeOutMessageYellowStatus( pMessage );
				break;
			}
		case TIMER_ITEMCHANGE:
			{
				OnTimerItemChange(pMessage);
			}
			break;
		case TIMER_NOTIFYREFRESH_TEN:
			{
				OnTimeOutMessageRefreshTen( pMessage );
			}
			break;
		case TIMER_NOTIFYREFRESH_FIVE:
			{
				OnTimeOutMessageRefreshFive( pMessage );
			}
			break;
		case TIMER_CREATEOGRE_TEN:
			{
				OnTimeOutMessageCreateOgreTen( pMessage );
			}
			break;
		case TIMER_MAGICWEAPON_INCMP:
			{
				OnTimeOutMessageMagicWeaponIncMp( pMessage );
			}
			break;
		case TIMER_MAGICWEAPON_DECHP:
			{
				OnTimeOutMessageMagicWeaponDecHp( pMessage );
			}
			break;
		case TIMER_FIREBATTLE:
			{
				OnTimeOutMessageFireBattle( pMessage );
				break;
			}
		case TIMER_STARTCORPSBATTLE:
			{
				OnTimeOutMessageStartBattle( pMessage );
				break;
			}
		case TIMER_TASKTIMELIMIT:
			{
				OnTimeOutMessageTimeLimitTask( pMessage );
				break;
			}
		case TIMER_CDGROUP:
			{
				OnTimeOutMessageCDGroup( pMessage );
				break;
			}
		case TIMER_BUFF_FUNCTION:
			{
				OnTimeoutMessageBuffEvent( pMessage );
				break;
			}
		case TIMER_ITEM_DESTROY:
			{
				OnTimeoutMessageDestroyItem( pMessage );
				break;
			}
		case TIMER_NATION_PROTECT:
			{
				OnTimeOutMessageNonProtect( pMessage );
				break;
			}
		case TIMER_TITLE_DISAPPEAR:
			{
				OnTimeOutMessageTitleDisappear( pMessage );
				break;
			}
		default:
			{
				break;
			}	
	}
	
	return ;
}

// ***************************************************************
//  Function:		OnTimeoutMessageSkillCoolDown
//  Description:	通过Observer触发相应的处理逻辑
//	Input:			
//	OutPut:			
//	Return:			
//  Date:			12/25/2008
// 
// ***************************************************************
void CPropertyModule::OnTimeOutMessageAssignment( CMessage* pMsg )
{
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();

	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, 
			pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	if( pTimerOwner->IsCharacter() )
	{
		CEntityCharacter* tpCharacter = ( CEntityCharacter* )pTimerOwner;
		
		tpCharacter->TimeAssignment( tpCharacter, pTimerItem->get_id( ), pTimerItem->mOtherInfoLength, 
			pTimerItem->mOtherInfo );

//		bool bDelTimer = pProperty->OnSkillCooldownTimeOut( (CEntityPlayer*)pTimerOwner, pTimerItem->mOtherInfo[1], pTimerItem->mOtherInfo[2], pTimerItem->mMillSeconds );
//		if( bDelTimer )
//		{	
			//// 非强制超时的才删定时器，否则会造成vector变遍历边删除的错误
//			((CEntityPlayer*)pTimerOwner)->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
//		}
	}

}

// ***************************************************************
//  Function:		OnTimeoutMessageSkillCoolDown
//  Description:	处理技能CD超时消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:			注意：有些技能CD很长，如果玩家下线时还没有超时，会
//					在定时器强制超时处理一次，保证存盘正确。
//					【风险】如果中途服务器down了，某些比较长的技能CD会不正确，因为timer还没有超时
//					数据还没有改变，不过这个优先级比较低，允许这种情况发生，不会造成太大影响。
//  Date:			12/25/2008
// 
// ***************************************************************
void CPropertyModule::OnTimeoutMessageSkillCoolDown( CMessage* pMsg ){
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();

	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
	
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
#ifdef _DEBUG_
		print_trace_fd( "pro" );	
#endif
		return;
	}

	if( pTimerOwner->IsPlayer() )
	{
		CPropertyPlayer* pProperty = (CPropertyPlayer*) pTimerOwner->GetProperty();

		bool bDelTimer = pProperty->OnSkillCooldownTimeOut( (CEntityPlayer*)pTimerOwner, pTimerItem->mOtherInfo[1], pTimerItem->mOtherInfo[2], pTimerItem->mMillSeconds, pTimerItem->mOtherInfo[3] );
		if( bDelTimer )
		{	
			//// 非强制超时的才删定时器，否则会造成vector变遍历边删除的错误
			((CEntityPlayer*)pTimerOwner)->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
		}
	}

	return ;
}

//***********************************
// FunctionName : OnTimeoutMessageEntityDisappear 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/27/2009]
//***********************************

void CPropertyModule::OnTimeoutMessageEntityDisappear( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	// 必须是npc才能往下进行
	if( pTimerOwner->IsNpc() == false )
	{
		LOG_ERROR( "pro", "[%s:%d] entity %d is not npc ", __FUNCTION__, __LINE__, pTimerOwner->GetEntityID() );
		return;
	}

	CPropertyNPC* pProperty = (CPropertyNPC*) pTimerOwner->GetProperty();

	// 统一都先删除定时器，还没有什么例外
	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

	pProperty->OnEntityDisappearTimeout( pTimerOwner );

	return ;
}
//
////***********************************
//// FunctionName : OnTimeoutMessageKillEntityWithHide 
//// Description  : 带渐隐的 干掉NPC 超时处理 奇缘NPC用
//// Input Params : 
//// Output Params: 
//// Return Types : 
//// Modified Time: [6/9/2009]
////***********************************
//void CPropertyModule::OnTimeoutMessageKillEntityWithHide( CMessage* pMsg )
//{
//	if ( pMsg == NULL )
//		return;
//
//	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
//	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
//	if( pTimerOwner == NULL )
//	{
//		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
//		return;
//	}
//
//	CPropertyCharacter* pProperty = (CPropertyCharacter*) pTimerOwner->GetProperty();
//
//	// 统一都先删除定时器，还没有什么例外
//	((CEntityNpc*)pTimerOwner)->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
//
//	pProperty->OnKillEntityWithHideTimeout( pTimerOwner );
//
//	return ;
//}


//***********************************
// FunctionName : OnTimeoutMessageEntityClear 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/27/2009]
//***********************************

void CPropertyModule::OnTimeoutMessageEntityClear( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}
	
	//TODO: 这里就不需要cleartimer了，因为销毁实体时会销毁所有它的定时器

	// 如果是NPC 要把该置失败的任务弄失败了
	if ( pTimerOwner->IsFunNpc() )
	{
		int nPlayerCharID = pTimerItem->mOtherInfo[1];
		CEntityPlayer* pPlayer = CSceneLogic::GetSingleton().GetPlayerByCharID( nPlayerCharID );
		CEntityNpc* pNpc = (CEntityNpc*)pTimerOwner;
		CTemplateNpc* pTplNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID() );
		LK_ASSERT( pTplNpc!=NULL, return );
		if (pPlayer != NULL)
		{			
			for (int i = 0 ; i < MAX_FAIL_TASKS; ++i )
			{
				if ( pTplNpc->mFailTaskID[i] == 0 )
				{
					break;
				}
				else
				{
					CTaskModule::GetSingleton().OnTaskFailed( pPlayer, pTplNpc->mFailTaskID[i], false );
				}
			}
		}

		// 如果是灵石类型，不销毁，传回出生点
		if ( pTplNpc->mStoneBuff != 0 && pTplNpc->mTownX != 0 && pTplNpc->mTownY != 0 )
		{
			CMapModule::GetSingletonPtr()->Teleport( pNpc->GetLineID(), pNpc->GetMapID(), pTplNpc->mTownX, pTplNpc->mTownY, pNpc );
			CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
			SendWarEventNotify( NOTICE_WAR_STONE_CREATE, pNpc->GetMapID(), pTplNpc->mTownX, pTplNpc->mTownY, 
				0, 0, 0, pNpc->GetNpcID(), NULL );
			return;
		}
	}else
	{
		if( pTimerOwner->IsItem() )
		{
			LogDropedItemDestroyAction(pTimerOwner);
		}
	}
		
	CSceneLogic::GetSingleton().DestroyEntity( pTimerOwner, 0 );
	return ;
}


// ***************************************************************
//  Function:		OnTimeoutMessageEntityProtectTimeOver
//  Description:	处理道具保护时间到期
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:			02/17/2009
// 
// ***************************************************************
void CPropertyModule::OnTimeoutMessageEntityProtectTimeOver( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );	
		return;
	}

	if( pTimerOwner->IsItem() != true )
	{
		LOG_ERROR( "pro", "is not item protect time over event" );
		return ;
	}

	CPropertyDrop* pItemProperty = (CPropertyDrop*) pTimerOwner->GetProperty();

	// 清空所有者
	pItemProperty->CleanOwnerCharID( );

	// 发送消息修改物品归属,所有人可捡
	CMessage tMessage;
	CMessageChangeAppertainings tChangeAppertainings;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEAPPERTAININGS );
	tMessage.set_msgpara( (unsigned int)&tChangeAppertainings );
	tChangeAppertainings.set_entityid( pTimerOwner->GetEntityID() );
	CMapModule::GetSingletonPtr()->MessageBroadCast( pTimerOwner, &tMessage );

	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

	int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY, 0, 0, 0};
	
	// 设置物品消失定时器
	( (CEntityItem*) pTimerOwner )->GetTimerReciver()->SetTimer( pTimerOwner->get_id(), TIMER_ENTITY_CLEAR, ITEM_DISAPPER_TIME, 1, nTimerOtherInfo );

	return ;
}

//***********************************
// FunctionName : OnTimeoutMessageEntityRelive 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/27/2009]
//***********************************

void CPropertyModule::OnTimeoutMessageEntityRelive2( CMessage* pMsg )
{
    LOG_ERROR( "YaoQianShu", "[%s:%s:%d]  Start OnTimeoutMessageEntityRelive2", __LK_FILE__, __FUNCTION__, __LINE__ );

	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
    COgreCreator* pCreator = ( COgreCreator* )CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
    if ( pCreator == NULL )
    {
        LOG_ERROR( "YaoQianShu", "[%s:%s:%d] Can't find Creator %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
        CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
        return;
    }
    int liStoreBoxIndex = pCreator->GetIndex();

    CStoreBox loStoreBox;
    bool lbRetForGetStoreBox = CActivityYqsCfg::GetSingleton().GetStoreBox( liStoreBoxIndex, loStoreBox );
    if ( lbRetForGetStoreBox == false )
    {
        LOG_ERROR( "YaoQianShu", "[%s:%s:%d] Can't find loStoreBox %d", __LK_FILE__, __FUNCTION__, __LINE__, liStoreBoxIndex );
        CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
        return;
    }

    if ( CActivityYqs::GetSingleton().mbIsFinished == true )
    {
        LOG_NOTICE( "YaoQianShu", "[%s:%s:%d]  the YaoQianShu activiy is finished! StoreBox(%d)", __LK_FILE__, __FUNCTION__, __LINE__, loStoreBox.miNpcID );
        CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
        return;
    }

    int liLineID        = CSceneLogic::GetSingleton().GetLineID();
    unsigned int liEntityId  = 0;
    bool lbRetForCreateNpc = CMapModule::GetSingleton().CreateNpc( liLineID, 
        loStoreBox.miMapID, 
        0, 
        pCreator, 
        liEntityId );
    if ( lbRetForCreateNpc == false )
    {
        LOG_ERROR( "YaoQianShu", "[ %s:%d ][ %s ] Create npc(%d) failed!", __LK_FILE__, __LINE__, __FUNCTION__, loStoreBox.miNpcID );
        CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
        return ;
    }

    CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );

    LOG_ERROR( "YaoQianShu", "[%s:%s:%d]  Finished OnTimeoutMessageEntityRelive2", __LK_FILE__, __FUNCTION__, __LINE__ );
	return ;
}

void CPropertyModule::OnTimeoutMessageEntityRelive( CMessage* pMsg )
{
    if ( pMsg == NULL )
        return;

    CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
    CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
    if( pTimerOwner == NULL )
    {
        LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
        CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
        return;
    }

    if ( pTimerOwner->IsNpc() )
    {
        CEntityNpc *pNpc = (CEntityNpc*)pTimerOwner;
        pNpc->SetOccurTimer( pNpc->GetOccurTime( ) );
        EntityRelive( pTimerOwner );

		COgreCreator *tCreator = (COgreCreator*)CSceneObjManager::GetSingletonPtr()->GetObject( pNpc->GetCreatorID( ) );
		if ( tCreator != NULL )
		{
			tCreator->mNextRefreshTime = 0;
		}

        pNpc->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
    }

    return ;
}

void CPropertyModule::OnTimeOutMessageRefreshTen( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	if ( pTimerOwner->IsNpc() )
	{
		CEntityNpc *pNpc = (CEntityNpc*)pTimerOwner;
	
		int tIntParam[ 3 ] = { 0 };
		tIntParam[ 0 ] = pNpc->GetNpcID( );
		tIntParam[ 1 ] = 10;
		tIntParam[ 2 ] = pNpc->GetMapID( );
		SendEventNotify( NOTICE_PREREFRESHBOSS, pNpc->GetLineID( ), tIntParam, ARRAY_CNT(tIntParam), NULL, NULL );

		pNpc->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
	}


	return ;
}
void CPropertyModule::OnTimeOutMessageRefreshFive( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );	
		return;
	}

	if ( pTimerOwner->IsNpc() )
	{
		CEntityNpc *pNpc = (CEntityNpc*)pTimerOwner;

		int tIntParam[ 3 ] = { 0 };
		tIntParam[ 0 ] = pNpc->GetNpcID( );
		tIntParam[ 1 ] = 5;
		tIntParam[ 2 ] = pNpc->GetMapID( );
		SendEventNotify( NOTICE_PREREFRESHBOSS, pNpc->GetLineID( ), tIntParam, ARRAY_CNT(tIntParam), NULL, NULL );
		
		pNpc->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
	}


	return ;
}

void CPropertyModule::OnTimeOutMessageCreateOgreTen( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	CCreator *pNpcCreator = (CCreator *)CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOtherInfo[ 1 ] );
	if ( pNpcCreator == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find entity %d ", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		return;
	}

	if( pTimerOwner->IsNpc() )
	{
		CSceneLogic::GetSingleton( ).CreateEntity( pTimerOwner, pNpcCreator );

		pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
		pTimerOwner->mHasCreated = true;

	}
	

	return ;
}

// 限时任务到时间
void CPropertyModule::OnTimeOutMessageTimeLimitTask(CMessage *pMsg)
{
	if ( pMsg == NULL )
	{
		return ;
	}
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntityPlayer* pTimerOwner = (CEntityPlayer*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	// 如果是强制超时的 不处理 下线的时候会处理的
	if ( pTimerItem->mMillSeconds > 0 )
		return;

	unsigned short tTaskID = (unsigned short)pTimerItem->mOtherInfo[1];

	CTaskModule::GetSingleton().OnTaskTimeOut( pTimerOwner, tTaskID );
}

// cd组到时间
void CPropertyModule::OnTimeOutMessageCDGroup(CMessage* pMsg)
{
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntityPlayer* pTimerOwner = (CEntityPlayer*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	CPropertyPlayer* tpPlayerPro =  (CPropertyPlayer*)pTimerOwner->GetProperty();
	CGroupCD& rGroupCD = tpPlayerPro->GetCDGroupList().GetGroupCD( pTimerItem->mOtherInfo[1] );
	
	rGroupCD.SetCDTime( std::max(pTimerItem->mMillSeconds, 0) );
	rGroupCD.SetTimerID( INVALID_OBJ_ID );

	// 给客户端发消息
	if( rGroupCD.GetCDTime() == 0 )
	{
		CSceneLogic::GetSingletonPtr()->Send2Player( pTimerOwner, 
			BuildFuncResultMessage( pTimerOwner, FUNC_PHCOOLDOWN, RESULT_NORMAL, 0, rGroupCD.GetCDGroupIdx(), 0 ) );
	}

	// 清除定时器
	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

}

// buff作用超时
void CPropertyModule::OnTimeoutMessageBuffEvent( CMessage* pMsg )
{
	CTimerItem* pTimerItem = ( CTimerItem* ) pMsg->msgpara();
	CEntityCharacter* pTimerOwner = ( CEntityCharacter* ) CSceneObjManager::GetSingleton().GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	CPropertyCharacter* pPro = (CPropertyCharacter*) pTimerOwner->GetProperty();

	int nBuffID = pTimerItem->mOtherInfo[1];
	int tListID = pTimerItem->mOtherInfo[2];

	CBuffObject* tpBuff = pPro->GetBuffList()->GetBuffObjectByID( nBuffID );
	if( tpBuff == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] player %d can't find buff %d", __LK_FILE__, __LINE__, 
			pTimerOwner->GetEntityID(), nBuffID );
		pTimerOwner->GetTimerReciver()->ClearTimer(  pTimerItem->get_id() );
		return;
	}

	CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( nBuffID );
	if ( tpBuffTpl == NULL )
	{
		LOG_ERROR( "[%s:%s:%d] can't find buff %d for entity %d ", 
			__LK_FILE__, __FUNCTION__, __LINE__, nBuffID, pTimerOwner->GetEntityID() );
		return;
	}

	pTimerOwner->BuffTimeEvent( tpBuffTpl, tpBuff );

	//TODO: 前面buff里面作用完以后,有可能已经被CBuffObject已经被删除了，但是我们使用的是静态内存，tpBuff指针依然有效，只是逻辑失效。
	tpBuff->mPersistTime -= ( pTimerItem->mDurationSeconds - pTimerItem->mMillSeconds );
	if( tpBuff->mPersistTime <= 0 )
	{
		// 前面的BuffTimeEvent有可能已经把实体杀死了，实体死亡会删除一些buff，除了死后不删除的，这里就不用删了。
		if( pTimerOwner->IsAlive() || tpBuffTpl->mBuffDieDel == CTemplateBuff::BUFF_NOTCANCEL )
		{
			// RemoveBuff中间会修改tpBuff指向内容， tpBuff已经不是原来的buff了，后面一定不要对tpBuff做操作
			pTimerOwner->EntityRemoveBuff( nBuffID, tListID );
			if (pTimerOwner->IsPlayer())
			{
				LogEventLostBuffByTimeout((CEntityPlayer *)pTimerOwner,nBuffID ); // 时间到了失去
			}
			
		}

		return;
	}

	pTimerItem->mMillSeconds = pTimerItem->mDurationSeconds;
}

// 非保护计时到时间
void CPropertyModule::OnTimeOutMessageNonProtect(CMessage* pMsg)
{
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntityPlayer* pTimerOwner = (CEntityPlayer*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	if ( pTimerItem->mMillSeconds > 0 )
	{
		return;
	}

	pTimerOwner->SetProtectStatus( true );

	// 给客户端发消息
	pTimerOwner->InitFunResult( );
	pTimerOwner->AddFunResult( pTimerOwner->GetEntityID(), FUNC_CHANGEPROTECT, RESULT_NONE, true, pTimerOwner->GetProtectStatus() );
	ResultListSend( );	

	// 清除定时器
	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
}


void CPropertyModule::OnTimeOutMessageFireBattle(CMessage *pMsg)
{
	if ( pMsg == NULL )
	{
		return ;
	}

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( pTimerItem->get_id() );
		return;
	}

	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

	if ( pTimerOwner->IsNpc() == false )
	{		
		return ;
	}

	CEntityNpc* tpNpcEntity = (CEntityNpc*)pTimerOwner;

	CPropertyNPC* tpNpcProperty = ( CPropertyNPC* ) tpNpcEntity->GetProperty();
	tpNpcProperty->SetBattleTimer( INVALID_OBJ_ID );

	if ( pTimerItem->mMillSeconds <= LK_ZERO )
	{
		CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpNpcEntity->GetNpcID() );
		if ( tpTplNpc == NULL )
		{
			return ;
		}
		if ( tpTplNpc->mCorpsBattle == 0 )
		{
			return ;
		}
		CMessage tMessage;
		CMessageCorpsBidTimerStopRequest tPara;
		tPara.set_npcid( tpTplNpc->mTempID );
		tPara.set_battleid( tpTplNpc->mBattleCity );
		tMessage.mutable_msghead()->set_messageid( ID_S2G_REQUEST_BIDTIMERSTOP );
		tMessage.set_msgpara( (long) &tPara );
		CSceneLogic::GetSingleton().Send2Gate( &tMessage );

		CORPS_CFG* tpCfg = CSceneCfgManager::GetSingleton().GetCorps_cfg();
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, 0, 0, 0};
		tpNpcEntity->GetTimerReciver()->SetTimer( tpNpcEntity->GetEntityID(), TIMER_STARTCORPSBATTLE, tpCfg->mBattlewaitingtime * 60 * 1000, 1, nTimerOtherInfo );
	
		LOG_NOTICE( "pro", "[%s:%d] npc %d city %d", __LK_FILE__, __LINE__,
			tpTplNpc->mTempID, tpTplNpc->mBattleCity );
	}

	return ;
}

void CPropertyModule::OnTimeOutMessageStartBattle(CMessage *pMsg)
{
	if ( pMsg == NULL )
	{
		return ;
	}

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( pTimerItem->get_id() );
		return;
	}

	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

	if ( pTimerOwner->IsNpc() == false )
	{		
		return ;
	}

	CEntityNpc* tpNpcEntity = (CEntityNpc*)pTimerOwner;

	( ( CPropertyNPC* )tpNpcEntity->GetProperty() )->SetBattleTimer( 0 );

	if ( pTimerItem->mMillSeconds <= LK_ZERO )
	{
		CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpNpcEntity->GetNpcID() );
		if ( tpTplNpc == NULL )
		{
			return ;
		}
		if ( tpTplNpc->mCorpsBattle == 0 )
		{
			return ;
		}

		CMessage tMessage;
		CMessageCorpsStartBattleRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_S2G_REQUEST_STARTCOPRSBATTLE );
		tMessage.set_msgpara( (long) &tPara );

		tPara.set_npcid( tpTplNpc->mTempID );
		tPara.set_battleid( tpTplNpc->mBattleCity );
		CSceneLogic::GetSingleton().Send2Gate( &tMessage );

		LOG_NOTICE( "pro", "[%s:%d] npc %d city %d battle start", __LK_FILE__, __LINE__, 
			tpTplNpc->mTempID, tpTplNpc->mBattleCity );
	}
	return ;
}

// ***************************************************************
//  Function:	 OnTimeoutMessageEntityAliveRefresh
//  Description: 怪物存活时间刷新
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:			02/17/2009
// 
// ***************************************************************
void CPropertyModule::OnTimeoutMessageEntityAliveRefresh( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntity* pTimerOwner = (CEntity*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id()  );
		return;
	}

	LK_ASSERT( pTimerOwner->IsNpc(), return );

	//  存活刷新
	CCreatureRefresher::GetSingletonPtr()->OnLifetimeRefreshEvent( (CEntityNpc*)pTimerOwner, 
		pTimerItem->mOtherInfo[ 1 ] );

	// 销毁原怪物实体
	pTimerOwner->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
	SceneServer::CSceneLogic::GetSingletonPtr()->DestroyEntity( pTimerOwner, 0 );	

	return ;
}

//***********************************
// FunctionName : OnTimeoutMessageDiploidTime 
// Description  : 刷新有效的双倍时间
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/26/2009]
//***********************************

void CPropertyModule::OnTimeoutMessageDiploidTime( CMessage* pMsg )
{
	LK_ASSERT( pMsg != NULL, return );

	CTimerItem* pTimerItem = ( CTimerItem* ) pMsg->msgpara();
	CEntity* pTimerOwner = ( CEntity* ) CSceneObjManager::GetSingleton().GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( pTimerItem->get_id() );
		return;
	}

	if ( pTimerOwner->IsPlayer() == false )
	{
		return ;
	}

	// 刷新玩家身上的双倍经验时间
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pTimerOwner->GetProperty();
	tpProperty->SetValidDiploid( pTimerItem->mMillSeconds );
	if ( pTimerItem->mMillSeconds <= LK_ZERO )
	{
		((CEntityPlayer*) pTimerOwner)->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );
		tpProperty->InitDoubleState();		
	}
	return ;
}

void CPropertyModule::OnTimeOutMessageYellowStatus( CMessage* pMsg )
{
	if ( pMsg == NULL )
	{
		return ;
	}
	
	CTimerItem* pTimerItem = ( CTimerItem* ) pMsg->msgpara();
	CEntity* pTimerOwner = ( CEntity* ) CSceneObjManager::GetSingleton().GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( pTimerItem->get_id() );
		return;
	}

	if ( pTimerOwner->IsPlayer() == false )
	{
		return ;
	}

	CEntityPlayer* tpPlayer = (  CEntityPlayer* ) pTimerOwner;
	// 删掉计时器
	tpPlayer->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pTimerOwner->GetProperty();
	if ( tpProperty == NULL )
		return ;

	tpProperty->SetYellowTimer( LK_ZERO );
	
	// 非屠杀模式，通知周围黄名消失
	if ( tpPlayer->GetPKMode() != PKMODE_ALL && tpPlayer->GetPKMode() != PKMODE_CORPS )
		SendYellowStateNotice( tpPlayer, false );

	return ;
}

// 物品变化超时
void CPropertyModule::OnTimerItemChange( CMessage* pMsg )
{
	if ( pMsg == NULL )
	{
		return ;
	}

	CTimerItem* pTimerItem = ( CTimerItem* ) pMsg->msgpara();
	CEntity* pTimerOwner = ( CEntity* ) CSceneObjManager::GetSingleton().GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		CTimerMng::GetSingleton().ClearTimer( pTimerItem->get_id() );
		return;
	}

	if ( pTimerOwner->IsPlayer() == false )
	{
		return ;
	}

	CEntityPlayer* pPlayer = (CEntityPlayer*)pTimerOwner;
	CPropertyPlayer* pPro = (CPropertyPlayer*)pPlayer->GetProperty();
	LK_ASSERT( pPro, return );
	if ( pPro->GetTaskBaggage()->HasItem( pTimerItem->mOtherInfo[1] ) > 0  )
	{
		uint64_t ullGUID = 0;
		bool tBind = false;
		if ( PlayerRemoveItemByID( pPlayer, pTimerItem->mOtherInfo[1], 1, tBind, &ullGUID ) == 0)
		{
			LogEventLostItemByChange(pPlayer, ullGUID, pTimerItem->mOtherInfo[1], 1, 0, 0);
		}

		CItemObject * pInsItemPile = PlayerInsertItem( pPlayer, pTimerItem->mOtherInfo[2], 1, false );
		if ( pInsItemPile != NULL)
		{
			LogEventGetItemByRollBack(pPlayer, pInsItemPile->GetGUID(), 
					pTimerItem->mOtherInfo[2], 1, pPlayer->GetPosX(), pPlayer->GetPosY());
		}


		// 强制让任务失败
		CTaskModule::GetSingleton().OnTaskFailed( pPlayer, (unsigned short)pTimerItem->mOtherInfo[3] );
	}

	// 删掉计时器
	pPlayer->GetTimerReciver()->ClearTimer( pTimerItem->get_id() );

}


//***********************************
// FunctionName : OnTimeOutMessageRedstoneProcess 
// Description  : 客户端读秒处理超时
// Input Params : 
// Output Params: 
// Return Types : 
// Date         : 3/25/2009
//***********************************
void CPropertyModule::OnTimeOutMessageRedstoneProcess( CMessage* pMsg )
{
	LK_ASSERT( pMsg != NULL, return );
	CTimerItem *tpTimerItem = ( CTimerItem * )pMsg->msgpara();	
	CEntityRedStone *tpRedstone = ( CEntityRedStone * )CSceneObjManager::GetSingleton().GetObject( tpTimerItem->mOwnerID );
	// 如果内丹还没有消失
	if ( tpRedstone == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, tpTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( tpTimerItem->get_id() );
		return ;
	}

	ClearRedstoneStatus( tpRedstone );

	// 删掉计时器
	tpRedstone->GetTimerReciver()->ClearTimer( tpTimerItem->get_id() );
}

// ***************************************************************
//  Function:	 OnTimeoutMessageEndRedstoneProtect
//  Description: 内丹的保护时间结束
//	Input:		 CMessage* pMsg	
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// ***************************************************************
void CPropertyModule::OnTimeoutMessageEndRedstoneProtect(CMessage* pMsg)
{
	if ( pMsg == NULL )
	{
		return;
	}
	CTimerItem *tpTimerItem = ( CTimerItem * )pMsg->msgpara();
	if ( tpTimerItem == NULL )
	{
		return;
	}	
	EndRedStoneProtect( tpTimerItem ); 		
}


// ***************************************************************
//  Function:	 OnTimeOutMessageRedStoneClear
//  Description: 内丹的消失时间到
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// ***************************************************************

void CPropertyModule::OnTimeOutMessageRedStoneClear( CMessage* pMsg )
{
	if ( pMsg == NULL )
	{
		return;
	}		
	CTimerItem *tpTimer = ( CTimerItem * )pMsg->msgpara();
	if ( tpTimer == NULL )
	{	
		return;
	}
	ClearRedStone( tpTimer );
}

// ***************************************************************
//  Function:	 OnTimeOutMessageFireRedStoneMagic
//  Description: 内丹的噬炼结束
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// ***************************************************************
void CPropertyModule::OnTimeOutMessageFireRedStoneMagic( CMessage* pMsg ) 
{
	if ( pMsg == NULL )
	{
		return;
	}
	CTimerItem *tpTimer = ( CTimerItem * )pMsg->msgpara();
	if ( tpTimer == NULL )
	{
		return;
	}
	RedStoneMagicTime( tpTimer );
}

void CPropertyModule::OnMessageChangeFashionShow( CEntityPlayer* pPlayer, CMessage* pMessage )
{
    LK_ASSERT( pPlayer != NULL && pMessage != NULL , return )
    CMessagePlayerChangeFashionShowRequest *tpMsg = ( CMessagePlayerChangeFashionShowRequest* )pMessage->msgpara();
    LK_ASSERT( tpMsg != NULL, return )
    CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

    CMessage tMessage;
    CMessagePlayerChangeFashionShowResponse tPara;
    tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_PLAYERCHANGEFASHIONSHOW );
    tMessage.set_msgpara( (long) &tPara );
    tPara.set_result( SUCCESS );
    tPara.set_playerid( tpMsg->playerid() );

    int liPlayerId = pPlayer->GetCharID();
    int liPlayerFashionShowState = tpMsg->fashionshowstate();

    LOG_DEBUG( "pro", "[%s %s:%d] change player(%d) is fashion state(%d)", 
        __FUNCTION__, __LK_FILE__, __LINE__, liPlayerId, liPlayerFashionShowState );


    tpProperty->SetIsShowFashion( liPlayerFashionShowState );
    tPara.set_fashionshowstate( tpProperty->GetIsShowFashion() );
    CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );

    CMessage tMessage2;
    CMessagePlayerChangeFashionNotice tPara2;
    tMessage2.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_PLAYERCHANGEFASHIONSHOW );
    tMessage2.set_msgpara( (long) &tPara2 );
    tPara2.set_playerid( liPlayerId );
    tPara2.set_fashionshowstate( liPlayerFashionShowState );
    CMapModule::GetSingleton().MessageBroadCast( pPlayer, &tMessage2, false, false );

    return;     

}

void CPropertyModule::OnMessageChangeEquipShow( CEntityPlayer* pPlayer, CMessage* pMessage )
{
    LK_ASSERT( pPlayer != NULL && pMessage != NULL , return )
    CMessagePlayerChangeEquipShowRequest *tpMsg = ( CMessagePlayerChangeEquipShowRequest* )pMessage->msgpara();
    LK_ASSERT( tpMsg != NULL, return )
    CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
  
    CMessage tMessage;
    CMessagePlayerChangeEquipShowResponse tPara;
    tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_PLAYERCHANGEEQUIPTSHOW );
    tMessage.set_msgpara( (long) &tPara );
    tPara.set_result( SUCCESS );

    int liPlayerId = pPlayer->GetCharID();
    int liPlayerEquipShowState = tpMsg->equipshowstate();

    LOG_DEBUG( "pro", "[%s %s:%d] change player(%d) is equip state(%d)", 
        __FUNCTION__, __LK_FILE__, __LINE__, liPlayerId, liPlayerEquipShowState );

    tPara.set_playerid( liPlayerId );
    tpProperty->SetIsShowEquip( liPlayerEquipShowState );
    tPara.set_equipshowstate( tpProperty->GetIsShowEquip() );
    CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
    return;
}


// 客户端发送消息
void CPropertyModule::OnClientMessage( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( ( pMessage != NULL ) && ( pMessage->msgpara() != 0 ) , return );

	//CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )pPlayer->GetProperty( );
	switch(  pMessage->mutable_msghead()->messageid() )
	{
        case ID_C2S_REQUEST_PLAYERCHANGEFASHIONSHOW:
            {
                OnMessageChangeFashionShow( pPlayer, pMessage );
                break;
            }
        case ID_C2S_REQUEST_PLAYERCHANGEEQUIPSHOW:
            {
                OnMessageChangeEquipShow( pPlayer, pMessage );
                break;
            }
		case ID_C2S_REQUEST_OPENKITBAG:
			{
				OnMessageOpenKitBag( pPlayer, pMessage );
				break;	
			}
		case ID_C2S_REQUEST_ADDKITBAG:
			{
				OnMessageAddKitBagRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_STORMONEY:
			{
				OnMessageStorMoneyRequest( pPlayer, pMessage );
				break;
			}	
		case ID_C2S_REQUEST_TAKESTORMONEY:
			{
				OnMessageTakeStorMoneyRequest( pPlayer, pMessage );
				break;
			}	
		case ID_C2S_REQUEST_SETPASSWORD:
			{
				OnMessageSetPassWordRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MODIFYPASSWORD:
			{
				OnMessageModifyPasswordRequest( pPlayer, pMessage );
				break;
			}						
		case ID_C2S_REQUEST_CHECKPASSWORD:
			{
				OnMessageCheckPasswordRequest( pPlayer, pMessage );
				break;
			}
		/*case ID_C2S_NOTIFY_SETPASSWORDOPTION:
			{
				OnMessageSetPasswordOption( pPlayer, pMessage );
				break;
			}*/
		//case ID_C2S_REQUEST_CLICKWELFARE:
		//	{
		//		OnMessageClickWelfare( pPlayer, pMessage );
		//		break;
		//	}
		case ID_C2S_REQUEST_CLICKREDSTONDE:
			{
				OnMessageClickRedStoneRequest( pPlayer, pMessage );
				break;	
			}
		case ID_C2S_NOTIFY_REDSTONETIMEREND:
			{
				OnMessageRedStoneTimerEnd( pPlayer, pMessage );
				break;
			}	
		case ID_C2S_REQUEST_ADDEQTFORRESUMEBIND:
			{
				OnMessageAddEqtForResumeBind( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_TAKEEQTFORRUMEBIND:
			{
				OnMessageTakeEqtForResumeBind( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_RESUMEBIND:
			{
				OnMessageResumeBind( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CHANGEHELPSTATUS:
			{
				OnMessageChangeHelpStatus( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_THROWSTORITEM:
			{
				OnMessageThrowStorItemRequest( pPlayer, pMessage );
				break;				
			}
		case ID_C2S_REQUEST_ADDITEMREQUEST:
			{
				OnMessageAddItemRequest( pPlayer , pMessage );
				break;			 
			}
		case ID_C2S_REQUEST_TAKEITEMREQUEST:
			{
				OnMessageTakeItemRequest( pPlayer, pMessage );
				break;			
			}
		case ID_C2S_REQUEST_ADDITEMFORFREE:
			{
				OnMessageAddItemForFreeRequest( pPlayer , pMessage );
				break;
			}
		case ID_C2S_REQUEST_TAKEITEMFORFREE:
			{
				OnMessageTakeItemForFreeRequet( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_FREEITEM:
			{	
				OnMessageFreeItem( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_BINDITEMREQ:
			{
				OnMessageBindItemRequest ( pPlayer, pMessage );	
				break;	
			}
		case ID_C2S_REQUEST_MENDEQUIPMENT:
			{
				OnMessageMendEquipment( pPlayer,pMessage );
				break;
			}	
	/*	case ID_C2S_REQUEST_MOVESTORAGEITEM:
			{
				OnMessageMoveStorageItem( pPlayer , pMessage );
				break;
			}*/
		case ID_S2C_NOTIFY_PRODEBUG:
			{
				OnMessageProDebugNotice( pPlayer, pMessage );
				break;
			}
		case ID_C2S_DEBUGCOMMAND:
			{
				OnMessageProDebugCommand( pPlayer, pMessage );
				CGMModule::GetSingleton().OnClientMessage(pPlayer, pMessage);
				break;
			}
		case ID_C2S_REQUEST_SETSHORTCUT:
			{
				OnMessageSetShortcutRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PLAYERRELIVE:
			{
				OnMessagePlayerReliveRequest( pPlayer, pMessage );
				break;
			}
		//case ID_C2S_REQUEST_THROWMONEY:
		//	{
		//		OnMessageThrowMoneyRequest( pPlayer, pMessage );
		//		break;
		//	}
		case ID_C2S_REQUEST_THROWITEM:
			{
				OnMessageThrowItemRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_SELLITEM:
			{
				OnMessageSellItemRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PURCHASEITEM:
			{
				OnMessagePurchaseItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家获取购回界面道具列表信息请求
		case ID_C2S_REQUEST_SALEITEM:
			{
				OnMessageObtainSaleItemString( pPlayer, pMessage );
				break ;
			}
			// 玩家回购道具请求
		case ID_C2S_REQUEST_BUYBACK:
			{
				OnMessageBuyBackItem( pPlayer, pMessage );
				break ;
			}
		case ID_S2C_NOTIFY_CLOSEDIALOG:
			{
				PlayerCloseDialog( pPlayer );
				break;
			}
			// 玩家点击功能NPC请求
		case ID_C2S_REQUEST_CLICKNPC:
			{
				OnMseeageClickNpcRequest( pPlayer, pMessage );
				break;
			}
			// 玩家拾取道具请求
		case ID_C2S_REQUEST_PICKITEM:
			{
				OnMessagePickItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家重置所有属性点
		case ID_C2S_REQUEST_RESETAPP:
			{
				ResetAllPP( pPlayer );
				break;
			}
			// 玩家重置所有技能点
		case ID_C2S_REQUEST_RESETASP:
			{
				ResetAllSP( pPlayer );
				break;
			}
			// 玩家重置一点技能点
		case ID_C2S_REQUEST_RESETSSP:
			{
				OnMessageResetSSPRequest( pPlayer, pMessage );
				break;
			}
			// 玩家配置技能点请求
		case ID_C2S_REQUEST_CLICKSKILLPOINT:
			{
				OnMessageClickSkillPointRequest( pPlayer, pMessage );
				break;
			}
			// 玩家卸下道具的请求
		case ID_C2S_REQUEST_UNEQUIPITEM:
			{
				OnMessageUnEquipItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家装备道具的请求
		case ID_C2S_REQUEST_EQUIPITEM:
			{
				OnMessageEquipItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家移动道具请求
		case ID_C2S_REQUEST_MOVEITEM:
			{
				OnMessageMoveItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家普通攻击请求
		case ID_C2S_REQUEST_NORMALATTACK:
			{
				//OnMessageNormalAttackRequest( pPlayer, pMessage );
				break;
			}
			// 玩家使用技能请求
		case ID_C2S_REQUEST_USESKILL:
			{
				OnMessageUseSkillRequest( pPlayer, pMessage );
				break;
			}
			// 玩家要通过ID来获取玩家资料
		case ID_C2S_REQUEST_GETROLEPERSONALINFOBYID:
			{
				break;
			}
			// 玩家要通过角色名来获取玩家资料
		case ID_C2S_REQUEST_GETROLEPERSONALINFOBYNAME:
			{
				break;
			}
			// 玩家要修改自己的玩家资料
		case ID_C2S_REQUEST_SETROLEPERSONALINFO:
			{
				break;
			}
			// 玩家使用道具
		case ID_C2S_REQUEST_USEITEM:
			{
				OnMessageUseItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家生产装备
		case ID_C2S_REQUEST_PRODUCEEQUIP:
			{
				OnMessageProduceEquipRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageProduceEquipRequest( pPlayer, pMessage );
				break;
			}
			// 玩家生产药品
		case ID_C2S_REQUEST_PRODUCEPHY:
			{
				OnMessageProducePhysRequest( pPlayer, pMessage );
				//CTaskModule::GetSingleton().OnMessageProducePhysRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageProduceEquipRequest( pPlayer, pMessage );
				break;
			}
			// 玩家放置升级物品
		case ID_C2S_REQUEST_UPGADDITEM:
			{
				OnMessageUpgAddItemRequest( pPlayer, pMessage );
				break;
			}

			// 玩家拿回升级物品
		case ID_C2S_REQUEST_UPGDELITEM:
			{
				OnMessageUpgDelItemRequest( pPlayer, pMessage );
				break;
			}
			// 玩家升级装备
		case ID_C2S_REQUEST_UPGEQUIP:
			{
				OnMessageUpgEquipRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageUpgEquipRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_PUSHRUNE:
			{
				OnMessagePushRuneRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPRUNE:
			{
				OnMessagePopRuneRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_INSERTRUNE:
			{
				OnMessageInsertRuneRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageInsertRuneRequest( pPlayer, pMessage );
				break;
			}

			//符文第二期
		case ID_C2S_REQUEST_CHANGERUNE:
			{
				OnMessageChangeRuneRequest(pPlayer, pMessage);
				break;
			}
		case ID_C2S_REQUEST_RUNECOM:
			{
				OnMessageRuneComRequest(pPlayer,pMessage);
				break;
			}
		case ID_C2S_REQUEST_PUSHJEWEL:
			{
				OnMessageInsertPushJewelRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPJEWEL:
			{
				OnMessageInsertPopJewelRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_INSERTJEWEL:
			{
				OnMessageInsertJewelRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageInsertJewelRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHSLOT:
			{
				OnMessageOpenPushRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPSLOT:
			{
				OnMessageOpenPopRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_OPENSLOT:
			{
				CMessageOpenSlotRequest *pMsg = (CMessageOpenSlotRequest*)pMessage->msgpara();
				PlayerOpenSlot( pPlayer, pMsg->equipindex(), pMsg->eggindex() );
				CTaskModule::GetSingleton().PlayerOpenSlot( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_PUSHEAT:
			{
				OnMessageEatPushEquipRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_POPEAT:
			{
				OnMessageEatPopEquipRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_EATEQUIP:
			{
				OnMessageEatEquipRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageEatEquipRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHCOMPOSE:
			{
				OnMessageComposePushRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_POPCOMPOSE:
			{
				OnMessageComposePopRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_COMPOSE:
			{
				CMessageComposeRequest *pMsg = (CMessageComposeRequest*)pMessage->msgpara( );
				PlayerComposeItem( pPlayer, pMsg->index() );
				break;
			}

		case ID_C2S_REQUEST_PLAYERTELE:
			{
				OnMessagePlayerTeleRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_NOTIFY_DIRECTION:
			{
				OnMessageNotifyDirection( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CHANGEPETMODE:
			{
				OnMessageChangePetModeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CLOSEWINDOW:
			{
				CMessageCloseWindowRequest *pCloseRequest = (CMessageCloseWindowRequest*)pMessage->msgpara();
				PlayerCloseWindow( pPlayer, pCloseRequest->closetype() );
				break;
			}
		case ID_C2S_REQUEST_STUDYSKILL:
			{
				OnMessageStudySkillRequest( pPlayer, pMessage );
				CTaskModule::GetSingleton().OnMessageStudySkillRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDPROPERTYPOINT:
			{
				OnMessageAddPropertyPointRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_SETTOWN:
			{
				OnMessageSetTownRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CHANGEPKMODE:
			{
				OnMessageChangePKModeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_LOOKPROPERTY:
			{
				OnMessageLookPropertyRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_TASKCOLLECT:
			{
				OnMessageTaskCollectRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_OBTAINDIPLOIDTIME:
			{
				OnMessageObtainDiploidRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_FREEZEDIPLOID:
			{
				OnMessageFreezeDiploidRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_QUERYREMAINTIME:
			{
				OnMessageQueryDiploidTimeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_USECONTINUEDSKILL:
			{
				OnMessageUseContinuedSkillRequest( pPlayer, pMessage );
				break;
			}
			
		case ID_C2S_REQUEST_HONORTOEXP:
			{
				CMessageHonorToExpRequest *pRequest = (CMessageHonorToExpRequest*)pMessage->msgpara();
				PlayerChangeHonorToExp( pPlayer, pRequest->changehonor( ) );
				break;
			}
		case ID_C2S_CHANGE_CAMP_REQUEST:
			{
				CMessageChangeCampRequest* tpMessage = ( CMessageChangeCampRequest* ) pMessage->msgpara();
				ChangeNationality( pPlayer, ( CampDef )tpMessage->campid( ) );	
				break;
			}

		case ID_C2S_REQUEST_OPEN_SERVICE:
			{
				OnMessageOpenServiceRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ACTIVEREMOVEBUFF:
			{
				OnMessageActiveRemoveBuffRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CLICKSYMBOL:
			{
				OnMessageClickTeleSymbolRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDSLOT:
			{
				OnMessageAddSlotRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_REMOVEJEWEL:
			{
				OnMessageRemoveJewelRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_JUDGE:
			{
				OnMessageJudgeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHADDSLOT:
			{
				OnMessagePushAddSlotRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPADDSLOT:
			{
				OnMessagePopAddSlotRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHREMOVEJEWEL:
			{
				OnMessagePushRemoveJewelRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPREMOVEJEWEL:
			{
				OnMessagePopRemoveJewelRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHJUDGE:
			{
				OnMessagePushJudgeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPJUDGE:
			{
				OnMessagePopJudgeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHCHANGE:
			{
				OnMessagePushChangeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPCHANGE:
			{
				OnMessagePopChangeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CHANGE:
			{
				OnMessageChangeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHJEWCOM:
			{
				OnMessagePushJewComRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPJEWCOM:
			{
				OnMessagePopJewComRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_JEWCOM:
			{
				OnMessageJewComRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_LISTACTIVITYMENU:
			{
				OnMessageListActivityMenu(pPlayer, pMessage);
				break;
			}

		case ID_C2S_REQUEST_LISTACTIVITYITEM:
			{
				OnMessageListActivityItem( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_MINUSACTIVITYITEM:
			{
				OnMessageMinusActivityItem( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_INTERRUPTSKILL:
			{
				OnMessageInterruptSkill( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MULTICOM:
			{
				OnMessageMultiComRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHCARD:
			{
				OnMessagePushCardRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CLICKTALENTPOINT:
			{
				OnMessageClickTalentPointRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_INCREASESTAGE:
			{
				OnMessageIncreaseTalentRequest( pPlayer, pMessage );
				break;
			}
			
			
		case ID_C2S_REQUEST_INITIALLIFESKILL:
			{
				OnMessageInitialLifeSkillRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_LEVELUPLIFESKILL:
			{
				OnMessageLevelUpLifeSkillRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_STUDYCOMPOSE:
			{
				OnMessageStudyComposeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_SETMAGICSTONE:
			{
				OnMessageSetMagicStoneRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_DECOMPOUNDEQUIP:
			{
				OnMessageDecompoundEquipRequest( pPlayer, pMessage );
				break;
			}	
		case ID_C2S_REQUEST_ADDMATERIAL:
			{
				OnMessageAddMaterialRequest( pPlayer, pMessage );
				break;
			}		
		case ID_C2S_REQUEST_TAKEMATERIAL:
			{
				OnMessageTakeMaterialRequest( pPlayer, pMessage );
				break;
			}	
		case ID_C2S_REQUEST_FORGETLIFESKILL:
			{
				OnMessageForgetLifeSkill( pPlayer, pMessage );
				break;
			}	 		 
			
		case ID_C2S_REQUEST_ADDPOTENTIAL:
			{
				OnMessageMWAddPotential( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CHANGEEXPSCALE:
			{
				OnMessageChangeExpScaleRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MWADDSKILLPOINTS:
			{
				OnMessageMWAddSkillPoints( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MWJUDGESKILL:
			{
				OnMessageMWJudgeSkill( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MWLOCKBAG:
			{
				OnMessageLockMWInBagRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MWTAKEOFF:
			{
				OnMessagePlayerTakeOffMW( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_JUDGEPROPERTY:
			{
				OnMessagePlayerJudgeMWProperty( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_SELECTTITLE:
			{
				OnMessageSelectTitleRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_USESKILLBOOK:
			{
				OnMessageMWUseSkillBookRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_CHANGEPKDROP:
			{
				OnMessageChangePKDrop( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MULTIBUFF:
			{
				OnMessageProcessMultiBuffRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_AUTOHOOK:
			{
				OnMessageAutoPlayerGameRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_BUYPHYSIC:
			{
				OnMessageBuyPhysicRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_PUSHMULTI:
			{
				OnMessagePushMultiComRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_POPMULTI:
			{
				OnMessagePopMultiComRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDDECOMPOUNDEQUIP:
			{
				OnMessageAddDecompoundEquipRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_TAKERDECOMPOUNDEQUIP:
			{
				OnMessageTakeDecompoundEquipRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_MAGICWEAPONCLEARPOINTREQUEST:
			{
				OnMessageMagicWeaponClearPointRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_MAGICWEAPONCLEARPOINT_ADDMWREQUEST:
			{
				OnMessageMagicWeaponClearPointAddMWRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDWIZARDPOINT:
			{
				OnMessageAddWizardPointRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_HONORTOWIZARD:
			{
				CMessageHonorToWizardRequest *pRequest = (CMessageHonorToWizardRequest*)pMessage->msgpara();
				PlayerChangeHonorToWizard( pPlayer, pRequest->changehonor( ), pRequest->type() );
				break;
			}
		case ID_C2S_GETHELPDATAREQUEST:
			{
				OnMessageGetHelpRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_TAKEKITBAG:
			{
				OnMessageTakeKitBag( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_GETTELELIST:
			{
				OnMessageGetTeleList( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDTELEPOINT:
			{
				OnMessageAddTelePoint( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_DELTELEPOINT:
			{
				OnMessageDelTelePoint( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_USETELEITEM:
			{
				OnMessageUseTeleItem( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_QUERY_GOLDENYB:
			{
				OnMessageQueryGoldenYB(pPlayer, pMessage);	
				break;
			}

		case ID_C2S_REQUEST_DRAW_GOLDENYB:
			{
				OnMessageDrawGoldenYB(pPlayer, pMessage);	
				break;
			}
		case ID_C2S_REQUEST_SETPWDPROTECTTIME:
			{
				OnMessageSetPwdProtectTimeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_USEFLOWER:
			{
				OnMessagePlayerUseFlowerRequest( pPlayer, pMessage );
				break;
			}

			// 远程修理装备 [3/5/2010 GaoHong]
		case ID_C2S_REQUEST_REMOTEMEND:
			{
				OnMessageRemoteMendAllEquip( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_COMMONBIND:
			{
				OnMessageCommonBindRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_STARTPROGRESS:
			{
				OnMessageStartProgressRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_GETACTVITYINFO:
			{
				CActivityModule::GetSingleton().OnMessageGetActivityInfo( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_CHANGEEQUIPPRO:
			{
				OnMessageChangeEquipProRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_USEKITBAGNEEDLE:
			{
				OnMessageUseKitbagNeedleRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_OPENSTONE:
			{
				OnMessageOpenStoneRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_LOCKPASSWORD:
			{
				OnMessageLockPasswordRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_LEARNOGRESKILL:
			{
				OnMessageLearnOgreSkillRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_USESUMMONITEM:
			{
				OnMessageUseSummonItemRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_QUERYPEDAL:
			{
				OnMessageQueryPedalRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_GETSTAR:
			{
				OnMessageGetStarRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDSTAR:
			{
				OnMessageAddStarRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_ADDEXTRA:
			{
				OnMessageAddExtraRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_WAROPERATE:
			{
				OnMessageWarOperateRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_LEARNFANGCUNSKILL:
			{
				OnMessageLearnFangCunSkillRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_HONORTOITEM:
			{
				OnMessageHonorToItemRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_JEWELCARVE:
			{
				OnMessageJewelCarveRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_STARTDIGITALFIREWORKS:
			{
				OnMessageStartDigitalFireworks( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_QUERYBOSS:
			{
				OnMessageQueryBossRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_DECOMPOSEMW:
			{
				OnMessageDecomposeMW( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_MWQLPNT:
			{
				OnMessageMWQLPrintRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_QUICKUP:
			{
				OnMessageMWQuickUpRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_REQUEST_QLCOMPOSE:
			{
				OnMessageQilinComposeRequest( pPlayer, pMessage );
				break;
			}
		case ID_C2S_QUERY_AROUND_PLAYER:
			{
				OnMessageQueryAroundPlayerRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_NOTIFY_BAGGAGELOCKEN:
			{
				OnMessageBagLockRequest( pPlayer, pMessage );
				break;
			}

		case ID_C2S_REQUEST_SPIRIT_OPEN:
			{
				OnMessageSpiritOpenRequest(pPlayer, pMessage);
			}
			break;
		case ID_C2S_REQUEST_SPIRIT_CASTING:
			{
				OnMessageSpiritCastingRequest(pPlayer, pMessage);
			}
			break;
		case ID_C2S_REQUEST_SPIRIT_UPGRADE:
			{
				OnMessageSpiritUpgradeRequest(pPlayer, pMessage);
			}
			break;
		case ID_C2S_REQUEST_SPIRIT_DOWNGRADE:
			{
				OnMessageSpiritDowngradeRequest(pPlayer, pMessage);
			}
			break;
		case ID_C2S_REQUEST_SPIRIT_INFO:
			{
				OnMessageSpiritInfoRequest(pPlayer, pMessage);
			}
			break;
		default:
			break;
	}

	return ;
}


// ***********************************************************
//  Function:		GetPropertyPercent
//  Description:	获取实体HP,MP百分比,当前AP及等级
//  Input:			unsigned int vEntityID
//  OutPut:			int& vHPPercent
//					int& vMPPercent
//					unsigned int& vCurAP
//					unsigned int& vLevel
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::GetPropertyPercent( CEntityCharacter* pEntity, int& vHPPercent, int& vMPPercent, int& vCurAP, int& vLevel )
{
	/*CPropertyPlayer* tpProperty = (CPropertyPlayer*) CProperty::SearchProByEntityID( vEntityID );
	  LK_ASSERT( tpProperty != NULL, return );*/
	LK_ASSERT( pEntity != NULL, return );
	CPropertyPlayer* tpProperty = (CPropertyPlayer*) pEntity->GetProperty();

	vHPPercent = (int)tpProperty->GetHPPercent();
	vMPPercent = (int)tpProperty->GetMPPercent();
	vCurAP = tpProperty->GetCurAP( );
	vLevel = tpProperty->GetLevel( );
	return;
}

// NPC普通攻击

// ***********************************************************
//  Function:		OnNpcNormalAttack
//  Description:	怪物普通攻击,跨模块使用
//  Input:			CEntityNpc* pSrcNpc
//					CEntity* pTarget
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::OnNpcNormalAttack( CEntityNpc* pSrcNpc, CEntityCharacter* pTarget )
{
	LK_ASSERT( pSrcNpc != NULL && pTarget != NULL, return );

	pSrcNpc->AddAttackCount();

	// 以后全部走技能流程,这里暂时保留接口,等策划配置
	CTemplateOgre* tpOgreTpl = (CTemplateOgre*) CDataStatic::SearchTpl( pSrcNpc->GetNpcID( ) );
	if ( tpOgreTpl == NULL )
	{
		return;
	}

	CTemplateSkill* tpSkillTpl = (CTemplateSkill*) CDataStatic::SearchSkill( tpOgreTpl->mSkillID, tpOgreTpl->mSkillLevel );
	if ( tpSkillTpl == NULL )
	{
		return;
	}

	// 调用UseSkill
	UseSkill( pSrcNpc, pTarget, tpOgreTpl->mSkillID, tpOgreTpl->mSkillLevel, pSrcNpc->GetAttListID( ), 0, NULL, 0 );
}

// ***********************************************************
//  Function:		OnNpcUseSkill
//  Description:	NPC使用技能,跨模块调用
//  Input:			CEntityNpc*		pSrcNpc			原实体
//					CEntity*		pTarget			目标实体
//					unsigned int	vSkillID		技能ID
//					unsigned int	vSkillLevel		技能等级
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::OnNpcUseSkill( CEntityNpc* pSrcNpc, CEntityCharacter* pTarget, unsigned int vSkillID, unsigned int vSkillLevel )
{
	LK_ASSERT( pSrcNpc != NULL && pTarget != NULL, return );

	pSrcNpc->AddAttackCount();

	bool bCanUse = false;
	PERF_FUNC( "UseSkill", bCanUse = UseSkill( pSrcNpc, pTarget, vSkillID, vSkillLevel, pSrcNpc->GetAttListID(), 0, NULL, 0 ) );
	
	//if( bCanUse == false && pSrcNpc->IsPet() )
	//{
	//	ChangePetTargetSingle( pSrcNpc->GetOwner(), NULL );
	//}
}

// ***********************************************************
//  Function:		GetItemString
//  Description:	得到道具信息字符流
//  Input:			unsigned int	tEntityID			实体ID
//					int				tBaggageIndex		背包格子索引
//					int				tItemNumber			物品数量
//  OutPut:			char*			tpItemBuffer		字符流指针		
//					int&			vLockType			锁定类型
//					int&			vBufferSize			流大少
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::GetItemString( unsigned int tEntityID, int tBaggageIndex, int tItemNumber, char* tpItemBuffer, int& vLockType, int& vBufferSize )
{
	vBufferSize = 0;
	CPropertyPlayer* tpSrcProperty	= ( CPropertyPlayer* )CProperty::SearchProByEntityID( tEntityID );
	if ( tpSrcProperty == NULL || tpSrcProperty->GetEntityType( ) != ENTITYTYPE_PLAYER )
		return ;
		
	if ( !( tpSrcProperty->GetBaggage()->CheckIndexValid( tBaggageIndex ) ) )
	{
		return;
	}
		
	//if ( tBaggageIndex < 0 || tBaggageIndex >= (int)tpSrcProperty->GetBaggage( )->mReleaseIndex )
	//	return ;

	CItemObject* tpItemObj	= tpSrcProperty->GetBaggage( )->GetItemObjPtr( tBaggageIndex );
	if ( tpItemObj == NULL )
		return;

	CEntityPlayer *tpPlayer = ( CEntityPlayer * )CSceneLogic::GetSingletonPtr()->GetEntity( tEntityID );
	// 如果处于手动绑定解除状态则检查绑定解除时间
	if ( IfItemBindFree( tpItemObj ) == 1 )
	{	
		CheckItemBindFreeTime( tpItemObj );	
	}

	if ( GetItemObjBindStatus( tpItemObj ) != ITEM_BINDSTATUS_FREE )
	{
		// 发送装备绑定不能交易的通知
		SendProErrorNotice( tpPlayer , ITEM_TRADE_BINDED );
		return;
	}

	// 道具是否被绑定
	if ( tpItemObj->GetLockStatus() != LOCKTYPE_NONE )
	{
		vLockType = LOCKTYPE_EXCHANGE; 
	}
	else
	{
		// 是否是任务道具
		CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpItemObj->GetItemID() );
		if ( tpTplItem == NULL )
			return ;

		if ( IS_TASK_ITEM( tpTplItem ) )
			vLockType = LOCKTYPE_TASK; 
	}	

	//vBufferSize = tpItemObj->GetItemStringBuffer( tpItemBuffer, tItemNumber );
}

int CPropertyModule::GetItemBinary(unsigned int tEntityID, int tBaggageIndex, int tItemNumber, PBItemObject *tpItemObject, int &vLockType, bool bIsCheck )
{
	CPropertyPlayer* tpSrcProperty	= ( CPropertyPlayer* )CProperty::SearchProByEntityID( tEntityID );
	if ( tpSrcProperty == NULL || tpSrcProperty->GetEntityType( ) != ENTITYTYPE_PLAYER )
		return LK_IERROR;
	
	if ( !tpSrcProperty->GetBaggage()->CheckIndexValid( tBaggageIndex ) )
	{
		return LK_IERROR;
	}
		
	//if ( tBaggageIndex < 0 || tBaggageIndex >= (int)tpSrcProperty->GetBaggage( )->mReleaseIndex )
	//	return LK_IERROR;

	CItemObject* tpItemObj	= tpSrcProperty->GetBaggage( )->GetItemObjPtr( tBaggageIndex );
	if ( tpItemObj == NULL )
	{
		return LK_IERROR;
	}

	CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	if ( tpTplItem == NULL )
		return LK_IERROR;

	if ( tItemNumber > (int)tpItemObj->GetItemNum() || tItemNumber > (int)tpTplItem->mPileLimit  )
	{
		return LK_IERROR;
	}

	if ( bIsCheck == true )
	{
		CEntityPlayer *tpPlayer = ( CEntityPlayer * )CSceneLogic::GetSingletonPtr()->GetEntity( tEntityID );
		// 如果处于手动绑定解除状态则检查绑定解除时间
		if ( IfItemBindFree( tpItemObj ) == 1 )
		{	
			CheckItemBindFreeTime( tpItemObj );	
		}

		if ( GetItemObjBindStatus( tpItemObj ) != ITEM_BINDSTATUS_FREE )
		{
			// 发送装备绑定不能交易的通知
			SendProErrorNotice( tpPlayer , ITEM_TRADE_BINDED );
			return LK_IERROR;
		}

		// 道具是否被绑定
		if ( tpItemObj->GetLockStatus() != LOCKTYPE_NONE )
		{
			vLockType = LOCKTYPE_EXCHANGE; 
			SendProErrorNotice( tpPlayer, ERROR_MOVEITEM_ITEMLOCKED );
			return LK_IERROR;
		}
		else
		{	
			// 是否是任务道具
			if ( IS_TASK_ITEM( tpTplItem ) )
			{
				vLockType = LOCKTYPE_TASK;
				SendProErrorNotice( tpPlayer, ERROR_CANTUSE );
				return LK_IERROR;
			} 
		}
	}		

	tpItemObj->GetItemBinaryBuffer2( tpItemObject, tItemNumber );
	return LK_ISUCCESS;
}

void CPropertyModule::SaveStallInfo(
		CEntityPlayer *pEntity,
		const char* pName,
		const char* pAd,
		int* pNumAry, 
		int* pPriceAry, 
		int* pItemIndexAry, 
		int* pStallIndexAry, 
		int* pPriceTypeAry,
		int vNumber,
		int vStallType)
{
	LK_ASSERT( pEntity != NULL, return );
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pEntity->GetProperty();

	LK_ASSERT( pName != NULL && pAd != NULL, return );
	tpProperty->SaveStallText( pName, pAd ,vStallType);
	tpProperty->GetStallInfo( vStallType )->SetFlag( true );

	for ( int i = 0; i < vNumber; ++ i )
	{
		CItemObject* tpObj = tpProperty->GetBaggage( )->GetItemObjPtr( pItemIndexAry[ i ] );
		LK_ASSERT( tpObj  != NULL, return );

		CStallInfo* tpStall = tpProperty->GetStallInfo( vStallType );
		tpStall->PushObj( tpObj->get_id(), pStallIndexAry[ i ] , pNumAry[ i ], pPriceAry[ i ], pPriceTypeAry[i] );
	}	
	return ;
}

//***************************************
// Function Name : GetStallInfo
// Description 	 : 获得上线摆摊的摆摊记录，并且自动放入摊位
// Input Params  :
// Output Params :
// Return Type   :
// Modified Time : 2/19/2009
//***************************************

int CPropertyModule::GetStallInfo(CEntityPlayer* pPlayer, const int vStallType, char* pName, char* pAd, int* pItemIndexAry, int* pStallIndexAry, int* pPriceAry, int* pPriceTypeAry )
{
	LK_ASSERT( pPlayer != NULL && pName != NULL && pAd != NULL, return LK_IERROR );
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	CStallInfo* tpStall = tpProperty->GetStallInfo(vStallType);
	if ( tpStall->IsSaved() == false )
	{
		return LK_IERROR;
	}

	strcpy( pName, tpStall->GetName() );
	strcpy( pAd, tpStall->GetAd() );
	tpStall->SetFlag( false );

	int tIndex = 0, tNum = 0;
	bool bFlag = false;

	int tBaggageIndex = tpProperty->GetBaggage()->GetReleaseIndex() + tpProperty->GetBaggage()->GetKitBagIndex() * MAXKITBAGINDEXNUM;

	CStallInfo::StallList::iterator itBegin = tpStall->mStall.begin();
	CStallInfo::StallList::iterator	itEnd = tpStall->mStall.end();
	for ( ; itBegin != itEnd; ++ itBegin )
	{
		tIndex = 0;
		bFlag = false;
		for ( int i = 0; i < tBaggageIndex; ++ i )
		{
			CItemObject* tpObj = tpProperty->GetBaggage( )->GetItemObjPtr( i );
			if ( tpObj == NULL )
			{
				continue;
			}
			if ( tpObj->get_id() == (int)((*itBegin).obj_id) )
			{
				tIndex = i;
				bFlag = true;
				break;
			}
		}
		if ( tIndex < tBaggageIndex && bFlag == true )
		{
			pItemIndexAry[ tNum ] = tIndex;
			pStallIndexAry[ tNum ] = (*itBegin).Index;
			pPriceAry[ tNum ] = (*itBegin).Price;
			pPriceTypeAry[tNum] = (*itBegin).PriceType;
			tNum ++;
		}
	}
	tpStall->CleanStall();
	return tNum;
}

void CPropertyModule::OnEventSaveStallRecord( CEntityPlayer* vpPlayer, CStallRecord* vpRecord, const int vStallType )
{
	if ( vpPlayer == NULL || vpRecord == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();

	CStallInfo* tpStallInfo = tpProperty->GetStallInfo(vStallType);
	if ( tpStallInfo == NULL )
	{
		return ;
	}

	tpStallInfo->PushRecord( vpRecord );
	return ;
}

void CPropertyModule::OnEventGetStallRecord(CEntityPlayer *vpPlayer, CMessageStallGetRecordResponse *vpMessage, const int vStallType)
{
	if ( vpPlayer == NULL || vpMessage == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();

	CStallInfo* tpInfo = tpProperty->GetStallInfo(vStallType);
	if ( tpInfo == NULL )
	{
		return ;
	}

	vpMessage->set_entityid( vpPlayer->GetEntityID() );

	CStallInfo::RecordList::iterator it = tpInfo->mRecordList.begin();
	for ( ; it != tpInfo->mRecordList.end(); ++ it )
	{
		PBStallRecord* tpPBRecord = vpMessage->add_record();
		tpPBRecord->set_mastername( vpPlayer->GetCharName() );
		tpPBRecord->set_buyername( it->mBuyerName.c_str() );
		tpPBRecord->set_itemid( it->mItemID );
		tpPBRecord->set_number( it->mNumber );
		tpPBRecord->set_price( it->mPrice );
		tpPBRecord->set_time( it->mTimeStamp );
		tpPBRecord->set_action( it->mAction );
		tpPBRecord->set_tax( it->mTax );
		tpPBRecord->set_pricetype( it->mPriceType);
		tpPBRecord->set_fee(it->mFee);
	}
	
	return ;
}


// ***********************************************************
//  Function:		ResetFirstEntity
//  Description:	重置第一刀,跨模块调用
//  Input:			unsigned int vEntityID 实体ID
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::ResetFirstEntity( unsigned int vEntityID )
{
	CPropertyCharacter*	tpProperty	= ( CPropertyCharacter* )CProperty::SearchProByEntityID( vEntityID );
	if ( tpProperty == NULL )
		return;

	tpProperty->SetFirstEntityID( 0 );
}


// ***********************************************************
//  Function:		LockBaggage
//  Description:	锁定包裹,跨模块调用
//  Input:			unsigned int	vEntityID			实体ID
//					int				vBaggageIndex		包裹索引
//					int				vLockType			锁定类型
//  OutPut:			bool&			tIsOK				是否成功
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::LockBaggage( unsigned int vEntityID, int vBaggageIndex, int vLockType, bool& tIsOK )
{
	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )CProperty::SearchProByEntityID( vEntityID );
	if ( tpSrcProperty == NULL || tpSrcProperty->GetEntityType() != ENTITYTYPE_PLAYER )
		return;

	if ( tpSrcProperty->GetBaggage( )->Lock( vBaggageIndex, vLockType ) == true )
	{
		tIsOK = true;
		SendLockItemNotice( vEntityID, vBaggageIndex, vLockType );
	}
	else
	{
		tIsOK = false;
	}
}
//
//
//// ***********************************************************
////  Function:		OnEntityTrap
////  Description:	实体触发陷阱
////  Input:			CEntity*		tpDesEntity		触发实体
////					unsigned int	tSrcEntityID	陷阱实体ID
////					unsigned int	tSkillID		陷阱技能ID
////					unsigned int	tSkillLevel		陷阱技能等级
////					int				tEntityNumber	作用实体个数
////					CEntity**		tpEntityList	作用实体列表
////  OutPut:			bool&			tIsOK			是否成功触发
////  Return:			void
////  Others:
////  Date:	11/18/2008
//// **********************************************************
//void CPropertyModule::OnEntityTrap( CEntityCharacter* tpDesEntity, unsigned int tSrcEntityID, unsigned int tSkillID, unsigned int tSkillLevel, int tEntityNumber, CEntityCharacter** tpEntityList, bool& tIsOK )
//{
//	tIsOK = false;
//
//	CEntity* tpSrcEntity = CSceneLogic::GetSingleton( ).GetEntity( tSrcEntityID );
//	if ( tpSrcEntity == NULL || tpDesEntity == NULL )
//		return;
//
//	if ( tpSrcEntity->IsAlive( ) == false || tpDesEntity->IsAlive( ) == false )
//		return;
//
//	if ( tpSrcEntity == tpDesEntity )
//		return;
//	if( tpSrcEntity->IsCharacter() == false )
//	{
//		return;	
//	}
//	CEntityCharacter* tpSrcEntityCharacter = ( CEntityCharacter* )tpSrcEntity;
//
//	CPropertyCharacter* tpDesProperty = ( CPropertyCharacter* )tpDesEntity->GetProperty();
//
//	tpSrcEntity->InitFunResult( );
//	CTemplateTrapSkill* tpTrapTpl = (CTemplateTrapSkill*) CDataStatic::SearchSkill( tSkillID, tSkillLevel );
//	// 判断是否可以被触发
//	if ( EntityPKValid( tpSrcEntityCharacter, tpDesEntity, tpTrapTpl ) == false )
//		return;
//
//	if ( tpTrapTpl != NULL )
//	{
//		// 如果是单体作用的技能
//		tpTrapTpl->mApplyType = CTemplateTrapSkill::APPLYTYPE_SINGLE;
//		if ( tpTrapTpl->mApplyType == CTemplateTrapSkill::APPLYTYPE_SINGLE )
//			EntityBuffSkill( tpSrcEntityCharacter, tpDesEntity, tpTrapTpl->mBuffGroupID, ARRAY_CNT(tpTrapTpl->mBuffGroupID),  0 );
//
//		// 如果是范围作用的技能
//		if ( tpTrapTpl->mApplyType == CTemplateTrapSkill::APPLYTYPE_RANGE )
//		{
//			for ( int i = 0; i < tEntityNumber; i ++ )
//			{
//				LK_ASSERT( tpDesProperty != NULL, continue );
//				// 判断技能PK模式是否满足
//				if ( EntityPKValid( tpSrcEntity, tpDesEntity, tpTrapTpl ) == false )
//				{
//					continue;
//				}
//
//				EntityBuffSkill( tpSrcEntityCharacter, tpEntityList[ i ], tpTrapTpl->mBuffGroupID, ARRAY_CNT(tpTrapTpl->mBuffGroupID), 0 );
//			}
//		}
//
//		// 得到技能关联实体
//		tIsOK = true;
//
//		ResultListSend( );
//
//	}
//}

// ***********************************************************
//  Function:		GetBaggageRelease
//  Description:	得到指定玩家的包裹格子数目,跨模块调用
//  Input:			CEntity* tpSrcEntity 指定玩家实体
//  OutPut:			
//  Return:			unsigned int 包裹格子数目
//  Others:
//  Date:	11/18/2008
// **********************************************************
unsigned int CPropertyModule::GetBaggageRelease( CEntity* tpSrcEntity )
{
	if ( tpSrcEntity == NULL || tpSrcEntity->GetEntityType() != ENTITYTYPE_PLAYER)
		return 0;

	//	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )CProperty::SearchProByProID( tpSrcEntity->mPropertyID );
	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )tpSrcEntity->GetProperty();
	if ( tpSrcProperty == NULL )
		return 0;

	return tpSrcProperty->GetBaggage( )->mReleaseIndex;
}

// ***********************************************************
//  Function:		GetPlayerMoney
//  Description:	获得玩家金钱,跨模块调用
//  Input:			unsigned int vEntityID 玩家实体ID
//  OutPut:			
//  Return:			int 失败返回-1,成功返回金钱数
//  Others:
//  Date:	11/18/2008
// **********************************************************
unsigned int CPropertyModule::GetPlayerMoney( unsigned int vEntityID )
{
	CProperty* tpProperty = CProperty::SearchProByEntityID( vEntityID );

	// 失败情况下返回0，都比-1好
	if ( tpProperty == NULL && tpProperty->GetEntityType( ) != ENTITYTYPE_PLAYER )
		return 0;

	int tMoney = ( ( CPropertyPlayer* )tpProperty )->GetMoney( );
	return tMoney;
}

// ***********************************************************
//  Function:		SetPlayerMoney
//  Description:	修改玩家金钱,跨模块调用
//  Input:			unsigned int	vEntityID	玩家实体ID
//					int				vMoney		改变金钱数
//  OutPut:			
//  Return:			int		失败返回-1,成功返回0
//  Others:
//  Date:	11/18/2008
// **********************************************************
int CPropertyModule::SetPlayerMoney( unsigned int vEntityID, int vMoney )
{
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* )CProperty::SearchProByEntityID( vEntityID );
	if ( tpProperty == NULL && tpProperty->GetEntityType( ) != ENTITYTYPE_PLAYER )
		return -1;

	int nRet = -1;

	CSceneLogic* tpLogic = CSceneLogic::GetSingletonPtr( );
	if( vMoney > 0 )
	{
		nRet = PlayerChangeMoney( (CEntityPlayer*)tpLogic->GetEntity( vEntityID ), vMoney, false, false );
	}
	else
	{
		nRet = PlayerChangeMoney( (CEntityPlayer*)tpLogic->GetEntity( vEntityID ), abs(vMoney), true, false );
	}

	return nRet == SUCCESS ? 0 : -1;
}

// ***********************************************************
//  Function:		CheckChange
//  Description:	交易检查,跨模块调用
//  Input:			CEntity*	tpSrcEntity		原实体
//					CEntity*	tpDesEntity		目标实体
//					int			tSrcNumber		原交易数量
//					int			tDesNumber		目标交易数量
//					int			tSrcMoney		原金钱交易数量
//					int			tDesMoney		目标金钱交O易数量
//  OutPut:			
//  Return:			int		错误码
//  Date:	11/18/2008
// **********************************************************
int CPropertyModule::CheckChange( CEntityPlayer* tpSrcEntity, CEntityPlayer* tpDesEntity, int tSrcNumber, int tDesNumber, int tSrcMoney, int tDesMoney )
{
	if ( tpSrcEntity == NULL || tpSrcEntity->GetEntityType() != ENTITYTYPE_PLAYER )
		return EXCHAGE_SRCISNOTPLAYER;

	if ( tpDesEntity == NULL || tpDesEntity->GetEntityType() != ENTITYTYPE_PLAYER )
		return EXCHAGE_DESISNOTPLAYER;

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )tpSrcEntity->GetProperty();
	CPropertyPlayer* tpDesProperty = ( CPropertyPlayer* )tpDesEntity->GetProperty();
	if ( tpSrcProperty == NULL )
		return EXCHAGE_SRCISNOTPLAYER;

	if ( tpDesProperty == NULL )
		return EXCHAGE_SRCISNOTPLAYER;

	// 创建临时的检查空间
	unsigned int tSrcIndex, tDesIndex;
	int tSrcBagMoney, tDesBagMoney;
	tSrcIndex = tpSrcProperty->GetBaggage( )->mReleaseIndex;
	tDesIndex = tpDesProperty->GetBaggage( )->mReleaseIndex;
	tSrcBagMoney = tpSrcProperty->GetMoney( );
	tDesBagMoney = tpDesProperty->GetMoney( );
	unsigned int tSrcEmpty = 0, tDesEmpty = 0;
	
	CItemBoxToolkit tSrcBoxToolTip( tpSrcProperty->GetBaggage( ) );
	CItemBoxToolkit tDesBoxToolTip( tpDesProperty->GetBaggage( ) );
	
	tSrcEmpty = tSrcBoxToolTip.GetLeftPileNum( -1 );
	tDesEmpty = tDesBoxToolTip.GetLeftPileNum( -1 );
	
	LOG_NOTICE( "trade", "[ %s : %d ] [ %s ] Player %s SrcBag empty count = %d, Item count = %d, ReleaseIndex = %d", 
		__LK_FILE__, __LINE__, __FUNCTION__, tpSrcEntity->GetCharNameShow(), tSrcEmpty, tSrcNumber, tSrcIndex );
	LOG_NOTICE( "trade", "[ %s : %d ] [ %s ] Player %s DesBag empty count = %d, Item count = %d, ReleaseIndex = %d", 
		__LK_FILE__, __LINE__, __FUNCTION__, tpDesEntity->GetCharNameShow(), tDesEmpty, tDesNumber, tDesIndex );

	// 源包裹空间不够
	// 剩余包裹空间的计算要减去交易的物品数
	if ( (int)( tSrcEmpty + tSrcNumber ) < tDesNumber )
		return EXCHAGE_SRCOUTOFSPACE;

	// 目标包裹空间不够
	// 剩余包裹空间的计算要减去交易的物品数
	if ( (int)( tDesEmpty + tDesNumber ) < tSrcNumber )
		return EXCHAGE_DESOUTOFSPACE;	

	// 目标包裹金币空间溢出
	// 计算金钱时，对交易的金钱数也要计算在内

	int tDeltaMoney = tSrcMoney - tDesMoney;

	// 金币溢出  
	// 最新：增加对携带上限的判断
	CTemplateLevelMoneyLmt* tpMoneyTable = (CTemplateLevelMoneyLmt*)CDataStatic::GetTemp(TEMP_MONEYLMT_CFG);
	LK_ASSERT( tpMoneyTable!=NULL, return EXCHAGE_DESMONEYOVERFLOW );
	LK_ASSERT( tpDesEntity->GetLevel() >= 0 && tpDesEntity->GetLevel() < TMP_MAX_GRADE, return EXCHAGE_DESMONEYOVERFLOW );
	LK_ASSERT( tpSrcEntity->GetLevel() >= 0 && tpSrcEntity->GetLevel() < TMP_MAX_GRADE, return EXCHAGE_DESMONEYOVERFLOW );

	if ( tDesBagMoney + tDeltaMoney > MONEY_LIMIT
		||  (unsigned int)(tDesBagMoney + tDeltaMoney) > tpMoneyTable->mLmtTable[tpDesEntity->GetLevel()].mBagMoneyLmt )
	{
		return EXCHAGE_DESMONEYOVERFLOW;
	}
	// 如果tDeltaMoney是正的 则是我付出 走上面的验证 如果是负的 等于给我 要用我的钱减去！负负得正
	// 检查我的会不会溢出 溢出的话 不行！
	if (  tSrcBagMoney - tDeltaMoney > MONEY_LIMIT
		|| tSrcBagMoney - tDeltaMoney > (int)(tpMoneyTable->mLmtTable[tpSrcEntity->GetLevel()].mBagMoneyLmt ) )
	{
		return EXCHAGE_MYMONEYOVERFLOW;
	}

	// 金币不够
	if ( tSrcBagMoney - tDeltaMoney < 0
		|| tDesBagMoney + tDeltaMoney < 0 )
	{
		return EXCHAGE_SRCMONEYNOTENOUGH;
	}			

	return EXCHAGE_SUCCESS;
}

// ***********************************************************
//  Function:		ExchangeBaggage
//  Description:	玩家间交易,跨模块调用
//  Input:			CEntity*	tpSrcEntity		交易原实体
//					CEntity*	tpDesEntity		交易目标实体
//					int			tSrcNumber		原交易数量
//					short*		tpSrcItemList	原交易物列表
//					int			tDesNumber		目标交易数量
//					short*		tpDesItemList	目标交易物列表
//					int			tSrcMoney		原交易金币
//					int			tDesMoney		目标交易金币
//  OutPut:			
//  Return:			int		错误码
//  Others:
//  Date:	11/18/2008
// **********************************************************
int CPropertyModule::ExchangeBaggage( CEntityPlayer* tpSrcEntity, CEntityPlayer* tpDesEntity, int tSrcNumber, short* tpSrcItemList, int tDesNumber, short* tpDesItemList, int tSrcMoney, int tDesMoney, EExchangeFlag emExchange)
{
	if ( tpSrcEntity == NULL || tpSrcEntity->GetEntityType() != ENTITYTYPE_PLAYER || tpSrcEntity->GetCommState() != CEntityPlayer::STATE_INMAP )
		return EXCHAGE_SRCISNOTPLAYER;

	if ( tpDesEntity == NULL || tpDesEntity->GetEntityType() != ENTITYTYPE_PLAYER || tpDesEntity->GetCommState() != CEntityPlayer::STATE_INMAP )
		return EXCHAGE_DESISNOTPLAYER;

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) tpSrcEntity->GetProperty();
	CPropertyPlayer* tpDesProperty = ( CPropertyPlayer* ) tpDesEntity->GetProperty();
	if ( tpSrcProperty == NULL )
		return EXCHAGE_SRCISNOTPLAYER;

	if ( tpDesProperty == NULL )
		return EXCHAGE_SRCISNOTPLAYER;

	// 先把双方的道具“腾”出来
	int tSrcItemID[ 64 ]		 = { 0 };
	int tSrcItemNumber[ 64 ]	 = { 0 };
	uint64_t ullSrcItemGUID[64]  = { 0 };

	CItemObject* tpSrcItem[ 64 ] = { NULL };
	CItemBox tSrcOldBaggage;
	memcpy( &tSrcOldBaggage, tpSrcProperty->GetBaggage( ), sizeof( tSrcOldBaggage ) );
	for ( int i = 0; i < tSrcNumber; i ++ )
	{
		tpSrcItem[ i ] = tpSrcProperty->GetBaggage( )->EraseItem( tpSrcItemList[ i * 2 ], tpSrcItemList[ i * 2 + 1 ] );
		if ( tpSrcItem[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] can't find item, ID=%d, NUMBER=%d", __LK_FILE__, __LINE__, __FUNCTION__, tpSrcItemList[ i * 2 ], tpSrcItemList[ i * 2 + 1 ] );
			break;
		}
		tSrcItemID[ i ]		= tpSrcItem[ i ]->GetItemID();
		tSrcItemNumber[ i ] = tpSrcItemList[ i * 2 + 1 ];
		ullSrcItemGUID[ i ] = tpSrcItem[ i ]->GetGUID();

		SendRemoveItemNotice( tpSrcEntity, POS_BAGGAGE, tpSrcItemList[ i * 2 ], tSrcItemNumber[ i ] );
		// 处理道具失去后，任务状态变化
		OnTaskRemoveItem( (CEntityPlayer*) tpSrcEntity, tSrcItemID[ i ], tSrcItemNumber[ i ] );

		// 记录丢物品日志
		if ( emExchange == em_exchange_by_trade)
		{
			LogEventLostItemByExchange( (CEntityPlayer*) tpSrcEntity, ullSrcItemGUID[i], 
					tSrcItemID[i], tSrcItemNumber[i], ((CEntityPlayer*) tpDesEntity)->GetCharID()); 
		}
	}

	int tDesItemID[ 64 ]		 = { 0 };
	int tDesItemNumber[ 64 ]	 = { 0 };
	uint64_t  ullDesItemGUID[ 64 ] = { 0 };

	CItemObject* tpDesItem[ 64 ] = { NULL };
	CItemBox tDesOldBaggage;
	memcpy( &tDesOldBaggage, tpDesProperty->GetBaggage( ), sizeof( tDesOldBaggage ) );
	for ( int i = 0; i < tDesNumber; i ++ )
	{
		tpDesItem[ i ] = tpDesProperty->GetBaggage( )->EraseItem( tpDesItemList[ i * 2 ], tpDesItemList[ i * 2 + 1 ] );
		if ( tpDesItem[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] can't find item, ID=%d, NUMBER=%d", __LK_FILE__, __LINE__, __FUNCTION__, tpDesItemList[ i * 2 ], tpDesItemList[ i * 2 + 1 ] );
			break;
		}
		tDesItemID[ i ]		= tpDesItem[ i ]->GetItemID();
		tDesItemNumber[ i ] = tpDesItemList[ i * 2 + 1 ];
		ullDesItemGUID[ i ] = tpDesItem[ i ]->GetGUID();

		SendRemoveItemNotice( tpDesEntity, POS_BAGGAGE, tpDesItemList[ i * 2 ], tDesItemNumber[ i ] );
		// 处理道具失去后，任务状态变化
		OnTaskRemoveItem( (CEntityPlayer*) tpDesEntity, tDesItemID[ i ], tDesItemNumber[ i ] );

		// 记录丢物品日志
		if ( emExchange == em_exchange_by_trade)
		{
			LogEventLostItemByExchange( (CEntityPlayer*) tpDesEntity, ullDesItemGUID[i], 
					tDesItemID[i], tDesItemNumber[i], ((CEntityPlayer*) tpSrcEntity)->GetCharID());
		}else if(emExchange == em_exchange_by_stall)
		{
			LogEventLostItemByStallSell( (CEntityPlayer*) tpDesEntity, 
					ullDesItemGUID[i], tDesItemID[i], tDesItemNumber[i],
					((CEntityPlayer*) tpSrcEntity)->GetCharID(), CYuanBao::em_unbind_money,  tSrcMoney);
		}
		else if(emExchange == em_exchange_by_stall_yb)//增加元宝摆摊处理
		{
			LogEventLostItemByStallSell( (CEntityPlayer*) tpDesEntity, 
				ullDesItemGUID[i], tDesItemID[i], tDesItemNumber[i],
				((CEntityPlayer*) tpSrcEntity)->GetCharID(), CYuanBao::em_golden_yuanbao,  tSrcMoney);

		}
	}	


	for ( int i = 0; i < tSrcNumber; i ++ )
	{
		CItemObject * pInsItemPile = PlayerInsertItem( (CEntityPlayer*) tpDesEntity, tpSrcItem[ i ]);
		if ( pInsItemPile != NULL)
		{
			if ( emExchange == em_exchange_by_trade)
			{
				LogEventGetItemByExchange( (CEntityPlayer*) tpDesEntity, ullSrcItemGUID[i], 
						tSrcItemID[i], tSrcItemNumber[i], ((CEntityPlayer*) tpSrcEntity)->GetCharID()); 
			}
		}
	}

	for ( int i = 0; i < tDesNumber; i ++ )
	{
		CItemObject * pInsItemPile = PlayerInsertItem( (CEntityPlayer*) tpSrcEntity, tpDesItem[ i ]);
		if ( pInsItemPile != NULL)
		{
			if ( emExchange == em_exchange_by_trade)
			{
				LogEventGetItemByExchange( (CEntityPlayer*) tpSrcEntity, ullDesItemGUID[i], 
						tDesItemID[i], tDesItemNumber[i], ((CEntityPlayer*) tpDesEntity)->GetCharID());
			}else if( emExchange == em_exchange_by_stall)
			{
				LogEventGetItemByStallBuy((CEntityPlayer*) tpSrcEntity, 
					ullDesItemGUID[i], tDesItemID[i], tDesItemNumber[i],
					((CEntityPlayer*) tpDesEntity)->GetCharID(), CYuanBao::em_unbind_money, tSrcMoney);
			}
			else if( emExchange == em_exchange_by_stall_yb)
			{
				LogEventGetItemByStallBuy((CEntityPlayer*) tpSrcEntity, 
					ullDesItemGUID[i], tDesItemID[i], tDesItemNumber[i],
					((CEntityPlayer*) tpDesEntity)->GetCharID(), CYuanBao::em_golden_yuanbao, tSrcMoney);

			}
		}
	}

	// 交易金钱 结算
	int tDeltaMoney = 0, tAbsMoney = 0;
	bool tPayout = true;
	if (emExchange != em_exchange_by_stall_yb)
	{
		tDeltaMoney = tSrcMoney - tDesMoney;
		tAbsMoney = tDeltaMoney;
		if ( tDeltaMoney < 0 )
		{
			tAbsMoney = ( -1 * tDeltaMoney );
			tPayout = false;
		}

	}
	

	if ( tAbsMoney > 0 )
	{
		//int tAbsMoney = ( -1 * tDeltaMoney );
		// tPayout = false 源方收益金钱
		if (PlayerChangeMoney( (CEntityPlayer*) tpSrcEntity, tAbsMoney, tPayout, false ) == SUCCESS)
		{
			if ( emExchange == em_exchange_by_trade)
			{
				if(tPayout)
				{
					LogEventLostMoneyByExchange((CEntityPlayer*) tpSrcEntity, 
						CYuanBao::em_unbind_money, tAbsMoney, ((CEntityPlayer*) tpDesEntity)->GetCharID());
				}
				else
				{
					LogEventGetMoneyByExchange((CEntityPlayer*) tpSrcEntity, 
						CYuanBao::em_unbind_money, tAbsMoney, ((CEntityPlayer*) tpDesEntity)->GetCharID());
				}
				
			}else if( emExchange == em_exchange_by_stall)
			{
				if (tPayout)
				{
					LogEventLostMoneyByStall((CEntityPlayer*) tpSrcEntity, CYuanBao::em_unbind_money, tAbsMoney, 
						((CEntityPlayer*) tpDesEntity)->GetCharID(), tDesItemID[0], ullDesItemGUID[0]);
				}
				else
				{
					LogEventGetMoneyByStall((CEntityPlayer*) tpSrcEntity, CYuanBao::em_unbind_money, tAbsMoney, 
						((CEntityPlayer*) tpDesEntity)->GetCharID(), tDesItemID[0], ullDesItemGUID[0]);
				}
				
			}

		}

		// tPayout = false 对方亏损金钱
		if (PlayerChangeMoney( (CEntityPlayer*) tpDesEntity, tAbsMoney, !tPayout, false ) == SUCCESS)
		{
			if ( emExchange == em_exchange_by_trade )
			{
				if (tPayout)
				{
					LogEventGetMoneyByExchange((CEntityPlayer*) tpDesEntity, 
						CYuanBao::em_unbind_money, tAbsMoney, ((CEntityPlayer*) tpSrcEntity)->GetCharID());
				}
				else
				{
					LogEventLostMoneyByExchange((CEntityPlayer*) tpDesEntity, 
						CYuanBao::em_unbind_money, tAbsMoney, ((CEntityPlayer*) tpSrcEntity)->GetCharID());
				}
				
			}else if( emExchange == em_exchange_by_stall)
			{
				if (tPayout)
				{
					LogEventGetMoneyByStall((CEntityPlayer*) tpDesEntity, CYuanBao::em_unbind_money, tAbsMoney, 
						((CEntityPlayer*) tpSrcEntity)->GetCharID(), tDesItemID[0], ullDesItemGUID[0]);
				}
				else
				{
					LogEventLostMoneyByStall((CEntityPlayer*) tpDesEntity, CYuanBao::em_unbind_money, tAbsMoney, 
						((CEntityPlayer*) tpSrcEntity)->GetCharID(), tDesItemID[0], ullDesItemGUID[0]);
				}
				
			}

		}
	}
	//else
	//{
	//	// 源方亏损金钱
	//	if (PlayerChangeMoney( (CEntityPlayer*) tpSrcEntity, tDeltaMoney, true, false ) == SUCCESS)
	//	{
	//		if ( emExchange == em_exchange_by_trade)
	//		{
	//			LogEventLostMoneyByExchange((CEntityPlayer*) tpSrcEntity, 
	//				CYuanBao::em_unbind_money, tDeltaMoney, ((CEntityPlayer*) tpDesEntity)->GetCharID());
	//		}else
	//		{
	//			LogEventLostMoneyByStall((CEntityPlayer*) tpSrcEntity, CYuanBao::em_unbind_money, tDeltaMoney, 
	//				((CEntityPlayer*) tpDesEntity)->GetCharID(), tDesItemID[0], ullDesItemGUID[0]);
	//		}
	//	}

	//	// 对方收益金钱
	//	if (PlayerChangeMoney( (CEntityPlayer*) tpDesEntity, tDeltaMoney, false, false ) == SUCCESS)
	//	{
	//		if ( emExchange == em_exchange_by_trade )
	//		{
	//			LogEventGetMoneyByExchange((CEntityPlayer*) tpDesEntity, 
	//				CYuanBao::em_unbind_money, tDeltaMoney, ((CEntityPlayer*) tpSrcEntity)->GetCharID());
	//		}else
	//		{
	//			LogEventGetMoneyByStall((CEntityPlayer*) tpDesEntity, CYuanBao::em_unbind_money, tDeltaMoney, 
	//				((CEntityPlayer*) tpSrcEntity)->GetCharID(), tDesItemID[0], ullDesItemGUID[0]);
	//		}
	//	}
	//}
	//交易元宝

	return EXCHAGE_SUCCESS;
}


// ***********************************************************
//  Function:		RecoverPer
//  Description:	按百分比回复,跨模块
//  Input:			CEntity*	tpDesEntity		实体
//					int			tPer			百分比
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::RecoverPer( CEntity* tpDesEntity, int tPer )
{
	// 回复的对象
	LK_ASSERT( tpDesEntity != NULL, return );

	if( !tpDesEntity->IsPlayer() && !tpDesEntity->IsPet() && !tpDesEntity->IsOgre() && !tpDesEntity->IsFunNpc() )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) be cur is type Err, type is %d", __LK_FILE__, __LINE__,
				__FUNCTION__, tpDesEntity->GetEntityID( ), tpDesEntity->GetEntityType() );
		return;
	}
	// 回复的百分比

	CPropertyCharacter* tpProperty = ( CPropertyCharacter* )tpDesEntity->GetProperty();
	if ( tpProperty == NULL )
		return;

	unsigned int tOldHP = tpProperty->GetCurHP( );
	unsigned int tOldMP = tpProperty->GetCurMP( );

	((CEntityCharacter*)tpDesEntity)->CureHP( (unsigned int)tpProperty->GetMaxHP( )/100.0*tPer + 1, tpDesEntity->GetEntityID(), RESULT_NORMALREFRESH, false );
	((CEntityCharacter*)tpDesEntity)->CureMP( (unsigned int)tpProperty->GetMaxMP( )/100.0*tPer + 1, tpDesEntity->GetEntityID(), RESULT_NORMALREFRESH, false );
	
	if ( tpProperty->GetCurHP( ) != tOldHP || tpProperty->GetCurMP( ) != tOldMP )
	{
		CMessage tEntityRefresh;
		CMessageEntityRefreshNotice tMessage;
		bool vBool = false;
		vBool = CreateMessageEntityRefreshNotice(
				&tEntityRefresh,
				&tMessage,
				tpDesEntity->GetEntityID( ),
				tpProperty->GetCurHP( ),
				tpProperty->GetCurMP( ),
				tpProperty->GetMaxHP( ),
				tpProperty->GetMaxMP( )
				);
		if ( vBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( tpDesEntity, &tEntityRefresh );
		}
	}	
}

CBuffList* CPropertyModule::GetBuffInfo( unsigned int vEntityID )
{
	// Property 对象
	CPropertyCharacter* tpProperty = ( CPropertyCharacter* )CProperty::SearchProByEntityID( vEntityID );
	if ( tpProperty == NULL )
	{
		return NULL;
	}

	return tpProperty->GetBuffList( );
}

// 建立实体
void CPropertyModule::OnCreateEntity( CEntity* pEntity, CCreator* pCreator, bool vFirst )
{

	if ( pEntity->IsPlayer() )
	{
	
		CEntityPlayer* tpPlayer = (CEntityPlayer*) pEntity;

		CPropertyPlayer* tpProperty = ( CPropertyPlayer* )tpPlayer->GetProperty();
		LK_ASSERT( tpProperty != NULL, return );	

		tpProperty->Refresh( );

		tpProperty->StartSavedTimer();

		tpProperty->CheckDiploidState();

		// 处理每周事务
		WeeklyDispose( tpPlayer, false );

		// 处理每日事务
		DaylyDispose( tpPlayer, false );	

		// VIP 
		RefreshVip( tpPlayer );

		// 发送双倍活动通知( 只有开启时才发 )
		int tBeginTime = 0;
		int tEndTime = 0;
		int nRate = CActivityModule::GetSingletonPtr()->GetDoubleState( tBeginTime, tEndTime );
		if( nRate > 0 )
		{
			FireActivityDiploid( tpPlayer, nRate, false, tBeginTime, tEndTime );
		}
		else
		{
			//TODO:  检查身上的活动双是否存在，有bug的话会存盘，这里要清除
			if( tpProperty->IsActivityDouble( ) == true )
				tpProperty->SetActivityState( 0 );
		}


		// 处理双倍时间
		// 每周刷新双倍的时候，你不在线，现在强制给你刷一次
		if ( tpProperty->UnFreezeDouble() )
		{
			// 时间没有冻结
			time_t tNow = time( NULL );
			int tLastLeaveTime = ( tpProperty->GetLastStopTime() > 0 ? tpProperty->GetLastStopTime() : tNow );
			int tDisTime = (int)tNow - tLastLeaveTime; // 单位为秒
			int tValidTime = std::max( 0, ( tpProperty->GetValidDiploid() - tDisTime*1000 ) );  // 单位为毫秒
			if ( tValidTime > LK_ZERO )
			{
				// 双倍时间还有
				tValidTime = std::min( tValidTime, DIPLOID_LIMIT );
				tpProperty->SetValidDiploid( tValidTime );

				// 如果有系统双倍，这里跳过
				if( tpProperty->GetDiploidState( ACTIVITY_STATE ) != LK_ZERO )
				{
					; // do sth
				}
				else
				{
					int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, 0, 0, 0 };
					int tTimerID = tpPlayer->GetTimerReciver()->SetTimer( tpPlayer->get_id(), TIMER_DIPLOID_TIME, tValidTime, 1, nTimerOtherInfo );
					tpProperty->SetDoubleTimerID( tTimerID );
				}

				tpProperty->SetValidDiploid( tValidTime );
			}
			else
			{
				// 双倍时间已经消耗完
				// 最后一个状态是特殊处理，不需要重置...TODO
				tpProperty->InitDoubleState();			
			}
		}

		// focus refresh diploid time while you lose the key time for refreshing
		RefreshDiploid( tpPlayer, false );

		if ( vFirst == true )
		{
			// 初次创建要删除无用道具
			tpProperty->DeleteItem( );
		}

		// 检查身上有没有不该有的东西
		PERF_FUNC( "CheckBagContent", CheckBagContent( tpPlayer ) );
		
		// 计算离线时间
		tpProperty->GetExpTimeInfo()->ExchangeEffectiveOffLineTime( 0 );
		tpProperty->GetExpTimeInfo()->GetExpFromOffLine( tpPlayer->GetLevel() );

		// 如果是齐天大战，修改PK模式
		if ( IS_BATTLE_LINE_ID( CSceneLogic::GetSingleton().GetLineID() ) == true )
		{
			tpPlayer->SetPKMode( PKMODE_ALLY );
		}

		// 发送玩家属性数据
		SendYourProDataNotice( tpPlayer );

		// 刷新要放在yourprodata之后，否则有问题。
		RefreshPlayerProperty(tpPlayer);
		//((CEntityPlayer*)pEntity)->NotifyPropertyRefresh( );

		// 发送铸灵信息
		if (vFirst)
		{
			SendSpiritInfo(tpPlayer);
		}

		// 如果身上装备着法宝 要开启定时器
		CItemMagicWeapon* tpObjMW = (CItemMagicWeapon*)tpProperty->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON) ;
		if ( tpObjMW != NULL )
		{
			tpObjMW->OnStartMagicWeapon( tpPlayer );
		}

		// 遍历包裹、仓库东西，看是不是有过期的
		CheckPlayerItems( tpPlayer );

		// 将玩家处于绑定解除状态的物品加入队列中
		GetItemForFreeFromPlayer( tpPlayer );		

		// 给客户端发客户端功能控制信息
		SendClientCtrlInfo(tpPlayer);

		// 刷新称号附加属性
		RefreshTitleAddProperty( tpPlayer );

		// 如果玩家是黄名,开启定时器
		if ( tpPlayer->GetPKMode() == PKMODE_CORPS || tpPlayer->GetPKMode() == PKMODE_ALL )
		{
			tpPlayer->GetTimerReciver()->ClearTimer( tpProperty->GetYellowTimer() );
			int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY,0,0,0};
			CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
			int tTimerID = tpPlayer->GetTimerReciver()->SetTimer( tpPlayer->get_id(), TIMER_YELLOWNAME, tpTable != NULL ? tpTable->mYellowTime * 1000 : 30000, 1, nTimerOtherInfo );
			tpProperty->SetYellowTimer( tTimerID );
			SendYellowStateNotice( tpPlayer, true );	
		}		
		
		// 计算玩家的离线经验
		if ( vFirst == true )
		{
			ChangeOffLineTimeToExp( tpPlayer );
		}		
	}
	
	// 如果是内丹
	else if ( pEntity->IsRedStone() )
	{			 		
		int OtherInfo[ 3 ]={0};
		OtherInfo[0]=MESSAGE_PROPERTY;
		CEntityRedStone *tpRedStone = ( CEntityRedStone * )pEntity;

		// 设置内丹处于保护状态
		tpRedStone->SetStatus( REDSTONE_STATUS_PROTECT );

		// 设置保护时间计时器
		tpRedStone->GetTimerReciver()->SetTimer( pEntity->get_id(), TIMER_REDSTONE_PROTECT,
			REDSTONE_PROTECT_TIME,1, OtherInfo );

		// 设置消失时间计时器
		tpRedStone->GetTimerReciver()->SetTimer( pEntity->get_id(), TIMER_REDSTONE_CLEAR,
			REDSTONE_DISAPPER_TIME,1, OtherInfo );					
	}		
	
	// 如果是NPC
	else if ( pEntity->IsNpc() )
	{
		CEntityNpc* tpNpc = (CEntityNpc*) pEntity;
		CPropertyNPC* tpProperty = ( CPropertyNPC* )tpNpc->GetProperty( );
		LK_ASSERT( tpProperty != NULL, return );	


		// 如果NPC类型是怪物
		if ( tpNpc->IsOgre() || tpNpc->IsBlock() || tpNpc->IsFunNpc() )
		{	
			CTemplateOgre* tpOgreTpl = (CTemplateOgre*) CDataStatic::SearchTpl( tpNpc->GetNpcID( ) );
			if ( tpOgreTpl == NULL )
				return;

			if ( tpOgreTpl->mRedstoneID > 0 )
			{
				StartRedstone( pEntity, CSceneLogic::GetSingleton().GetLineID(), tpOgreTpl->mRedstoneID, false );
			}
			
			// 建立NPC时, NPC状态为初始状态
			tpProperty->SetCurAP( 100);
			tpProperty->SetCurHP( tpOgreTpl->mHP );
			tpProperty->SetCurMP( tpOgreTpl->mMP );
			tpProperty->SetCurSpeed( CPropertyFormula::GetRunSpeed( tpProperty ) );

			COgreCreator* tpCreator = ( COgreCreator* ) pCreator;
			if ( tpCreator != NULL )
			{
				tpProperty->SetRelifeTime( tpCreator->mRelife );
				tpProperty->SetDisappearTime( tpCreator->mDisappear );
			}

			// 存活时间刷怪，也可以理解成怪物活一段时间后变另一个
			if( tpNpc->GetOccurTime( ) > 0 )
			{
				int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, 0, 0, 0 } ;
				tpNpc->GetTimerReciver()->SetTimer( tpNpc->get_id(), TIMER_ENTITY_ALIVE_REFRESH, tpNpc->GetOccurTime( ), 1, nTimerOtherInfo );
			}
		}

		else if ( tpNpc->IsCollect() ) // 采集NPC
		{
			CPropertyNPC* tpProperty = ( CPropertyNPC* )tpNpc->GetProperty( );
			LK_ASSERT( tpProperty != NULL, return );	

			CCollectCreator* tpCreator = ( CCollectCreator* ) pCreator;
			if ( tpCreator != NULL )
			{
				tpProperty->SetRelifeTime( tpCreator->mRelife );
				tpProperty->SetDisappearTime( tpCreator->mDisappear );
			}
		}

		else if( tpNpc->IsBox() )
		{
			CPropertyNPC* tpProperty = ( CPropertyNPC* )tpNpc->GetProperty( );
			CTemplateBox* tpNpcTpl = (CTemplateBox*) CDataStatic::SearchTpl( tpNpc->GetNpcID( ) );
			LK_ASSERT( tpNpcTpl != NULL, return );

			tpProperty->SetLevel( tpNpcTpl->mLevel );
		}

		// 如果NPC类型是召唤兽
		else if ( tpNpc->IsPet() )
		{
			CPropertyPet* tpProperty = ( CPropertyPet* )tpNpc->GetProperty();
			LK_ASSERT( tpProperty != NULL, return );
			//CEntityPet* tpPet = ( CEntityPet* ) tpNpc;

			CTemplateSummonBeast* tpPetTpl = (CTemplateSummonBeast*) CDataStatic::SearchTpl( tpNpc->GetNpcID( ) );
			if ( tpPetTpl == NULL )
			{
				LOG_ERROR( "pro", "[ %s : %d ] [ %s ] %d", __LK_FILE__, __LINE__, __FUNCTION__ , tpNpc->GetNpcID( ));
				return;
			}
			// 先设主人再刷新
			tpProperty->Refresh( true );			
			tpProperty->SetCurSpeed( CPropertyFormula::GetRunSpeed( tpProperty ) );
			tpProperty->SetDisappearTimer( 6000 );
		}
		//// 如果NPC类型是服务NPC 或者任务护送NPC
		//else if ( tpNpc->IsFunNpc() )
		//{
		//	CTemplateNpc* tpNpcTpl = (CTemplateNpc*) CDataStatic::SearchTpl( tpNpc->GetNpcID( ) );
		//	if ( tpNpcTpl == NULL )
		//		return;

		//	CPropertyNPC* tpProperty = ( CPropertyNPC* )tpNpc->GetProperty();
		//	LK_ASSERT( tpProperty != NULL, return );

		//	// 建立NPC时, NPC状态为初始状态
		//	tpProperty->SetCurAP( 100 );

		//	tpProperty->SetCurHP( tpNpcTpl->mHP );
		//	tpProperty->SetCurMP( tpNpcTpl->mMP );
		//	tpProperty->SetLevel( tpNpcTpl->mLevel );
		//	tpProperty->SetCurSpeed( CPropertyFormula::GetRunSpeed( tpProperty ) );
		//
		//	CNpcCreator* pNpcCreater = (CNpcCreator*)pCreator;
		//	tpNpc->SetOwnerCharID( pNpcCreater->mOwnerCharID );
		//	tpNpc->SetSendNpcState( pNpcCreater->mIsSendNpc );
		//	tpNpc->SetIsShowOwner( pNpcCreater->mIsShowOwner );
		//	tpProperty->SetDisappearTime( pNpcCreater->mDisappear );
		//	tpProperty->SetRelifeTime( pNpcCreater->mRelife );
		//}
		else if( tpNpc->IsPedal() )
		{
			CPropertyPedal* tpProperty = ( CPropertyPedal* )tpNpc->GetProperty();
			LK_ASSERT( tpProperty != NULL, return );

			tpProperty->SetDisappearTimer( 100000 );
		}
			
	}
	// 如果NPC类型是道具
	else if ( pEntity->IsItem() )
	{
		CPropertyItem* tpProperty = ( CPropertyItem* )pEntity->GetProperty();
		CItemCreator* tpCreator		= (CItemCreator*) pCreator;

		tpProperty->CloneOwnerCharID( tpCreator->mOwnerCharID );
		tpProperty->SetItemID( ( tpCreator->mpItem == NULL ) ? INVALID_OBJ_ID : ( ( CItemObject* )( tpCreator->mpItem ) )->get_id() );

		//TODO: use timer
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY, 0, 0, 0};

		if ( tpCreator->mProtect == true )
		{
			( (CEntityItem*) pEntity )->GetTimerReciver()->SetTimer( pEntity->get_id(), TIMER_ENTITY_PROTECT, ITEM_PROTECT_TIME, 1, nTimerOtherInfo );
		}
		else
		{
			( (CEntityItem*) pEntity )->GetTimerReciver()->SetTimer( pEntity->get_id(), TIMER_ENTITY_CLEAR, ITEM_DISAPPER_TIME, 1, nTimerOtherInfo );
		}
	}


}

// 保存玩家道具信息
int CPropertyModule::SaveItemInfo( CEntityPlayer* pPlayer, int* apPkgIdx, int nIdxNum, int nSaveCode )
{
	CSession* pSession= (CSession*) CSceneObjManager::GetSingletonPtr()->CreateObject( OBJTYPE_SESSION );
	LK_ASSERT( pSession != NULL, return -1 ); 

	pSession->SetSessionType( SESSION_SAVE_PLAYER_BAGGAGE );
	pSession->SetParam1( nSaveCode );
	pSession->SetParam2( pPlayer->GetEntityID() );
	pSession->SetTimer( CWTimer(30000) ); 

	CMessage tMessage;
	CMessageSavePlayerItemInfoRequest tReqPara;

	tMessage.mutable_msghead()->set_messageid( ID_S2D_SAVEPLAYERITEMINFO_REQUEST );
	tMessage.set_msgpara( (unsigned int)(&tReqPara) );

	tReqPara.set_accountid( pPlayer->GetAccountID() );
	tReqPara.set_charid( pPlayer->GetCharID() );
	tReqPara.set_sessionid( pSession->get_id() );

	CPropertyPlayer* pPlayerProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	
	std::vector<std::string> tFields;
	for( int i = 0; i < nIdxNum; i++ )
	{
		tReqPara.add_packageidx( apPkgIdx[i] );
		pSession->SetParam( 3+i,apPkgIdx[i]); // 从第3个参数开始设置

		PBItemBox* pItemBox = tReqPara.add_itembox();
		LK_ASSERT( pItemBox != NULL, return -1 );

		switch( apPkgIdx[i] )
		{
		case PACKAGE_BAGGAGE:
			{
				pPlayerProperty->GetBaggage()->GetTlvBuffer2( pItemBox );
				tFields.push_back(std::string( "role_package" ) );
				break;
			}
		case PACKAGE_TASK:
			{
				pPlayerProperty->GetTaskBaggage()->GetTlvBuffer2( pItemBox );
				tFields.push_back(std::string( "role_task_package" ));
				break;
			}
		case PACKAGE_STORAGE:
			{
				pPlayerProperty->GetStorage()->GetTlvBuffer2( pItemBox );
				tFields.push_back(std::string( "role_storage" ));
				break;
			}
		case PACKAGE_EQUIPMENT:
			{
				pPlayerProperty->GetEquipment()->GetTlvBuffer2( pItemBox );
				tFields.push_back(std::string( "role_equipment" ));
				break;
			}
		default:
			{
				LOG_ERROR( "default", "invalide pkgidx %d", apPkgIdx[i] );
				tFields.push_back(std::string( "none" ));
				break;
			}
		}

	}

	if (nSaveCode != SAVE_REDIRECT && nSaveCode != SAVE_TIMETRIGER)
	{
		SceneServer::CSceneLogic::GetSingletonPtr()->Send2Log( 
					&tMessage, tMessage.msghead().messageid(), pPlayer->GetCharID(), pPlayer->GetRoleWorldID() );
	}

	if( nSaveCode == SAVE_FILE )
	{
		std::string tFileName;
		CSceneLogic::GetSingletonPtr( )->Save2File(SESSION_SAVE_PLAYER_BAGGAGE, pPlayer->GetCharID(), &tReqPara, tFileName.c_str(), tFields, pPlayer->GetAccountID() );
		return SUCCESS;
	}
	
	if( SceneServer::CSceneLogic::GetSingletonPtr()->Send2Data( pPlayer->GetAccountID(), tMessage, pPlayer->GetRoleWorldID() ) < 0 )
	{
		LOG_ERROR( "default", "[%s:%d] player %d send messag to data failed.", __FUNCTION__, __LINE__, pPlayer->GetCharID() );
		return -1;
	}

#ifdef _DEBUG_
	LOG_DEBUG( "pro", "player %d item: %s", pPlayer->GetCharID(), tReqPara.ShortDebugString().c_str() );
#endif

	return 0;
}



// 存储数据
bool CPropertyModule::OnSaveData( CEntityPlayer* pPlayer, int vSaveCode )
{
	LK_ASSERT( pPlayer!=NULL, return false);
	
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* )pPlayer->GetProperty();				 
	
	if( vSaveCode != SAVE_TIMETRIGER )
	{
		// 只在非定时存储触的时机才强制超时定时器,以便某些系统需要定时器把剩余时间送回逻辑处理。
		//pPlayer->TimeoutTimerForSaveData();

		// 删除组队事件buff
		CTeamModule::GetSingletonPtr()->RemoveTeamEventBuff( pPlayer )	;
	}

	pPlayer->GetLeftTimeofPlayerTimer();

	int tIsCallBack = SQL_NEED_CALLBACK;
	if ( vSaveCode == SAVE_TIMETRIGER )
		tIsCallBack = SQL_NONE;

	CMessagePlayerProperty* tpSave = CSceneLogic::GetSingletonPtr( )->GetSavePlayerProperty( );

	tpSave->set_role_hp( tpProperty->GetCurHP( ) );	
	tpSave->set_role_mp( tpProperty->GetCurMP( ) );	
	tpSave->set_role_ap( tpProperty->GetCurAP( ) );	

	// 这里存储 property,skill,buff,equipment
	tpProperty->GetBasicInfoTlvBuffer( tpSave->mutable_role_basic( ) );

	tpProperty->GetBuffList( )->GetTlvBuffer2( tpSave->mutable_role_buff( ) );

	tpProperty->GetSkillList( ).GetTlvBuffer2( tpSave->mutable_role_skill( ) );
	
	tpProperty->GetPvPBlobInfoTlvBuffer( tpSave->mutable_role_pvp( ) );

	tpProperty->GetCDGroupTlvBuffer( tpSave->mutable_role_cdgroup( ) );	

	tpProperty->GetActivityInfoTlvBuffer( tpSave->mutable_role_activity( ), true );

	tpProperty->GetTalentInfoTlvBuffer( tpSave->mutable_role_talent( ) );	

	tpProperty->GetMonsterRecordInfoTlvBuffer( tpSave->mutable_role_monster_record( ) );

	tpProperty->GetTitleInfoTlvBuffer( tpSave->mutable_role_title( ) );

	tpProperty->GetMWInfoTlvBuffer( tpSave->mutable_role_mw( ) );

	tpProperty->GetTelePosTlvBuffer( tpSave->mutable_role_tele_pos( ) );

	tpProperty->GetPlayerLifeSkill( )->CreatTlvPB( *tpSave->mutable_role_lifeskill( ) );

	tpProperty->GetStatisticTlvBuffer( tpSave->mutable_role_statistic( ) );

	tpProperty->mWizard.GetTlvBuffer( tpSave->mutable_role_wizard( ) );

	tpProperty->GetRoleClientInfoTlvBuffer( tpSave->mutable_role_client( ) );

	tpProperty->GetCharmInfoTlvBuffer( tpSave->mutable_role_charm() );

	tpProperty->GetTimesInfoTlvBuffer( tpSave->mutable_role_times() );

	//如果是在跨服，不存储师徒数据
	if ( IS_GLOBAL_SCENESERVER( pPlayer->GetLineID() ) == false && IS_DUNGEONSERVER_LINE( pPlayer->GetLineID() ) == false )
	{
		tpProperty->GetMatrixRecordInfoTlvBuffer( tpSave->mutable_role_matrix() );
	}
	
	tpProperty->GetExpTimeInfo()->CreatTlvPB( *tpSave->mutable_role_exptimeinfo() );
	
	tpProperty->GetTreasureBowlInfo()->CreateTlvPB(  *tpSave->mutable_role_treasurebowl() );

	int nPkgIdx[3] = { PACKAGE_BAGGAGE, PACKAGE_EQUIPMENT, PACKAGE_TASK };
	if( SaveItemInfo( pPlayer, nPkgIdx, 3, vSaveCode ) < 0 )
	{
		LOG_FATAL( "pro", "[%s:%d] save player %d baggage, equipment, taskbaggage failed" ,__FUNCTION__, __LINE__, pPlayer->GetCharID() );
		return false;
	}

	//// 这里存储仓库
	nPkgIdx[0] = PACKAGE_STORAGE;
	if( SaveItemInfo( pPlayer, nPkgIdx, 1, vSaveCode ) < 0 )
	{
		LOG_FATAL( "pro", "[%s:%d] save player %d storage failed" ,__FUNCTION__, __LINE__, pPlayer->GetCharID() );
		return false;
	}

	tpProperty->GetSpiritInfo().CreateTlvPB(*tpSave->mutable_role_spiritinfo());
	// 存盘写一下日志
	if( vSaveCode != SAVE_TIMETRIGER )
	{
		LOG_NOTICE( "pro", "Player[ %s : %d ] SaveData LineID %d MapID %d Pos( %d : %d ) SaveCode %d", 
			pPlayer->GetCharNameShow(), pPlayer->GetCharID(), pPlayer->GetLineID( ), pPlayer->GetMapID( ), 
			pPlayer->GetPosX( ), pPlayer->GetPosY( ), vSaveCode );
	}

	return true;
}

// 销毁实体
void CPropertyModule::OnDestroyEntity( CEntity* pEntity, int vCode )
{		
	if( pEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Parames Err, Entity Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if ( pEntity->GetEntityType() == ENTITYTYPE_PLAYER )
	{
		CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pEntity->GetProperty();		
		CPropertyPlayer::SaleItemList::iterator it;
		CItemObject* tpItem = NULL;
		for ( it = tpProperty->GetSaleItem( )->begin(); it != tpProperty->GetSaleItem( )->end(); ++ it )
		{
			SaleItem tSale = (SaleItem) *it;
			tpItem = ( CItemObject* )CSceneObjManager::GetSingletonPtr()->GetObject( tSale.mItemID );
			if ( tpItem == NULL )
			{
				continue ;
			}
			CSceneObjManager::GetSingletonPtr()->DestroyObject( tpItem->get_id() );
		}			

		// 回收玩家占用资源( 清除所有道具, 以及陷阱， 等等 )
		tpProperty->Final();
	}	
	else if ( pEntity->IsFunNpc() || pEntity->IsOgre() )
	{
		// 如果是功能NPC 检查是不是被人召唤出来的 是的话 要清除玩家身上的状态
		CEntityNpc* tpNpc = (CEntityNpc*)pEntity;
		if ( tpNpc->GetCallerEntityID() != INVALID_OBJ_ID )
		{
			CEntityPlayer* tpPlayer = (CEntityPlayer*)CSceneLogic::GetSingleton().GetEntity(tpNpc->GetCallerEntityID() );
			if ( tpPlayer == NULL )
			{
				LOG_ERROR("pro", "npc destroy but can't find player? npc tempid = %d ownerid=%d", tpNpc->GetProperty()->GetPropertyTempID(), tpNpc->GetCallerEntityID() );
			}
			else
			{
				if ( tpPlayer->GetCallNpcEntityID() == (int)tpNpc->GetEntityID() ) // 匹配 才重置 否则会出问题
					tpPlayer->SetCallNpcEntityID(INVALID_OBJ_ID);
			}
		}

	}

	// 清除所有已设置定时器
	if( pEntity->GetTimerReciver() != NULL )
		pEntity->GetTimerReciver()->ClearAllTimer();
	
	return ;
}

// 玩家复活逻辑
void CPropertyModule::PlayerRelive( CEntityPlayer* pPlayer, ERelive vReliveType, int vHPPer, int vMPPer )
{
	if( pPlayer->IsAlive( ) == true )
		return;
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty( );
	
	// 正常原地复活，需要消耗人民币道具
	if ( vReliveType == RELIVE_NORMAL )
	{
		// 扣除金币
		CTemplateReliveTable* tpFeeTable = ( CTemplateReliveTable* ) CDataStatic::GetTemp( TEMP_RELIVETABLE );
		if ( tpFeeTable == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] cannt find template TEMPTYPE = %d", __LK_FILE__, __LINE__, __FUNCTION__, TEMP_RELIVETABLE );
			return ;
		}
		if ( pProperty->GetMoney( ) < tpFeeTable->mFee[ pPlayer->GetLevel() ] )
		{
			// 金钱不足,无法复活
			//LOG_ERROR( "pro", "[ %s : %d ] [ %s ] not enough money", __LK_FILE__, __LINE__, __FUNCTION__ );
			SendProErrorNotice( pPlayer, ERROR_PROPERTY_MONEYNOTENOUGH );
			return;
		}
		pPlayer->SetAliveStatus( ALIVE_NORMAL );
		// 不需要再清楚BUFF和状态了,在玩家死亡的时候已经处理
		//CBuffList *tpBuff = pProperty->GetBuffList( );
		//tpBuff->Clean( );

		// 刷新属性
		pProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );

		pProperty->SetCurHP( pProperty->GetMaxHP( ) );
		pProperty->SetCurMP( pProperty->GetMaxMP( ) );
		pProperty->SetOriginReliveTimes( pProperty->GetOriginReliveTimes()+1 );  // 设置原地复活次数

		CMessage tPlayerRelife;
		CMessagePlayerReliveNotice tMessage;
		bool tBool = CreateMessagePlayerReliveNotice( 
				&tPlayerRelife, 
				&tMessage, 
				pPlayer->GetEntityID( ),
				pPlayer->GetPosX( ),
				pPlayer->GetPosY( ),
				pProperty->GetCurHP( ),
				pProperty->GetCurMP( ),
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( )
				);
		if ( tBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tPlayerRelife, false, true );
		}

		// 金钱复活要获得功勋
		PlayerReliveHonor( pPlayer, (CPropertyPlayer*)pProperty );		

		if (PlayerChangeMoney( pPlayer, tpFeeTable->mFee[ pPlayer->GetLevel() ], true, false ) == SUCCESS)
		{
			LogEventLostMoneyByRelife(pPlayer, CYuanBao::em_unbind_money, tpFeeTable->mFee[ pPlayer->GetLevel() ]);
		}

		LogEventPlayerReliveByNormal(pPlayer, pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetPosX(), pPlayer->GetPosY());
	}

	// 暂时没有复活技能了,所以暂时注释掉,但不要删除,可能以后会添加
	// 技能原地复活
	else if ( vReliveType == RELIVE_SKILL )
	{
		pPlayer->SetAliveStatus( ALIVE_NORMAL );
		// 刷新属性
		pProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		
		pProperty->SetCurHP( 
			std::max( (int)( (unsigned int)pProperty->GetMaxHP( ) * vHPPer / SERVER_PERCENT_FLOAT ), 1 ) );
		pProperty->SetCurMP( 
			std::max( (int)( (unsigned int)pProperty->GetMaxMP( ) * vMPPer / SERVER_PERCENT_FLOAT ), 1 ) );

		CMessage tPlayerRelife;
		CMessagePlayerReliveNotice tMessage;
		bool tBool = CreateMessagePlayerReliveNotice( 
				&tPlayerRelife, 
				&tMessage, 
				pPlayer->GetEntityID( ),
				pPlayer->GetPosX( ),
				pPlayer->GetPosY( ),
				pProperty->GetCurHP( ),
				pProperty->GetCurMP( ),
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( )
				);
		if ( tBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tPlayerRelife, false,  true );
		}

		LogEventPlayerReliveBySkill(pPlayer, pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetPosX(), pPlayer->GetPosY());
	}

	// 虚弱墓地复活，需要消耗金币
	else if ( vReliveType == RELIVE_WEAKGRAVE )
	{
	//	if( CRepetionModule::GetSingletonPtr( )->IsBattleMap( pPlayer->GetMapID( ) ) == true )
	//	{
	//		return;
	//	}
#ifdef _FB_
		if( CRepetionModule::GetSingletonPtr( )->IsUnRelive( pPlayer->GetMapID( ) ) == true )
		{
			LOG_NOTICE( "default", "[ %s : %d ][ %s ] Map %d Cannt Comm Relive", __LK_FILE__, __LINE__, __FUNCTION__,
				pPlayer->GetMapID( ) );
			return;
		}
#endif

		pPlayer->SetAliveStatus( ALIVE_NORMAL );
		// 不需要再清楚BUFF和状态了,在玩家死亡的时候已经处理
		//CBuffList *tpBuff = pProperty->GetBuffList( );
		//tpBuff->Clean( );
		// 刷新属性
		pProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		
		pProperty->SetCurHP( ( ( int )CPropertyFormula::GetMaxHP( pProperty ) ) >> 1 );
		pProperty->SetCurMP( ( ( int )CPropertyFormula::GetMaxMP( pProperty ) ) >> 1 );

		CMessage tPlayerRelife;
		CMessagePlayerReliveNotice tMessage;
		bool tBool = CreateMessagePlayerReliveNotice( 
				&tPlayerRelife, 
				&tMessage, 
				pPlayer->GetEntityID( ),
				pPlayer->GetPosX( ),
				pPlayer->GetPosY( ),
				pProperty->GetCurHP( ),
				pProperty->GetCurMP( ),
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( )
				);
		if ( tBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tPlayerRelife, false, true );
		}

		// 如果玩家在本国, 找到本地图的复活点
		if( pPlayer->GetNationality( ) == pPlayer->GetLineID( ) 
			|| IS_REPETION_LINE_ID( pPlayer->GetLineID( ) ) == true
			|| IS_NEUTRAL_LINE_ID( pPlayer->GetLineID() ) == true
			|| IS_BATTLE_LINE_ID( pPlayer->GetLineID() ) == true )
		{
			RelivePositionMap::iterator tFindIter = mRelivePosition.find( pPlayer->GetMapID( ) );
			if ( tFindIter == mRelivePosition.end( ) )
			{
				// 如果没有找到,传送玩家到边境复活点
				CMapModule::GetSingleton().Teleport( pProperty->GetTownPos( )->mLineID, pProperty->GetTownPos( )->mMapID, pProperty->GetTownPos( )->mPos.mX, pProperty->GetTownPos( )->mPos.mY, pPlayer );
				LogEventPlayerReliveByWeak(pPlayer, pProperty->GetTownPos( )->mLineID, pProperty->GetTownPos( )->mMapID, pProperty->GetTownPos( )->mPos.mX, pProperty->GetTownPos( )->mPos.mY);
				return;
			}

			CRelivePosition* tpRelive = ( CRelivePosition* ) CSceneObjManager::GetSingletonPtr( )->GetObject( tFindIter->second );
			if ( tpRelive == NULL )
			{
				LOG_ERROR( "pro", "[ %s : %d ][ %s ]Parames Err, tpRelive Is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
				CMapModule::GetSingleton().Teleport( pProperty->GetTownPos( )->mLineID, pProperty->GetTownPos( )->mMapID, pProperty->GetTownPos( )->mPos.mX, pProperty->GetTownPos( )->mPos.mY, pPlayer );
				LogEventPlayerReliveByWeak(pPlayer, pProperty->GetTownPos( )->mLineID, pProperty->GetTownPos( )->mMapID, pProperty->GetTownPos( )->mPos.mX, pProperty->GetTownPos( )->mPos.mY);
				return;
			}
			
			// 传送玩家到复活点
#ifdef _FB_
			CMapObject* tpMapObject = pPlayer->GetMapObject( );

			// 传送玩家到复活点
			CMapModule::GetSingleton().Teleport( tpRelive->mLineID, tpRelive->mReliveMapID, tpRelive->mPosition.mX, tpRelive->mPosition.mY, pPlayer, INVALID_MAP_INDEX, ( tpMapObject != NULL ) ? tpMapObject->GetKey( ) : INVITED_KEY_VALUE );
			pPlayer->SetCommState( CEntityPlayer::STATE_INMAP );
			LogEventPlayerReliveByWeak(pPlayer, tpRelive->mLineID, tpRelive->mReliveMapID, tpRelive->mPosition.mX, tpRelive->mPosition.mY);
#else
			if ( tpRelive->mSpecial == 0 )
			{
				CMapModule::GetSingleton().Teleport( tpRelive->mLineID, tpRelive->mReliveMapID, tpRelive->mPosition.mX, tpRelive->mPosition.mY, pPlayer );

				LogEventPlayerReliveByWeak(pPlayer, tpRelive->mLineID, tpRelive->mReliveMapID, tpRelive->mPosition.mX, tpRelive->mPosition.mY);
			}
			else
			{
				CSpecialRelive *tpSpecial = tpRelive->GetPosByNation( pPlayer->GetNationality() );
				CMapModule::GetSingleton().Teleport( tpSpecial->mLineID, tpSpecial->mMapID, tpSpecial->mX, tpSpecial->mY, pPlayer );

				LogEventPlayerReliveByWeak(pPlayer, tpSpecial->mLineID, tpSpecial->mMapID, tpSpecial->mX, tpSpecial->mY);
			}
#endif

		}

		// 如果玩家不在本国
		else
		{
			// 传送玩家到边境复活点
			CMapModule::GetSingleton().Teleport( pPlayer->GetNationality(), mBorderMapID, mBorderPosX, mBorderPosY, pPlayer );

			LogEventPlayerReliveByWeak(pPlayer,  pPlayer->GetNationality(), mBorderMapID, mBorderPosX, mBorderPosY );
		}			
	}
	else if ( vReliveType == RELIVE_SYSTEM )
	{
		pPlayer->SetAliveStatus( ALIVE_NORMAL );
		// 刷新属性
		pProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		
		pProperty->SetCurHP( 
			std::max( (int)( (unsigned int)pProperty->GetMaxHP( ) * vHPPer / SERVER_PERCENT_FLOAT ), 1 ) );
		pProperty->SetCurMP( 
			std::max( (int)( (unsigned int)pProperty->GetMaxMP( ) * vMPPer / SERVER_PERCENT_FLOAT ), 1 ) );

		CMessage tPlayerRelife;
		CMessagePlayerReliveNotice tMessage;
		bool tBool = CreateMessagePlayerReliveNotice( 
				&tPlayerRelife, 
				&tMessage, 
				pPlayer->GetEntityID( ),
				pPlayer->GetPosX( ),
				pPlayer->GetPosY( ),
				pProperty->GetCurHP( ),
				pProperty->GetCurMP( ),
				pProperty->GetMaxHP( ),
				pProperty->GetMaxMP( )
				);
		if ( tBool == true )
		{
			CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tPlayerRelife, false, true );
		}

		LogEventPlayerReliveBySystem(pPlayer, pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetPosX(), pPlayer->GetPosY());
	}

	// 复活通知

	//CTeamModule::GetSingleton().TeamMemberRelive( pPlayer/*->GetEntityID()*/ );

#ifdef _FB_
	CMapObject* tpMapObject = pPlayer->GetMapObject( );
	CRepetion* tpRepetion = tpMapObject->GetRepetion( );
	CRepetionInfo* tpRepetionInfo = CRepetionModule::GetSingletonPtr( )->GetRepetionInfoByMapID( tpMapObject->GetMapID( ) );

	lua_tinker::table vParame( CRepetionModule::GetSingletonPtr( )->mLua );

	vParame.set( "entityid", pPlayer->get_id() );
	vParame.set( "relive_type", vReliveType);
	PERF_FUNC( "Repetion_DoEvent", tpRepetion->DoEvent( tpRepetion->GetRepetionInfo( ),EEPETION_RELIVE , &vParame ) );
#endif

}

void CPropertyModule::EntityRelive( CEntity* pEntity )
{
	LK_ASSERT( pEntity != NULL, return );

	// 只有某些NPC才能复活
	if ( pEntity->IsNpc() )
	{
		// 如果是采集NPC
		if ( pEntity->IsCollect() )
		{
			CEntityCollect *tpCollect = (CEntityCollect*)pEntity;
			tpCollect->SetNumber( 0 );
			CCollectCreator *tpCreator = (CCollectCreator*)CSceneObjManager::GetSingletonPtr()->GetObject( tpCollect->GetCreatorID() );
			if ( tpCreator != NULL )
			{
				tpCollect->SetOrginPos( tpCreator->mPosition[ RAND( tpCreator->mPCount ) ] );
			}			
		}

		CEntityNpc* tpNpc = (CEntityNpc*) pEntity;
		CTemplateBuff *tplBuff = NULL;
		if ( tpNpc->IsOgre() || tpNpc->IsBlock() )
		{
			CTemplateOgre *tplOgre = (CTemplateOgre*)CDataStatic::SearchTpl( tpNpc->GetNpcID( ) );
			// 通知世界BOSS刷新
			if ( tplOgre != NULL )
			{
				if( tplOgre->mDisplayLevel == CTemplateOgre::OGRESHOW_BOSS )
				{
					int tIntParam[ 4 ] = { 0 };
					tIntParam[ 0 ] = tpNpc->GetNpcID( );
					tIntParam[ 1 ] = tpNpc->GetMapID( );
					tIntParam[ 2 ] = tpNpc->GetPosX( );
					tIntParam[ 3 ] = tpNpc->GetPosY( );
					CPropertyModule::GetSingletonPtr()->SendEventNotify( NOTICE_REFRESHBOSS, tpNpc->GetLineID( ), tIntParam, ARRAY_CNT(tIntParam), NULL, NULL );
				}
			}
			COgreCreator *tpCreator = (COgreCreator*)CSceneObjManager::GetSingletonPtr()->GetObject( tpNpc->GetCreatorID() );
			if ( tpCreator != NULL )
			{
				int tRand = RAND(SERVER_PERCENT_INT);
				short tLow = 0;
				short tHigh = 0;
				for ( int i = 0; i < tpCreator->mRCount1; i++ )
				{
					tLow += ( i == 0 ) ? 0 : tpCreator->mRefresh1[ i - 1 ].mOgreRand;
					tHigh += tpCreator->mRefresh1[ i ].mOgreRand;
					if ( tRand >= tLow && tRand <= tHigh )
					{
						tpNpc->SetNpcID( tpCreator->mRefresh1[ i ].mOgreID );
						break;
					}
				}
				tplBuff = (CTemplateBuff*)CDataStatic::SearchTpl( tpCreator->mInitBuffID );				
			}
		}
		
		CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();
		// 刷新属性
		pProperty->Refresh( );

		pEntity->SetAliveStatus( ALIVE_NORMAL );
		// 不需要再清楚BUFF和状态了,在玩家死亡的时候已经处理

		pProperty->SetCurAP( pProperty->GetMaxAP() );
		pProperty->SetCurHP( pProperty->GetMaxHP( ) ); 
		pProperty->SetCurMP( pProperty->GetMaxMP( ) ); 
		pProperty->SetFirstEntityID( 0 );

		if ( tplBuff != NULL )
		{
			tpNpc->EntityInsertBuff( tpNpc, tplBuff );
		}

		if ( tpNpc->IsFunNpc() && tpNpc->GetNpcChangeState() != 0  ) // 功能NPC 而且变成怪物之后
		{
			// 把NPC改成中立状态
			CNpcPolicy* tpPolicy = (CNpcPolicy*)CSceneLogic::GetSingleton().GetEntity( tpNpc->GetPolicyID() );
			LK_ASSERT( tpPolicy, return );
			tpPolicy->ResetTarget( );
			tpPolicy->mPreList.clear();
			tpPolicy->mPathList.clear();
			tpPolicy->mPathPos = tpNpc->GetPos();
			tpPolicy->mTargetPos = CWTPoint(0,0);
			tpPolicy->mNpcState = CNpcPolicy::STATE_BATTLE;
			tpPolicy->Return2Orgin( true, true );
			CTemplateOgre *tpOgre = (CTemplateOgre*)CDataStatic::SearchTpl( tpNpc->GetNpcID( ) );
			if ( tpOgre == NULL )
			{
				tpPolicy->mTeleTimer = 25000;
			}
			else
			{
				tpPolicy->mTeleTimer = tpOgre->mTeleTime;
			}
			LOG_NOTICE("default", "***ChangedNpcRelife! NPCID=%d entityid=%d", tpNpc->GetNpcID(), tpNpc->GetEntityID() );
		}
		else
		{
			// 传送NPC到重生点
			CMapModule::GetSingleton( ).Teleport( tpNpc->GetLineID(), tpNpc->GetMapID(), tpNpc->GetOrginPos( ).mX, tpNpc->GetOrginPos( ).mY, tpNpc );
		}

		// 发送消息通知客户端，实体复活
		CMessage tEntityRelife;
		CMessageEntityRelifeNotice tMessage;
		if ( CreateMessageEntityRelifeNotice( &tEntityRelife, pEntity, &tMessage ) == false )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] create entity relife notice error", __LK_FILE__, __LINE__, __FUNCTION__ );
			return;
		}

		CMapModule::GetSingletonPtr()->MessageBroadCast( tpNpc, &tEntityRelife );
	}
}


// ***********************************************************
//  Function:		PlayerCloseDialog2
//  Description:	关闭对话框,跨模块
//  Input:			CEntityPlayer*		pPlayer		实体
//					CPropertyPlayer*	pProperty	实体属性
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::PlayerCloseDialog2( CEntityPlayer* pPlayer )
{
	if ( pPlayer != NULL )
	{
		PlayerCloseDialog( pPlayer );
	}
}

// ***********************************************************
//  Function:		PlayerChangeMetier2
//  Description:	改变职业,跨模块
//  Input:			CEntityPlayer*		pPlayer			实体
//					CPropertyPlayer*	pProperty		实体属性
//					unsigned int		nDesMetier		职业类型
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::PlayerChangeMetier2( CEntityPlayer* pPlayer, unsigned int nDesMetier )
{
	if ( pPlayer == NULL )
		return;

	PlayerChangeMetier( pPlayer, nDesMetier );
}
// ***********************************************************
//  Function:		PlayerObtainExp2
//  Description:	获得经验,跨模块
//  Input:			CEntityPlayer*		pPlayer			实体
//					CPropertyPlayer*	pProperty		实体属性
//					unsigned int		vExp			经验
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
int  CPropertyModule::PlayerObtainExp2( CEntityPlayer* pEntity, int vExp, int vListID, int vReason,int* pMemberList, int vMemberCount )
{
	if ( pEntity == NULL )
		return 0;

	pEntity->InitFunResult( );

	int nObExp = PlayerObtainExp( pEntity, vExp, vReason, pMemberList, vMemberCount );

	ResultListSend( );

	return nObExp;
}



unsigned int CPropertyModule::CountSize()
{
	unsigned int tSize = sizeof( CPropertyModule );

	//	tSize += CPropertyManager::CountSize( );

	return tSize;
}

// ***********************************************************
//  Function:		ConsumeItemByIndex
//  Description:	消耗特定格子的道具,跨模块
//  Input:			unsigned int	vEntityId		实体ID
//					unsigned int	vItemId			道具ID
//					int				vItemNum		道具数量
//					int				vItemIndex		包裹索引
//  OutPut:			int&			tBackType		返回类型
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::ConsumeItemByIndex( unsigned int vEntityId, unsigned int vItemId, int vItemNum, int vItemIndex, int& tBackType )
{
	CPropertyPlayer *pProperty = ( CPropertyPlayer* )CProperty::SearchProByEntityID( vEntityId );

	if ( pProperty == NULL || pProperty->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		LOG_ERROR( "pro","[ %s : %d ] [ %s ] CPropertyModule::ConsumeItemByIndex", __LK_FILE__, __LINE__, __FUNCTION__ );

		tBackType = -1;
		return;
	}
	CItemObject * tpSrcItem = pProperty->GetBaggage( )->GetItemObjPtr( vItemIndex );
	if ( tpSrcItem == NULL )
	{
		LOG_ERROR( "pro","[ %s : %d ] [ %s ] CPropertyModule::ConsumeItemByIndex:EmptyIndex", __LK_FILE__, __LINE__, __FUNCTION__ );
		tBackType = -1;
		return;
	}
	if ( tpSrcItem->GetItemID() != vItemId )
	{
		LOG_ERROR( "pro","[ %s : %d ] [ %s ] CPropertyModule::ConsumeItemByIndex:WrongItem", __LK_FILE__, __LINE__, __FUNCTION__ );
		tBackType = -1;
		return;
	}
	CEntityPlayer *pPlayer =( CEntityPlayer * )CSceneLogic::GetSingletonPtr()->GetEntity( vEntityId );
	if ( pPlayer == NULL )
	{
		tBackType = -1;
		return;
	}

	//int ConsumeResult = 0;
	uint64_t ullGUID = tpSrcItem->GetGUID();
	int nItemID = tpSrcItem->GetItemID();
	if ( PlayerRemoveItem(pPlayer,( unsigned short )vItemIndex ,( unsigned short )vItemNum, &ullGUID, false) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID, nItemID, vItemNum);

	}else
	{
		LOG_ERROR( "pro","[ %s : %d ] [ %s ] CPropertyModule::ConsumeItemByIndex:WrongItem", __LK_FILE__, __LINE__, __FUNCTION__ );
		tBackType = -1;
		return;
	}
	tBackType = 1;
}


// ***********************************************************
//  Function:		HasItem
//  Description:	查询道具,跨模块
//  Input:			unsigned int	vEntityID		实体ID
//					unsigned int	vItemID			道具ID
//					unsigned int	vNumber			道具数量
//					int IfCountLockItem				是否计算锁定的道具
//  OutPut:			int&			tBackType		返回类型   
//  Return:			检索到的第一个可用物品的格子索引
//  Others:
//  Date:	11/18/2008
// **********************************************************
int CPropertyModule::HasItem( unsigned int vEntityID, unsigned int vItemID, unsigned int vNumber, int& tBackType, int IfCountLockItem, int vType )
{
	CPropertyPlayer* pProperty = ( CPropertyPlayer* )CProperty::SearchProByEntityID( vEntityID );

	if ( pProperty == NULL || pProperty->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] CPropertyModule::HasItem", __LK_FILE__, __LINE__, __FUNCTION__ );

		tBackType = -1;
		return -1;
	}

	CItemObject* tpSrcItem;

	int vBagCount = pProperty->GetBaggage( )->mReleaseIndex;
	int vFirstItemIndex = -1;

	unsigned int ItemCount=0;

	for ( int i = 0; i < vBagCount; i++ )
	{
		tpSrcItem = ( CItemObject* )pProperty->GetBaggage( )->GetItemObjPtr( i );

		if ( tpSrcItem == NULL )
		{
			continue;
		}
		
		if ( tpSrcItem->GetLockStatus( ) != LOCKTYPE_NONE && IfCountLockItem != 1 )
		{
			continue;
		}  
				
		if( tpSrcItem->IsSameItemGroup( vItemID, vType ) )
		{						
			ItemCount = ItemCount + tpSrcItem->GetItemNum();	
			if ( vFirstItemIndex == -1 )
			{
				vFirstItemIndex = i;
			}						
		}
	}
	
	// TODO::搜索包裹背包
	for ( int i = 0; i < pProperty->GetBaggage()->GetKitBagIndex(); ++i )
	{
		int tBeginIndex = -1;
		int tEndIndex	= -1;
		int tRet = pProperty->GetBaggage()->GetKitBagIndexRange( BAGTYPE_KITBAG, i, tBeginIndex, tEndIndex );
		if ( tRet != SUCCESS )
		{
			continue;
		}
		for ( int j = tBeginIndex; j <= tEndIndex; ++j )
		{
			tpSrcItem = ( CItemObject* )pProperty->GetBaggage( )->GetItemObjPtr( j );

			if ( tpSrcItem == NULL )
			{
				continue;
			}

			if ( tpSrcItem->GetLockStatus() != LOCKTYPE_NONE && IfCountLockItem != 1 )
			{
				continue;
			}  

			if( tpSrcItem->IsSameItemGroup( vItemID, vType ) )
			{						
				ItemCount = ItemCount + tpSrcItem->GetItemNum();	
				if ( vFirstItemIndex == -1 )
				{
					vFirstItemIndex = j;
				}						
			}
		}
	}

	if ( ItemCount >= vNumber )
	{
		tBackType = 1;
	}
	else
	{
		tBackType = 0;
	}
	return vFirstItemIndex;
}


// ***********************************************************
//  Function:		HasItemOnIndex
//  Description:	查询道具,跨模块
//  Input:			unsigned int	vEntityID		实体ID
//					unsigned int	vItemID			道具ID
//					unsigned int	vNumber			道具数量
//					int				nType			扣绑定/非绑定/全扣
//  OutPut:			bool							是否有 
//  Return:			检索到的第一个可用物品的格子索引
//  Others:
//  Date:	11/18/2008
// **********************************************************
bool CPropertyModule::HasItemOnIndex( unsigned int unEntityID, int nIndex, unsigned int unItemID, unsigned int unNumber, int nType /*= BIND_ALL*/ )
{
	CEntityPlayer* pPlayer = (CEntityPlayer*)SceneServer::CSceneLogic::GetSingletonPtr()->GetEntity( unEntityID );
	if( pPlayer == NULL )
	{
		LOG_ERROR( "default", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, unEntityID );
		return false;
	}

	CPropertyPlayer* pProPlayer =  (CPropertyPlayer*)pPlayer->GetProperty();

	return pProPlayer->GetBaggage()->HasItem( nIndex, unItemID, unNumber, nType );
}




// 
// ***********************************************************
//  Function:		GetItemNumOnIndex
//  Description:	查询道具数量
//  Input:			unsigned int	vEntityID		实体ID
//					unsigned int	nIndex			索引
//					int				nType			扣绑定/非绑定/全扣
//  OutPut:			
//  Return:			返回指定索引上的道具个数
//  Others:
//  Date:	11/18/2008
// **********************************************************
int CPropertyModule::GetItemNumOnIndex( unsigned int unEntityID, unsigned int unItemID, int nIndex, int nType /*= BIND_ALL*/ )
{
	CEntityPlayer* pPlayer = (CEntityPlayer*)SceneServer::CSceneLogic::GetSingletonPtr()->GetEntity( unEntityID );
	if( pPlayer == NULL )
	{
		LOG_ERROR( "default", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, unEntityID );
		return false;
	}

	CPropertyPlayer* pProPlayer =  (CPropertyPlayer*)pPlayer->GetProperty();

	return pProPlayer->GetBaggage()->GetItemNum( nIndex, unItemID, nType );
}

// ***********************************************************
//  Function:		DestroyTripEntity
//  Description:	销毁陷阱实体
//  Input:			unsigned int	tSrcEntityID		陷阱释放者实体ID
//					unsigned int	tTripEntityID		陷阱实体ID
//  OutPut:			bool&			bIsOK				是否成功
//  Return:			
//  Others:
//  Date:	11/18/2008
// **********************************************************
//void CPropertyModule::DestroyTripEntity( unsigned int tSrcEntityID, unsigned int tTripEntityID, bool& bIsOK )
//{
//	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )CProperty::SearchProByEntityID( tSrcEntityID );
//	if ( tpSrcProperty == NULL )
//	{
//		bIsOK = false;
//		return;
//	}
//
//	if ( tpSrcProperty->ClearAddTripEntityID( tTripEntityID ) == true )
//	{
//		bIsOK = true;
//		return;
//	}
//	bIsOK = false;
//}

// ***********************************************************
//  Function:		DisplayTripPlayerAddTeam
//  Description:	当玩家加入队伍的时候,把队伍中的陷阱给玩家显示
//  Input:			CEntityPlayer*		pSrcEntity			源实体
//					CEntityPlayer**		pTeamMemberList		队伍实体列表
//					int					vTeamNum			队伍人数
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::DisplayTripPlayerAddTeam( CEntityPlayer* pSrcEntity, CEntityPlayer** pTeamMemberList, int vTeamNum )
{
	LK_ASSERT( pTeamMemberList != NULL && pSrcEntity != NULL && vTeamNum <= TEAMNUM && vTeamNum > 0 , return );

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pSrcEntity->GetProperty();
	if ( tpSrcProperty == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] display trip entity to player who join team error : can't find SrcProperty : tSrcEntityID ( %d )", __LK_FILE__, __LINE__, __FUNCTION__, pSrcEntity->GetEntityID() );
		return;
	}

	// 源玩家是否有陷阱
	for ( int i = 0; i < MAX_TRIP_ENTITY; i++ )
	{
		if ( tpSrcProperty->GetTripEntityIDList( i ).mTripEntityID == 0 )
			continue;

		CEntityPedal* tpEntityPedal = (CEntityPedal*) CSceneLogic::GetSingleton().GetEntity( tpSrcProperty->GetTripEntityIDList( i ).mTripEntityID );
		if ( tpEntityPedal == NULL )
			continue;

		//CEntityPlayer* pEntityList[ TEAMNUM ] = { NULL };
		//int tListCount = 0;
		std::vector<CEntityPlayer*> tTeamVec;
		bool bIsSend = false;

		for ( int j = 0; j < vTeamNum && j < TEAMNUM; j++ )
		{
			if ( pTeamMemberList[ j ] == NULL )
				break;

			if ( pTeamMemberList[ j ] == pSrcEntity )
				continue;

			if ( tpEntityPedal->IsWithinViewDistance( pTeamMemberList[ j ] ) == false )
				continue;

			//pEntityList[ tListCount ] = pTeamMemberList[ j ];
			//tListCount++;
			tTeamVec.push_back( pTeamMemberList[ j ] );
			bIsSend = true;
		}

		if ( bIsSend == true )
		{
			SendTripEntityDisplay( &tTeamVec, tpEntityPedal );
		}
	}

	// 队伍中队员是否有陷阱
	for ( int i = 0; i < vTeamNum && i < TEAMNUM; i++ )
	{
		if ( pTeamMemberList[ i ] == NULL )
			continue;
		if ( pTeamMemberList[ i ] == pSrcEntity )
			continue;

		CPropertyPlayer* tpTeamMemberProperty = ( CPropertyPlayer* ) pTeamMemberList[ i ]->GetProperty();
		if ( tpTeamMemberProperty == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] display trip entity to player who join team error : can't find TeamMemberProperty : TeamMemberID ( %d )", __LK_FILE__, __LINE__, __FUNCTION__, pTeamMemberList[ i ]->GetEntityID() );
			continue;
		}

		// 目标队友是否有陷阱存在
		for ( int k = 0; k < MAX_TRIP_ENTITY; k++ )
		{
			if ( tpTeamMemberProperty->GetTripEntityIDList( k ).mTripEntityID == 0 )
				continue;

			CEntityPedal* tpEntityPedal = (CEntityPedal*) CSceneLogic::GetSingleton().GetEntity( tpTeamMemberProperty->GetTripEntityIDList( k ).mTripEntityID );
			if ( tpEntityPedal == NULL )
				continue;

			if ( tpEntityPedal->IsWithinViewDistance( pSrcEntity ) == false )
				continue;

			SendTripEntityDisplay( pSrcEntity, tpEntityPedal );
		}
	}
}

// ***********************************************************
//  Function:		发送显示陷阱的消息
//  Description:	SendTripEntityDisplay
//  Input:			CEntityPlayer*		pPlayer
//					unsigned int		vPedalID
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/16/2008
// **********************************************************
void CPropertyModule::SendTripEntityDisplay( CEntityPlayer* pPlayer, CEntityPedal* pEntityPedal )
{
	LK_ASSERT( pPlayer != NULL && pEntityPedal != NULL, return );

	static CMessageCreateNpcProNotice tCreateNpc;
	static CMessage tMessage;

	tCreateNpc.Clear();
	tMessage.Clear();

	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CREATENPC );
	tMessage.set_msgpara( (uint32)&tCreateNpc );

	CNpcProInfo* tpProInfo = tCreateNpc.add_npclist();
	if ( tpProInfo == NULL )
		return;

	tpProInfo->set_entityid( pEntityPedal->GetEntityID() );
	tpProInfo->set_npcid( pEntityPedal->GetNpcID( ) );
	tpProInfo->set_npctype( pEntityPedal->GetEntityType() );
	tpProInfo->set_posx( pEntityPedal->GetPosX() );
	tpProInfo->set_posy( pEntityPedal->GetPosY() );
	tpProInfo->set_direction( pEntityPedal->GetDirection() );
	tpProInfo->set_alivestate( pEntityPedal->GetSkillID() );
	tpProInfo->set_motionstate( pEntityPedal->GetSkillLevel() );
	//tpProInfo->set_skillid( pEntityPedal->GetSkillID() );
	//tpProInfo->set_skilllevel( pEntityPedal->GetSkillLevel() );
	tpProInfo->set_pedaltype( pEntityPedal->GetPedalType() );

	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}


void CPropertyModule::SendTripEntityDisplay(std::vector<CEntityPlayer*>* pTeamVec, CEntityPedal* pEntityPedal )
{
	LK_ASSERT( pTeamVec != NULL && pEntityPedal != NULL && pTeamVec->empty() != true, return );

	static CMessageCreateNpcProNotice tCreateNpc;
	static CMessage tMessage;

	tCreateNpc.Clear();
	tMessage.Clear();

	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CREATENPC );
	tMessage.set_msgpara( (uint32)&tCreateNpc );

	CNpcProInfo* tpProInfo = tCreateNpc.add_npclist();
	if ( tpProInfo == NULL )
		return;

	tpProInfo->set_entityid( pEntityPedal->GetEntityID() );
	tpProInfo->set_npcid( pEntityPedal->GetNpcID( ) );
	tpProInfo->set_npctype( pEntityPedal->GetEntityType() );
	tpProInfo->set_posx( pEntityPedal->GetPosX() );
	tpProInfo->set_posy( pEntityPedal->GetPosY() );
	tpProInfo->set_direction( pEntityPedal->GetDirection() );
	tpProInfo->set_alivestate( pEntityPedal->GetSkillID() );
	tpProInfo->set_motionstate( pEntityPedal->GetSkillLevel() );
	//tpProInfo->set_skillid( pEntityPedal->GetSkillID() );
	//tpProInfo->set_skilllevel( pEntityPedal->GetSkillLevel() );
	tpProInfo->set_pedaltype( pEntityPedal->GetPedalType() );

	CSceneLogic::GetSingleton().Send2Player( pTeamVec, &tMessage );
}


// ***********************************************************
//  Function:		发送陷阱消息的消息
//  Description:	SendTripEntityDisappear
//  Input:			CEntityPlayer*		pPlayer
//					unsigned int		vPedalID
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/16/2008
// **********************************************************
void CPropertyModule::SendTripEntityDisappear( CEntityPlayer* pPlayer, CEntityPedal* pEntityPedal )
{
	LK_ASSERT( pPlayer != NULL && pEntityPedal != NULL, return );

	static CMessageDestroyEntityNotice tDestroyDesEntity;
	static CMessage tMessage;

	tDestroyDesEntity.Clear();
	tMessage.Clear();

	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_DESTROYENTITY );
	tMessage.set_msgpara( (uint32)&tDestroyDesEntity );

	tDestroyDesEntity.add_entityid( pEntityPedal->GetEntityID() );
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::SendTripEntityDisappear( std::vector<CEntityPlayer*>* pTeamVector, CEntityPedal* pEntityPedal )
{
	LK_ASSERT( pTeamVector != NULL && pEntityPedal != NULL && pTeamVector->empty() != true , return );

	static CMessageDestroyEntityNotice tDestroyDesEntity;
	static CMessage tMessage;

	tDestroyDesEntity.Clear();
	tMessage.Clear();

	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_DESTROYENTITY );
	tMessage.set_msgpara( (uint32)&tDestroyDesEntity );

	tDestroyDesEntity.add_entityid( pEntityPedal->GetEntityID() );

	CSceneLogic::GetSingleton().Send2Player( pTeamVector, &tMessage );
}


// 发送玩家点击内丹的回复消息
void CPropertyModule::SendClickRedStone( CEntityPlayer *pPlayer, int EntityID, int Result )
{
	if ( pPlayer == NULL )
	{
		return;
	}
	CMessage						MessageHead;
	CMessageClickRedStoneResponse   MsgClickRedStone;
	
	MsgClickRedStone.set_result( Result );
	MsgClickRedStone.set_redstoneid( EntityID );	
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_CLICKREDSTONDE );
	MessageHead.set_msgpara( ( int )&MsgClickRedStone );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &MessageHead );
	// TODO:	可能要发送给队伍里面的人
}
// ***********************************************************
//  Function:		SendStopRedStoneTimer
//  Description:	通知客户端停止内丹读秒
//  Input:						
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::SendStopRedStoneTimer( CEntityPlayer *pPlayer, int EntityId ) 
{
	if ( pPlayer == NULL )
	{
		return;
	}
	
	CMessage MessageHead;
	CMessageStopRedStoneTimer MsgStopRedStoneTimer;
	MsgStopRedStoneTimer.set_redstoneid( EntityId );
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_STOPRENDSTONETIMEER ) ;
	MessageHead.set_msgpara( (int)&MsgStopRedStoneTimer );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &MessageHead );
}


// ***********************************************************
//  Function:		SendStopRedStoneTimer
//  Description:	通知客户端停止内丹读秒
//  Input:						
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::SendChangeStatus( CEntityPlayer *pPlayer, int Status )
{
	if ( pPlayer == NULL )
	{
		return;
	}
	CMessageChangeRestoneStaus MsgChangeStatus;
	CMessage				   MsgHead;
	MsgChangeStatus.set_entityid( pPlayer->GetEntityID() );
	MsgChangeStatus.set_status( Status );
	MsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEREDSTONESTATUS);
	MsgHead.set_msgpara( (int)&MsgChangeStatus );
	CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer,& MsgHead , false, true );
}

// ***********************************************************
//  Function:		SendMsgRedstoneStarted
//  Description:	发送内丹成功开启噬炼的消息
//  Input:						
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	03/23/2008
// **********************************************************
void CPropertyModule::SendMsgRedstoneStarted( CEntityPlayer *pPlayer, int TeamID )
{
	LK_ASSERT( pPlayer != NULL, return );
	if ( TeamID == 0 )
	{
		return;
	}
	CMessage MessageHead;
	CMessageRedstoneStarted MsgRedstoneStated;
	MsgRedstoneStated.set_name( pPlayer->GetCharName() );
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_REDSTONESTATRED );
	MessageHead.set_msgpara( (int)&MsgRedstoneStated );
	
	CEntityPlayer  *TeamMember[TEAMNUM] ={ 0 };	
	int tRtn = 0, tTeamNum = 0;
	tRtn = CTeamModule::GetSingletonPtr()->OnGetMemberList( TeamID,TeamMember, ARRAY_CNT( TeamMember ), tTeamNum );
	if ( tRtn < 0 )
	{
		return ;
	}
	
	for ( int i =0 ; i < tTeamNum; i++ )
	{	
		if ( TeamMember[i] == NULL )
		{
			break;
		}	
		CSceneLogic::GetSingleton().Send2Player( TeamMember[i], &MessageHead ); 
	}	
}

// ***********************************************************
//  Function:		DisappearTripPlayerLeaveTeam
//  Description:	当玩家离开队伍的时候,把队伍中的陷阱从玩家视野中消失,跨模块
//  Input:			CEntityPlayer*		pSrcEntity			源实体
//					CEntityPlayer**		pTeamMemberList		队伍实体列表
//					int					vTeamNum			队伍人数
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::DisappearTripPlayerLeaveTeam( CEntityPlayer* pSrcEntity, CEntityPlayer** pTeamMemberList, int vTeamNum )
{
	LK_ASSERT( pTeamMemberList != NULL && pSrcEntity != NULL && vTeamNum > 0 && vTeamNum <= TEAMNUM, return );

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pSrcEntity->GetProperty();
	if ( tpSrcProperty == NULL || pSrcEntity->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] disappear trip entity to player who leave team error : can't find SrcProperty : tSrcEntityID ( %d )", __LK_FILE__, __LINE__, __FUNCTION__, pSrcEntity->GetEntityID() );
		return;
	}


	// 源玩家是否有陷阱
	for ( int i = 0; i < MAX_TRIP_ENTITY; i++ )
	{
		if ( tpSrcProperty->GetTripEntityIDList( i ).mTripEntityID == 0 )
			continue;

		CEntityPedal* tpEntityPedal = (CEntityPedal*) CSceneLogic::GetSingleton().GetEntity( tpSrcProperty->GetTripEntityIDList( i ).mTripEntityID );
		if ( tpEntityPedal == NULL )
			continue;

	/*	CEntityPlayer* pEntityList[ TEAMNUM ] = { NULL };
		int tListCount = 0;*/
		std::vector<CEntityPlayer*> tTeamVec; 
		
		bool bIsSend = false;

		for ( int j = 0; j < vTeamNum && j < TEAMNUM; j++ )
		{
			if ( pTeamMemberList[ j ] == NULL )
				break;

			if ( pTeamMemberList[ j ] == pSrcEntity )
				continue;

			if ( tpEntityPedal->IsWithinViewDistance( pTeamMemberList[ j ] ) == false )
				continue;

			//pEntityList[ tListCount ] = pTeamMemberList[ j ];
			//tListCount++;
			tTeamVec.push_back( pTeamMemberList[ j ] );
			bIsSend = true;
		}

		if ( bIsSend == true )
		{
			SendTripEntityDisappear( &tTeamVec, tpEntityPedal );
		}
	}

	// 队伍中队员是否有陷阱
	for ( int i = 0; i < vTeamNum && i < TEAMNUM; i++ )
	{
		if ( pTeamMemberList[ i ] == NULL )
			continue;
		if ( pTeamMemberList[ i ] == pSrcEntity )
			continue;

		CPropertyPlayer* tpTeamMemberProperty = ( CPropertyPlayer* ) pTeamMemberList[ i ]->GetProperty();
		if ( tpTeamMemberProperty == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] display trip entity to player who join team error : can't find TeamMemberProperty : TeamMemberID ( %d )", __LK_FILE__, __LINE__, __FUNCTION__, pTeamMemberList[ i ]->GetEntityID() );
			continue;
		}

		// 目标队友是否有陷阱存在
		for ( int k = 0; k < MAX_TRIP_ENTITY; k++ )
		{
			if ( tpTeamMemberProperty->GetTripEntityIDList( k ).mTripEntityID == 0 )
				continue;

			CEntityPedal* tpEntityPedal = (CEntityPedal*) CSceneLogic::GetSingleton().GetEntity( tpTeamMemberProperty->GetTripEntityIDList( k ).mTripEntityID );
			if ( tpEntityPedal == NULL )
				continue;

			if ( tpEntityPedal->IsWithinViewDistance( pSrcEntity ) == false )
				continue;

			SendTripEntityDisappear( pSrcEntity, tpEntityPedal );
		}
	}
}

// ***********************************************************
//  Function:		DisappearTripTeamDisband
//  Description:	当队伍解散的时候,把队伍成员中各自陷阱从其他队员的视野中消失,跨模块
//  Input:			CEntityPlayer**		pTeamMemberList		队伍实体列表
//					int					vTeamNum			队伍人数
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::DisappearTripTeamDisband( CEntityPlayer** pTeamMemberList, int vTeamNum )
{
	LK_ASSERT( pTeamMemberList != NULL && vTeamNum > 0 && vTeamNum <= TEAMNUM, return );

	if ( vTeamNum <= 1 )
		return;

	for ( int i = 0; i < vTeamNum && i < TEAMNUM; i++ )
	{
		CEntityPlayer* tpSrcEntity = pTeamMemberList[ i ];
		if ( tpSrcEntity == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] disappear trip entity to player when team disband error : why can't find srcentity", __LK_FILE__, __LINE__, __FUNCTION__ );
			continue;
		}

		if( tpSrcEntity->GetEntityType() != ENTITYTYPE_PLAYER )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Entity( %d ) isn't player, type is %d", __LK_FILE__, __LINE__,
					__FUNCTION__, tpSrcEntity->GetEntityID( ), tpSrcEntity->GetEntityType() );
			continue;
		}

		CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) tpSrcEntity->GetProperty();
		if ( tpSrcProperty == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] disappear trip entity to player when team disband error : why can't find srcproperty : SrcEntityID ( %d )\n", __LK_FILE__, __LINE__, __FUNCTION__, tpSrcEntity->GetEntityID() );
			continue;
		}

		for ( int j = 0; j < MAX_TRIP_ENTITY; j++ )
		{
			if ( tpSrcProperty->GetTripEntityIDList( j ).mTripEntityID == 0 )
				continue;

			CEntityPedal* tpEntityPedal = (CEntityPedal*) CSceneLogic::GetSingleton().GetEntity( tpSrcProperty->GetTripEntityIDList( j ).mTripEntityID );
			if ( tpEntityPedal == NULL )
				continue;

			//CEntityPlayer* pEntityList[ TEAMNUM ] = { NULL };
			//int tListCount = 0;
			std::vector<CEntityPlayer*> tTeamVec;
			
			bool bIsSend = false;

			for ( int n = 0; n < TEAMNUM; n++ )
			{
				if ( pTeamMemberList[ i ] == pTeamMemberList[ n ] )
					continue;

				CEntityPlayer* tpDesEntity = pTeamMemberList[ n ];
				if ( tpDesEntity == NULL )
					break;

				if ( tpEntityPedal->IsWithinViewDistance( tpDesEntity ) == false )
					continue;

				//pEntityList[ tListCount ] = pTeamMemberList[ n ];
				//tListCount++;
				tTeamVec.push_back( pTeamMemberList[ n ] );
				bIsSend = true;
			}

			if ( bIsSend == true )
			{
				SendTripEntityDisappear( &tTeamVec, tpEntityPedal );
			}
		}
	}
}

// ***********************************************************
//  Function:		RemoveDamage
//  Description:	离开视野范围的时候,清除双方的伤害列表,跨模块
//  Input:			unsigned int	tSrcEntityID	源实体ID
//					unsigned int	tDesEntityID	目标实体ID
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/18/2008
// **********************************************************
void CPropertyModule::RemoveDamage( unsigned int tSrcEntityID, unsigned int tDesEntityID )
{
	CEntity* tpSrcEntity = CSceneLogic::GetSingletonPtr()->GetEntity( tSrcEntityID );
	if ( tpSrcEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]remove damage error : can't find SrcEntity : tSrcEntityID ( %d )", 
				__LK_FILE__, __LINE__, __FUNCTION__, tSrcEntityID );
		return;
	}

	if( !tpSrcEntity->IsCharacter() )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) Is not Character, type is %d", __LK_FILE__, __LINE__, 
				__FUNCTION__, tpSrcEntity->GetEntityID( ), tpSrcEntity->GetEntityType() );
		return ;
	}
	CPropertyCharacter* tpSrcProperty = ( CPropertyCharacter* ) tpSrcEntity->GetProperty();
	if ( tpSrcProperty == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]remove damage error : can't find SrcProperty : tSrcEntityID ( %d )", 
				__LK_FILE__, __LINE__, __FUNCTION__, tSrcEntityID );
		return;
	}

	CEntity* tpDesEntity = CSceneLogic::GetSingletonPtr()->GetEntity( tDesEntityID );
	if ( tpSrcEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]remove damage error : can't find DesEntity : tDesEntityID ( %d )", 
				__LK_FILE__, __LINE__, __FUNCTION__, tDesEntityID );
		return;
	}
	if( !tpDesEntity->IsCharacter() )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) Is not Character, type is %d", __LK_FILE__, __LINE__, 
				__FUNCTION__, tpSrcEntity->GetEntityID( ), tpSrcEntity->GetEntityType() );
		return;
	}
	CPropertyCharacter* tpDesProperty = ( CPropertyCharacter* ) tpDesEntity->GetProperty();
	if ( tpSrcProperty == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ]remove damage error : can't find DesProperty : tDesEntityID ( %d )", 
				__LK_FILE__, __LINE__, __FUNCTION__, tDesEntityID );
		return;
	}

	CDamageList *tpSrcList = tpSrcProperty->GetDamageList( );
	tpSrcList->RemoveDamage( tDesEntityID );
	CDamageList *tpDesList = tpDesProperty->GetDamageList( );
	tpDesList->RemoveDamage( tSrcEntityID );
}

void CPropertyModule::SummonBeastLevelUp( CEntity* vpSrcEntity, unsigned int vTickOffset,  bool bBroadCast/* = true */)
{
	if ( vpSrcEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]\n", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	// 必须是召唤兽
	if ( vpSrcEntity->IsPet() == false )
	{	
		return;
	}

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) vpSrcEntity->GetProperty();

	CEntityPet* tpPet = (CEntityPet*) vpSrcEntity;

	if ( tpPet->GetCurLevel( ) == CTemplateSummonBeast::PET_LEVEL_THREE )
	{
		return;
	}

	tpPet->SetOnlineTime( tpPet->GetOnlineTime( ) + vTickOffset );

	CTemplateSummonBeast* tpPetTpl = (CTemplateSummonBeast*) CDataStatic::SearchTpl( tpPet->GetNpcID( ) );
	if ( tpPetTpl == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]\n", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	// 判断召唤兽是否可以升到2级
	if (
			(int)tpPet->GetOnlineTime( ) >= tpPetTpl->mLevelUpDelayTime[ CTemplateSummonBeast::PET_LEVEL_TWO ] 
			&& (int)tpPet->GetOnlineTime( ) < tpPetTpl->mLevelUpDelayTime[ CTemplateSummonBeast::PET_LEVEL_THREE ]
	   )
	{
		if ( tpPet->GetCurLevel( ) != CTemplateSummonBeast::PET_LEVEL_TWO )
		{
			tpPet->SetCurLevel( CTemplateSummonBeast::PET_LEVEL_TWO );

			if( bBroadCast == true )
			{
				tpPet->AddFunResult( 0, FUNC_PETLEVELUP, RESULT_NORMAL, true, tpPet->GetCurLevel( ) );
				// 刷新属性
				pSrcProperty->Refresh( true );
				tpPet->NotifyPropertyRefresh();
			}

			return;
		}
	}

	// 判断召唤兽是否可以升到3级
	if ( (int)tpPet->GetOnlineTime( ) > tpPetTpl->mLevelUpDelayTime[ CTemplateSummonBeast::PET_LEVEL_THREE ] )
	{
		if ( tpPet->GetCurLevel( ) != CTemplateSummonBeast::PET_LEVEL_THREE )
		{
			tpPet->SetCurLevel( CTemplateSummonBeast::PET_LEVEL_THREE );

			if( bBroadCast == true ) 
			{
				tpPet->AddFunResult( 0, FUNC_PETLEVELUP, RESULT_NORMAL, true, tpPet->GetCurLevel( ) );
				// 刷新属性
				pSrcProperty->Refresh( true );
				tpPet->NotifyPropertyRefresh();
			}

			return;
		}
	}


}

void CPropertyModule::OnMessageUseSkillRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageUseSkillRequest* tpUseSkill = (CMessageUseSkillRequest*) pMessage->msgpara( );	   

	// 源默认为玩家
	CEntityCharacter* tpSrcEntity = pPlayer;

	// 得到源实体
	if( tpUseSkill->srcentityid() != 0 )
	{
		tpSrcEntity = dynamic_cast< CEntityPet* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
			tpUseSkill->srcentityid() ) );
		if( tpSrcEntity == NULL )
		{
			//TODO: 副本里先不打日志，太多了
#ifndef _FB_
			LOG_ERROR( "pro", "[%s:%d] can't find entityid %d, may be entity is not a pet", 
				__FUNCTION__, __LINE__, tpUseSkill->srcentityid() );
#endif 
			return;
		}
	}

	// 得到目标实体
	CEntity* tpDesEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		tpUseSkill->entityid( ) ) );
	if ( tpDesEntity == NULL )
		tpDesEntity = pPlayer;


	// 客户端传过来的实体,有可能为内丹或者陷阱这些非character实体,所以把这些实体赋值为玩家自己
	if ( tpDesEntity->IsCharacter() == false )
		tpDesEntity = pPlayer;

	CEntityCharacter* tpCharacter = ( CEntityCharacter* )tpDesEntity;

	//// TODO: 判断释放技能的坐标是否跟当前坐标一致,如果一致则不处理,不一致,则先处理移动
	//if ( tpSrcEntity->GetPosX( ) != (int)tpUseSkill->posx( ) || tpSrcEntity->GetPosY( ) != (int)tpUseSkill->posy( ) )
	//{
	//	return ;
	//	//PERF_FUNC( "Skill_Move", CMapModule::GetSingleton( ).OnEntityMove( tpSrcEntity, CWTPoint( tpUseSkill->posx( ), tpUseSkill->posy( ) ) ));
	//}

	if( tpSrcEntity->IsPlayer() )
	{
		// 使用技能停止读条
		StopProgress( pPlayer );
		
		// 判断玩家是否在骑乘状态,如果在骑乘状态要先通知客户端下马
		CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pPlayer->GetProperty( );
		if ( tpProPlayer->GetHorseState( ) != 0 )
		{
			// 最新要求：改为使用技能先下马
			CTplItemHorse* pTplHorse = (CTplItemHorse*)CDataStatic::SearchTpl( tpProPlayer->GetHorseTempID() );
			if ( pTplHorse == NULL )
			{
				LOG_ERROR("pro", "can't find horse?? in use skill. tempid=%d", tpProPlayer->GetHorseTempID() );
			}
			else
			{
				// 如果是飞行坐骑则不下马
				CTemplateBuff *tpBuff = (CTemplateBuff*)CDataStatic::SearchTpl( pTplHorse->mSpeedBuff );
				bool tOffHorse = true;
				if ( tpBuff != NULL )
				{
					for ( unsigned int i = 0; i < ARRAY_CNT(tpBuff->mBuff); i++ )
					{
						if ( tpBuff->mBuff[ i ].mBuffFunc == CTemplateBuff::BUFFFUNC_FLY )
						{
							tOffHorse = false;
							break;
						}
					}
				}
				if ( tOffHorse == true )
				{
					tpProPlayer->OffHorse( pTplHorse->mSpeedBuff );
					SendRideHorseNotice( pPlayer, pTplHorse->mTempID, 0 );
				}				
			}
		}
	}

	int tListNum = tpUseSkill->entityidlist_size( );
	if ( tListNum > 0 )
	{
		// 提取范围攻击作用实体列表
		CEntityCharacter* tEntityList[ FUNC_LIMIT ] = { NULL };
		int tEntityIndex = 0;
		for ( int i = 0; i < tListNum && i < FUNC_LIMIT; i++ )
		{
			CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject(
 				tpUseSkill->entityidlist( i ) ) );
			if ( tpEntity == NULL )
				continue;

			// 被攻击实体只能为CHARACTER及其子类
			if (tpEntity->IsCharacter() == false )
				continue;

			CEntityCharacter* tpEntityCharacter = (CEntityCharacter*) tpEntity;

			tEntityList[ tEntityIndex ] = tpEntityCharacter;
			tEntityIndex++;
		}

		UseSkill( tpSrcEntity, tpCharacter, tpUseSkill->skillid( ), 0, tpUseSkill->listid( ), tpUseSkill->index( ), tEntityList, tEntityIndex, (tpUseSkill->ismagicweapon()==1) );
	} 
	else
	{
		UseSkill( tpSrcEntity, tpCharacter, tpUseSkill->skillid( ), 0, tpUseSkill->listid( ), tpUseSkill->index( ), NULL, 0, (tpUseSkill->ismagicweapon()==1) );
	}
	
}



void CPropertyModule::OnMessagePickItemRequest(  CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePickItemRequest* tpPickItem = (CMessagePickItemRequest*) pMessage->msgpara( );
	if ( tpPickItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	PlayerPickItem( pPlayer, tpPickItem->entityid() );
}

void CPropertyModule::OnMseeageClickNpcRequest(  CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageClickNpcRequest* tpClickNpc = (CMessageClickNpcRequest*) pMessage->msgpara( );
	if ( tpClickNpc == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	if ( tpProperty->GetServiceStatus() == SERVICE_STALL || tpProperty->GetServiceStatus() == SERVICE_TRADE )
	{
		return ;
	}

	PlayerClickNpc( pPlayer, tpClickNpc->entityid() );
	ResultListSend(  );
}

//void CPropertyModule::OnMessageClickShopServiceRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL  )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickShopServiceRequest* tpShopService = (CMessageClickShopServiceRequest*) pMessage->msgpara( );
//	if ( tpShopService == NULL )
//	{
//		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerClickShop( pPlayer, tpShopService->entityid() );
//}
//
//void CPropertyModule::OnMessageClickMailService( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickMailServiceRequest* tpMailService = (CMessageClickMailServiceRequest*) pMessage->msgpara( );
//	if ( tpMailService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerClickMail( pPlayer, tpMailService->entityid() );
//}
//
//void CPropertyModule::OnMessageClickStorageServiceRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL  )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickStorageServiceRequest* tpStorageService = (CMessageClickStorageServiceRequest*) pMessage->msgpara( );
//	if ( tpStorageService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerClickStorage( pPlayer, tpStorageService->entityid() );
//}
//
//void CPropertyModule::OnMessageClickUpgService( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL  )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickUpgServiceRequest* tpUpgService = (CMessageClickUpgServiceRequest*) pMessage->msgpara( );
//	if ( tpUpgService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerClickUpg( pPlayer, tpUpgService->entityid() );
//}
//
//void CPropertyModule::OnMessageClickTeleServiceRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL  )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickTeleServiceRequest* tpTeleService = (CMessageClickTeleServiceRequest*) pMessage->msgpara( );
//	if ( tpTeleService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerClickTele( pPlayer, tpTeleService->entityid() );
//}
//
//void CPropertyModule::OnMessageClickBindServiceRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL)
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickBindSeviceRequest* tpClickService = ( CMessageClickBindSeviceRequest* ) pMessage->msgpara( );
//	if ( tpClickService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//	PlayerClickBind( pPlayer, tpClickService->entityid() );
//}
//

// 玩家点击内丹的请求
void CPropertyModule::OnMessageClickRedStoneRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageClickRedStoneRequest *tpMsg = ( CMessageClickRedStoneRequest * ) pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		return;
	}
	PlayerClickRedStone( pPlayer, tpMsg->redstoneid() );
}

// 内丹读秒结束的请求
void CPropertyModule::OnMessageRedStoneTimerEnd( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL  || pMessage == NULL )
	{
		return;
	}
	CMessageRedStoneTimerEnd *tpMsg =( CMessageRedStoneTimerEnd * )	pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		return;
	}
	StopRedStonTimer( pPlayer, tpMsg->redstoneid() );	
}

//void CPropertyModule::OnMessageClickWelfare( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickWelfareRequest* tpClickService = ( CMessageClickWelfareRequest* ) pMessage->msgpara( );
//	if ( tpClickService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//	PlayerClickWelfare( pPlayer, tpClickService->entityid() );
//}
//

void CPropertyModule::OnMessagePurchaseItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePurchaseItemRequest* tpPurchaseItem = (CMessagePurchaseItemRequest*) pMessage->msgpara( );
	if ( tpPurchaseItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	PlayerPurchase( pPlayer, tpPurchaseItem->entityid(), tpPurchaseItem->pageindex(), tpPurchaseItem->itemindex(), tpPurchaseItem->number(), tpPurchaseItem->entityid() );
}



void CPropertyModule::OnMessageSellItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageSellItemRequest* tpSellItem = (CMessageSellItemRequest*) pMessage->msgpara( );
	if ( tpSellItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	PlayerSellItem( pPlayer, tpSellItem->entityid(), tpSellItem->itemindex(), tpSellItem->number() );
}

//************************************
// Method:    OnMessageThrowItemRequest
// FullName:  CPropertyModule::OnMessageThrowItemRequest
// Access:    public 
// Returns:   void
// Qualifier: 丢地上直接销毁
// Parameter: CEntityPlayer * pPlayer
// Parameter: CMessage * pMessage
//************************************
void CPropertyModule::OnMessageThrowItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageThrowItemRequest* tpThrowItem = (CMessageThrowItemRequest*) pMessage->msgpara( );
	if ( tpThrowItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	//PlayerThrowItem( pPlayer, tpThrowItem->itemindex(), tpThrowItem->number() );
	PlayerDestroyItem(  pPlayer, tpThrowItem->itemindex(), tpThrowItem->number() );
}

//void CPropertyModule::OnMessageThrowMoneyRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL )
//	{
//		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageThrowMoneyRequest* tpThrowItem = (CMessageThrowMoneyRequest*) pMessage->msgpara( );
//	if ( tpThrowItem == NULL )
//	{
//		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerThrowMoney( pPlayer, tpThrowItem->number() );
//}

void CPropertyModule::OnMessageSetShortcutRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageSetShortcutRequest* tpSetShortcut = (CMessageSetShortcutRequest*) pMessage->msgpara( );
	if ( tpSetShortcut == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	PlayerSetShortcut( pPlayer, tpSetShortcut->shortcut(), tpSetShortcut->type(), tpSetShortcut->index(), tpSetShortcut->labeltype(), tpSetShortcut->labelindex(), tpSetShortcut->param1() );
}

void CPropertyModule::OnMessagePlayerReliveRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePlayerReliveRequest* tpRelive = (CMessagePlayerReliveRequest*) pMessage->msgpara( );
	if ( tpRelive == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	PlayerRelive( pPlayer, (ERelive)tpRelive->relivetype(), 0, 0 );
}

void CPropertyModule::OnMessageMoveItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageMoveItemRequest* tpMoveItem = (CMessageMoveItemRequest*) pMessage->msgpara( );
	if ( tpMoveItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}	   	

	// 距离和服务的判断
	if ( tpMoveItem->srcslot() == SLOT_STORAGE || tpMoveItem->desslot() == SLOT_STORAGE )
	{
		CEntityNpc* tpEntity = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMoveItem->npcid() ) );		
		if ( tpEntity == NULL )
		{
			LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) moves item ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMoveItem->npcid() );
			return;
		}
		if ( tpEntity->GetEntityType() != ENTITYTYPE_FUNCNPC )
		{
			LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) moves item ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMoveItem->npcid() );
			return;
		}

		// 服务判断
		CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
		CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );		
		if ( tpTmpNpc == NULL )
		{
			LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) moves item ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMoveItem->npcid() );
			return;	
		}
		if ( tpTmpNpc->mStorageService == 0 )
		{
			LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) moves item ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMoveItem->npcid() );
			return;
		}
		if ( pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) != true )
		{
			LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) moves item ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMoveItem->npcid() );
			return;
		}
	}

	MoveItem( pPlayer, tpMoveItem->srcindex(), tpMoveItem->srcslot(), tpMoveItem->desindex(), tpMoveItem->desslot(), tpMoveItem->number() );
}

void CPropertyModule::OnMessageProDebugNotice( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	////TODO: 临时代码,为了封测期间调试用，后面会干掉。帐号是zhanghl私人号码
	//if( pPlayer->GetAccountID() != 10905901 )
	//{
#ifndef _DEBUG_
		return;
#endif
	//}

	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageProDebugNotice* tpDebug = (CMessageProDebugNotice*) pMessage->msgpara( );

	if ( tpDebug->parameternumber() <= 0 )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	switch( tpDebug->command() )
	{
		// 转换职业
		case COMMAND_CHANGEMETIER:
			{
				if ( tpDebug->parameternumber() != 1 )
				{
					LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
					return;
				}
				int tMetierID = tpDebug->parameter( 0 );

				PlayerChangeMetier( pPlayer, tMetierID );
				break;
			}

			// 获得道具命令
		case COMMAND_INSERTITEM:
			{
				if ( tpDebug->parameternumber() != 2 )
				{
					LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
					return;
				}
				int tItemID = tpDebug->parameter( 0 );
				int tNumber = tpDebug->parameter( 1 );

				CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tItemID, tNumber, false );
				if ( pInsItemPile != NULL)
				{
					LogEventGetItemByGmInsert(pPlayer, pInsItemPile->GetGUID(), tItemID, tNumber);
				}
				break;
			}

			// 移动道具命令
		case COMMAND_MOVEITEM:
			{
				if ( tpDebug->parameternumber() != 5 )
				{
					LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
					return;
				}
				int tSrcIndex	= tpDebug->parameter( 0 );
				int tDesIndex	= tpDebug->parameter( 1 );
				int tSrcSlot	= tpDebug->parameter( 2 );
				int tDesSlot	= tpDebug->parameter( 3 );
				int tNumber		= tpDebug->parameter( 4 );

				MoveItem( pPlayer, tSrcIndex, tSrcSlot, tDesIndex, tDesSlot, tNumber );
				break;
			}

			// 装备道具指令
		case COMMAND_EQUIPITEM:
			{
				if ( tpDebug->parameternumber() != 1 )
				{
					LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
					return;
				}
				int tIndex	= tpDebug->parameter( 0 );

				EquipItem( pPlayer, tIndex );
				break;
			}

			// 卸下道具指令
		case COMMAND_UNEQUIPITEM:
			{
				if ( tpDebug->parameternumber() != 2 )
				{
					LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
					return;
				}
				int tPart	= tpDebug->parameter( 0 );
				unsigned int tIndex	= tpDebug->parameter( 1 );

				UnEquipItem( pPlayer, tPart, tIndex );
				break;
			}

			// 获得经验指令
		case COMMAND_OBTAINEXP:
			{
				if ( tpDebug->parameternumber() != 1 )
				{
					LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
					return;
				}
				int tExp	= tpDebug->parameter( 0 );
				int nTeamList[1] = {pPlayer->GetCharID()};
				int nFinalExp = PlayerObtainExp2( pPlayer, tExp, 0,  EXPREASON_TASK, nTeamList, 1  );
				if( nFinalExp > 0)
				{
					LogEventGetExpByCommand( pPlayer, tExp, nFinalExp);
				}
				break;
			}
		default:
			{
				SendProErrorNotice( pPlayer, ERROR_DEBUG_CMDNOTFOUND );
				break;
			}
	}
}

void CPropertyModule::OnMessageEquipItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageEquipItemRequest* tpEquipItem = (CMessageEquipItemRequest*) pMessage->msgpara( );
	if ( tpEquipItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	EquipItem( pPlayer, tpEquipItem->srcindex(), tpEquipItem->desindex() );
}

void CPropertyModule::OnMessageUnEquipItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageUnEquipItemRequest* tpUnEquipItem = (CMessageUnEquipItemRequest*) pMessage->msgpara( );
	if ( tpUnEquipItem == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	unsigned int idx= tpUnEquipItem->index();
	UnEquipItem( pPlayer, tpUnEquipItem->part(), idx );
}

void CPropertyModule::OnMessageClickSkillPointRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
}


void CPropertyModule::OnMessageResetSSPRequest( CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageResetSSPRequest* tpResetSPP = (CMessageResetSSPRequest*) pMessage->msgpara( );
	if ( tpResetSPP == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	// 此消息已不使用，为避免错误不处理
	//ResetSingleSP( pPlayer, tpResetSPP->generid(), tpResetSPP->col(), tpResetSPP->row() );
}

void CPropertyModule::OnMessageUseItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageUseItemRequest* tpUseItem = (CMessageUseItemRequest*) pMessage->msgpara( );
	if ( tpUseItem == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	// 保护状态检查
	// 摆摊情况下，禁止使用道具
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	if ( tpProperty->GetServiceStatus() == SERVICE_STALL )
	{
		return ;
	}	

	int tPos = tpUseItem->pos();
	// 如果是包裹
	if ( tPos == POS_BAGGAGE || tPos == POS_EQUIPMENT )
	{
		UseItem( pPlayer, tPos, tpUseItem->index(), tpUseItem->param() );
	}
	else if( tPos == POS_TASK_BAGGAGE )
	{
		UseTaskItem( pPlayer, tpUseItem->index() );
	}	
}

void CPropertyModule::OnMessageProduceEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )  
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageProduceEquipRequest* pMsg = ( CMessageProduceEquipRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	PlayerProduceEquip( pPlayer, pMsg->type1(), pMsg->type2(), pMsg->type3(), pMsg->level(), pMsg->rank(), pMsg->bind() );

	/*tpSrcProperty->GetProduce( )->mType1	= pMsg->type1();
	tpSrcProperty->GetProduce( )->mType2	= pMsg->type2();
	tpSrcProperty->GetProduce( )->mType3	= pMsg->type3();
	tpSrcProperty->GetProduce( )->mLevel	= pMsg->level();
	tpSrcProperty->GetProduce( )->mRank		= pMsg->rank();
	tpSrcProperty->GetProduce( )->mNumber	= pMsg->number();
	tpSrcProperty->GetProduce( )->mTimer	= pMsg->number()* 1500;*/
}

void CPropertyModule::OnMessageUpgAddItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageUpgAddItemRequest *pMsg = ( CMessageUpgAddItemRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex1 = tpSrcProperty->GetBaggage( )->mUpgIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mUpgIndex2;
	int tIndex3 = tpSrcProperty->GetBaggage( )->mUpgIndex3;
	int tResult = tpSrcProperty->GetBaggage( )->AddUpgItem( pMsg->index() );
	if ( tResult < 0 )
	{

		SendProErrorNotice( pPlayer, ERROR_PRONOTYPE );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tIndex3 >= 0 && tResult == 2 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex3, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex3, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_UPG ) == true )
		{

			SendUpgAddItemResponse( pPlayer, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_UPG );
		}
	}
}

void CPropertyModule::OnMessageUpgDelItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageUpgDelItemRequest *pMsg = ( CMessageUpgDelItemRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tResult = tpSrcProperty->GetBaggage( )->DelUpgItem( pMsg->index() );
	if ( tResult < 0 )
	{

		SendProErrorNotice( pPlayer, ERROR_PRONOTYPE );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{			
			SendUpgDelItemResponse( pPlayer, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}

//***********************************
// FunctionName : OnMessageUpgEquipRequests 
// Description  : b渖
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************

void CPropertyModule::OnMessageUpgEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageUpgEquipRequest* pMsg = ( CMessageUpgEquipRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tIndex[ UPG_ITEM_NUM ] = { -1 };
	for ( size_t i = 0; i < ARRAY_CNT(tIndex) && i < (size_t)pMsg->luckindex_size(); i++ )
	{
		tIndex[ i ] = pMsg->luckindex( i );
	}
	PlayerUpItem( pPlayer, pMsg->equipindex(), pMsg->itemindex(), tIndex, pMsg->type(), pMsg->npcentityid() );	
}

void CPropertyModule::OnMessageProducePhysRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	CMessageProducePhysRequest* pMsg = ( CMessageProducePhysRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	//PlayerProduceEquip( pPlayer, pMsg->type(), 0, 0, pMsg->number(), 0 );
}

void CPropertyModule::OnMessagePushRuneRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushRuneRequest *pMsg = ( CMessagePushRuneRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex1 = tpSrcProperty->GetBaggage( )->mRuneIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mRuneIndex2;
	int tResult = tpSrcProperty->GetBaggage( )->AddRuneItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_RUNE ) == true )
		{
			SendPushRuneResponse( pPlayer, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_RUNE );
		}
	}
}

void CPropertyModule::OnMessagePopRuneRequest( CEntityPlayer* pPlayer, CMessage* pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopRuneRequest *pMsg = ( CMessagePopRuneRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tResult = tpSrcProperty->GetBaggage( )->DelRuneItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{

			SendPopRuneResponse( pPlayer, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}

void CPropertyModule::OnMessageInsertRuneRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageInsertRuneRequest *pMsg = (CMessageInsertRuneRequest*)pMessage->msgpara( );
	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	PlayerInsertRune( pPlayer, pMsg->equipindex(), pMsg->runeindex() );
}

void  CPropertyModule::OnMessageChangeRuneRequest(CEntityPlayer* pPlayer,CMessage * pMessage)
{
	//回复 转换
	CMessage tMsg;
	CMessageResponseChangeRune tresponseMsg;
	int reasult =1;

	if (pPlayer == NULL || pMessage == NULL)
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CMessageRequestChangeRune *pMsg = ( CMessageRequestChangeRune* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}
	CItemObject *tItem = NULL;
	if ( pMsg->bagslot() == SLOT_BAGGAGE )
	{
		tItem = pProperty->GetBaggage()->GetItemObjPtr(   pMsg->runeindex());	
	}
	else if(  pMsg->bagslot() == SLOT_STORAGE )
	{	
		tItem = pProperty->GetStorage()->GetItemObjPtr(   pMsg->runeindex()); 	
	}
	else if (  pMsg->bagslot() == SLOT_BAGGAGEKITBAG )
	{
		tItem = pProperty->GetBaggage()->GetKitBagItemByIndex(   pMsg->runeindex() );
	}
	else if(  pMsg->bagslot() == SLOT_STORKITBAG )
	{
		tItem = pProperty->GetStorage()->GetKitBagItemByIndex(   pMsg->runeindex() );
	}

	if ( tItem == NULL )
	{
		//// 发送转换符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}

	CTplItem *tpItem = (CTplItem*)CDataStatic::SearchTpl( tItem->GetItemID() );
	if ( tpItem == NULL)
	{
		//// 发送转换符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}
	// 如果不是符文
	if ( tpItem->mItemType != CTplItem::ITEM_RUNE )
	{
		//// 发送转换符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}	

	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( pMsg->runechangeindex() );
	if ( tItem2 == NULL  )
	{
		return;
	}
	int isBind =  ITEM_BINDSTATUS_FREE;
	CTplItem *tpItem2 = ( CTplItem * )CDataStatic::SearchTpl( tItem2->GetItemID());
	LK_ASSERT( tpItem2 != NULL, return  )
	if( tpItem2->mItemType != CTplItem::ITEM_FUNCITEM )
	{		 	
		return;
	}	   
	CTplFuncItem *tpTplFuncItem = ( CTplFuncItem * )tpItem2;
	if ( tpTplFuncItem->mFuncCode != FUNCCODE_CHANGERUNE )
	{
		return;
	}
	if (tItem2->GetBindStatus() == ITEM_BINDSTATUS_BINDED)
	{
		isBind =  ITEM_BINDSTATUS_BINDED;
	}
	if(tpItem2->mLevel != tpItem->mLevel)
	{
		//// 发送转换符文的错误通知
		SendProErrorNotice( pPlayer, ERROR_RUNENOTYPE );
		return;
	}


	////替换符文	
	CTplItemRune *tpRune = (CTplItemRune*)tpItem;
	if (tpRune)
	{
		int randtempid =0;
		randtempid =  CDataStatic::GetChangeRandRuneId( tpRune->mLevel, tItem->GetItemID() );
		CTplItem *tpItem3 = (CTplItem*)CDataStatic::SearchTpl( randtempid );
		//CItemObject* tpItemObj = NULL;
		if (tpItem3)
		{
			//创建新的道具对象
			// 直接从对象池上创建对象
			//int nCreateResult = CreateItem(tpItem3,1,tpRune->mLevel,&tpItemObj);
			//// 如果创建失败
			//if ( nCreateResult != 0)
			//{
			//	return ;
			//}
			//消除原来符文 并得到新的符文
			//uint64_t ullGUID = 0 ;
			bool  backresult =  False;
			if ( pMsg->bagslot() == SLOT_BAGGAGE )// pMsg->bagslot() == SLOT_BAGGAGEKITBAG)
			{
				backresult = pProperty->GetBaggage()->ChangeItemByIndex(pMsg->runeindex(),randtempid,isBind);
			}
			else if(  pMsg->bagslot() == SLOT_STORAGE )
			{	
				backresult =  pProperty->GetStorage()->ChangeItemByIndex(pMsg->runeindex(),randtempid,isBind);	
			}
			else if (  pMsg->bagslot() == SLOT_BAGGAGEKITBAG )
			{
				 backresult = pProperty->GetBaggage()->ChangeKitBagItemByIndex(pMsg->runeindex(),randtempid,isBind);	
			}
			else if(  pMsg->bagslot() == SLOT_STORKITBAG )
			{
				 backresult =  pProperty->GetStorage()->ChangeKitBagItemByIndex(pMsg->runeindex(),randtempid,isBind);	
			}
			if (backresult)
			{
				////消除转换符文
				uint64_t ullGUID2 = 0 ;
				if(PlayerRemoveItem( pPlayer, pMsg->runechangeindex() , 1, &ullGUID2) == 0)
				{
					if (isBind ==  ITEM_BINDSTATUS_BINDED)
					{
						SendBindItemNotify( pPlayer, pMsg->runeindex(), ITEM_BINDSTATUS_BINDED );
					}
					
					LogEventLostItemByUse(pPlayer, ullGUID2, tItem->GetItemID(), 1);
					reasult  = SUCCESS;
				}
				
			}
			tresponseMsg.set_srcitemid(randtempid);
			tresponseMsg.set_runeindex(pMsg->runeindex());
			tresponseMsg.set_bagslot( pMsg->bagslot());
		}
	}
	tresponseMsg.set_result(reasult);			
	tMsg.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_CHANGERUNE);
	tMsg.set_msgpara((uint32_t) &tresponseMsg);

	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &tMsg );
}

//处理 玩家 发送升级符消息
void CPropertyModule::OnMessageRuneComRequest( CEntityPlayer* pPlayer,CMessage* pMessage)
{
	if (pPlayer == NULL || pMessage == NULL)
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CMessageRequestRuneCom *pMsg = ( CMessageRequestRuneCom* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}
	//统计白色有多少个数据
	//判断是否有转阵营道具
	CTemplateComRuneCfg *tpConfig = (CTemplateComRuneCfg*)CDataStatic::GetTemp( TEMP_RUNECOMCONFIG );
	if ( tpConfig == NULL )
		return;
	int nwhiteNum =0;int nblueNum  =0;int npurpleNum =0;int ngoldNum = 0;
	int tListNum = pMsg->runeindex_size();
	if ( tListNum < tpConfig->m_min || tListNum > tpConfig->m_max  )
	{
		return;
	}
	int  isBind = ITEM_BINDSTATUS_FREE;
	lk::hash_map< int, int, 5 >	upRuneItemMap;
	upRuneItemMap.initailize();
	for ( int i = 0; i < tListNum ; i++ )
	{
		int vindex =  pMsg->runeindex(i);

	    //判断是否同一个索引
		
		lk::hash_map< int, int, 5 >::iterator tFindIter = upRuneItemMap.find( vindex );
		if ( tFindIter != upRuneItemMap.end( ) )
		{
			return;
		}
		upRuneItemMap.insert( std::pair< int, int >( vindex, 1 ) );

		//取出每个符文
		CItemObject *tItem = pProperty->GetBaggage( )->GetItemObjPtr( vindex );
		if ( tItem == NULL  )
		{
			return;
		}
		CTplItem *tpItem = (CTplItem*)CDataStatic::SearchTpl( tItem->GetItemID() );
		if ( tpItem == NULL)
		{
			return;
		}
		// 如果不是符文
		if ( tpItem->mItemType != CTplItem::ITEM_RUNE )
		{
			return;
		}
		// 有升级符 道具 判断等级是否相同
		if( (int)(pMsg->itemindex()) != -1) 
		{
			CItemObject *tpItemValue = pProperty->GetBaggage( )->GetItemObjPtr( pMsg->itemindex() );
			if (tpItemValue == NULL)
			{
				SendProErrorNotice(pPlayer,ERROR_RUNENOTYPE);
				return;
			}
			CTplItem *tpItem3 = (CTplItem*)CDataStatic::SearchTpl( tpItemValue->GetItemID() );
			if ( tpItem3->mLevel != tpItem->mLevel )
			{
				SendProErrorNotice(pPlayer,ERROR_RUNENOTYPE);
				return;
			}

		}
		if( tpItem->mLevel == WHITE_RUNE)
		{
			nwhiteNum++;
		}
		else if ( tpItem->mLevel == BLUE_RUNE)
		{
			nblueNum++; 
		}
		else if (tpItem->mLevel ==PURPLE_RUNE)
		{
			npurpleNum++;
		}
		else if(tpItem->mLevel == GOLD_RUNE)
		{
			ngoldNum++;
		}

		if (tItem->GetBindStatus() == ITEM_BINDSTATUS_BINDED)
		{
			isBind  = ITEM_BINDSTATUS_BINDED;
		}
		
	}
	int stRand = 0; int reasultLevel = 0;int stmoney = 0; bool isHave =  False;
	for (int i=0;i<MAX_RUNECOMTYPE;i++)
	{
		if (tpConfig->m_Rune[i].m_whitenum == nwhiteNum && tpConfig->m_Rune[i].m_bluenum == nblueNum&& tpConfig->m_Rune[i].m_purplenum == npurpleNum&& ngoldNum == 0)
		{
			stRand =  tpConfig->m_Rune[i].m_rand;
			reasultLevel = tpConfig->m_Rune[i].m_runeLevel;
			stmoney   =  tpConfig->m_Rune[i].m_money;
			isHave =  True;
		}
	}
	if (isHave ==  False)
	{
		return;
	}
	//判断背包是否有空格
	CItemBox *tpitemBox = NULL;
	tpitemBox =	pProperty->GetBaggage();
	if(tpitemBox == NULL)
	{
		return;
	}
	if (tpitemBox->Space(-1,1) == FALSE)
	{
		SendProErrorNotice( pPlayer, ERROR_PRONOSPACE );
		return;
	}

	// 扣除金钱
	if (pProperty->IsMoneyEnough( true, stmoney ) == false )
	{
		SendProErrorNotice( pPlayer, ERROR_PRONOMONEY );
		return ;
	}	
	if(PlayerChangeMoney( pPlayer, stmoney , true, true )==SUCCESS)
	{
		LogEventLostMoneyByStudySkill(pPlayer, CYuanBao::em_bind_money, stmoney);
	}
	
	// 扣除面板上的符文道具
	for (int j = 0; j < tListNum ; j++)
	{
		int vItemIndex =  pMsg->runeindex(j); 
		CItemObject *tItemRemove = pProperty->GetBaggage( )->GetItemObjPtr( vItemIndex );
		if ( tItemRemove == NULL  )
		{
			return;
		}
		uint64_t ullGUID = 0 ;
		if ( vItemIndex != -1 )
		{
			int itemid =  tItemRemove->GetItemID();
			if(CPropertyModule::GetSingletonPtr()->PlayerRemoveItem( pPlayer, vItemIndex, 1, &ullGUID)==0)
			{
				//LogEventLostItemByUse(pPlayer, ullGUID, tItemRemove->GetItemID(), 1);
				LogEventLostItemByCompose ( pPlayer, ullGUID, itemid, 1, itemid, 1, 0 );
			}
			
		}

	}
	if( (int)(pMsg->itemindex()) != -1) // 有升级符 道具
	{
		//验证 是否是升级符
		CItemObject *tpItem3 = pProperty->GetBaggage( )->GetItemObjPtr( pMsg->itemindex() );
		if ( tpItem3 )
		{
			CTplItem *tpRuneItem = (CTplItem*)CDataStatic::SearchTpl( tpItem3->GetItemID() );
			if ( tpRuneItem->mItemType == CTplItem::ITEM_FUNCITEM )
			{
				CTplFuncItem *tpTplFuncItem = ( CTplFuncItem * )tpRuneItem;
				if ( tpTplFuncItem->mFuncCode == FUNCCODE_UPRUNE )
				{
					//增加升级概率
					stRand += tpTplFuncItem->mParams[0];
					//删除道具
					uint64_t ullGUID = 0 ;
					int itemid = tpItem3->GetItemID();
					if(CPropertyModule::GetSingletonPtr()->PlayerRemoveItem( pPlayer, pMsg->itemindex() , 1, &ullGUID) == 0)
					{
						if (tpItem3->GetBindStatus() == ITEM_BINDSTATUS_BINDED)
						{
							isBind  = ITEM_BINDSTATUS_BINDED;
						}
						LogEventLostItemByUse(pPlayer, ullGUID,itemid, 1);
						
					}
						
				}
			}
		}
		

	}
	//通知 升级是否成功
	CMessage tMsg;
	CMessageResponseRuneCom tresponseMsg;
	// 按概率得到新的符文道具
	if (stRand  >= RAND(10000))
	{
		int randtempid =0;
		randtempid =  CDataStatic::GetChangeRandRuneId( reasultLevel,  1);
		CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( randtempid );
		if (tpItem2)
		{	
			CItemObject* pInsItem = NULL;
			pInsItem = CPropertyModule::GetSingleton().PlayerInsertItem( pPlayer, tpItem2->mTempID,  1,false, reasultLevel, NULL, isBind);
			if ( pInsItem != NULL)
			{
				//pInsItem->SetBindStatus(isBind);
				LogEventGetItemByCompose(pPlayer, pInsItem->GetGUID(), 0, 0, tpItem2->mTempID, 1);
				tresponseMsg.set_errorcod(SUCCESS);
				tresponseMsg.set_result(1);
			}
			else{
				tresponseMsg.set_errorcod(ERROR_RUNE_COM_LOSE);
				tresponseMsg.set_result(0);
			}
			
		}

	}
	else{
		tresponseMsg.set_errorcod(SUCCESS);
		tresponseMsg.set_result(0);
	}

	tMsg.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_RUNECOM);
	tMsg.set_msgpara((uint32_t) &tresponseMsg);
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &tMsg );
	
	
	
}
void CPropertyModule::OnMessageInsertPushJewelRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageInsertPushJewelRequest *pMsg = ( CMessageInsertPushJewelRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tIndex0 = tpSrcProperty->GetBaggage( )->mJewelIndex0;
	int tIndex[ JEWELNUM ] = { -1 };
	for( int i = 0; i < (int)ARRAY_CNT(tpSrcProperty->GetBaggage( )->mJewelIndex); i++ )
	{
		tIndex[ i ] = tpSrcProperty->GetBaggage( )->mJewelIndex[ i ];
	}
	int tResult = tpSrcProperty->GetBaggage( )->AddJewelItem( pMsg->srcindex(), pMsg->desindex() );

	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
	}
	else
	{
		if ( tIndex0 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex0, LOCKTYPE_NONE ) == true )
			{		
				//CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &CMessageLockItemNotice( tIndex0, LOCKTYPE_NONE ) );
				SendLockItemNotice( pPlayer, tIndex0, LOCKTYPE_NONE );
			}
		}
		for ( int i = 0; i < 5; i++ )
		{
			if ( tIndex[ i ] >= 0 && tResult == ( i + 1 ) )
			{
				if ( tpSrcProperty->GetBaggage( )->Lock( tIndex[ i ], LOCKTYPE_NONE ) == true )
				{		
					//CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &CMessageLockItemNotice( tIndex[ i ], LOCKTYPE_NONE ) );
					SendLockItemNotice( pPlayer, tIndex[ i ], LOCKTYPE_NONE );
				}
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->srcindex(), LOCKTYPE_JEWEL ) == true )
		{
			SendInsertPushJewelResponse( pPlayer, pMsg->srcindex(), tResult );
			SendLockItemNotice( pPlayer, pMsg->srcindex(), LOCKTYPE_JEWEL );
		}				
	}
}

void CPropertyModule::OnMessageInsertPopJewelRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageInsertPopJewelRequest *pMsg = ( CMessageInsertPopJewelRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	int tIndex = pMsg->index();


	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	int tResult = tpSrcProperty->GetBaggage( )->DelJewelItem( tIndex );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELNOTYPE );
	}
	else if ( tIndex == 0 )
	{
		// 新增功能，要解锁所有宝石
		int tTempIndex = 0;
		for ( int i = 0; i < (int)ARRAY_CNT( tpSrcProperty->GetBaggage( )->mJewelIndex ); i++ )
		{
			if ( ( tTempIndex = tpSrcProperty->GetBaggage( )->DelJewelItem( i + 1 ) ) >= 0 )
			{
				// 解锁对应格子
				if ( tpSrcProperty->GetBaggage( )->Lock( tTempIndex, LOCKTYPE_NONE ) == true )
				{
					SendInsertPopJewelResponse( pPlayer, tTempIndex, i + 1 );
					SendLockItemNotice( pPlayer, tTempIndex, LOCKTYPE_NONE );
				}
			}
		}
	}
	if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
	{
		SendInsertPopJewelResponse( pPlayer, tResult, tIndex );
		SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
	}
}


void CPropertyModule::OnMessageInsertJewelRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}	

	CMessageInsertJewelRequest *pMsg = (CMessageInsertJewelRequest*)pMessage->msgpara( );

	int tIndex[ JEWELNUM ] = { -1 };
	for ( size_t i = 0; i < ARRAY_CNT(tIndex) && i < (size_t)pMsg->jewelindex_size(); i++ )
	{
		tIndex[ i ] = (int)(pMsg->jewelindex( i ));
	}

	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	PlayerInsertJewel( pPlayer, pMsg->equipindex(), tIndex );
}

void CPropertyModule::OnMessageEatPushEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageEatPushEquipRequest *pMsg = ( CMessageEatPushEquipRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	// 如果已经放了东西，返回
	CItemObject *tItem = tpSrcProperty->GetBaggage( )->GetItemObjPtr( pMsg->index() );
	if ( tItem != NULL )
	{
		if ( tItem->GetLockStatus() != LOCKTYPE_NONE )
		{
			//SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
			return;
		}
	}

	int tIndex0 = tpSrcProperty->GetBaggage( )->mYuanIndex0;
	int tIndex[ YUANNUM ] = { -1 };
	for( int i = 0; i < YUANNUM; i++ )
	{
		tIndex[ i ] = tpSrcProperty->GetBaggage( )->mYuanIndex[ i ];
	}
	int tResult = tpSrcProperty->GetBaggage( )->AddYuanItem( pMsg->index() );

	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_CANNOTEAT );
	}
	else
	{
		if ( tIndex0 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex0, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex0, LOCKTYPE_NONE );
			}
		}
		for ( int i = 0; i < YUANNUM; i++ )
		{
			if ( tIndex[ i ] >= 0 && tResult == ( i + 1 ) )
			{
				if ( tpSrcProperty->GetBaggage( )->Lock( tIndex[ i ], LOCKTYPE_NONE ) == true )
				{		
					SendLockItemNotice( pPlayer, tIndex[ i ], LOCKTYPE_NONE );
				}
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_EAT ) == true )
		{

			SendEatPushEquipResponse( pPlayer, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_EAT );
		}
	}
}

void CPropertyModule::OnMessageEatPopEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageEatPopEquipRequest *pMsg = ( CMessageEatPopEquipRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tResult = tpSrcProperty->GetBaggage( )->DelYuanItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELEATFAIL );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{
			SendEatPopEquipResponse( pPlayer, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}

void CPropertyModule::OnMessageEatEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageEatEquipRequest *pMsg = (CMessageEatEquipRequest*)pMessage->msgpara( );

	int tIndex[ YUANNUM ] = { -1 };
	for ( size_t i = 0; i < ARRAY_CNT(tIndex) && ((int) i) < pMsg->equipindex_size(); i++ )
	{
		tIndex[ i ] = pMsg->equipindex(i);
	}

	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	PlayerEatEquip( pPlayer, pMsg->bugindex(), tIndex );
}

void CPropertyModule::OnMessageComposePushRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageComposePushRequest *pMsg = ( CMessageComposePushRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex = tpSrcProperty->GetBaggage( )->mComposeIndex;
	int tResult = tpSrcProperty->GetBaggage( )->AddComposeItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex, LOCKTYPE_NONE ) == true )
			{		
				//CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &CMessageLockItemNotice( tIndex, LOCKTYPE_NONE ) );
				SendLockItemNotice( pPlayer, tIndex, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_COMPOSE ) == true )
		{
			SendComposePushResponse( pPlayer, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_COMPOSE );
		}
	}
}

void CPropertyModule::OnMessageComposePopRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tResult = tpSrcProperty->GetBaggage( )->DelComposeItem( );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_COMPOSEFAIL );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{
			SendComposePopResponse( pPlayer, tResult );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}

void CPropertyModule::OnMessageOpenPushRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageOpenPushRequest *pMsg = ( CMessageOpenPushRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tIndex1 = tpSrcProperty->GetBaggage( )->mSlotIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mSlotIndex2;
	int tResult = tpSrcProperty->GetBaggage( )->AddSlotItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_SLOT ) == true )
		{
			SendOpenPushResponse( pPlayer, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_SLOT );
		}
	}
}

void CPropertyModule::OnMessageOpenPopRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageOpenPopRequest *pMsg = ( CMessageOpenPopRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tResult = tpSrcProperty->GetBaggage( )->DelSlotItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_JEWELOPENFAIL );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{
			SendOpenPopResponse( pPlayer, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}

void CPropertyModule::OnMessagePlayerTeleRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
																	
	CMessagePlayerTeleRequest *pMsg = ( CMessagePlayerTeleRequest* )pMessage->msgpara( );
	LK_ASSERT ( pMsg != NULL, return  )

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	// check service status
	// just now, confirm that it can't teleport while in trade or stall service
	if ( tpSrcProperty->CanTeleport() == false )
	{
		SendProErrorNotice( pPlayer, ERROR_INSERVICE );
		return ;
	}	

	int nDstLineID = 0;
	int nDstMapID = 0;
	int nDstPosX = 0;
	int nDstPosY = 0;
	int nMoneyNeed = 0;
	int tNeedTempID = 0;
	CEntityNpc* pNpc = NULL;

	if( pMsg->npcentityid() != 0 )
	{
		pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
			pMsg->npcentityid( ) ) );
		if ( pNpc == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_TELENONPC );
			return;
		}
		if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
		{
			LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(),  pMsg->npcentityid(), __FUNCTION__ );
			return;
		}
		CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
		if ( tpNpc == NULL || tpNpc->mStageID == 0 )
		{
			SendProErrorNotice( pPlayer, ERROR_TELENONPC );
			return;
		}
		CTemplateTeleTable *tpTeleTable = ( CTemplateTeleTable* )CDataStatic::SearchTpl( tpNpc->mStageID );
		if ( tpTeleTable == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_TELENONPC );
			return;
		}

		if ( pMsg->order() < 0 || pMsg->order() >= ARRAY_CNT(tpTeleTable->mFee) )
		{
			SendProErrorNotice( pPlayer, ERROR_TELENONPC );
			return;
		}

		// 检查金币+绑定金钱是否足够传送
		unsigned int tBaggageMoney = ( unsigned int )( tpSrcProperty->GetMoney() + tpSrcProperty->GetBindMoney() );
		if ( tBaggageMoney < (unsigned int)tpTeleTable->mFee[ pMsg->order() ] )
		{
			SendProErrorNotice( pPlayer, ERROR_TELENOFEE );
			return;
		}	

		if ( pPlayer->GetLevel() < tpTeleTable->mNeedLevel[ pMsg->order() ] )
		{
			SendProErrorNotice( pPlayer, ERROR_TELEPORT_NOLEVEL );
			return;
		}

		nMoneyNeed = (unsigned int)tpTeleTable->mFee[ pMsg->order() ];
		nDstLineID = tpTeleTable->mLineID[ pMsg->order() ];
		nDstMapID = tpTeleTable->mMapID[ pMsg->order() ];
		nDstPosX = tpTeleTable->mPosX[ pMsg->order() ];
		nDstPosY = tpTeleTable->mPosY[ pMsg->order() ];

		tNeedTempID = tpTeleTable->mNeedTempID[ pMsg->order() ];
		if( tNeedTempID != 0 )
		{
			CItemObject* tpItem = pPlayer->GetItemObject( pMsg->index( ) );
			if( tpItem != NULL )
			{
				if( tpItem->GetItemID() != (unsigned int)tNeedTempID )
				{
					SendProErrorNotice( pPlayer, ERROR_TELEPORT_NOITEM );
					return;
				}	
			}
			else
			{
				SendProErrorNotice( pPlayer, ERROR_TELEPORT_NOITEM );
				return;
			}
		}
		if ( tpTeleTable->mNeedBuffID[ pMsg->order() ] != 0 && pPlayer->HasBuff( tpTeleTable->mNeedBuffID[ pMsg->order() ] ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_TELEPORT_NOBUFF );
			return;
		}
	}
	else if( pMsg->pedalentityid() > 0 )
	{
		CEntityPedal* pPedal = dynamic_cast< CEntityPedal* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
			pMsg->pedalentityid() ) );

		if ( pPedal == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_TELENONPC );
			return;
		}

		if( pPedal->IsTouchOn( pPlayer ) != true )
		{
			return ;
		}

		nDstLineID = pPedal->GetDstLineID();
		nDstMapID = pPedal->GetDstMapID();
		nDstPosX = pPedal->GetDesPos().mX;
		nDstPosY = pPedal->GetDesPos().mY;
	}
	else if ( pMsg->asynteletokenid() > 0 )
	{
		CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
		if ( tpTable == NULL )
		{
			return;
		}

		// 检查是否在监狱
		if ( pPlayer->GetMapID() == tpTable->mMapID )
		{
			CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, ERROR_WORLD_SUMMONEDINPRI );
			return;
		}			
		
		if ( pPlayer->HasStall() == true )
		{
			CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, ERROR_WORLD_SUMMONEDINSTA );
			return;
		}

		CAsynTeleport* pAsynTele =  CMapModule::GetSingletonPtr()->GetAsyncTeleport( pMsg->asynteletokenid() );
		if( pAsynTele == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_TELEPORT_CALLTIMEOUT );
			return;
		}

		if ( pAsynTele->mDstChar.mNationID != 0 && pAsynTele->mDstChar.mNationID != pPlayer->GetNationality() )
		{
			return;
		}
		else if ( pAsynTele->mDstChar.mCountryID != COUNTRY_NONE && pAsynTele->mDstChar.mCountryID != pPlayer->GetCountryID() )
		{
			return;
		}
		else if ( pAsynTele->mDstChar.mCorpsID != 0 && pAsynTele->mDstChar.mCorpsID != pPlayer->GetCorpsID() )
		{
			return;
		}
		else if ( pAsynTele->mDstChar.mFamilyID != 0 && pAsynTele->mDstChar.mFamilyID != pPlayer->GetFamilyID() )
		{
			return;
		}

		nDstLineID = pAsynTele->mDestination.mLineID;
		nDstMapID = pAsynTele->mDestination.mMapID;
		nDstPosX = pAsynTele->mDestination.mPos.mX;
		nDstPosY = pAsynTele->mDestination.mPos.mY;
	}

	else if ( pMsg->isstatic() != 0 )
	{
		if ( pPlayer->CanFly( ) == false || pPlayer->CanRemainFly( ) == true 
			|| CMapModule::GetSingleton().IsStaticBlock( pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetMapIndex(), pPlayer->GetPos() ) == false )
		{
			return;
		}
		RelivePositionMap::iterator tFindIter = mRelivePosition.find( pPlayer->GetMapID( ) );
		if ( tFindIter == mRelivePosition.end( ) )
		{
			// 如果没有找到,传送玩家到边境复活点
			nDstLineID = pPlayer->GetNationality();
			nDstMapID = tpSrcProperty->GetTownPos( )->mMapID;
			nDstPosX = tpSrcProperty->GetTownPos( )->mPos.mX;
			nDstPosY = tpSrcProperty->GetTownPos( )->mPos.mY;
		}
		else
		{
			CRelivePosition* tpRelive = ( CRelivePosition* ) CSceneObjManager::GetSingletonPtr( )->GetObject( tFindIter->second );
			if ( tpRelive == NULL )
			{
				nDstLineID = pPlayer->GetNationality();
				nDstMapID = tpSrcProperty->GetTownPos( )->mMapID;
				nDstPosX = tpSrcProperty->GetTownPos( )->mPos.mX;
				nDstPosY = tpSrcProperty->GetTownPos( )->mPos.mY;
			}
			else
			{
				// 传送玩家到复活点
				nDstLineID = tpRelive->mLineID;
				nDstMapID = tpRelive->mReliveMapID;
				nDstPosX = tpRelive->mPosition.mX;
				nDstPosY = tpRelive->mPosition.mY;
			}
		}
	}
	else if( pMsg->has_marriageitem() )
	{

	}

	// TODO: 暂时在非跨服状态下验证地图等级限制 ；副本有自己的限制逻辑
	if( CMapModule::GetSingletonPtr()->IsLevelMatched( pPlayer, nDstMapID ) != true )
	{
		SendProErrorNotice( pPlayer, ERROR_TELEPORT_MAPLEVELLIMIT  );
		return;		
	}
	
	pPlayer->SetCreatMethod( PLAYERCREAT_TELEPORT ); 

	// 先扣除费用和道具
	if( nMoneyNeed  > 0 )
	{
		if( PlayerChangeMoney( pPlayer, nMoneyNeed, true, true ) == 0 ) 
		{
			LogEventLostMoneyByNpcTeleport(pPlayer, CYuanBao::em_bind_money, nMoneyNeed, pNpc != NULL ? pNpc->GetNpcID( ) : 0); 		
		}
		else
		{
			SendProErrorNotice( pPlayer, ERROR_TELENOFEE  );
			return;
		}
	}

	// 先扣物品
	if( tNeedTempID > 0 )
	{
		// 目前只有从包裹里消耗的。
		CItemObject* pItmeObj = tpSrcProperty->GetBaggage()->GetItemObjPtr( pMsg->index( ) );
		if( pItmeObj != 0 )
		{
			// 客户端上报的物品和实际需求的物品不符合
			if( (unsigned int)(tNeedTempID) != pItmeObj->GetItemID() )
			{
				return;
			}
		}
		else
		{
			SendProErrorNotice( pPlayer, ERROR_TELEPORT_NOITEM  );
			return;
		}
		
		if( PlayerRemoveItem( pPlayer, pMsg->index( ), 1 ) == 0 )
		{
			// Log...
		}
		else
		{
			SendProErrorNotice( pPlayer, ERROR_TELEPORT_NOITEM  );
			return;
		}
	}
	
	CGlobalMapData tMapData;
	tMapData.mMapID = nDstMapID;
	tMapData.mPosX = nDstPosX;
	tMapData.mPosY = nDstPosY;
	if ( IS_GLOBAL_SCENESERVER( nDstLineID ) == true )
	{
		if ( IS_GLOBAL_SCENESERVER( pPlayer->GetLineID() ) == false )
		{
			CGlobalModule::GetSingleton().GlobalTelePort( pPlayer, EGLOBALTELE_TYPE_GLOBALSERVER, ESERVERTYPE_SCENESER, &tMapData );
			return;	
		}
	}
	else if ( IS_GLOBAL_SCENESERVER( pPlayer->GetLineID() ) == true )
	{
		CGlobalModule::GetSingleton().GlobalTelePort( pPlayer, EGLOBALTELE_TYPE_RETURNTOGAME, ESERVERTYPE_SCENESER, &tMapData );
		return;
	}

	int tRtn = ERR_UNKNOWN;
	if( IS_REPETION_LINE_ID( nDstLineID ) == false )
	{
		bool tBoolRtn = true;

#ifndef _FB_
		tBoolRtn = CMapModule::GetSingleton().Teleport( nDstLineID,nDstMapID,nDstPosX,nDstPosY,pPlayer );
#else
		CMapObject* tpMapObj = pPlayer->GetMapObject( );
		if( tpMapObj == NULL )
		{
			LOG_ERROR( "default", "[ %s : %d ][ %s ] Cannt Find Player( %d : %d : %s ) Map( %d : %d : %d )",
				__LK_FILE__, __LINE__, __FUNCTION__, pPlayer->GetEntityID( ), pPlayer->GetCharID( ),
				pPlayer->GetCharNameShow( ), pPlayer->GetLineID( ), pPlayer->GetMapID( ), pPlayer->GetMapIndex( ));
			return;
		}
		tBoolRtn = CMapModule::GetSingleton().Teleport(nDstLineID,nDstMapID,nDstPosX,nDstPosY,pPlayer,
			INVALID_MAP_INDEX,
			( tpMapObj != NULL ) ? tpMapObj->GetKey( ) : INVITED_KEY_VALUE );
#endif
		if( tBoolRtn == true )
		{
			tRtn = SUCCESS;
		}
	}	
	else
	{
		tRtn = CRepetionModule::GetSingletonPtr( )->RedirectRepetionMap( pPlayer, nDstMapID, nDstPosX, nDstPosY, pNpc );
	}

	if( tRtn != SUCCESS )
	{
		// 传送失败，金钱回滚
		if( nMoneyNeed > 0 )
		{
			PlayerChangeMoney( pPlayer, nMoneyNeed, false, true );
			LogEventGetMoneyByTeleErr(pPlayer, nMoneyNeed ); 
		}

		// 传送失败，道具回滚
		if( tNeedTempID > 0 )
			PlayerInsertItem( pPlayer, tNeedTempID , 1 );
	}

	
	// 修改创建方式为移动
	pPlayer->SetCreatMethod( PLAYERCREAT_MOVE ); 

}


// 法宝升级指令
void CPropertyModule::MWLevelUp(CEntityPlayer* pPlayer, int nLevel)
{
	LK_ASSERT( pPlayer != NULL, return  );

	// 先获得当前是不是装备法宝了
	CPropertyPlayer* pPro = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemMagicWeapon* tpMW = (CItemMagicWeapon*)pPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
	if ( tpMW == NULL )
		return ;
	CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl( tpMW->GetItemID() );
	LK_ASSERT( tpItemMW!=NULL, return  );
	CTplMagicWeaponProIncTable* tpLevelExp = (CTplMagicWeaponProIncTable*)CDataStatic::SearchTpl(tpItemMW->mLevelTableID);
	LK_ASSERT( tpLevelExp != NULL, return  );

	for (int i = 0; i < nLevel; ++i )
	{
		if ( tpMW->GetMWLevel() >= MAX_MAGICWEAPON_GRADE || tpMW->GetMWLevel() >= pPlayer->GetLevel()
			|| tpMW->GetMWLevel() >= MAGICWEAPON_MAX_GRADE )
			break;

		//tpMW->SetExp( tpMW->GetExp( ) - tpLevelExp->mValues[ tpMW->GetMWLevel( ) ].mLevelExp );
		tpMW->LevelUp();
		// 激活新技能框 返回数量
		int tNextActIndex = -1;
		int tActNum = tpMW->OnActiveNewSkillBox( tNextActIndex );
		if ( tActNum > 0 )
		{
			CMessageActiveSkillBoxNotify msg;
			for( int i = 0; i < tActNum; ++i )
			{
				msg.add_index( tNextActIndex+i );
			}
			CMessage   tMessage;
			tMessage.set_msgpara((uint32_t) &msg);
			tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_ACTIVESKILLBOX);
			CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		}
		// 升级领悟新技能
		unsigned char tIndexs[SKILL_BOX_LMT] = {-1};
		int tLearnNum = tpMW->OnSelfLearnSkill( tIndexs );
		if ( tLearnNum > 0 ) //领悟到新技能了 还要刷新属性~~
		{
			for ( int i = 0; i < tLearnNum; ++i )
			{
				CMessageInsertSkillNotify msg;
				int tSkillID = 0;
				int tSkillLevel = 0;
				int tActedNum = 0;
				int tBookID = 0;

				tpMW->GetSkillBaseInfo( tIndexs[i], tSkillID, tSkillLevel, tActedNum, tBookID );

				// 设置消息
				msg.set_index(tIndexs[i]);
				msg.set_skillid( tSkillID );
				msg.set_curlevel(tSkillLevel);
				msg.set_reason(GETSKILL_LEARN); 
				msg.set_actednum(tActedNum);
				msg.set_bookid( tBookID );
				msg.set_bagindex(-1);

				CMessage   tMessage;
				tMessage.set_msgpara((uint32_t) &msg);
				tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_INSERTSKILL);
				CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
			}
		}

	}

	// 法宝属性已刷新 通知客户端
	NotifyRefreshMagicWeaponProperty( pPlayer, -1 );
	// 刷新人
	RefreshPlayerProperty( pPlayer );
	// 通知
	SendProErrorNotice( pPlayer, ERROR_MW_LEVELUP );
}


void CPropertyModule::OnMessageProDebugCommand( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	////TODO: 临时代码,为了封测期间调试用，后面会干掉。帐号是zhanghl私人号码
	//if( pPlayer->GetAccountID() != 10905901 )
	//{
#ifndef _DEBUG_
	return;
#endif
	/*}*/

	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageProDebugCommand* tpMessage = ( CMessageProDebugCommand* )pMessage->msgpara( );
	if ( tpMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* )pPlayer->GetProperty();
	CPropertyPlayer* tpSrcProperty =  ( CPropertyPlayer* )pPlayer->GetProperty();

	Tokens tToken = StrSplit( tpMessage->debugcommond(), " " );
	LK_ASSERT( tToken.size() >= 1, return );

	const char* tCommandName = tToken[0].c_str();

		
	if( strcasecmp( tCommandName, "GetPDefence" ) == 0 )
	{
		CPropertyValue tValue = CPropertyFormula::GetPDefence( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d )	Physis Defence is %d", pPlayer->GetEntityID( ), (int)tValue );
	} 
	else if ( strcasecmp( tCommandName, "enterrepetion" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tIndex =  atoi( tToken[1].c_str() );
		CMessage tMsgHead;
		CMessageEnterLastReptionRequest tEnterRepetion;
		tMsgHead.mutable_msghead()->set_messageid(ID_C2S_REQUEST_ENTERLASTREPETION);
		tMsgHead.set_msgpara( (int)&tEnterRepetion );
		tEnterRepetion.set_index( tIndex );		
		CRepetionModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );
	}
	else if ( strcasecmp( tCommandName, "changeintimacy" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 4, return )
		int tType = atoi( tToken[1].c_str() );
		int tValue = atoi( tToken[2].c_str() );
		const char *pFriendName = tToken[3].c_str();
		CEntityPlayer *tpFriend = CSceneLogic::GetSingleton().GetPlayerByName( pFriendName );
		if ( tpFriend != NULL )
		{
			CFriendModule::GetSingleton().ChangeIntimacy( pPlayer->GetCharID(), tpFriend->GetCharID(), EM_EntimacyChangeType(tType), tValue );
		}		
	}
	else if ( strcasecmp( tCommandName, "changeintimacybyid" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 4, return )
		int tType = atoi( tToken[1].c_str() );
		int tValue = atoi( tToken[2].c_str() );
		int tFriendID = atoi( tToken[3].c_str() );		
		CFriendModule::GetSingleton().ChangeIntimacy( pPlayer->GetCharID(), tFriendID, EM_EntimacyChangeType(tType), tValue );		
	}
	else if ( strcasecmp( tCommandName, "dunservermsg" ) == 0 )
	{
		CMessage tMsgHead;
		CMessageS2GGetCampRankForYQSRequest tMsg;		
		tMsgHead.set_msgpara( (int)&tMsg );		
		tMsgHead.mutable_msghead()->set_messageid( ID_S2G_GETCAMPRANKFORYQS_REQUEST );
		CSceneLogic::GetSingleton().Send2GlobalDunServer( &tMsgHead );
	}
	else if (  strcasecmp( tCommandName, "globaltele" ) == 0 )
	{
		LK_ASSERT( tToken.size()>=3, return )
		int tServerType = atoi( tToken[1].c_str() );
		int tReturnBack = atoi( tToken[2].c_str() );
		CGlobalModule::GetSingleton().GlobalTelePort( pPlayer, EGlobalTeleType(tReturnBack), EServerType(tServerType) );
	}
	else if (  strcasecmp( tCommandName, "applyglobalwar" ) == 0 )
	{
		CGlobalModule::GetSingleton().PlayerApplyWar( pPlayer );
	}
	else if ( strcasecmp( tCommandName, "changestability" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )		
		int tStability = atoi( tToken[1].c_str() );
		CFamilyModule::GetSingleton().ChangeFamilyStability( pPlayer, tStability, 0 );
		
	}
	else if ( strcasecmp( tCommandName, "GetTreasureBowlInfo" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tIndex = atoi( tToken[1].c_str() );
		CMessage tMsgHead;
		CMessageGetTreasureBowlInfoRequest tMsg;
		
		tMsg.set_itemindex( tIndex );
		tMsgHead.set_msgpara( (int)&tMsg );		
		CActivityModule::GetSingleton().OnMessageGetTreasureBowl( pPlayer, &tMsgHead );
	}
	else if ( strcasecmp( tCommandName, "StartTreasureBowlInfo" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tIndex = atoi( tToken[1].c_str() );
		CMessage tMsgHead;
		CMessageStartTreasureBowlRequest tMsg;

		tMsg.set_itemindex( tIndex );
		tMsgHead.set_msgpara( (int)&tMsg );		
		CActivityModule::GetSingleton().OnMessageStartTreasureBowl( pPlayer, &tMsgHead );
	}	
	else if ( strcasecmp( tCommandName, "setovertime" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 4, return )
		int tTime = atoi( tToken[1].c_str() );
		int tIndex = atoi( tToken[2].c_str() );
		int tSlot = atoi( tToken[3].c_str() );
		
		CItemObject *tpItem = NULL;
		if ( tSlot == SLOT_BAGGAGE )
		{
			tpItem = tpProperty->GetBaggage()->GetItemObjPtr( tIndex );
		}
		else if ( tSlot == SLOT_EQUIPMENT )
		{
			tpItem = tpProperty->GetEquipment()->GetItemObjPtr( tIndex );
		}
		
		if ( tpItem == NULL )
		{
			return;
		}
		
		tpItem->SetInvalidTime( time( NULL ) + tTime );		
	}
	else if ( strcasecmp( tCommandName, "usefashionneedle" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 4, return )
		int tNeedleIndex	= atoi( tToken[1].c_str() );
		int tFashionSlot	= atoi( tToken[2].c_str() );				
		int tFashionIndex	= atoi( tToken[3].c_str() );				
		UseFashionNeedle( pPlayer, tNeedleIndex, tFashionIndex, tFashionSlot );
	}
	else if( strcasecmp( tCommandName, "campmail" ) == 0 )
	{		
		LK_ASSERT( tToken.size() >= 1, return )
		int tNewCampID = atoi( tToken[1].c_str() );
		CMailModule::GetSingleton().ChangeCampMail( pPlayer, pPlayer->GetNationality(), tNewCampID );		
	}
    else if( strcasecmp( tCommandName, "EachOther" ) == 0 )
    {
#ifdef _FB_
        CRepetionModule::GetSingletonPtr( )->EachOther( pPlayer, atoi( tToken[ 1 ].c_str( ) ),
            atoi( tToken[ 2 ].c_str( ) ),  atoi( tToken[ 3 ].c_str( ) ) );
#endif
    }
	else if( strcasecmp( tCommandName, "saveinvest" ) == 0 )
	{	
		CActivityModule::GetSingleton().WriteInvestResultToFile();
	}
	else if( strcasecmp( tCommandName, "endwedding" ) == 0 )
	{
		CMarriageInfo *tpMarriage = CMarriageManager::GetSingleton().GetCurrentWeddingInfo();
		if ( tpMarriage != NULL )
		{
			if ( tpMarriage->GetMarriageStatus() == MARRIAGESTATUS_WEDDINGONSTREET )
			{
				
				CMarriageModule::GetSingleton().ClearWeddingInfo( tpMarriage );
				CMarriageManager::GetSingleton().ClearWeddingTimer( TIMER_WEDDINGONSTREET );
				CMarriageModule::GetSingleton().InitialWeddingHall( tpMarriage );
			}			
		}					
	}
	else if( strcasecmp( tCommandName, "endweddinghall" ) == 0 )
	{
		CMarriageModule::GetSingleton().EndWedding();
	}
	else if( strcasecmp( tCommandName, "clearhydrangeastatus" ) == 0 )
	{	
		CActivityModule::GetSingleton().ClearHydrangeaStatus( pPlayer );
	}
	else if( strcasecmp( tCommandName, "starthydrangea" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tActivityID = atoi( tToken[1].c_str() );
		CActivityModule::GetSingleton().EndHydrangeaActivity();
		CActivityModule::GetSingleton().StartHydrangeaActivity( tActivityID ); 				
	}
	
	else if( strcasecmp( tCommandName, "setkitbagtime" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 4, return )	
		int tIndex = atoi( tToken[1].c_str() );
		int tTime = atoi( tToken[2].c_str() );	
		int tBagType = atoi( tToken[3].c_str() );	
		
		CItemObject *  tpItemObj = NULL;
		switch( tBagType )
		{
			case SLOT_BAGGAGE:
			{
				tpItemObj = tpSrcProperty->GetBaggage()->GetItemObjPtr( tIndex );
				break;
			}			
			
			case SLOT_STORAGE:
			{
				tpItemObj = tpSrcProperty->GetStorage()->GetItemObjPtr( tIndex );
				break;
			}
			
			case SLOT_STORKITBAG:
			{
				tpItemObj = tpSrcProperty->GetStorage()->GetKitBagItemByIndex( tIndex );
				break;
			}
			
			case SLOT_BAGGAGEKITBAG:
			{
				tpItemObj = tpSrcProperty->GetBaggage()->GetKitBagItemByIndex( tIndex );
				break;
			}
		}		
	
		if ( tpItemObj != NULL )
		{
			tpItemObj->SetInvalidTime( time( 0 ) + tTime );
		}
		
	}  	
	else if( strcasecmp( tCommandName, "SetMarryInfo" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return )
		int tWeddingTime = atoi( tToken[1].c_str() );
		int tMarriageStatus = atoi( tToken[2].c_str() );
		
		CMarriageInfo *tpMarriageInfo = CMarriageManager::GetSingleton().GetMarriageInfo( pPlayer->GetMarriageID() );
		if ( tpMarriageInfo != NULL )
		{
			tpMarriageInfo->SetMarriageStatus( tMarriageStatus );
			tpMarriageInfo->SetWeddingTime( time(0) + tWeddingTime );
			tpMarriageInfo->SetWeddingEventStatus( 0 );
		}			
	}
	else if ( strcasecmp( tCommandName, "marrytel" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tIndex = atoi( tToken[1].c_str() );
		CMessage tMsgHead;		
		
		CMessagePlayerTeleRequest tMsgPlayerTel;
		tMsgHead.set_msgpara( (int)&tMsgPlayerTel );
		tMsgPlayerTel.set_marriageitem( tIndex );			
		OnMessagePlayerTeleRequest( pPlayer, &tMsgHead );
	}
	
	else if ( strcasecmp( tCommandName, "sendinvitation" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return  )
		int tIndex = atoi( tToken[1].c_str() );
		const char *pName = tToken[2].c_str();
		
		CMarriageModule::GetSingleton().UseSysInvitation( pPlayer, tIndex, pName );
				
	}
	
	else if ( strcasecmp( tCommandName, "marriageapply" ) == 0 )
	{
		CMessage tMsgHead;
		CMessageApplyMarryRequest tMsgMarriageApply;
		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_APPLYMARRY );
		tMsgHead.set_msgpara( (int)&tMsgMarriageApply );
		
		tMsgMarriageApply.set_dayid( 0 );
		tMsgMarriageApply.set_holdwedding( 1 );
		tMsgMarriageApply.set_timeid( 1 );
		tMsgMarriageApply.set_weddingmodule( 1 );  	
		
		CMarriageModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );	
	}	  
	
	else if ( strcasecmp( tCommandName, "replymarry" ) == 0 )
	{
		CMessage tMsgHead;
		CMessageReplyMarryRequest tMsgReplyMarriage;

		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPLYMARRY );
		tMsgHead.set_msgpara( (int)&tMsgReplyMarriage );	 	
		
		tMsgReplyMarriage.set_result( 1 );
		CMarriageModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );	
	}	
	
	else if ( strcasecmp( tCommandName, "npcpath" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 6, return )
		
		unsigned int tEntityID = 0;
		CNpcCreator tCreator;	
								
		tCreator.set_id(0);				
		tCreator.mPosition = CWTPoint( atoi( tToken[2].c_str() ), atoi( tToken[3].c_str() ) );
		tCreator.mNpcID = atoi( tToken[1].c_str() );	
		tCreator.SetIndex( pPlayer->GetMapIndex() );
		tCreator.mOwnerCharID = pPlayer->GetCharID();
		tCreator.mIsSendNpc = 1;
		tCreator.mIsShowOwner = 1;		
		
		bool tRet = CMapModule::GetSingleton().CreateNpc( (unsigned short)CSceneLogic::GetSingleton().GetLineID(), (unsigned short)62, pPlayer->GetMapIndex(), &tCreator, tEntityID );
		if ( tRet != true )
		{
			return;
		}
		
		CEntityNpc *tpEntity = (CEntityNpc *)CSceneLogic::GetSingleton().GetEntity( tEntityID ) ;
		if ( tpEntity == NULL )
		{
			return;
		}	  		
		
		tpEntity->SetOrginPos( CWTPoint( atoi( tToken[4].c_str() ), atoi( tToken[5].c_str() ) ) );
		tpEntity->SetPKType( ENEMY_TO_OGRE | ENEMY_WITH_OGRE | NEUTRAL_WITH_SC | NEUTRAL_TO_SC | NEUTRAL_WITH_FC | NEUTRAL_TO_FC );	

		CNpcModule::GetSingleton().OnMoveNpc( tEntityID, atoi( tToken[4].c_str() ), atoi( tToken[5].c_str() ) );		
	}
	
	else if ( strcasecmp( tCommandName, "beginwedding" ) == 0 )
	{
		CMessage tMsgHead;
		CMessageReplyBeginWeddingRequest tMsgReplyBeginWedding;

		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPLYBEGINWEDDING );
		tMsgHead.set_msgpara( (int)&tMsgReplyBeginWedding );	 	

		tMsgReplyBeginWedding.set_result( 1 );
		CMarriageModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );	
	}
	
	else if ( strcasecmp( tCommandName, "enterhall" ) == 0 )
	{
		CMessage tMsgHead;
		CMessageNewlyEnterHallRequest tMsgEnterHall;		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_NEWLYWEDENTERHALL );
		tMsgHead.set_msgpara( (int)&tMsgEnterHall );		
		
		CMarriageModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );
	}
	
	else if ( strcasecmp( tCommandName, "putkeepsake" ) == 0 )
	{	
		LK_ASSERT( tToken.size() >= 2, return )
		int tIndex = atoi( tToken[1].c_str() );
		CMarriageModule::GetSingleton().PlayerPutKeepsake( pPlayer, tIndex );
	}		    
	
	else if ( strcasecmp( tCommandName, "exchangekeepsake" ) == 0 )
	{			
		CMarriageModule::GetSingleton().PlayerExchangeKeepsake( pPlayer );
	}		    
		
	else if( strcasecmp( tCommandName, "GetAccount" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->OnMessageC2SBourseLoadAccount( pPlayer, NULL );
	}
	else if( strcasecmp( tCommandName, "GetSelfList" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->OnMessageC2SBourseLoadSelfList( pPlayer, NULL );
	}
	else if( strcasecmp( tCommandName, "IncAccount" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->IncAccount( pPlayer, atoi( tToken[ 1 ].c_str() ), 
			atoi( tToken[ 2 ].c_str() ) );
	}
	else if( strcasecmp( tCommandName, "DecAccount" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->DecAccount( pPlayer, atoi( tToken[ 1 ].c_str( ) ), 
			atoi( tToken[ 2 ].c_str( ) ) );
	}
	else if( strcasecmp( tCommandName, "AddDocBuy" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->AddBuyOrder( pPlayer, atoi( tToken[ 1 ].c_str( ) ),
			atoi( tToken[ 2 ].c_str( ) ) );
	}
	else if( strcasecmp( tCommandName, "AddDocSell" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->AddSellOrder( pPlayer, atoi( tToken[ 1 ].c_str( ) ),
			 atoi( tToken[ 2 ].c_str( ) ) );
	}
	else if( strcasecmp( tCommandName, "GetSelfDoc" ) == 0 )
	{
		CBourseModule::GetSingletonPtr( )->GetPlayerSelfDocList( pPlayer );
	}
	else if( strcasecmp( tCommandName, "ShowSaveChar" ) == 0 )
	{
		printf( "file %s size %d\n", tToken[ 1 ].c_str( ), get_file_length( tToken[ 1 ].c_str( ) ) );
		int tFileLen = get_file_length( tToken[ 1 ].c_str( ) );
		char tBuff [ 10240 ] = { 0 };
		FILE* file = fopen( tToken[ 1 ].c_str( ), "r" );
		if( file == NULL ){ printf( "cannt open file %s\n", tToken[ 1 ].c_str( ) ); return; }
		fread( tBuff, sizeof( tBuff[ 0 ] ), tFileLen, file );
		fclose( file );
		CMessageSavePlayerRequest tSave;
		std::string str( tBuff, tFileLen );
		tSave.ParseFromString( str );

		printf( "DebugInfo: %s\n", tSave.ShortDebugString( ).c_str( ) );
	}
	else if ( strcasecmp( tCommandName, "GetRecord" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tEntityID = atoi( tToken[ 1 ].c_str() );

		CMessage tMessage;
		CMessageStallGetRecordRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_STALLRECORD );
		tMessage.set_msgpara( (long) &tPara );
		tPara.set_entityid( tEntityID );
		CStallModule::GetSingleton().OnMessageGetStallRecord( pPlayer, &tMessage );
	}
	else if ( strcasecmp( tCommandName, "Return" ) == 0 )
	{
		int tPosX = 199; int tPosY = 375;
		int tLineID = pPlayer->GetLineID();
		if ( pPlayer->GetMapID() == 53 )
		{
			CMapModule::GetSingleton().Teleport( tLineID, 62, tPosX, tPosY, pPlayer );
		}
		else
		{
			LK_ASSERT( tToken.size() >= 4, return );
			int tMapID = atoi( tToken[ 1 ].c_str() );
			tPosX = atoi( tToken[ 2 ].c_str() );
			tPosY = atoi( tToken[ 3 ].c_str() );
			CMapModule::GetSingleton().Teleport( tLineID, tMapID, tPosX, tPosY, pPlayer );
		}
		
	}
	else if ( strcasecmp( tCommandName, "Honor" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tMapID = atoi( tToken[ 1 ].c_str() );

		CAchieveModule::GetSingleton().OnEventInsertHonor( pPlayer, tMapID );
	}
	else if ( strcasecmp( tCommandName, "Clean" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tIndex = atoi( tToken[ 1 ].c_str() );

		CMessage tMessage;
		CMessageUseItemRequest tPara;
		tMessage.set_msgpara( (long) &tPara );
		tPara.set_index( tIndex );
		OnMessageUseItemRequest( pPlayer, &tMessage );
	}
	else if ( strcasecmp( tCommandName, "SetPK" ) == 0  )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tValue = atoi( tToken[ 1 ].c_str() );
		CPropertyPlayer* tpProperty = ( CPropertyPlayer* )pPlayer->GetProperty( );
		tpProperty->SetPKValue( tValue );
		SendPKValueMessage( pPlayer, tValue );
	}
	 
	else if( strcasecmp( tCommandName, "AddCollectSkill" ) == 0 )
	{
		CPropertyPlayer* tpProperty = ( CPropertyPlayer* )pPlayer->GetProperty( );
		CLifeSkill* tpLifeSkill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( LIFESKILL_COLLECT );
		if ( tpLifeSkill == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_LIFESKILL_COLLECTWITHOUTRIGHTSKILL );
			return;
		}
		tpLifeSkill->AddSpecializedDegree( 600, CLifeSkill::DEGREEADDTYPE_USECOMPOSE );
		SendNotifyLifeSkillAttribute( pPlayer, tpLifeSkill->GetLifeSkillType(), tpLifeSkill->GetSpecializedDegree() );
	}
	else if ( strcasecmp( tCommandName, "Achieve" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tID = atoi( tToken[ 1 ].c_str() );
		int tValue = atoi( tToken[ 2 ].c_str() );

		CMessage tMessage;
		CMessageAchieveReportRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPORTACHIEVE );
		tMessage.set_msgpara( (long) &tPara );
		tPara.set_achieveid( tID );
		tPara.set_key( tValue );
		CAchieveModule::GetSingleton().OnMessageReportAchieveRequest( pPlayer, &tMessage );
	}
	else if ( strcasecmp( tCommandName, "Bid" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		
		int tNpcID = atoi( tToken[ 1 ].c_str() );
		int tMoney = atoi( tToken[ 2 ].c_str() );

		CMessage tMessage;
		CMessageCorpsBattleBidRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_BATTLEBID );
		tMessage.set_msgpara( (long) &tPara );
		tPara.set_npcid( tNpcID );
		tPara.set_money( tMoney );
		tPara.mutable_corphead()->set_roleid( pPlayer->GetCharID() );
		CCorpsModule::GetSingleton().OnMessageCorpsBattleBidRequest( pPlayer, &tMessage );
	}
	else if ( strcasecmp( tCommandName, "SetCorpsMoney" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tMoney = atoi( tToken[ 1 ].c_str() );

		CMessage tMessage;
		CMessageContributeCorpsMoneyRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_CONTRIBUTECORPSMONEY );
		tPara.mutable_corphead()->set_roleid( pPlayer->GetCharID() );
		tMessage.set_msgpara( (long) &tPara );
		tPara.set_money( tMoney );
		CSceneLogic::GetSingleton().Send2Gate( &tMessage );
	}
	else if ( strcasecmp( tCommandName, "InsertTitle" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tTitle = atoi( tToken[ 1 ].c_str() );

		OnPlayerAddTitleEvent( pPlayer, tTitle );
	}
	else if ( strcasecmp( tCommandName, "FireBattle" ) == 0 )
	{

		LK_ASSERT( tToken.size() >= 2, return );
		int tNpcID = atoi( tToken[ 1 ].c_str() );

		CTemplateNpc* tpNpc = (CTemplateNpc*) CDataStatic::SearchTpl( tNpcID );
		if ( tpNpc != NULL )
		{
			CMessage tMessage;
			CMessageCorpsStartBattleRequest tPara;
			tMessage.mutable_msghead()->set_messageid( ID_S2G_REQUEST_STARTCOPRSBATTLE );
			tMessage.set_msgpara( (long) &tPara );

			tPara.set_npcid( tNpcID );
			tPara.set_battleid( tpNpc->mBattleCity );
			CSceneLogic::GetSingleton().Send2Gate( &tMessage );
		}
	}
	else if ( strcasecmp( tCommandName, "MWIS" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tIndex = atoi( tToken[ 1 ].c_str() );
		int tSkillID = atoi( tToken[ 2 ].c_str() );

		CMessage   tMessage;
		// 发给客户端新加技能
		CMessageInsertSkillNotify msg;

		CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
		CItemMagicWeapon* pObj = (CItemMagicWeapon*)pProperty->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);

		if( pObj == NULL ) return ;

		pObj->mActiveState[tIndex] = 1;
		int tRet = pObj->OnInsertSkill( tSkillID, 1, tIndex );
		if ( 0 == tRet )
		{
			++pObj->mSkillActNum[tIndex];
			pObj->mAddedSkillPoints[tIndex] = 0;
			pObj->mSkillBookID[tIndex] = 0;
			// 设置消息
			msg.set_index(tIndex);
			msg.set_skillid( tSkillID );
			msg.set_curlevel(MW_SKILL_INIT_LEVEL);
			msg.set_reason(GETSKILL_LEARN); // 鉴定的
			msg.set_actednum(pObj->mSkillActNum[tIndex]);
			msg.set_bookid( pObj->mSkillBookID[tIndex] );
			// 新加技能
			tMessage.set_msgpara((uint32_t) &msg);
			tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_INSERTSKILL);
			CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );

			// 刷新属性
			NotifyRefreshMagicWeaponProperty( pPlayer, pProperty->GetBaggage()->GetMWLockIndex() );
		}
		else
		{
			SendProErrorNotice( pPlayer, tRet );
		}
	}
	else if ( strcasecmp( tCommandName, "DecAp" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tValue = atoi( tToken[ 1 ].c_str() );

		unsigned int tAp = tpProperty->GetCurAP();
		tpProperty->SetCurAP( std::max( (unsigned int)0, tAp - tValue ) );
		pPlayer->AddFunResult( pPlayer->GetEntityID(), FUNC_DECAP, RESULT_NORMAL, true, tValue, tpProperty->GetCurAP(), tpProperty->GetMaxAP() );
	}
	else if ( strcasecmp( tCommandName, "JoinBattle" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tNpcID = atoi( tToken[ 1 ].c_str() );

		CTemplateNpc* tpNpc = (CTemplateNpc*) CDataStatic::SearchTpl( tNpcID );
		if ( tpNpc != NULL )
		{
			CMessage tMessage;
			CMessageCorpsBidTimerStopRequest tPara;
			tPara.set_npcid( tNpcID );
			tPara.set_battleid( tpNpc->mBattleCity );
			tMessage.mutable_msghead()->set_messageid( ID_S2G_REQUEST_BIDTIMERSTOP );
			tMessage.set_msgpara( (long) &tPara );
			CSceneLogic::GetSingleton().Send2Gate( &tMessage );
		}
	}
	else if ( strcasecmp( tCommandName, "LoginBattle" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tMapID = atoi( tToken[ 1 ].c_str() );

		CRepetionModule::GetSingleton().PlayerIntoRepetion( pPlayer, tMapID, 25, 31 );
	}
	else if( strcasecmp( tCommandName, "CreateBattle" ) == 0 )
	{
		CRepetionModule::GetSingletonPtr( )->CreateBattle( 55, 30 );
	}
	else if( strcasecmp( tCommandName, "PlayerIntoBattle" ) == 0 )
	{
		CRepetionModule::GetSingletonPtr( )->PlayerIntoBattleByKey( pPlayer, 55, 1, INVITED_KEY_VALUE );
	}
	else if( strcasecmp( tCommandName, "TeamWaitBattle" ) == 0 )
	{
		CRepetionModule::GetSingletonPtr( )->TeamWaitBattle( pPlayer, atoi( tToken[1].c_str( ) ) );
	}
	else if( strcasecmp( tCommandName, "JoinBattle" ) == 0 )
	{
		CRepetionModule::GetSingletonPtr( )->PlayerIntoRepetion( pPlayer, atoi( tToken[1].c_str( ) ), 0, 0 );
	}
	else if( strcasecmp( tCommandName, "StaticMessage" ) == 0 )
	{
		for( int i = 0; i < 1000000000; i++ )
		{
			//BuildPlayerDieLogMessage( pPlayer, 1, 1, "3333333333333333" );
		}
	}

	else if( strcasecmp( tCommandName, "CreateEquip" ) == 0 )
	{
		int i = 0;
		int tMax = SERVER_CAP_ITEM_EQUIPMENT * 2;
		int tDelete = 0;
		int tDeleteCount = 0;

		srand( time( NULL ) );

		printf( "Begin CreateEquipment\n" );
		for( i = 0; i < tMax; i++ )
		{
			CObj* tpObj = CSceneObjManager::GetSingletonPtr( )->CreateObject( OBJTYPE_ITEM_EQUIPMENT );
			if( tpObj == NULL )
			{
				printf( "CreateEquipment Is NULL, Count %d\n", i );
				printf( "DestroyEquipCount Is %d", tDeleteCount );
				return;
			}

			if( tDelete == 0 )
			{
				tDelete = tpObj->get_id( );
			}

			if( rand( ) % 100 < 30 )
			{
				CSceneObjManager::GetSingletonPtr( )->DestroyObject( tDelete );
				tDelete = 0;
				tDeleteCount++;
			}

			if( i % 1000 == 0 )
			{
				printf( "CreateEquipment Count %d\n", i );
				printf( "CreateEquipment Delete %d\n", tDeleteCount );
			}

		}
		printf( "End CreateEquipment\n" );
	}
	else if( strcasecmp(tCommandName, "client") == 0 )
	{
		LK_ASSERT(tToken.size()>=2, return);

		char tInfo[256] = "jfdaslkf jdl2	ljlkewjfdnsam,fd";
		CMessage tMessage;
		CMessageSendClientInfoRequest tPara;
		tMessage.mutable_msghead()->set_messageid(ID_C2S_REQUEST_CLIENTINFO);
		tPara.set_macaddr(tToken[1].c_str());
		tPara.set_hostinfo(tInfo);
		tMessage.set_msgpara((long) &tPara);
		CSceneServer::GetSingleton().OnMessageClientInfoRequest( &tMessage, pPlayer );
	}
	else if( strcasecmp( tCommandName, "Save2File" ) == 0 )
	{
		CSceneLogic::GetSingletonPtr( )->SavePlayer( pPlayer, SAVE_FILE ); 
	}
	else if( strcasecmp( tCommandName, "ReSave" ) == 0 )
	{
		LK_ASSERT(tToken.size()>=2, return);
		int tID = atoi( tToken[ 1 ].c_str() );
		CSceneLogic::GetSingletonPtr( )->ReSavePlayerFromFile( tID ); 
	}
	else if( strcasecmp( tCommandName, "ChangeCamp" ) == 0 )
	{
		ChangeNationality( pPlayer, ( CampDef )atoi( tToken[ 1 ].c_str( ) ) );
	}  
	else if( strcasecmp( tCommandName, "GetSelfPos" ) == 0 )
	{
		LOG_ERROR( "pro", "Entity( %d ) Pos Is %d : %d", pPlayer->GetEntityID( ), pPlayer->GetPosX( ), pPlayer->GetPosY( ) );	
	}
	else if( strcasecmp( tCommandName, "DropItem" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tItemID = atoi( tToken[ 1 ].c_str() );
		int tBaggageIndex = tpSrcProperty->GetBaggage()->mReleaseIndex;
		for ( int i = 0; i < tBaggageIndex; i ++ )
		{
			CItemObject* tpItem = tpSrcProperty->GetBaggage()->GetItemObjPtr( i );
			if ( tpItem == NULL )
			{
				continue;
			}
			if ( (int)tpItem->GetItemID() == tItemID )
			{
				PlayerThrowItem( pPlayer, i, 1 );
				break;
			}
		}
	}
	else if ( strcasecmp( tCommandName, "MineMap" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tType = atoi( tToken[ 1 ].c_str() );
		int tValue = atoi( tToken[ 2 ].c_str() );
		switch ( tType )
		{
			case CTplMineMap::EVENT_DROPITEM:
				{
					//RandomDropItem( pPlayer, tValue );
					break;
				}
			case CTplMineMap::EVENT_DESBUFF:
				{
					RandomHitBuff( pPlayer, tValue );
					break;
				}
			case CTplMineMap::EVENT_BRUSHOGRE:
				{
					//BrushOgre( pPlayer, tValue, false, false );
					break;
				}
			default:
				break;
		}		
	}
	
	else if( strcasecmp( tCommandName, "ClickNpc" ) == 0 )
	{
		unsigned int tEntityID = atoi( tToken[ 1 ].c_str( ) );
		PlayerClickNpc( pPlayer, tEntityID );
	}
	else if( strcasecmp( tCommandName, "GetRepetionMapInfo" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2 , return );
		int tMapID = atoi( tToken[ 1 ].c_str( ) );

		CPlayerRepetion* tpPlayerRepetion = CRepetionModule::GetSingletonPtr( )->GetPlayerRepetion( pPlayer );
		LK_ASSERT( tpPlayerRepetion != NULL, return );

		unsigned int tCount = 0;
		tpPlayerRepetion->GetRepetionCount( tMapID, &tCount ); 

		LOG_DEBUG( "pro", "Entity( %d : %d : %s ) RepetionMap( %d ) Count Is %d", pPlayer->GetEntityID( ),
			pPlayer->GetCharID( ), pPlayer->GetCharNameShow( ), tMapID, tCount );
	}
	else if( strcasecmp( tCommandName, "ClearPlayerRepetion" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2 , return );
		int tMapID = atoi( tToken[ 1 ].c_str( ) );

		CPlayerRepetion* tpPlayerRepetion = CRepetionModule::GetSingletonPtr( )->GetPlayerRepetion( pPlayer );
		LK_ASSERT( tpPlayerRepetion != NULL, return )
		tpPlayerRepetion->SetRepetion( tMapID, 0, 0 );
	}
	else if( strcasecmp( tCommandName, "Distance" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		CEntity* tpEntity1 = CSceneLogic::GetSingletonPtr()->GetEntity( atoi( tToken[ 1 ].c_str() ) );
		CEntity* tpEntity2 = CSceneLogic::GetSingletonPtr()->GetEntity( atoi( tToken[ 2 ].c_str() ) );
		if( tpEntity1 == NULL || tpEntity2 == NULL )
		{
			LOG_DEBUG( "pro", "[ %s : %d  ][ %s ]Debug Command %s args err", __LK_FILE__, __LINE__,
					__FUNCTION__, tCommandName );
			return;
		}
		LOG_DEBUG( "pro", "Entity( %d ) Pos( %d : %d ) Entity( %d ) Pos( %d : %d ) Distance is %d",
				tpEntity1->GetEntityID( ), tpEntity1->GetPosX( ), tpEntity1->GetPosY( ), tpEntity2->GetEntityID( ),
				tpEntity2->GetPosX( ), tpEntity2->GetPosY( ), tpEntity1->GetPos( ).Length( tpEntity2->GetPos( ) ) );

	}
	else if( strcasecmp( tCommandName, "GetPos" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 1, return );
		CEntity* tpEntity = CSceneLogic::GetSingletonPtr()->GetEntity( atoi( tToken[ 1 ].c_str() ) );
		if( tpEntity == NULL )
		{
			tpEntity = pPlayer;
		}
		LOG_DEBUG( "pro", "Entity( %d ) Pos( %d : %d )", tpEntity->GetEntityID( ), tpEntity->GetPosX( ), 
				tpEntity->GetPosY( ) );
	}
	else if ( strcasecmp(tCommandName,"MendEqt") == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int IfMendAll=atoi(tToken[1].c_str());		
		if ( IfMendAll == 1 )
		{			
			MendAllEquipment( pPlayer  );
		}
		else
		{
			LK_ASSERT( tToken.size() >= 4, return );
			int IsInBag=atoi(tToken[2].c_str());
			int Index=atoi( tToken[3].c_str() ) ;
			MendSigleEquipment( pPlayer  , IsInBag ,Index );
		}
	} 
	else if( strcasecmp( tCommandName, "GetMDefence" ) == 0 )
	{
		CPropertyValue tValue = CPropertyFormula::GetMDefence( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d )  Magic Defence is %d", pPlayer->GetEntityID( ), (int)tValue );
	}
	else if( strcasecmp( tCommandName, "GetMoney" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tMoney = atoi( tToken[1].c_str() );
		if (SetPlayerMoney( pPlayer->GetEntityID(), tMoney ) == 0)
		{
			LogEventGetMoneyByGMInsert(pPlayer, CYuanBao::em_unbind_money, tMoney);
		}

		LOG_DEBUG( "pro", "Entity( %d ) get money( %d ) from DebugCommand", pPlayer->GetEntityID( ),
				tMoney );
	}
	else if ( strcasecmp( tCommandName, "GetBindMoney" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tMoney = atoi( tToken[1].c_str() );
		if ( tMoney > 0 )
		{
			if (PlayerChangeMoney( pPlayer, tMoney, false, true ) == SUCCESS)
			{
				LogEventGetMoneyByGMInsert(pPlayer, CYuanBao::em_bind_money, tMoney);
			}
		}
		else
		{
			if (PlayerChangeMoney( pPlayer, (unsigned int)abs(tMoney), true, true ) == SUCCESS)
			{
				LogEventGetMoneyByGMInsert(pPlayer, CYuanBao::em_bind_money, (unsigned int)abs(tMoney));
			}
		}		
	}
	
	else if ( strcasecmp( tCommandName, "SetRefresh" ) == 0 )
	{
		time_t tNow = time( NULL );
		tpSrcProperty->SetLastRefreshTime( tNow );
	}	

	else if( strcasecmp( tCommandName, "GetPAttack" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) physis attack max value is %d, low value is %d", pPlayer->GetEntityID( ),
				int( CPropertyFormula::GetPAttackUpper( tpSrcProperty ) ), 
				int( CPropertyFormula::GetPAttackLower( tpSrcProperty ) ) );
	}
	else if( strcasecmp( tCommandName, "GetMAttack" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) Magic attack max value is %d, low value is %d", pPlayer->GetEntityID( ),
				int( CPropertyFormula::GetMAttackUpper( tpSrcProperty ) ),
				int( CPropertyFormula::GetMAttackLower( tpSrcProperty ) ) );
	}
	else if( strcasecmp( tCommandName, "GetSkillDuck" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) skill duck value is %d", pPlayer->GetEntityID( ), 
				int( CPropertyFormula::GetSkillDuck( tpSrcProperty ) ) );
	}
	else if( strcasecmp( tCommandName, "GetDamageLess" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) GetDamageLess value is %f", pPlayer->GetEntityID( ),
				CPropertyFormula::GetPImmunity( pPlayer->GetLevel(), tpSrcProperty ) );
	}
	else if( strcasecmp( tCommandName, "GetDeathValue" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) Death Value is %d", pPlayer->GetEntityID( ),
				(int)CPropertyFormula::GetDeathValue( tpSrcProperty ) );
	}
	else if( strcasecmp( tCommandName, "GetSkillless" ) == 0 )
	{	
		LK_ASSERT( tToken.size() >= 2, return );
		CPropertyValue tValue = CPropertyFormula::GetSkillLess( tpSrcProperty, atoi( tToken[1].c_str() ) ); 
		LOG_DEBUG( "pro", "Entity( %d ) Use SkillGeneriD use Magic less fix is %d, per is %d", 
				pPlayer->GetEntityID( ), tValue.mInitValue, tValue.mDeltaValue );
	}
	else if( strcasecmp( tCommandName, "GetDeathRate" ) == 0 )
	{
		int tValue = CPropertyFormula::GetDeathRate( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Death Rate is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetAddFixDamage" ) == 0 )
	{
		int tValue = CPropertyFormula::GetAddFixDamage( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Add Fix Damage is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetAddPerDamage" ) == 0 )
	{
		int tValue = CPropertyFormula::GetAddPerDamage( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Add Per Damage is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetDecFixPDamage" ) == 0 )
	{
		int tValue = CPropertyFormula::GetDecFixPDamage( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Dec Fix P Damage is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetDecPerPDamage" ) == 0 )
	{
		int tValue = CPropertyFormula::GetDecPerPDamage( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Dec Per P Damage is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetDecFixMDamage" ) == 0 )
	{
		int tValue = CPropertyFormula::GetDecFixMDamage( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Dec Fix M Damage is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetDecPerMDamage" ) == 0 )
	{
		int tValue = CPropertyFormula::GetDecPerMDamage( tpSrcProperty );
		LOG_DEBUG( "pro", "Entity( %d ) Dec Per M Damage is %d", pPlayer->GetEntityID( ), tValue );
	}
	else if( strcasecmp( tCommandName, "GetMaxHP" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) HP Max Value is %d", pPlayer->GetEntityID( ), 
//				int(CPropertyFormula::GetMaxHP( tpSrcProperty ) ) );
			( int )( ( ( CPropertyPlayer* )pPlayer->GetProperty( ) )->GetMaxHP( ) ) );
	}
	else if( strcasecmp( tCommandName, "GetCurHP" ) == 0 )
	{
		 LOG_DEBUG( "pro", "Entity( %d ) HP Cur Value is %d", pPlayer->GetEntityID( ),
		 	( ( CPropertyPlayer* )pPlayer->GetProperty( ) )->GetCurHP( ) );
	}
	else if( strcasecmp( tCommandName, "GetMaxMP" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) MP Max Value is %d", pPlayer->GetEntityID( ), 
				int(CPropertyFormula::GetMaxMP( tpSrcProperty ) ) );
	}
	else if( strcasecmp( tCommandName, "SetAP" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return  );
		int tAP = atoi( tToken[1].c_str() );
		CPropertyPlayer* pProPerty = (CPropertyPlayer*)pPlayer->GetProperty();
		pProPerty->SetCurAP(tAP);
	}
	else if( strcasecmp( tCommandName, "SetMP" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return  );
		int tMP = atoi( tToken[1].c_str() );

		int tEntityID = ( tToken.size() > 2 ) ? atoi( tToken[2].c_str() ) : pPlayer->GetEntityID();
		CEntity* pEntity = SceneServer::CSceneLogic::GetSingletonPtr()->GetEntity( tEntityID );
		if( pEntity != NULL && pEntity->IsCharacter() )
		{
			CPropertyCharacter* pCharProperty = (CPropertyCharacter*)( (CEntityCharacter*)pEntity)->GetProperty();
			pCharProperty->SetCurMP(tMP);
			pCharProperty->Refresh();
			((CEntityCharacter*)pEntity)->NotifyPropertyRefresh( );
		}

	}
	else if( strcasecmp( tCommandName, "SetHP" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return  );
		int tHP = atoi( tToken[1].c_str() );

		int tEntityID = ( tToken.size() > 2 ) ? atoi( tToken[2].c_str() ) : pPlayer->GetEntityID();
		CEntity* pEntity = SceneServer::CSceneLogic::GetSingletonPtr()->GetEntity( tEntityID );
		if( pEntity != NULL && pEntity->IsCharacter() )
		{
			CPropertyCharacter* pCharProperty = (CPropertyCharacter*)(( CEntityCharacter*)pEntity)->GetProperty();
			pCharProperty->SetCurHP(tHP);
			pCharProperty->Refresh();
			((CEntityCharacter*)pEntity)->NotifyPropertyRefresh( );
		}

	}
	else if( strcasecmp( tCommandName, "teleport" ) == 0 )	// 真正的传送
	{
		//Tokens tToken = StrSplit( tpMessage->debugcommond(), " " );

		LK_ASSERT( tToken.size() >= 3, return  );
		int tPosX = atoi( tToken[1].c_str() );
		int tPosY = atoi( tToken[2].c_str() );

		CMapModule::GetSingleton().Teleport( pPlayer->GetLineID(),
				pPlayer->GetMapID(),
				tPosX,
				tPosY,
				pPlayer );
	}
	else if( strcasecmp( tCommandName, "GetSP" ) == 0 )
	{
		LOG_DEBUG( "pro", "Entity( %d ) Have SkillPoint is %d", pPlayer->GetEntityID( ), 
				tpSrcProperty->GetSkillPoint( ) );
	}
	else if( strcasecmp( tCommandName, "KickAll" ) == 0 )	//  踢人功能
	{
		LK_ASSERT( tToken.size() >= 1, return  );
		//unsigned int uiCharID = atoi( tToken[1].c_str() );KickAllExcept( unsigned int unCharID )
		SceneServer::CSceneLogic::GetSingletonPtr()->KickAllExcept( pPlayer->GetEntityID());
		LOG_DEBUG( "pro", "kick all online player" );
	}
	else if ( strcasecmp( tCommandName, "Kick" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return  );
		SceneServer::CSceneLogic::GetSingletonPtr()->KickPlayer( atoi( tToken[1].c_str() ) );
	}
	
	else if ( strcasecmp( tCommandName, "ResetPK" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tValue = atoi( tToken[ 1 ].c_str() );
		tpSrcProperty->SetPKValue( tValue );
		SendPKValueMessage( pPlayer, tValue );
	}
	

	else if ( strcasecmp( tCommandName , "MoveItem" ) ==0 )
	{
		LK_ASSERT( tToken.size() >= 6, return  );
		int SrcKind  = atoi( tToken[1].c_str());
		int SrcIndex = atoi( tToken[2].c_str());
		int DesKind  = atoi( tToken[3].c_str());
		int DesIndex = atoi( tToken[4].c_str());
		int ItemNum  = atoi( tToken[5].c_str());
		MoveItem( pPlayer,  SrcIndex , SrcKind, DesIndex, DesKind ,ItemNum );		
	}
	//	
/*	else if ( strcasecmp( tCommandName, "GetStorMsg" ) == 0 )
	{
		GetStorageInfo( pPlayer );
	}*/	
	else if( strcasecmp( tCommandName, "GetCon" ) == 0 )
	{
		CPropertyValue tValue = tpProperty->GetCon( );
		LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %d : %d : %s ) Con( %d : %d )", __LK_FILE__, __LINE__, __FUNCTION__,
				pPlayer->GetEntityID( ), pPlayer->GetCharID(), pPlayer->GetCharNameShow(), tValue.mInitValue, 
				tValue.mDeltaValue );
	}
	else if( strcasecmp( tCommandName, "GetSta" ) == 0 )
	{
		CPropertyValue tValue = tpProperty->GetSta( );
		LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %d : %d : %s ) Sta( %d : %d )", __LK_FILE__, __LINE__, __FUNCTION__,
				pPlayer->GetEntityID( ), pPlayer->GetCharID(), pPlayer->GetCharNameShow(), tValue.mInitValue, 
				tValue.mDeltaValue );
	}
	else if( strcasecmp( tCommandName, "GetStr" ) == 0 )
	{
		CPropertyValue tValue = tpProperty->GetStr( );
		LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %d : %d : %s ) Str( %d : %d )", __LK_FILE__, __LINE__, __FUNCTION__,
				pPlayer->GetEntityID( ), pPlayer->GetCharID(), pPlayer->GetCharNameShow(), tValue.mInitValue, 
				tValue.mDeltaValue );
	}
	else if( strcasecmp( tCommandName, "GetWis" ) == 0 )
	{
		CPropertyValue tValue = tpProperty->GetWis( );
		LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %d : %d : %s ) Wis( %d : %d )", __LK_FILE__, __LINE__, __FUNCTION__,
				pPlayer->GetEntityID( ), pPlayer->GetCharID(), pPlayer->GetCharNameShow(), tValue.mInitValue, 
				tValue.mDeltaValue );
	}
	else if( strcasecmp( tCommandName, "GetSpr" ) == 0 )
	{
		CPropertyValue tValue = tpProperty->GetSpr( );
		LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %d : %d : %s ) Spr( %d : %d )", __LK_FILE__, __LINE__, __FUNCTION__,
				pPlayer->GetEntityID(), pPlayer->GetCharID(), pPlayer->GetCharNameShow(), tValue.mInitValue, 
				tValue.mDeltaValue );
	}
	//else if ( strcasecmp( tCommandName, "GetStorMsg" ) == 0 )
	//{
	//	GetStorageInfo( pPlayer );
	//}	
	else if (  strcasecmp( tCommandName, "ReduceDura" ) == 0  )
	{
		ChangeDurabilityOnDeath( ( CEntity * ) pPlayer );
	}
	else if( strcasecmp( tCommandName, "GetGridInfo" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return  );
		CMapObject* tpObj = CMapObjManager::GetSingletonPtr( )->GetMapObject( pPlayer->GetLineID(), 
				pPlayer->GetMapID( ), pPlayer->GetMapIndex( ) );
		if( tpObj == NULL )
			{
			LOG_DEBUG( "pro", "[ %s : %d ][ %s ] GetGridInfo::Map( %d : %d : %d ) Cannt find", __LK_FILE__, __LINE__, 
					__FUNCTION__, pPlayer->GetLineID(), pPlayer->GetMapID( ), pPlayer->GetMapIndex( ) );
			return;	
		}
		CGridBlock* tpGrid = tpObj->GetGridBlock( atoi( tToken[1].c_str( ) ), atoi( tToken[2].c_str() ) );
		if( tpGrid == NULL )
		{
			LOG_DEBUG( "pro", "[ %s : %d ][ %s ] GetGridInfo::Map( %d : %d : %d ) Cannt find Grid( %d : %d )",
					__LK_FILE__, __LINE__, __FUNCTION__, pPlayer->GetLineID(), pPlayer->GetMapID( ), 
					pPlayer->GetMapIndex( ), atoi( tToken[1].c_str( ) ), atoi( tToken[2].c_str() ) );
			return;
		} 
		LOG_DEBUG( "pro", "[ %s : %d ][ %s ] GetGridInfo::Map( %d : %d : %d ) Grid( %d : %d ) Info( %d )",
				__LK_FILE__, __LINE__, __FUNCTION__, pPlayer->GetLineID(), pPlayer->GetMapID( ), 
				pPlayer->GetMapIndex( ), atoi( tToken[1].c_str( ) ), atoi( tToken[2].c_str() ), 
				tpGrid->mBlockInfo[ 0 ] );

	}
	else if( strcasecmp( tCommandName,"thowstoritem" ) == 0  )
	{
		LK_ASSERT( tToken.size() >= 3, return  );
		int itemindex  = atoi( tToken[1].c_str());
		int num        = atoi( tToken[2].c_str());
		PlayerThrowStorItem( pPlayer, itemindex, num  );

	}
	
	else if( strcasecmp( tCommandName, "Repetion" ) == 0 )
	{
		//		unsigned short tLineID = atoi( tToken[ 1 ].c_str( ) );
		unsigned short tMapID = atoi( tToken[ 1 ].c_str( ) );
		//		unsigned short tPosX = atoi( tToken[ 3 ].c_str( ) );
		//		unsigned short tPosY = atoi( tToken[ 4 ].c_str( ) );

		//		if( CMapModule::GetSingletonPtr( )->Teleport( tLineID, tMapID, tPosX, tPosY, pPlayer, 0 ) == false )
		//		{
		//			LOG_DEBUG( "pro", "[ %s : %d ][ %s ]FB Telport ( %d : %d : %d : %d ) false", __LK_FILE__, __LINE__,
		//				__FUNCTION__, tLineID, tMapID, tPosX, tPosY);
		//		}
		CRepetionModule::GetSingletonPtr( )->RedirectRepetionMap( pPlayer, tMapID, 0, 0, NULL );
	}
	else if( strcasecmp( tCommandName, "GetMapInfo" ) == 0 )
	{
		KEY_TYPE tKey = INVITED_KEY_VALUE;

		CMapObject* tpMapObj = pPlayer->GetMapObject( );
		if( tpMapObj != NULL )
		{
			tKey = tpMapObj->GetKey( );
		}

		LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Entity( %s : %d : %d ) MapInfo( %d : %d : %d : %lld )", __LK_FILE__, 
				__LINE__, __FUNCTION__, pPlayer->GetCharNameShow(), pPlayer->GetCharID(), 
				pPlayer->GetEntityID( ), pPlayer->GetLineID( ), pPlayer->GetMapID( ), pPlayer->GetMapIndex( ), tKey );
	}

	//else if ( strcasecmp( tCommandName, "ClearTask" ) == 0 )
	//{
	//	LK_ASSERT( tToken.size() >= 2, return  );

	//	int nTaskID = atoi( tToken[1].c_str() );
	//	CTaskModule::GetSingletonPtr()->ClearCompletedTask( pPlayer, (unsigned short)nTaskID );
	//}
	else if( strcasecmp( tCommandName, "IsTaskOnPlayer" ) == 0 )
	{
		unsigned short tTaskID = atoi( tToken[ 1 ].c_str( ) );
		bool tBool = CTaskModule::GetSingletonPtr( )->IsTaskOnPlayer( pPlayer, tTaskID );
		if( tBool == true )
		{
			LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %s : %d : %d ) Have Task( %d )", __LK_FILE__, __LINE__, 
					__FUNCTION__, pPlayer->GetCharNameShow(), pPlayer->GetCharID(), pPlayer->GetEntityID( ), 
					tTaskID );
		}
		else
		{
			LOG_DEBUG( "pro", "[ %s : %d ][ %s ]Player( %s : %d : %d ) Don't Have Task( %d )", __LK_FILE__, __LINE__, 
					__FUNCTION__, pPlayer->GetCharNameShow(), pPlayer->GetCharID(), pPlayer->GetEntityID( ), 
					tTaskID );

		}
	}
	/*else if ( strcasecmp( tCommandName, "EndTeam" ) == 0 )
	{
		if ( pPlayer->GetTeamFlag() == (int)pPlayer->GetCharID() )
		{
			CMessage tMessage;
			tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_ENDTEAM );
			CMessageTeamEnd tPara;
			tMessage.set_msgpara( (long) &tPara );
			CTeamModule::GetSingleton().OnMessageEndTeam( pPlayer, &tMessage );
		}
	}	*/
	else  if( strcasecmp( tCommandName, "IrrigateYQS" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int vdaw;      //仙丹大小

		int iYQS = (int)atoi( tToken[1].c_str() );  //仙丹数
		const char *str = tToken[2].c_str();

		if(str == NULL)
		{ 
			vdaw = 70733;
		}
		else
		{
			char ch = str[0];
			switch(ch)
			{
			case 's':case 'S':vdaw = 70733;break;
			case 'm':case 'M':vdaw = 70734;break;
			case 'l':case 'L':vdaw = 70735;break;
			default:vdaw = 70733;break;
			}
		}

		for(int i = 0; i < iYQS; ++i)
		{

			CPropertyModule::GetSingleton().PlayerInsertItem( pPlayer, vdaw, 1);
			CMessage tMessage;
			CMessageHandInRequest tMsgRequest;	 
			tMessage.mutable_msghead()->set_messageid( ID_C2S_HANDIN_REQUEST );
			tMsgRequest.set_playerid(pPlayer->GetCharID());
			tMsgRequest.set_activityid(HELPID_YAOQIANSHU);
			tMsgRequest.set_itemnum(1);
			ItemForHandin* p = tMsgRequest.add_items();
			p->set_itemtype(ITEM_FUNCITEM);
			p->set_itemid(0);
			p->set_itemnum(1);
			tMessage.set_msgpara( (int)& tMsgRequest );
			CActivityYqs::GetSingleton().OnMessageHandinRequest(pPlayer,&tMessage);

		}

		LOG_DEBUG( "pro", "Entity( %d ) has irrigated  YaoQianShu %d  times from DebugCommand", pPlayer->GetEntityID(), iYQS );
	}



    else  if( strcasecmp( tCommandName, "JumpTower" ) == 0 )
	{
       
            LK_ASSERT( tToken.size() >= 2, return );
			int step;
		    int floor = (int)atoi( tToken[1].c_str() );
			LK_ASSERT( floor <=100, return );
			if (floor%10 == 0)
			{
				step = floor/10 - 1;
			}
			else
			{
				step = floor/10;

			}
		
		    CRepetionModule::GetSingletonPtr( )->PlayerJumpTower(pPlayer,step,floor);
	}




	else if( strcasecmp( tCommandName, "UseSkill" ) == 0 )
	{
		CPropertyCharacter* tpProPlayer = (CPropertyCharacter*) pPlayer->GetProperty();
		if( tpProPlayer != NULL )
		{
			int tSkill = atoi( tToken[ 1 ].c_str( ) );
			CTemplateSkill* tpSkill = ( CTemplateSkill* )CDataStatic::SearchTpl( tSkill );
			UseSkillForServer( pPlayer, pPlayer, tpSkill, NULL, 0 );
		}
	}
	else if ( strcasecmp( tCommandName, "InsertBuff" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		CPropertyCharacter* tpProPlayer = (CPropertyCharacter*) pPlayer->GetProperty();
		if ( tpProPlayer != NULL )
		{
			int tBuffID = atoi( tToken[1].c_str() );
			CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( tBuffID );
			if ( tpBuffTpl != NULL )
			{
				//TODO: 这里就不同步listid了
				pPlayer->EntityInsertBuff( pPlayer, tpBuffTpl );
		
			}
		}
	}
	else if ( strcasecmp( tCommandName, "RemoveBuff" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		CPropertyCharacter* tpProPlayer = (CPropertyCharacter*) pPlayer->GetProperty();
		if ( tpProPlayer != NULL )
		{
			int tBuffID = atoi( tToken[1].c_str() );

			//TODO: 这里就不同步listid了
			pPlayer->EntityRemoveBuff( tBuffID );
			LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
		}
	}
	else if ( strcasecmp( tCommandName, "AbortTask" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pPlayer->GetProperty();
		if ( tpProPlayer != NULL )
		{
			int tTaskID = atoi( tToken[1].c_str() );
			CTaskModule::GetSingleton().PlayerAbortTask( pPlayer, tTaskID, true );
			LogEventPlayerCancelTask(pPlayer, tTaskID,0);
		}
	}
	// 扣东西
	else if ( strcasecmp( tCommandName, "clearitem" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tID  = atoi( tToken[1].c_str() );
		int tNum = atoi( tToken[2].c_str() );
		bool tBind = false;
		PlayerRemoveItemByID( pPlayer, tID, tNum, tBind );
	}
	else if ( strcasecmp( tCommandName, "ClearTask" ) == 0 )
	{
		CTaskModule::GetSingleton().ClearTasks( pPlayer );
	}
	else if ( strcasecmp( tCommandName, "EndTask" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		unsigned short tTaskID = (unsigned short)atoi( tToken[1].c_str() );
		CTaskModule::GetSingleton().DisposeEndTask( pPlayer, tTaskID );
		LogEventPlayerEndTask(pPlayer, tTaskID);
	}
	else if ( strcasecmp( tCommandName, "GetOgre" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int nOgreID = (int)atoi( tToken[1].c_str() );
		//int nIndex  = (int)atoi( tToken[2].c_str() );
		//PlayerGetOgre( pPlayer, nOgreID );
		CWTPoint tPos = CWTPoint( pPlayer->GetPosX() + 1, pPlayer->GetPosY() + 1 );
		CreateNpc( pPlayer, nOgreID, ENTITYTYPE_OGRE, tPos, 0, true );
	}
	else if ( strcasecmp( tCommandName, "GetNpc" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int nNpcID = (int)atoi( tToken[1].c_str() );
		CWTPoint pos( pPlayer->GetPosX()+1, pPlayer->GetPosY()+1);
		//CreateNpc( pPlayer, nNpcID, ENTITYTYPE_FUNCNPC, pos, 20000, true, true );
		//for (int i = 0; i< 100; ++i)
			CreateNpc( pPlayer, nNpcID, ENTITYTYPE_FUNCNPC, pos, 100000, true, false, 0, 1 );
	}
	else if ( strcasecmp( tCommandName, "mwup" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int nLv = (int)atoi( tToken[1].c_str() );
		MWLevelUp(pPlayer, nLv);
	}
	else if ( strcasecmp( tCommandName, "Sysmail" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tMailID = (int)atoi( tToken[1].c_str() );
		int nItemIDs[MAIL_ITEM_COUNT_MAX] = {0};
		int nItemNums[MAIL_ITEM_COUNT_MAX] = {0};		
		int tSize = tToken.size();
		int tNum = 0;
		for ( tNum = 0; tNum < ( tSize - 2 ) && tNum < MAIL_ITEM_COUNT_MAX; ++tNum )
		{
			nItemIDs[tNum] = atoi(  tToken[tNum+2].c_str() );	
			nItemNums[tNum] = 1;					
		}		
		CMailModule::GetSingleton().SendSysMailBySysID( tMailID, pPlayer->GetCharName(), pPlayer->GetCharID()	
			, nItemIDs, nItemNums, tNum, pPlayer->GetNationality(), 100 ) ;
	}
	else if ( strcasecmp( tCommandName, "mailparam" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int	 tMailID = ( int )atoi( tToken[1].c_str() );
		char *pParamPtr[10] = { NULL };
		int pParamPos[10]    = { 0 };		
		int tSize = tToken.size();
		int tNum = 0;
		for ( int i = 2; i < tSize; ++i )
		{
			pParamPos[tNum] = atoi( tToken[i].c_str() );		
			if ( i + 1 >= tSize )
			{
				break;
			}			
			pParamPtr[tNum] = ( char * )tToken[i+1].c_str();
			++tNum;
			++i;
		}
		CMailModule::GetSingleton().SendSysMailBySysID( tMailID, pPlayer->GetCharName(), pPlayer->GetCharID()	
			, NULL, NULL, 0, pPlayer->GetNationality(), 100, pParamPtr, pParamPos, ( tSize - 2 )/2 ) ;
	}
	else if ( strcasecmp( tCommandName, "GetGTask" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		CMessageGetFamilyTaskRequest msg;
		msg.add_tasktypes((int)atoi( tToken[1].c_str() ));
		CMessage tMessage;
		tMessage.set_msgpara((uint32_t) &msg);
		CTaskModule::GetSingleton().OnMessagePlayerGeFamilyTask( pPlayer, &tMessage );
	}
	else if ( strcasecmp( tCommandName, "GetMWExp" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int num = (int)atoi( tToken[1].c_str() );
		OnMagicWeaponObtainExp( pPlayer, num );
	}
	else if (strcasecmp( tCommandName, "mmp" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		CPropertyPlayer* tpPro = (CPropertyPlayer*) pPlayer->GetProperty();
		CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
		int n = (int)atoi( tToken[1].c_str() );
		if ( tpMW == NULL )
			return ;
		tpMW->OnIncMp( n );
		NotifyRefreshMagicWeaponProperty( pPlayer, MAGIC_WEAPON_MP, -1 );
	}
	else if (strcasecmp( tCommandName, "mhp" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		CPropertyPlayer* tpPro = (CPropertyPlayer*) pPlayer->GetProperty();
		CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
		int n = (int)atoi( tToken[1].c_str() );
		if ( tpMW == NULL )
			return ;
		tpMW->OnIncHp( n );
		NotifyRefreshMagicWeaponProperty( pPlayer, MAGIC_WEAPON_HP, -1 );
	}
	else if ( strcasecmp( tCommandName, "Getbox" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int nNpcID = (int)atoi( tToken[1].c_str() );
		CWTPoint pos( pPlayer->GetPosX()+1, pPlayer->GetPosY()+1);
		//CreateNpc( pPlayer, nNpcID, ENTITYTYPE_FUNCNPC, pos, 20000, true, true );
		//for (int i = 0; i< 100; ++i)
			CreateNpc( pPlayer, nNpcID, ENTITYTYPE_BOX, pos, 100000, true, false, 0, 1 );
	}
	else if ( strcasecmp( tCommandName, "GetDrop" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tID = CActivityModule::GetSingleton().GetActivityOgreDropID((int)atoi( tToken[1].c_str() ));
		SendProErrorNotice( pPlayer, tID );
	}
	
	//else if ( strcasecmp( tCommandName, "GetRank" ) == 0 )
	//{
	//	LK_ASSERT( tToken.size() >= 2, return );
	//	CMessageGetPlayerRankRequest msg;
	//	msg.set_beginindex(0);
	//	msg.set_recordnum(50);
	//	int nType = (int)atoi( tToken[1].c_str() );
	//	msg.set_ranktype(nType);
	//	CMessage   tMessage;
	//	tMessage.set_msgpara((uint32_t) &msg);
	//	tMessage.mutable_msghead()->set_messageid(ID_C2S_REQUEST_PLAYERRANK);
	//	CRankModule::GetSingleton().OnClientMessagePlayerRankRequest( pPlayer, &tMessage );
	//}
	else if ( strcasecmp( tCommandName, "GetBox" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int nNpcID = (int)atoi( tToken[1].c_str() );
		CWTPoint pos( pPlayer->GetPosX()+1, pPlayer->GetPosY()+1);
		CreateNpc( pPlayer, nNpcID, ENTITYTYPE_BOX, pos, 20, true );
	}
	else if ( strcasecmp( tCommandName, "Kill" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		int nNpcEntityID = (int)atoi( tToken[1].c_str() );
		CEntityCharacter* pEntity = (CEntityCharacter*)CSceneLogic::GetSingleton().GetEntity( nNpcEntityID );
		if ( pEntity != NULL )
		{
			pEntity->EntityDie( pPlayer, true );
		}
	}
	//else if ( strcasecmp( tCommandName, "GiveTask" ) == 0 )
	//{
	//	LK_ASSERT( tToken.size() > 2, return );

	//	unsigned short tTaskID = (unsigned short)atoi( tToken[1].c_str() );
	//	int nIndex = (int)atoi( tToken[2].c_str() );
	//	CTaskModule::GetSingleton().OnPlayerEndTask( pPlayer, tTaskID, -100 );
	//}
	else if ( strcasecmp( tCommandName, "ClearTragedy" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );

		CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pPlayer->GetProperty();
		if ( tpProPlayer != NULL )
		{
			int tIndex = atoi( tToken[1].c_str() );
			CTaskModule::GetSingleton().ClearTragedy( pPlayer , tIndex );
		}
	}
	else if( strcasecmp( tCommandName, "GetSceneCount" ) == 0 )
	{
		LOG_DEBUG( "pro", "Scene Player Count Is %d", CSceneLogic::GetSingletonPtr( )->GetPlayerNumber( ) );
	}
	else if ( strcasecmp( tCommandName,"SetHelpStatus" ) == 0   )
	{
		LK_ASSERT( tToken.size()   >=3, return);
			int Index = atoi( tToken[1].c_str() );
			int Status = atoi( tToken[2].c_str() );
			tpSrcProperty->GetShortcut( )->SetHelpStatus( Status, Index );
			
	}
	else if (  strcasecmp( tCommandName,"fcht" ) == 0  )
	{
			LK_ASSERT( tToken.size()   >=4, return);
			int channel = atoi(tToken[1].c_str());
			int result  = atoi(tToken[2].c_str());
			int charid  = atoi( tToken[3].c_str() );
			if ( result == 0 )
			{
				CChatModule::GetSingleton().SetChannelFalse( charid, channel, 30*60 );
			}
			else
			{
				CChatModule::GetSingleton().SetChannelTrue( charid, channel );
			}
	}		
	else if ( strcasecmp( tCommandName, "TeleSymbol" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
			int tIndex = atoi( tToken[ 1 ].c_str() );
			int tOrder = atoi( tToken[ 2 ].c_str() );
			CMessage tMessage;
			CMessageUseItemRequest tPara;
			tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_USEITEM );
			tPara.set_pos( POS_BAGGAGE );
			tPara.set_index( tIndex );
			tPara.set_param( tOrder );
			tMessage.set_msgpara( (long) &tPara );
			OnMessageUseItemRequest( pPlayer, &tMessage );
	}
	else if ( strcasecmp( tCommandName, "getitem" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
			int tItemID = atoi( tToken[ 1 ].c_str() );
			int tNumber = atoi( tToken[ 2 ].c_str() );

			CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tItemID, tNumber, false );
			if ( pInsItemPile != NULL)
			{
				LogEventGetItemByGmInsert(pPlayer, pInsItemPile->GetGUID(), tItemID, tNumber);
			}
	}
	else if ( strcasecmp( tCommandName, "Freeze" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tType = atoi( tToken[ 1 ].c_str() );
		CMessage tMessage;
		CMessageFreezeDiploidRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_FREEZEDIPLOID );
		if ( tType > LK_ZERO )
		{
			tPara.set_type( (int) true );
		}
		else
		{
			tPara.set_type( (int) false );
		}
		tMessage.set_msgpara( (long) &tPara );
		OnMessageFreezeDiploidRequest( pPlayer, &tMessage );		
	}
	else if ( strcasecmp( tCommandName, "validtime" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 1, return );		
		int tTime = tpSrcProperty->GetValidDiploid();
		int tDiploid = tpSrcProperty->GetDiploid();
		LOG_DEBUG( "team", "valid time : %d", tTime );
		LOG_DEBUG( "team", "Diploid Has: %d", tDiploid ); 
	}
	
	else if (  strcasecmp( tCommandName, "startredstone" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tTempID = atoi( tToken[1].c_str() );	
		int tTeamID  = CTeamModule::GetSingleton().InTeam( pPlayer->GetCharID() );
		if ( tTeamID == INVALID_OBJ_ID )					
		{
			return;
		}
		StartRedstone( pPlayer, tTeamID, tTempID, false );				
	} 	
	else if (  strcasecmp( tCommandName, "creatredstone" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int TempID = atoi( tToken[1].c_str() );
		int Type = atoi( tToken[2].c_str() );
		unsigned int tEntityID = 0;
		int tCharIDList[TEAMNUM] = { 0 };
		tCharIDList[0] = pPlayer->GetCharID();
		CRedstondeCreator tDropCreator( TempID ,5,pPlayer->mPos.mX, 
			pPlayer->mPos.mY,tCharIDList );
		CMapModule::GetSingleton().CreateNpc( 
			pPlayer->GetLineID(),
			pPlayer->GetMapID(),
			pPlayer->GetMapIndex(),
			&tDropCreator,
			tEntityID);
		CEntityRedStone *tpRedStone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tEntityID );
		if ( tpRedStone != NULL )
		{
			switch( Type )
			{
				case CTplRedStone::TYPE_TEAM:
				{
					int tTeamID  = CTeamModule::GetSingleton().InTeam( pPlayer->GetCharID() );
					if ( tTeamID == INVALID_OBJ_ID )					
					{
						return;
					}
					tpRedStone->SetTeamID( tTeamID );
					break;
				}
				
				case CTplRedStone::TYPE_FAMILY:
				{
					if ( pPlayer->GetFamilyID() == 0 )
					{
						return;
					}
					tpRedStone->SetTeamID( pPlayer->GetFamilyID() );
					break;
				}
				
				case CTplRedStone::TYPE_CAMP:
				{
					int tCampID = CSceneLogic::GetSingleton().GetLineID();
					tpRedStone->SetTeamID( tCampID );
					break;
				}
			}
			
			BeginRedStoneMagic( tpRedStone,  pPlayer );
		}
	}
	else if ( strcasecmp( tCommandName, "clickredstone" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int RedStoneID = atoi( tToken[1].c_str() );
		PlayerClickRedStone( pPlayer, RedStoneID );
	}

	else if ( strcasecmp( tCommandName, "stoptimer" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int RedStoneID = atoi( tToken[1].c_str() );
		StopRedStonTimer( pPlayer, RedStoneID );
	}
	else if (  strcasecmp( tCommandName, "setwelfare" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int WelfareMark = atoi( tToken[1].c_str() );
		tpSrcProperty->SetWelfareStatus( WelfareMark );		
	}
	else if ( strcasecmp( tCommandName, "redura" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int dura = atoi( tToken[1].c_str() );
		int Index = atoi( tToken[2].c_str() );
		CItemObject *tpItemobj = ( CItemObject * )tpSrcProperty->GetBaggage()->GetItemObjPtr( Index );
		if ( tpItemobj == NULL )
		{
			return;
		} 
		CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl(  tpItemobj->GetItemID() );
		if ( tpTplItem == NULL )
		{
			return;
		}
		if ( tpTplItem->mItemType != ITEM_WEAPON && tpTplItem->mItemType != ITEM_ARMOR )
		{
			return;
		}  		
		CItemEquipment *tpItemEqupt = ( CItemEquipment * )	tpItemobj;
		tpItemEqupt->SetDurability( dura );
		CMessage                     MessageHead;
		CMessageNotifyEqptDurability MsgBodyItem;
		MsgBodyItem.add_eqptindex( Index );
		MsgBodyItem.add_eqptdurability( dura );
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEHARDINESS );
		MsgBodyItem.set_isinpackage( 1 );
		MessageHead.set_msgpara( ( int ) &MsgBodyItem );
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer , &MessageHead ); 
		
	}
	else if ( strcasecmp( tCommandName, "clearbuf" ) == 0 )
	{			   
		tpSrcProperty->GetBuffList()->Clean();
		tpSrcProperty->CleanStateParam( );
	}
	else if ( strcasecmp( tCommandName, "SysNotice" ) == 0 )
	{			   
		LK_ASSERT( tToken.size() >= 3, return );
		const char *pMsg =  tToken[1].c_str();
		int			Num	 =  atoi(tToken[2].c_str());
		CChatModule::GetSingleton().SendSysNotice( pMsg, Num );
	}			 		
	else if ( strcasecmp( tCommandName, "ListIbItem") == 0)
	{
		CMessageListIbItemsRequest tFactMsg;

		CMessage tMsg;
		tMsg.set_msgpara((uint32_t) &tFactMsg);
		pbmsg_sethead(&tMsg, ID_C2S_REQUEST_LISTIBITEMS, 0, 0, 0, 0, 0, 0);

		CIbStoreModule::GetSingleton().OnClientMessage(pPlayer, &tMsg);
	}
	else if ( strcasecmp( tCommandName, "PurchaseIbItem") == 0)
	{
		CMessagePurchaseIbItemRequest tFactMsg;

		tFactMsg.set_goodsid(atoi(tToken[1].c_str()));
		tFactMsg.set_goodscount(atoi(tToken[2].c_str()));

		CMessage tMsg;
		tMsg.set_msgpara((uint32_t) &tFactMsg);
		pbmsg_sethead(&tMsg, ID_C2S_REQUEST_PURCHASEIBITEM, 0, 0, 0, 0, 0, 0);

		CIbStoreModule::GetSingleton().OnClientMessage(pPlayer, &tMsg);
	}
	else if ( strcasecmp( tCommandName, "Invest") == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return )
		int Type = atoi(tToken[1].c_str());
		int ID =  atoi(tToken[2].c_str());
		CActivityModule::GetSingleton().OnEventInvestQuestion( Type, ID, pPlayer );
	}
	else if ( strcasecmp( tCommandName, "InvestAnswer" ) == 0 )
	{  
		CMessage tMsgHead;
		CMessageInvestAnswerNotify	tMsgInvestAnswer;
		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_NOTIFY_INVESTANSWER );
		tMsgHead.set_msgpara( (int)&tMsgInvestAnswer );
		
		tMsgInvestAnswer.add_questionid( 44 );
		tMsgInvestAnswer.add_questionanswer( 1 );
		tMsgInvestAnswer.add_questionid( 43 );
		tMsgInvestAnswer.add_questionanswer( 1 );
		
		tMsgInvestAnswer.add_questionid( 2 );
		tMsgInvestAnswer.add_questionanswer( 1 );
		
		tMsgInvestAnswer.add_questionid( 1 );
		tMsgInvestAnswer.add_questionanswer( 1 );
		
		tMsgInvestAnswer.add_questionid( 46 );
		tMsgInvestAnswer.add_questionanswer( 1 ); 
		
		tMsgInvestAnswer.set_ifanswernow( 1 );		
		CActivityModule::GetSingleton().OnMessageInvestAnwerNotify( pPlayer, &tMsgHead );
	}
	else if ( strcasecmp ( tCommandName, "ListActivityItem") == 0)
	{
		CMessageListActivityItemRequest tFactMsg;

		CMessage tMsg;
		tMsg.set_msgpara((uint32_t) &tFactMsg);
		pbmsg_sethead(&tMsg, ID_C2S_REQUEST_LISTACTIVITYITEM, 0, 0, 0, 0, 0, 0);

		OnMessageListActivityItem(pPlayer, &tMsg);
	}else if ( strcasecmp ( tCommandName, "MinusActivityItem") == 0)
	{
		CMessageMinusActivityItemRequest tFactMsg;

		CMessage tMsg;
		tMsg.set_msgpara((uint32_t) &tFactMsg);
		pbmsg_sethead(&tMsg, ID_C2S_REQUEST_MINUSACTIVITYITEM, 0, 0, 0, 0, 0, 0);
		OnMessageMinusActivityItem(pPlayer, &tMsg);
	}
	else if( strcasecmp( tCommandName, "creatfamily") == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		const char *FamilyName =  tToken[1].c_str();
		CMessage MsgHead;
		CMessageCreatFamilyRequest MsgCreatFamily;
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );
		MsgCreatFamily.set_familyname( FamilyName );
		MsgHead.set_msgpara( (int)&MsgCreatFamily );
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_CREATFAMILY );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );		 		
	}	
	else if ( strcasecmp( tCommandName, "disbandfamily") == 0 )
	{
		CMessage MsgHead;
		CMessageDisbandFamilyRequest MsgDisBandFamily;
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&MsgDisBandFamily );
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_DISBANDFAMILY );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );				
	}
	else if ( strcasecmp( tCommandName, "invitemember") == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CMessage MsgHead;
		CMessageInviteMemberRequest Msg;
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&Msg );
		Msg.set_rolename( tToken[1].c_str() );
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_INVITEMEMBER );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );			
	}
	else if ( strcasecmp( tCommandName, "replyinvite") == 0 )
	{													
		LK_ASSERT( tToken.size() >= 4, return )
		CMessage MsgHead;
		CMessageReplyFamilyInviteRequest Msg;
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&Msg ); 
		Msg.set_invitingroleid( atoi( tToken[1].c_str() ) );
		Msg.set_result( atoi( tToken[2].c_str() ) );	
		Msg.set_familyid( atoi( tToken[3].c_str() ) ); 
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPLYFAMILYINVITE );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );				
	}
	else if ( strcasecmp( tCommandName, "CreateEntityByCreator" ) == 0 )
	{
		CCreator* tpCreator = ( CCreator* )CCreatorManager::GetSingletonPtr( )->GetCreator( 
			atoi( tToken[ 1 ].c_str( ) ) );
		CMapObject* tpMapObj = CMapObjManager::GetSingletonPtr( )->GetMapObject( pPlayer->GetLineID( ), 
			pPlayer->GetMapID( ), pPlayer->GetMapIndex( ) );
		tpMapObj->CreateNpc( tpCreator, false );
	}
	else if ( strcasecmp( tCommandName, "hierogram" ) == 0 )
	{
		CWTPoint	tPoint( pPlayer->GetPosX( ) - 1, pPlayer->GetPosY( ) - 1 );
		CPedalCreator tPedalCreator;
		tPedalCreator.mPedalType	= PEDAL_HIEROGRAM;
		tPedalCreator.mMapID		= pPlayer->GetMapID();
		tPedalCreator.mLineID		= pPlayer->GetLineID();
		tPedalCreator.mSkillID		= 0;//::atoi( tToken[1].c_str() );
		tPedalCreator.mSkillLevel	= 0;//::atoi( tToken[2].c_str() );
		tPedalCreator.mSrcRect		= CWTRect( tPoint, tPoint );
		tPedalCreator.mTempID		= atoi( tToken[ 1 ].c_str( ) );//40511;

		CTplHierogram* tpTpl = ( CTplHierogram* )CDataStatic::SearchTpl( atoi( tToken[ 1 ].c_str( ) ) );
		CMapObject* tpMapObj = CMapObjManager::GetSingletonPtr( )->GetMapObject( 
			pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetMapIndex( ) );

		CreateHierogram( tpTpl, &tPoint, tpMapObj );  		
//		unsigned int tEntityID = 0;
//		if ( CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(),
//			pPlayer->GetMapID(), pPlayer->GetMapIndex(), &tPedalCreator, tEntityID ) == true )
//		{
//			LOG_DEBUG( "pro", "[%s:%d:%s] createhierogram success! SkillID(%d) SkillLevel(%d)", __LK_FILE__, __LINE__, __FUNCTION__, tPedalCreator.mSkillID, tPedalCreator.mSkillLevel );
//		}
//		else
//		{
//			LOG_DEBUG( "pro", "[%s:%d:%s] createhierogram failed! SkillID(%d) SkillLevel(%d)", __LK_FILE__, __LINE__, __FUNCTION__, tPedalCreator.mSkillID, tPedalCreator.mSkillLevel );
//		}
	}
	else if ( strcasecmp( tCommandName, "applyfamily"  ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CMessage MsgHead;
		CMessageApplyFamilyRequest Msg;
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&Msg ); 
		Msg.set_familyname( tToken[1].c_str() );
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_FAMILYAPPLY );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );	
	}	
	else if ( strcasecmp( tCommandName, "replyapply"  ) == 0  )
	{
		LK_ASSERT( tToken.size() >= 3, return )
		CMessage MsgHead;
		CMessageReplyMemberApplyRequest Msg;
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&Msg ); 
		Msg.set_roleid( atoi( tToken[1].c_str() ) );
		Msg.set_result( atoi( tToken[2].c_str() ) );
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPLYMEMBERAPPLY );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );	
			
	}
	else if ( strcasecmp( tCommandName, "listfamily" ) == 0 )
	{
		CMessage MsgHead;
		CMessageGetAllFanmilyInfoRequest MsgGetAllFamilyInfo;
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETALLFAMILYINFO );
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&MsgGetAllFamilyInfo );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );
	}	
	else if ( strcasecmp( tCommandName,"listmember" ) == 0 )
	{
		CMessage MsgHead;
		CMessageGetFamilyMemberInfoRequest MsgMemberInfo;
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETFAMILYMEMBERINFO );
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&MsgMemberInfo );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );
	} 
	else if ( strcasecmp( tCommandName,"changeheader" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		
		CMessage MsgHead;
		CMessageAppointHeaderRequest MsgAppHeader;
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_APPOINTHEADER );
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&MsgAppHeader );
		
		MsgAppHeader.set_playercharid( atoi( tToken[1].c_str() ) );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );
	} 
	else if( strcasecmp( tCommandName, "addkitbag" ) == 0 )
	{  
		//CPropertyPlayer *tpProperty = ( CPropertyPlayer * )	pPlayer->GetProperty();
		//int tOldID = 0;
		//tpProperty->GetBaggage()->AddKitBag( 0, 40285, tOldID );		
	}				
	else if ( strcasecmp( tCommandName,"movekitbag" ) == 0 )
	{
		MoveItem( pPlayer, 0, SLOT_BAGGAGE, 0, SLOT_BAGGAGEKITBAG, 1 );
	}	
	else if ( strcasecmp( tCommandName, "getkitbag" ) == 0 )
	{
		CMessage MsgHead;
		CMessageOpenKitBagRequest MsgKitbag;
		
		MsgKitbag.set_desslot( SLOT_BAGGAGEKITBAG );
		
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_OPENKITBAG );
		MsgHead.set_msgpara( (int)&MsgKitbag );
		OnMessageOpenKitBag( pPlayer, &MsgHead );
	}
	else if ( strcasecmp( tCommandName, "kickfamilymember" )  == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CMessage MsgHead;
		CMessageKickPlayerRequest MsgKickPlayer;
		MsgKickPlayer.set_playercharid( atoi( tToken[1].c_str() ) );
		
		MsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_KICKMEMBER );
		MsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		MsgHead.set_msgpara( (int)&MsgKickPlayer );
		CSceneServer::GetSingleton().ProcessClientMsg( &MsgHead );
	} 
	else if ( strcasecmp( tCommandName, "leavefamily" )	== 0 )
	{
		CMessage Msghead;
		CMessageLeaveFamilyRequest MsgLeaveFamily;
		

		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_LEAVEFAMILY );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgLeaveFamily );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	}
	else if ( strcasecmp( tCommandName, "creatcorps" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CMessage Msghead;
		CMessageCreatCorpsRequest MsgCreatCorps;

		MsgCreatCorps.set_corpsname( tToken[1].c_str() );
		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_CREATCORPS );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgCreatCorps );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	}
	else if ( strcasecmp( tCommandName, "getcorpslist" ) == 0 )
	{	
		CMessage Msghead;
		CMessageGetCorpsFamilyInfoRequest MsgCorpsList;

		
		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETCORPSFAMILYINFO );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgCorpsList );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	} 
	else if ( strcasecmp( tCommandName, "disbandcorps" ) == 0 )
	{
		CMessage Msghead;
		CMessageDisbandCorpsRequest MsgDisbandCorps;


		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_DISBANDCORPS );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgDisbandCorps );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	} 
	else if ( strcasecmp( tCommandName,"corpsheader" ) == 0 )
	{ 
		LK_ASSERT( tToken.size() >=2, return )
		CMessage Msghead;
		CMessageChangeCorpsHeaderRequest MsgChangeCorpsHeader;
		
				
		MsgChangeCorpsHeader.set_memberid( atoi( tToken[1].c_str() ) );		

		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_CHANGECORPSHEADER );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgChangeCorpsHeader );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );		
	}
	else if ( strcasecmp( tCommandName,"kickfamily" ) == 0 )
	{	
		LK_ASSERT( tToken.size() >=2, return )
		CMessage Msghead;
		CMessageKickFamilyRequest MsgKickFamily;


		MsgKickFamily.set_familyid( atoi( tToken[1].c_str() ) );		

		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_KICKFAMILY );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgKickFamily );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );			
	}
	else if ( strcasecmp( tCommandName,"applycorps" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return )
		CMessage Msghead;
		CMessageApplyCorpsRequest MsgApplyCorps;					
				
		MsgApplyCorps.set_corpsname( tToken[1].c_str() );					
		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_APPLYCORPS );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgApplyCorps );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	}	
	else if ( strcasecmp( tCommandName,"corpsinvite" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return )
		CMessage Msghead;
		CMessageInviteCorpsMemberRequest MsgInvite;					

		MsgInvite.set_familyname( tToken[1].c_str() );					
		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_INVITECORPSMEMBER );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgInvite );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	}
		
	else if ( strcasecmp( tCommandName,"replycorpsapply" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=3, return )
		CMessage Msghead;
		CMessageReplyCorpsMemberApplyRequest MsgReplyApply;					
		
		MsgReplyApply.set_familyid( atoi( tToken[1].c_str() ) );
		MsgReplyApply.set_result( atoi( tToken[2].c_str() ) );
		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPLYCORPSMEMBERAPPLY );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgReplyApply );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	}
	else if ( strcasecmp( tCommandName, "replycorpsinvite" ) == 0 )
	{ 		
		LK_ASSERT( tToken.size() >=4, return )
		CMessage Msghead;
		CMessageReplyCorpsInviteRequest MsgReplyInvite;					

		MsgReplyInvite.set_result( atoi( tToken[1].c_str() ) );
		MsgReplyInvite.set_corpsid( atoi( tToken[2].c_str() ) );
		MsgReplyInvite.set_invitingid( atoi(tToken[3].c_str()) );
		Msghead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_REPLYCORPSINVITE );
		Msghead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );		
		Msghead.set_msgpara( (int)&MsgReplyInvite );
		CSceneServer::GetSingleton().ProcessClientMsg( &Msghead );
	}
	else if ( strcasecmp( tCommandName, "chatsend" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return )
		CMessage tMsgHead;
		CMessageChatSend   tChatMsg;
		tChatMsg.set_channel( atoi( tToken[1].c_str() ) );
		tChatMsg.set_msg( tToken[2].c_str() );
		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_CMESSCHATSEND );		
		tMsgHead.set_msgpara( (int)&tChatMsg );				
		CChatModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );
	}	
	else if ( strcasecmp( tCommandName, "globalchat" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 4, return )
		CMessage tMsgHead;
		CMessageChatSendCallBack  tChatMsg;
		tChatMsg.set_channel( atoi( tToken[1].c_str() ) );
		tChatMsg.set_msg( tToken[2].c_str() );
		int tWorldID = atoi( tToken[3].c_str() );
		tMsgHead.mutable_msghead()->set_messageid( ID_S2C_CHATSENDCALLBACK );		
		tMsgHead.set_msgpara( (int)&tChatMsg );	
		CSceneLogic::GetSingleton().Send2OtherGate( &tMsgHead, tWorldID );
	}
	else if( strcasecmp( tCommandName, "listcorps" ) == 0 )
	{			
		CMessage tMsgHead;
		CMessageGetCorpsListRequest   tMsg;	

		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETCOPRSLIST );
		tMsgHead.mutable_msghead()->set_srcid( pPlayer->GetEntityID() );
		tMsgHead.set_msgpara( (int)&tMsg );				
		CSceneServer::GetSingleton().ProcessClientMsg(  &tMsgHead  );
	}
	else if ( strcasecmp( tCommandName,"talent" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return );
		PlayerObtainTalentExp( pPlayer, atoi( tToken[1].c_str() ) );
	}
	else if ( strcasecmp( tCommandName,"familytimeout" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return );
		CActivityModule::GetSingleton().DebugTimeOut( atoi( tToken[1].c_str() ) );
	}
	else if ( strcasecmp( tCommandName,"familybattlestart" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return );
		CActivityModule::GetSingleton().DebugBattleStart( atoi( tToken[1].c_str() ) );
	}
	else if ( strcasecmp( tCommandName,"familybattleend" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return );
		CActivityModule::GetSingleton().DebugBattleEnd( atoi( tToken[1].c_str() ) );
	}
	else if ( strcasecmp( tCommandName,"creatfamilyredstone" ) == 0 )
	{
		LK_ASSERT( tToken.size() >=2, return );
		CreatFamilyRedStone( pPlayer, atoi( tToken[1].c_str() ) );		
	}
	else if ( strcasecmp( tCommandName,"familyboss" ) == 0 )
	{
		CMessage tMsgHead;		
		CMessageStartFamilyBossRequest	tMsgFamilyBoss;
		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_STARTFAMILYBOSS );
		tMsgHead.set_msgpara( (int)&tMsgFamilyBoss );
		CMessageStartFamilyBossRequest *tpMsg =   &tMsgFamilyBoss;
		CMessage *tpHead = &tMsgHead;
			
		SenMsgToGate( tpHead, tpMsg, pPlayer );
	}
	
	else if ( strcasecmp( tCommandName,"GetExpCard" ) == 0 )
	{
		CMessage tMsg;
		CMessageGetExpCardRequest tMsgGetExpCard;
		
		tMsg.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETEXPCARD );
		tMsg.set_msgpara( (int)&tMsgGetExpCard );
		
		tMsgGetExpCard.mutable_headmsg()->set_roleid( pPlayer->GetCharID() );
		tMsgGetExpCard.mutable_headmsg()->set_entityid( pPlayer->GetEntityID() );
		
		CSceneLogic::GetSingleton( ).Send2Gate( &tMsg );
	}
		
	else if ( strcasecmp( tCommandName,"AddFamilyGlory" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		
		CFamilyModule::GetSingleton().ChangeFamilyGlory( pPlayer, atoi( tToken[1].c_str() ) );
	}		
	
	else if ( strcasecmp( tCommandName,"AddFamilyMoney" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )

		CFamilyModule::GetSingleton().ChangeFamilyMoney( pPlayer, atoi( tToken[1].c_str() ) );
	}
	
	else if ( strcasecmp( tCommandName,"AddFamilyContribute" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )

		CFamilyModule::GetSingleton().AddPlayerFamilyContribute( pPlayer->GetCharID(), atoi( tToken[1].c_str() ) );
	}	
	
	else if ( strcasecmp( tCommandName,"AddCorpsMoney" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CCorpsModule::GetSingleton().ChangeCorpsMoney( pPlayer, atoi( tToken[1].c_str() ) );
	}		
	
	else if ( strcasecmp( tCommandName,"AddCorpsGlory" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CCorpsModule::GetSingleton().ChangeCorpsGlory( pPlayer, atoi( tToken[1].c_str() ) );
	}		
	
	else if ( strcasecmp( tCommandName,"AddCorpsContribute" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		CCorpsModule::GetSingleton().AddPlayerCorpsContribute( pPlayer->GetCharID(), atoi( tToken[1].c_str() ) );
	}	
	else if (strcasecmp( tCommandName, "AddWizardValue" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tType = (int)atoi( tToken[1].c_str() );
		int tValue = (int)atoi( tToken[2].c_str() );
		PlayerObtainWizardValue( pPlayer, tType, tValue );
	}
	
	else if( strcasecmp( tCommandName, "UpgradeLevel" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int tLevel = atoi( tToken[1].c_str() );
		if ( tLevel <= ITEMUPLIMIT )
		{
			for ( int i = 0; i < EQUIP_LIMIT; i++ )
			{
				CItemEquipment *tpEquip = (CItemEquipment*)tpSrcProperty->GetEquipment()->GetItemObjPtr( i );
				if ( tpEquip != NULL )
				{
					tpEquip->SetLevel( tLevel );
				}
			}
		}		
	} 
	else if( strcasecmp( tCommandName, "StopCool" ) == 0 )
	{
		CSkillList &tpSkill = tpSrcProperty->GetSkillList( );
		tpSkill.ClearCooldown( );
	}	
	else if ( strcasecmp( tCommandName, "degreeadd" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tSkilltype = atoi(  tToken[1].c_str() );
		int tDegree	    = atoi(  tToken[2].c_str() );	
		CLifeSkill *tpLifeskill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tSkilltype );
		if ( tpLifeskill != NULL )
		{
			tpLifeskill->AddSpecializedDegree( tDegree, CLifeSkill::DEGREEADDTYPE_BYLEVELUP );
			SendNotifyLifeSkillAttribute( pPlayer, tSkilltype, tpLifeskill->GetSpecializedDegree() );
		}
		
	}	
	else if( strcasecmp( tCommandName, "GetSilver" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return );
		int nSilverYB = atoi( tToken[1].c_str() );

		PlayerChangeYuanbao(pPlayer, nSilverYB, true);
	}
	else if( strcasecmp( tCommandName, "countrywizard" ) == 0 )
	{
		CWorldModule::GetSingleton().SendChangeWizardRequest( pPlayer->GetNationality(), pPlayer->GetCountryID(), 0, pPlayer );
	}
	else if( strcasecmp( tCommandName, "countryconstruct" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tType[ 1 ] = {0};
		int tValue[ 1 ] = {0};
		tType[0] = (int)atoi( tToken[1].c_str() );
		tValue[0] = (int)atoi( tToken[2].c_str() );
		CWorldModule::GetSingleton().SendChangeConstructRequest( pPlayer->GetNationality(), pPlayer->GetCountryID(), tType, tValue, 1 );
	}
	else if( strcasecmp( tCommandName, "countrypower" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tType = (int)atoi( tToken[1].c_str() );
		int tValue = (int)atoi( tToken[2].c_str() );
		CWorldModule::GetSingleton().SendChangePowerRequest( pPlayer->GetNationality(), pPlayer->GetCountryID(), tType, tValue );
	}
	else if( strcasecmp( tCommandName, "kitbagitem" ) == 0 )
	{	
		LK_ASSERT( tToken.size() >= 2, return );		
		int tFuncType = (int)atoi( tToken[1].c_str() );
		switch( tFuncType )
		{		
			//  使用物品
			case 1:
			{
				LK_ASSERT( tToken.size() >= 5, return );
				int tIndex = atoi( tToken[2].c_str() );
				int tParam = atoi( tToken[3].c_str() );
				int tPos = atoi( tToken[4].c_str() );
				UseItem( pPlayer, tPos, tIndex, tParam );
				break;
			}
			
			// 修理装备
			case 2:
			{
				LK_ASSERT( tToken.size() >= 3, return );
				int tMendType = atoi( tToken[2].c_str() );
				if( tMendType == 1 )
				{
					MendAllEquipment( pPlayer );
					break;
				}				
				LK_ASSERT( tToken.size() >= 4, return );
				int tIsInPakage = atoi( tToken[3].c_str() );
				int tIndex		= atoi( tToken[4].c_str() );
				
				MendSigleEquipment( pPlayer, tIsInPakage, tIndex  );
				break;
			}
			
			// 扔物品
			case 3:
			{	
				LK_ASSERT( tToken.size() >= 5, return )
				int tIndex = atoi( tToken[2].c_str() );
				int tNum   = atoi( tToken[3].c_str() );
				int tID	   = atoi( tToken[4].c_str() );
				bool tBind = false;
				PlayerRemoveItem( pPlayer, tIndex, tNum );
				PlayerRemoveItemByID( pPlayer, tID, tNum, tBind );
				break;
			}
			
			// 装备升级
			case 4:
			{		
				LK_ASSERT( tToken.size() >= 6, return )
				//int tIndex1 = atoi( tToken[2].c_str() );
				//int tIndex2 = atoi( tToken[3].c_str() );
				//int tIndex3 = atoi( tToken[4].c_str() );
				//int tType	 = atoi( tToken[5].c_str() );
				//PlayerUpItem( pPlayer, tIndex1, tIndex2, tIndex3, tType, 0 );
				break;
			}
			
			// 玩家镶嵌符文
			case 5:				
			{
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex2 = atoi( tToken[3].c_str() );
				PlayerInsertRune( pPlayer, tIndex1, tIndex2 );
				break;	
			}
			
			// 玩家镶嵌宝石
			case 6:
			{	
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex1 = atoi( tToken[2].c_str() );				
				int tIndex[JEWELNUM] = { -1 };
				for ( int i = 0; i < JEWELNUM; ++i )
				{
					tIndex[i] = -1;
				}
				tIndex[0] = atoi( tToken[3].c_str() );
				tIndex[1] = -1;				
				PlayerInsertJewel( pPlayer, tIndex1, tIndex );
				break;
			}
			
			// 物品合成
			case 7:
			{
				LK_ASSERT( tToken.size() >= 3, return )
				int tIndex = atoi( tToken[2].c_str() );
				PlayerComposeItem( pPlayer, tIndex );
				break;
			}
			
			// 元气虫吃装备
			case 8:
			{
				LK_ASSERT( tToken.size( ) >= 5, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex[YUANNUM] = { -1 };
				for ( int i = 0; i < YUANNUM; ++i )
				{
					tIndex[i] = -1;
				}
				
				tIndex[0] = atoi( tToken[3].c_str() );
				tIndex[1] = atoi( tToken[4].c_str() );			
				
				PlayerEatEquip( pPlayer, tIndex1, tIndex );
				break;
			}
			
			// 玩家打开装备插槽
			case 9:
			{	
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex2 = atoi( tToken[3].c_str() );
				PlayerOpenSlot( pPlayer, tIndex1, tIndex2 );
				break;
			}
			
			// 交易检查,跨模块调用
			case 13:
			{			
				break;
			}
			
			// 检索到的第一个可用物品的格子索引
			case 14:
			{
				//HasItem()
				break;
			}		
	
			// 绑定装备
			case 15:
			{
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex = atoi( tToken[2].c_str() );
				int tIndex1 = atoi( tToken[3].c_str() );
				
				CItemObject *tpItemObj = tpSrcProperty->GetBaggage()->GetItemObjPtr( tIndex );
				BindItem( pPlayer, tpItemObj, ITEM_BINDWAY_BYITEM, tIndex1 );
				break;
			}
			
			// 玩家增加装备凹槽
			case 19:
			{
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex2 = atoi( tToken[3].c_str() );				
				PlayerAddSlot( pPlayer, tIndex1, tIndex2 );
				break;
			}	
			
			// 玩家摘除宝石
			case 20:
			{
				LK_ASSERT( tToken.size() >= 5, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex2 = atoi( tToken[3].c_str() );
				int tIndex3 = atoi( tToken[4].c_str() );
				PlayerRemoveJewel( pPlayer, tIndex1, tIndex2, tIndex3 );
				break;
			}		
			
			// 玩家鉴定装备
			case 21:
			{
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex2 = atoi( tToken[3].c_str() );
				PlayerJudge( pPlayer, tIndex1, tIndex2 );
				break;
			}
			
			// 玩家转换抗性
			case 22:
			{
				LK_ASSERT( tToken.size() >= 4, return )
				int tIndex1 = atoi( tToken[2].c_str() );
				int tIndex2 = atoi( tToken[3].c_str() );
				PlayerChangeRes( pPlayer, tIndex1, tIndex2 );
				break;
			}
			
			// 处理玩家放入卡片请求
			case 23:
			{
				LK_ASSERT( tToken.size() >= 3, return )
				int tIndex = atoi( tToken[2].c_str() );
				CMessage tMsgHead;
				CMessagePushCardRequest tMsgPushCard;
				
				tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_PUSHCARD );
				tMsgHead.set_msgpara( (int)&tMsgPushCard );
				
				tMsgPushCard.set_index( tIndex );
				OnMessagePushCardRequest( pPlayer, &tMsgHead );
				break;
			}
			
			// 检查包裹里的东西 如果有当前地图不允许有的 就干掉
			case 24:
			{					
				CheckBagContent( pPlayer );
				break;
			}
			
			// 遍历包裹、仓库东西，看是不是有过期的 没有的 开启定时器
			case 25:
			{
				CheckPlayerItems( pPlayer );
				break;
			}
			
			// 装备装备
			case 26:
			{	
				LK_ASSERT( tToken.size() >= 4, return )  
				unsigned int tIndex = ( unsigned int )atoi( tToken[2].c_str() );
				unsigned int tIndex1 = ( unsigned int )atoi( tToken[3].c_str() );
								
				// 装备装备
				EquipItem( pPlayer, tIndex, tIndex1 );
				break;
			}
			
			// 卸下装备
			case 27:
			{
				LK_ASSERT( tToken.size() >= 4, return )  
				unsigned int tIndex = ( unsigned int )atoi( tToken[2].c_str() );
				unsigned int tIndex1 = ( unsigned int )atoi( tToken[3].c_str() );

				// 装备装备
				UnEquipItem( pPlayer, tIndex, tIndex1 );
				break;				
			}
			
			// 放下背包
			case 28:
			{	
				LK_ASSERT( tToken.size() >= 6, return )  			
				int tSrcIndex = atoi( tToken[2].c_str() );
				int tDesIndex = atoi( tToken[3].c_str() );
				int tSrcSlot  = atoi( tToken[4].c_str() );
				int tDesSlot  = atoi( tToken[5].c_str() );
				CMessage tMsgHead;				
				CMessageTakeKitBagRequest tMsgTakeKitBag;
				tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_TAKEKITBAG );				
				tMsgHead.set_msgpara( (int)&tMsgTakeKitBag );
				
				
				tMsgTakeKitBag.set_srcindex( tSrcIndex );				
				tMsgTakeKitBag.set_desindex(  tDesIndex );
				tMsgTakeKitBag.set_srcslot( tSrcSlot );
				tMsgTakeKitBag.set_desslot( tDesSlot );
				OnMessageTakeKitBag( pPlayer, &tMsgHead );				
				break;
			}
		}		
	}
	else if( strcasecmp( tCommandName, "LeagueList" ) == 0 )
	{
		CMessageGetFamilyGoodsListRequest tMsgGetFamilyGood;
		CMessageGetFamilyExchangeGoodsListRequest tMsgGetFamilyExchange;
		
		CMessageGetCorpsGoodsListRequest tMsgGetCorpsGoods;
		CMessageGetCorpsExchangeGoodsListRequest tMsgGetCorpsExchange;
		
		CMessage tMsgHead;
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETFAMILYGOODSLIST );	
		tMsgHead.set_msgpara( (int)&tMsgGetFamilyGood );
		CMessage *tpMsg = &tMsgHead;		
		CMessageGetFamilyGoodsListRequest *tpMsgGetFamilyGood = &tMsgGetFamilyGood;
		tMsgGetFamilyGood.set_familyid( pPlayer->GetFamilyID() );
		SenMsgToGate( tpMsg, tpMsgGetFamilyGood, pPlayer )
		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETFAMILYEXCHANGEGOODSLIST );
		tMsgHead.set_msgpara( (int)&tMsgGetFamilyExchange );
		CMessageGetFamilyExchangeGoodsListRequest *tpMsgGetFamilyExchange = &tMsgGetFamilyExchange;
		tMsgGetFamilyExchange.set_familyid( pPlayer->GetFamilyID() );
		SenMsgToGate( tpMsg, tpMsgGetFamilyExchange, pPlayer )
		
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETCORPSGOODSLIST );
		tMsgHead.set_msgpara( (int)&tMsgGetCorpsGoods );
		CMessageGetCorpsGoodsListRequest *tpMsgGetCorpsGoods = &tMsgGetCorpsGoods;
		tMsgGetCorpsGoods.set_corpsid( pPlayer->GetCorpsID() );
		SendCorpsMsgToGate( tpMsg, tpMsgGetCorpsGoods, pPlayer )
		 
		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_GETCORPSEXCHANGEGOODSLIST );
		CMessageGetCorpsExchangeGoodsListRequest *tpMsgGetCorpsExchange = &tMsgGetCorpsExchange;
		tMsgHead.set_msgpara( (int)&tMsgGetCorpsExchange );
		tMsgGetCorpsExchange.set_corpsid( pPlayer->GetCorpsID() );
		SendCorpsMsgToGate( tpMsg, tpMsgGetCorpsExchange, pPlayer  ) 
		
		
	}
	else if( strcasecmp( tCommandName, "addexchangeitem" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tLeagueBagID = atoi( tToken[1].c_str() );
		CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tLeagueBagID );
		if ( tpTplItem == NULL )
		{
			return;
		}
		if ( tpTplItem->mItemType != CTplItem::ITEM_LEAGUEBAG )
		{
			return;
		}
		CTplLeagueBag *tpTplLeagueBag = ( CTplLeagueBag * )tpTplItem;
		if ( tpTplLeagueBag->mLeagueBagType == CTplLeagueBag::LEAGUEBAG_FAMILY )
		{
			CFamilyModule::GetSingleton().AddFamilyExchangeItem( pPlayer, tpTplLeagueBag );
		}
		else if( tpTplLeagueBag->mLeagueBagType == CTplLeagueBag::LEAGUEBAG_CORPS )
		{
			CCorpsModule::GetSingleton().AddCorpsExchangeItem( pPlayer, tpTplLeagueBag );			
		}										
	}
	else if( strcasecmp( tCommandName, "fcm") == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tTime = atoi( tToken[1].c_str() );

		if( tTime >= 3 && tTime < 5 )
		{
			pPlayer->SetFcmStatus( em_half_rate );
		}
		else if( tTime == 0 )
		{
			pPlayer->SetFcmStatus( em_normal_rate );
		}
		else if ( tTime >= 5 )
		{
			pPlayer->SetFcmStatus( em_none_rate );
		}

		// 只要进入不健康时间，就踢下线
		if( pPlayer->GetFcmStatus() != em_normal_rate )
		{
			SceneServer::CSceneLogic::GetSingletonPtr()->KickPlayer( pPlayer->GetCharID(), EM_KICKOUT_ANTIADDICTION );
		}
	}
	else if( strcasecmp( tCommandName, "warcontrol" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 6, return )
		int tState = atoi( tToken[1].c_str() );
		int tDay = atoi( tToken[2].c_str() );
		int tHour = atoi( tToken[3].c_str() );
		int tMinute = atoi( tToken[4].c_str() );
		int tSerial = atoi( tToken[5].c_str() );
		CWorldModule::GetSingleton().SendWarControlNotify( tState, tDay, tHour, tMinute, tSerial );
	}
	else if (strcasecmp( tCommandName, "exptimeinfo" ) == 0 )
	{		
		char tbuffer[300] = { 0 };		
		sprintf( tbuffer,"EffectiveTime:%d, OffLineTime:%d", tpSrcProperty->GetExpTimeInfo()->GetEffectiveOffTimeLength(),
			tpSrcProperty->GetExpTimeInfo()->GetOffLineTimeLength()  );
		LK_ASSERT( tToken.size() >= 3, return )
		CMessage tMsgHead;
		CMessageChatSend   tChatMsg;
		tChatMsg.set_channel( atoi( tToken[1].c_str() ) );
		tChatMsg.set_msg( tbuffer );

		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_CMESSCHATSEND );		
		tMsgHead.set_msgpara( (int)&tChatMsg );				
		CChatModule::GetSingleton().OnClientMessage( pPlayer, &tMsgHead );
	}
	else if( strcasecmp( tCommandName, "obtainhonor" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tHonor = atoi( tToken[1].c_str() );
		CTemplateHonorObtain *tpHonor = (CTemplateHonorObtain*)CDataStatic::GetTemp( TEMP_HONOROBTAIN );
		if ( tpHonor == NULL )
			return;
		if ( tHonor > 0 && ( tpProperty->GetHonor( ) + tHonor ) > tpHonor->mInLimit )
		{
			tHonor = std::max( tpHonor->mInLimit - tpProperty->GetHonor( ), 0 );
		}
		tpProperty->SetHonor( tpProperty->GetHonor( ) + tHonor );
		SendObtainHonorNotice( pPlayer, tHonor );
	}
	else if( strcasecmp( tCommandName, "GetOgreByIndex" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		int tIndex = atoi( tToken[1].c_str() );
		unsigned int tEntityID = 0;
		int tCreatObjID = CCreatorManager::GetSingletonPtr()->mOgreCreator[ tIndex ];
		COgreCreator *pTempCreator = (COgreCreator*)CSceneObjManager::GetSingletonPtr()->GetObject( tCreatObjID );
		if (pTempCreator == NULL )
		{
			return;
		}
		CMapModule::GetSingleton().CreateNpc( pTempCreator->mLineID, pTempCreator->mMapID, 0, pTempCreator, tEntityID, 0, CWTPoint(0,0), true );
	}
	else if( strcasecmp( tCommandName, "ExpPill" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 2, return )
		unsigned long long tExp = atoi( tToken[1].c_str() );
		AddExpToExpContainer( pPlayer, tExp );
	}
	else if( strcasecmp( tCommandName, "CalcWeakLevel" ) == 0 )
	{
		CMessageChangeGateNotify tChangeNotify;
		CMessage	tMsg;
		tMsg.mutable_msghead( )->set_messageid( ID_S2G_CHANGEGATE_NOTIFY );
		tMsg.set_msgpara( (uint32)&tChangeNotify );

		tChangeNotify.set_type( CMD_WORLD_CALC_WEAK_LEVEL );
		CSceneLogic::GetSingletonPtr()->Send2Gate( &tMsg );
	}
	else if( strcasecmp( tCommandName, "AddHonerScore" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return )
			int nCampID = atoi( tToken[1].c_str() );
		int nScore = atoi( tToken[2].c_str() );
		CWorldModule::GetSingleton().m_WeakProtecter.Send2GatePlayerGetHonerScoreNotify(nCampID, 0, nScore);
	}
	else  if(strcasecmp(tCommandName,"clearcampcd") == 0) //清除转阵营cd 指令
	{
		LK_ASSERT( tToken.size() >= 2, return )
			int cdtime = atoi( tToken[1].c_str() );
		pPlayer->SetChangeCampTime(cdtime);
	}
	else if (strcasecmp(tCommandName,"uprune") == 0) //升级符文
	{
		LK_ASSERT( tToken.size() >= 7, return )

			CMessage tMsgHead;
		CMessageRequestRuneCom tMsgRequestRuneCom;

		tMsgHead.mutable_msghead()->set_messageid( ID_C2S_REQUEST_RUNECOM );
		tMsgHead.set_msgpara( (int)&tMsgRequestRuneCom );
		for (int i =1 ;i<6 ;i++)
		{	
			int index = atoi( tToken[i].c_str() );
			tMsgRequestRuneCom.add_runeindex(index);
		}
		int itemup =  atoi(tToken[6].c_str() );
		tMsgRequestRuneCom.set_itemindex(itemup);
		OnMessageRuneComRequest( pPlayer, &tMsgHead );
	}
	else if ( strcasecmp( tCommandName, "ChangeFame" ) == 0 )
	{
		LK_ASSERT( tToken.size() >= 3, return );
		int tType = atoi( tToken[1].c_str() );
		int tValue = atoi( tToken[2].c_str() );
		if ( tType == FAME_TYPE_COMBAT )
			ChangeCombatFame( pPlayer, tValue );
		else if ( tType == FAME_TYPE_REPE )
			ChangeRepeFame( pPlayer, tValue );
		else if ( tType == FAME_TYPE_COMMON )
			ChangeCommonFame( pPlayer, tValue );
	}
	else
	{
		LOG_DEBUG( "pro", "Error DebugCommand [ %s ]", tCommandName );
	}
}

// 指令刷怪
void CPropertyModule::PlayerGetOgre( CEntityPlayer* pPlayer, int nOgreID)
{
	COgreCreator tCreater;
	tCreater.mRefresh1[0].mOgreID = nOgreID;
	tCreater.mRefresh1[0].mOgreRand = 10000;
	tCreater.mDisappear = 3;
	//COgreCreator* tTempCreator = ( COgreCreator*)CCreatorManager::GetSingletonPtr()->GetCreator( nIndex );
	//if ( tTempCreator != NULL )
	//{
		unsigned int tEntityID = 0;
		CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetMapIndex(), &tCreater, tEntityID, nOgreID
			, CWTPoint( pPlayer->GetPosX() + 1, pPlayer->GetPosY() + 1 ) );
	//}
}

// 动态刷NPC 在指定位置 一定是继承自 CEntityNpc的
// 参数表：玩家, 模板ID, 要创建的NPC类型, 坐标, 存活时间 0表示永远活着 (到时间以后死亡 干掉) 是否设置NPC的所有者
//         要创建到的地图ID  为0的话创建到玩家所在地图  是否在客户端显示归属者名字(仅功能NPC有效)
void CPropertyModule::CreateNpc( CEntityPlayer* pPlayer, int nNpcTempID, EEntityType nEntityType, CWTPoint& pos
								, int nLifeTime /*= 0*/, bool bIsSetOwner /*= false*/, bool bIsShout /*= false*/
								, int nDestMapID/* = 0*/ , int nIsShowOwner/* = 0*/ )
{
	if ( nDestMapID == 0 )
		nDestMapID = pPlayer->GetMapID();

	CTemplateNpc* pTempNpc = (CTemplateNpc*)CDataStatic::SearchTpl( nNpcTempID );
	LK_ASSERT( pTempNpc != NULL, return );

	// 获得有效点
	CMapObject* tpMapObj	= CMapObjManager::GetSingleton( ).GetMapObject( pPlayer->GetLineID( ), 
		nDestMapID, pPlayer->GetMapIndex( ) );

	LK_ASSERT( tpMapObj!=NULL, return );
	if (!tpMapObj->GetNpcCreatePos(pos, nEntityType))
	{
		LOG_WARN("pro", "create npc too many!! tempid=%d", nNpcTempID);
	}

	CCreator* pCreater = NULL;
	COgreCreator tOgre;
	tOgre.set_id(0);
	CNpcCreator tNpc;
	tNpc.set_id(0);
	CBoxCreator tBox;
	tBox.set_id(0);
	CGhostCreator tGhost;
	tGhost.set_id(0);

	// 这里巧妙利用下 creater的obj的id，因为在npc setup的时候会把这个值赋值给entity里的createrid，因此就可以根据这个值来判断这个NPC是否动态刷出来的
	switch( nEntityType )
	{
	case ENTITYTYPE_OGRE:
		{
			tOgre.mRefresh1[ 0 ].mOgreID = nNpcTempID;
			tOgre.mRefresh1[ 0 ].mOgreRand = 10000;
			tOgre.mDisappear = 3000;
			pCreater = &tOgre;
			break;
		}
	case ENTITYTYPE_FUNCNPC:
		{
			tNpc.mPosition = pos;
			tNpc.mNpcID = nNpcTempID;
			tNpc.mDirection = DIR_DOWN;
			if( bIsSetOwner == true )
			{
				tNpc.mOwnerCharID = pPlayer->GetCharID( );
			}
			tNpc.mIsShowOwner = nIsShowOwner;
			pCreater = &tNpc;
			break;
		}
	case ENTITYTYPE_BOX:
		{
			pCreater = &tBox;
			break;
		}
	case ENTITYTYPE_GHOST:
		{
			tGhost.mPos = pos;
			tGhost.mNpcID = nNpcTempID;
			tGhost.mDirection = ( EDirType )(rand() % 8);
			pCreater = &tGhost;
			break;
		}
	default:
		{
			LOG_ERROR("pro", "[ %s : %d ] [ %s ] nEntityType=%d not support", __LK_FILE__, __LINE__, __FUNCTION__, nEntityType);
			return;
		}
	}

	pCreater->SetShow( true );
	unsigned int tEntityID = 0;
	CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(), nDestMapID, pPlayer->GetMapIndex(), pCreater
		, tEntityID, nNpcTempID, pos );

	CEntityNpc* pEntity = (CEntityNpc*)CSceneLogic::GetSingleton().GetEntity( tEntityID );
	LK_ASSERT( pEntity != NULL, return );
	// 如果这个玩家已经召唤过NPC了 先干掉(只有功能NPC走！)
	// 草，连类型也不区别一个
	if ( nEntityType == ENTITYTYPE_FUNCNPC && pTempNpc->mStoneBuff == 0 )
	{
		if ( pPlayer->GetCallNpcEntityID() != INVALID_OBJ_ID )
		{
			CEntityNpc* tpLastNpc = (CEntityNpc*)CSceneLogic::GetSingleton().GetEntity( pPlayer->GetCallNpcEntityID() );
			if ( tpLastNpc == NULL )
			{
				LOG_ERROR( "pro", "Player %s create npc disappeared? npcid=%d", pPlayer->GetCharNameShow(), pPlayer->GetCallNpcEntityID() );
			}
			else if ( tpLastNpc->GetCallerEntityID() != (int)pPlayer->GetEntityID() )
			{
				LOG_ERROR( "pro", "Player %s create npc disappeared? npcid=%d", pPlayer->GetCharNameShow(), pPlayer->GetCallNpcEntityID() );
			}
			else // 干掉
			{
			//	CSceneLogic::GetSingleton().DestroyEntity( tpLastNpc, 0 );
				// 走延迟删除列表
				CSceneLogic::GetSingleton().AddDeleteList( tpLastNpc->GetEntityID() );
			}
		}
		pEntity->SetCallerEntityID( pPlayer->GetEntityID() ); // 设置召唤的ID
		pPlayer->SetCallNpcEntityID(tEntityID);
	}


	if (nEntityType == ENTITYTYPE_OGRE || nEntityType == ENTITYTYPE_BOX) // 等级转换
	{
		CEntityOgre* pOgre = (CEntityOgre*)pEntity;
		pOgre->ChangeNpcByLevel(pPlayer->GetLevel());
	}

	if (nLifeTime > 0 ) // 如果有存活时间
	{
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, pPlayer->GetCharID(), 0, 0};
		pEntity->GetTimerReciver()->SetTimer( tEntityID, TIMER_ENTITY_CLEAR, nLifeTime, 2, nTimerOtherInfo );
		//pEntity->GetTimerReciver()->SetTimer( tEntityID, TIMER_ENTITY_CLEAR, nLifeTime+3000, 1, nTimerOtherInfo );
	}

	if (bIsSetOwner && (nEntityType != ENTITYTYPE_FUNCNPC) )
	{
		pEntity->SetOwnerCharID( pPlayer->GetCharID() );
		if ( nEntityType == ENTITYTYPE_OGRE ) // 如果是怪物 给他上个仇恨 来打归属者
		{
			CNpcModule::GetSingleton().OnAttacked( pPlayer, pEntity, 100 );
		}
	}

	if (bIsShout)
	{
		// NPC说话		
		if (strcmp(pTempNpc->mTalk,"") != 0)
		{
			ChatCallBackMsg ChatCallBack;
			
			CChatContent tChatContent;
			tChatContent.mChannel = CHANNEL_COMMON;
			tChatContent.mMsg.append( pTempNpc->mTalk );
			tChatContent.mSrcCharName.append( pTempNpc->mName );
			tChatContent.mDstCharID = tEntityID;
			
			ChatCallBack.SetChatCallBackMsg( &tChatContent );

			CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &ChatCallBack.MessageHead );
		}
	}

}


void CPropertyModule::OnMessageNotifyDirection( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageNotifyDirection* tpMessage = ( CMessageNotifyDirection* )pMessage->msgpara( );
	if ( tpMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}


	CMessage tCallBack;
	CMessageNotifyDirectionCallBack tMessage;
	bool vBool = CreateMessageNotifyDirectionCallBack(
			&tCallBack,
			&tMessage,
			pPlayer->GetEntityID( ),
			tpMessage->direction()
			);
	pPlayer->SetDirection( (EDirType)tpMessage->direction() );
	if ( vBool == true )
	{
		CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tCallBack );
	}
}

void CPropertyModule::OnMessageChangePetModeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageChangePetModeRequest* tpMessage = ( CMessageChangePetModeRequest* )pMessage->msgpara( );
	if ( tpMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	CEntity* tpEntity = CSceneLogic::GetSingletonPtr()->GetEntity( tpSrcProperty->GetPetID( ) );
	if ( tpEntity == NULL )
	{
		// 找不到召唤兽
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CEntityPet* tpPet = (CEntityPet*)tpEntity;
	if ( tpPet == NULL )
	{
		// 找不到召唤兽
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	int tModeType = tpMessage->modetype();
	if ( tModeType != EM_PET_MODE_FOLLOW && tModeType != EM_PET_MODE_ASSIST )
	{
		// 模式错误
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if ( tpPet->GetCurMode( ) == tModeType )
	{
		// 模式相同，不需要修改
		return;
	}

	tpPet->SetCurMode( tModeType );
}

// 玩家获取购回界面道具列表信息
void CPropertyModule::OnMessageObtainSaleItemString(CEntityPlayer *pPlayer, CMessage *pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if ( pPlayer->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		LOG_DEBUG( "pro", "Not PLAYER. [%s : %d] [%s]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ;
	}

	CMessage tMessage;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_SALEITEM );
	CMessageObtainSaleItemCallBack tPara;

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	int tAmount = 0;
	CPropertyPlayer::SaleItemList::iterator it;
	CItemObject* tpItemObj = NULL;
	for ( it = tpProperty->GetSaleItem( )->begin(); it != tpProperty->GetSaleItem( )->end(); ++ it )
	{
		tpItemObj = ( CItemObject* ) CSceneObjManager::GetSingletonPtr()->GetObject( ( *it ).mItemID );
		if ( tpItemObj == NULL )
		{
			continue ;
		}

		PBItemObject* tpItem = tPara.add_itemlist();
		tpItemObj->GetItemBinaryBuffer2( tpItem, ( *it ).mNumber );
		tAmount ++;
	}

	tPara.set_amount( tAmount );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage ); 
	return ;
}

// 玩家回购道具
void CPropertyModule::OnMessageBuyBackItem(CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT ( pPlayer != NULL || pMessage != NULL, return );

	if ( pPlayer->GetEntityType() != ENTITYTYPE_PLAYER )
	{
		LOG_DEBUG( "pro", "Not PLAYER. [%s : %d] [%s]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ;
	}

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* )pPlayer->GetProperty();

	CMessageBuyBackItem* pEvent = ( CMessageBuyBackItem* ) pMessage->msgpara();
	if ( pEvent == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	unsigned int tIndex = 0;
	CPropertyPlayer::SaleItemList::iterator it;

	// 最后一次售出的道具
	if ( pEvent->saleindex() == (unsigned int)ITEM_LASTSELL )
	{
		it = tpSrcProperty->GetSaleItem( )->end();
		it --;
		tIndex = std::max( 0, (int)(tpSrcProperty->GetSaleItem()->size() - 1) );
	}
	else
	{
		for ( it = tpSrcProperty->GetSaleItem( )->begin(); it != tpSrcProperty->GetSaleItem( )->end(); ++ it )
		{
			if ( tIndex == pEvent->saleindex() )
			{								
				break ;
			}
			tIndex ++ ;
		}
	}

	if ( it == tpSrcProperty->GetSaleItem()->end() )
	{
		return ;
	}	
		
	SaleItem tSaleItem = ( SaleItem ) *it;
	CItemObject* tpItemObj = ( CItemObject* ) CSceneObjManager::GetSingletonPtr()->GetObject( tSaleItem.mItemID );
	if ( tpItemObj == NULL )
	{
		LOG_ERROR( "pro", "ItemObject pointer invalidation![%s : %d]", __LK_FILE__, __LINE__ );
		return ;
	}

	CTplItem* tpTplItem = ( CTplItem* ) CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	if ( tpTplItem == NULL )
	{
		return ;
	}

	unsigned int tBaggageMoney = ( unsigned int )( tpSrcProperty->GetMoney() + tpSrcProperty->GetBindMoney() ); 
	if ( tpTplItem->mSaleBindMoney != LK_NOTBIND )
	{
		if ( tBaggageMoney < ( tSaleItem.mPrice * tSaleItem.mNumber ) )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFMONEY );
			return ;
		}
	}
	else
	{
		if ( tpSrcProperty->GetMoney( ) < (int)( tSaleItem.mPrice * tSaleItem.mNumber ) )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFMONEY );
			return;
		}
	}

	uint64_t ullGUID = tpItemObj->GetGUID();
	int nItemNum = tpItemObj->GetItemNum();

	CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tpItemObj);
	if ( pInsItemPile == NULL) return;

	// LOG
	LogEventGetItemByBuyBack(pPlayer, ullGUID, pInsItemPile->GetItemID(), nItemNum,
		tpTplItem->mSaleBindMoney != LK_NOTBIND ? CYuanBao::em_bind_money : CYuanBao::em_unbind_money, tSaleItem.mPrice, 0);
	

	if ( tpTplItem->mSaleBindMoney != LK_NOTBIND )
	{
		if (PlayerChangeMoney( pPlayer, tSaleItem.mPrice * tSaleItem.mNumber, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByBuyBack(pPlayer, CYuanBao::em_bind_money, tSaleItem.mPrice * tSaleItem.mNumber,
					 tpItemObj->GetItemID(), tpItemObj->GetItemNum(),  pInsItemPile->GetGUID());
		}
	}
	else
	{
		if (PlayerChangeMoney( pPlayer, tSaleItem.mPrice * tSaleItem.mNumber, true, false ) == SUCCESS)
		{
			LogEventLostMoneyByBuyBack(pPlayer, CYuanBao::em_unbind_money, tSaleItem.mPrice * tSaleItem.mNumber,
					 tpItemObj->GetItemID(), tpItemObj->GetItemNum(),  pInsItemPile->GetGUID());
		}
	}

	tpSrcProperty->GetSaleItem( )->erase( it );
	//
	CMessage tMessage;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_BUYBACK );
	CMessageBuyBackItemCallBack tPara;
	tPara.set_saleindex( tIndex );

	// 更新后的回购商品列表
	int tNumber = 0;
	for ( it = tpSrcProperty->GetSaleItem( )->begin(); it != tpSrcProperty->GetSaleItem( )->end(); ++ it )
	{
		CItemObject* tpItemObj = ( CItemObject* ) CSceneObjManager::GetSingletonPtr()->GetObject( ( *it ).mItemID );
		if ( tpItemObj == NULL )
		{
			continue ;
		}

		PBItemObject* tpItem = tPara.add_itemlist();
		tpItemObj->GetItemBinaryBuffer2( tpItem, ( *it ).mNumber );
		tNumber ++;
	}

	tPara.set_number( tNumber );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage ); 
	return ;
}


//************************************
// Method:    SendYourProDataNotice
// FullName:  CPropertyModule::SendYourProDataNotice
// Access:    public 
// Returns:   void
// Qualifier: 发送玩家个人信息，因为个人信息太多了，一个包太大，拆成n个包发送，每次发不同内容，客户端再组合起来
// Parameter: CEntityPlayer * vpPlayer
//************************************
void CPropertyModule::SendYourProDataNotice( CEntityPlayer* vpPlayer )
{
	LK_ASSERT( vpPlayer != NULL, return );
	CPropertyPlayer* tpProperty = (CPropertyPlayer*)vpPlayer->GetProperty();

	static CMessage tTotalMessage;
	tTotalMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_YOURPRODATA );

	static CMessageYourProDataNotice tMessage;
	tMessage.Clear();

	tTotalMessage.set_msgpara( (long)&tMessage );

	// 共2个包
	tMessage.set_pkgtotal( 2 );

	// 第1个包	
	tMessage.set_pkgcurrentnum( 1 );
	tMessage.set_entityid( tpProperty->GetEntityID( ) );
	tMessage.set_exp( tpProperty->GetExp( ) );
	tMessage.set_level( tpProperty->GetLevel( ) );
	tMessage.set_metier( tpProperty->GetPropertyTempID( ) );
	tMessage.set_sex( tpProperty->GetSex( ) );
	
	// 有效离线时间
	tMessage.set_offlinetime( tpProperty->GetExpTimeInfo()->GetOffLineTimeLength() );
	tMessage.set_offlineexp( tpProperty->GetExpTimeInfo()->GetExpFromOffLine() );

	if( tpProperty->GetHorseState( ) != 0 )
	{
		tMessage.set_horsestate( tpProperty->GetHorseState( ) );
		tMessage.set_horsetempid( tpProperty->GetHorseTempID( ) );
	}

	tMessage.set_maxhp( tpProperty->GetMaxHP( ) );
	tMessage.set_maxmp( tpProperty->GetMaxMP( ) );
	tMessage.set_maxap( tpProperty->GetMaxAP( ) );
    
    tMessage.set_fashionshowstate( tpProperty->GetIsShowFashion() );
    tMessage.set_equipshowstate( tpProperty->GetIsShowEquip() );

    LOG_DEBUG( "pro", "[%s %s:%d] fashionstate(%d) equipstate(%d)", 
            __FUNCTION__, __LK_FILE__, __LINE__, tpProperty->GetIsShowFashion(), tpProperty->GetIsShowEquip() );


	tMessage.set_charid( vpPlayer->GetCharID() );
	tMessage.set_nationality( vpPlayer->GetNationality( ) );
	if(  vpPlayer->GetFamilyID() != 0 )
	{
		tMessage.set_familyid( vpPlayer->GetFamilyID() );
		CFamilyInfo *tpFamilyInfo = CFamilyModule::GetSingleton().GetFamilyInfo( vpPlayer->GetFamilyID() );
		if ( tpFamilyInfo != NULL )
		{
			tMessage.set_familyname( tpFamilyInfo->GetFamilyName() );
			CMemberInfo *tpMemberInfo = tpFamilyInfo->GetMemberInfo( vpPlayer->GetCharID() );
			if ( tpMemberInfo != NULL )
			{
				bool bFamilyHeader = false;
				if ( tpMemberInfo->mFamilyPost == FAMILY_POST_HEADER )
				{
					bFamilyHeader = true;
				}
				tMessage.set_isfamilyheader( bFamilyHeader ); 
				tMessage.set_ifhasfamilyapply( tpMemberInfo->mIfHasFamilyApplies );	
				tMessage.set_familyheaderid( tpMemberInfo->mFamilyHeaderID );
				tMessage.set_familypost( tpMemberInfo->mFamilyPost );
				tMessage.set_familymoney( tpMemberInfo->mFamilyMoney );

				if ( vpPlayer->GetCorpsID() > 0 )
				{
					tMessage.set_corpsid( vpPlayer->GetCorpsID() );
					bool bCorpsHeader = false;
					if ( tpMemberInfo->mCorpsPost  == CORPS_POST_CORPSHEADER )
					{
						bCorpsHeader = true;	
					} 	
					tMessage.set_iscorpsheader( bCorpsHeader );	
					tMessage.set_ifhascorpsapply( tpMemberInfo->mIfHasCorpsApply );	
					tMessage.set_corpsheaderid( tpMemberInfo->mCorpsHeaderID );
					tMessage.set_corpspost( tpMemberInfo->mCorpsPost );	
					tMessage.set_corpsmoney( tpMemberInfo->mCorpsMoney );	
					tMessage.set_corpsname( tpFamilyInfo->GetCorpsName() );
				}						
			}
		}
	}
	
	if( vpPlayer->GetUnionID() != 0 )
	{
		tMessage.set_unionid( vpPlayer->GetUnionID() );
		tMessage.set_unionname( vpPlayer->GetUnionName() );
		tMessage.set_headcorpsid( vpPlayer->GetHeadCorpsID() );
	}
	tMessage.set_countryid( vpPlayer->GetCountryID() );
	tMessage.set_officialid( vpPlayer->GetOfficialID() );
	tMessage.set_kingid( vpPlayer->GetKingID() );

	if( vpPlayer->GetCampID( ) != 0 )
		tMessage.set_campid( vpPlayer->GetCampID( ) );
	
	int tWeaponLevel = 0, tChestLevel = 0, tWeaponJewel = 0, tChestJewel = 0;
	tpProperty->GetEquipment( )->GetLightPoint( tWeaponLevel, tChestLevel, tWeaponJewel, tChestJewel );
	tMessage.set_weaponlevel( tWeaponLevel );
	tMessage.set_chestlevel( tChestLevel );
	tMessage.set_weaponjewel( tWeaponJewel );
	tMessage.set_chestjewel( tChestJewel );
	
	tpProperty->GetTotalBufferForClient( tMessage.mutable_property(), 1 );

	tpProperty->GetStateListTlvBuffer2( tMessage.mutable_statelist() );

	tpProperty->GetEquipSkill()->GetTlvBuffer2( tMessage.mutable_equipskill() );
	tMessage.set_money( tpProperty->GetMoney() );
	tMessage.set_bindmoney( tpProperty->GetBindMoney() );

	if (CGMModule::GetSingleton().IsGmTrusted(vpPlayer->GetGmStatus()) == false)
	{
		tMessage.set_passwordstatus( tpProperty->GetRolePassword()->GetStatus() );
		tMessage.set_protecttime( tpProperty->GetRolePassword()->GetProtectTime() );
		tMessage.set_protecttimelength( tpProperty->GetRolePassword()->GetProtectTimeLength() );
	}
	else
	{
		tMessage.set_passwordstatus( EM_PASSWORD_PASSFREE );
	}


	if ( CGMModule::GetSingleton().IsGm( vpPlayer->GetGmStatus() ) )
		tMessage.set_usertype( USERTYPE_GM );
	else
		tMessage.set_usertype( USERTYPE_NONE );		
	

	tMessage.set_charmvalue(tpProperty->GetCharmValue());
	int tKey = CPersonalTimesMgr::MakeKey(TIMESMGR_USEFLOWER, 0);

	CTemplateCountTable *tpCountTable = (CTemplateCountTable*)CDataStatic::GetTemp( TEMP_COUNT );

	int tTotalTimes=0;
	if ( tpProperty->IsVip() ) 
	{
		tTotalTimes=tpCountTable->mCountData[ TIMESMGR_USEFLOWER ].mVipTime;
	}
	else
	{
		tTotalTimes=tpCountTable->mCountData[ TIMESMGR_USEFLOWER ].mCountTime;
	}

	//if ( CSceneCfgManager::GetSingleton().GetProperty_cfg()->mFlower_lmt_type == 0 )
	tMessage.set_todayleftflower( std::max(0,tTotalTimes-tpProperty->GetTimesMgr()->GetTimes(tKey)) );

	tMessage.set_curwarhonor( tpProperty->GetFreeWar() );
	tMessage.set_allwarhonor( tpProperty->GetTotalWar() );
	tMessage.set_todaywarhonor( tpProperty->GetTodayWar() );
	tMessage.set_exphonor( tpProperty->GetExpHonor() );
	tMessage.set_itemhonor( tpProperty->GetItemHonor() );

	tpProperty->GetRepetDataForClient( tMessage.mutable_repedatatoclientlist() );

	CSceneLogic::GetSingleton().Send2Player( vpPlayer, &tTotalMessage );

	// 第2个包
	tMessage.Clear();
	tMessage.set_pkgtotal( 2 );
	tMessage.set_pkgcurrentnum( 2 );
	tpProperty->GetTotalBufferForClient( tMessage.mutable_property(), 2 );	
	CSceneLogic::GetSingleton().Send2Player( vpPlayer, &tTotalMessage );
	
	// 发送包裹背包数据
	for ( int i = 0; i < tpProperty->GetBaggage()->GetKitBagIndex(); ++i )
	{
		if ( tpProperty->GetBaggage()->GetKitBagItemByIndex( i ) == NULL  )
		{
			continue;
		}  				
		CMessage tMsgHead;
		CMessageOpenKitBagResponse tMsgOpenKitBag;	 
		tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_OPENKITBAG );
		tMsgHead.set_msgpara( (int)&tMsgOpenKitBag );

		tpProperty->GetBaggage()->GetItemInBag( BAGTYPE_KITBAG, i, *tMsgOpenKitBag.mutable_itembox() );
		tMsgOpenKitBag.set_desslot( SLOT_BAGGAGEKITBAG );
		tMsgOpenKitBag.set_kitbagindex( i );
		CSceneLogic::GetSingleton().Send2Player( vpPlayer, &tMsgHead );
	}
}


//************************************
// Method:    SendClickNpcResponse
// FullName:  CPropertyModule::SendClickNpcResponse
// Access:    public 
// Returns:   void
// Qualifier: 发送点击NPC回应消息
// Parameter: CEntity * pPlayer
// Parameter: unsigned int vNpcEntityID
//************************************
void CPropertyModule::SendClickNpcResponse( CEntity* pPlayer, unsigned int vNpcEntityID )
{
	LK_ASSERT ( pPlayer != NULL, return  );

	CMessage tTotalMessage;
	tTotalMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_CLICKNPC );

	CMessageClickNpcResponse tMessage;
	tMessage.set_entityid( vNpcEntityID );

	tTotalMessage.set_msgpara( (long)&tMessage );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}


//************************************
// Method:    SendCloseDialogNotice
// FullName:  CPropertyModule::SendCloseDialogNotice
// Access:    public 
// Returns:   void
// Qualifier: 发送关闭会话通知
// Parameter: CEntity * pPlayer
//************************************
void CPropertyModule::SendCloseDialogNotice( CEntity* pPlayer )
{
	LK_ASSERT ( pPlayer != NULL, return );

	CMessage tTotalMessage;
	tTotalMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CLOSEDIALOG );

	CMessageCloseDialogNotice tMessage;
	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}


//***************************************
// Function Name : SendUpdateMoneyNotice
// Description 	 :
// Input Params  :	vMoney--金钱改变量，vTotal--玩家包裹金钱总数
// Output Params :
// Return Type   :
// Modified Time : 2/12/2009
//***************************************

void CPropertyModule::SendUpdateMoneyNotice( CEntity* pPlayer, int vMoney, int vTotal )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if ( vMoney == LK_ZERO )
	{
		return ;
	}	

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_UPDATEMONEY );

	CMessageUpdateMoneyNotice tMessage;
	tMessage.set_money( vMoney );
	tMessage.set_total( vTotal );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

//***********************************
// FunctionName : SendUpdateBindMoneyNotice 
// Description  : 发送更新绑定金钱通知
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/25/2009]
//***********************************

void CPropertyModule::SendUpdateBindMoneyNotice( CEntity* pPlayer, int vMoney, int vTotal )
{
	LK_ASSERT( pPlayer != NULL, return );
	if ( vMoney == LK_ZERO )
	{
		return ;
	}

	CMessage tMessage;
	CMessageUpdateBindMoneyNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_BINDMONEYNOTICE );
	tPara.set_money( vMoney );
	tPara.set_total( vTotal );
	tMessage.set_msgpara( ( long ) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

void CPropertyModule::SendRemoveItemNotice( CEntity* pPlayer, int vPos, unsigned short vItemIndex, unsigned short vNumber )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_REMOVEITEM );

	CMessageRemoveItemNotify tMessage;
	tMessage.set_pos( vPos );
	tMessage.set_itemindex( vItemIndex );
	tMessage.set_number( vNumber );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendLockItemNotice( unsigned int vEntityID, int vIndex, int vLockType )
{
	if ( vEntityID == 0 )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_LOCKITEM );

	CMessageLockItemNotice tMessage;
	tMessage.set_index( vIndex );
	tMessage.set_locked( vLockType );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CEntity* pPlayer = CSceneLogic::GetSingletonPtr()->GetEntity( vEntityID );
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendLockItemNotice( CEntity* pPlayer, int vIndex, int vLockType )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_LOCKITEM );

	CMessageLockItemNotice tMessage;
	tMessage.set_index( vIndex );
	tMessage.set_locked( vLockType );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}


void CPropertyModule::SendObtainExpNotice( CEntity* pPlayer, int vExpDelta, unsigned long long vExp, int vListID, bool IsLevelUp, int vOffLineExp, int vLeftTime )
{
	LK_ASSERT ( pPlayer != NULL, return  );

	// 当前经验是64位，发之前先拆开，客户端来组合
	// value2 是高32位 value4是低32位
	unsigned int tLow = (int)(vExp&0x00000000FFFFFFFF);
	unsigned int tHigh = (int)(vExp>>32);

	pPlayer->AddFunResult( 0, FUNC_EXP, RESULT_NORMAL, false, vExpDelta, tHigh, IsLevelUp ? 1 : 0, tLow );
	if ( vOffLineExp > 0 )
	{
		pPlayer->AddFunResult( 0, FUNC_OFFLINEEXP, RESULT_NORMAL, false, vOffLineExp, vLeftTime, IsLevelUp ? 1 : 0 );	
	}
}

void CPropertyModule::SendObtainHonorNotice( CEntity* pPlayer, int vChangeHonor )
{
	LK_ASSERT ( pPlayer != NULL, return  );

	CPropertyPlayer *tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	pPlayer->AddFunResult( 0, FUNC_HONOR, RESULT_NORMAL, false, vChangeHonor, tpProperty->GetHonor( ),
		tpProperty->GetKillNumOut( ) + tpProperty->GetKillNumIn( ), tpProperty->GetExpHonor(), tpProperty->GetItemHonor() );
	ResultListSend( );
}

void CPropertyModule::SendMoveItemNotice( CEntity* pPlayer,unsigned short vSrcIndex, unsigned short vDesIndex, unsigned short vNumber, unsigned char vSrcSlot, unsigned char vDesSlot, int nErrcode, int nSrcNum, int nDesNum )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_MOVEITEM );

	CMessageMoveItemNotice tMessage;
	tMessage.set_srcindex( vSrcIndex );
	tMessage.set_desindex( vDesIndex );
	tMessage.set_number( vNumber );
	tMessage.set_srcslot( vSrcSlot );
	tMessage.set_desslot( vDesSlot );
	tMessage.set_errcode( nErrcode );
	tMessage.set_srcnum( nSrcNum );
	tMessage.set_desnum( nDesNum );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendProErrorNotice( CEntity* pPlayer, int vType )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if( pPlayer->IsPlayer() != true )
	{
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PROERROR );

	CMessageProErrorNotice tMessage;
	tMessage.set_errorcode( vType );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendEquipItemNotice( CEntity* pPlayer, unsigned int vSrcIndex, int nErrcode, unsigned int vDesIndex /* = ~0 */ )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_EQUIPITEM );

	CMessageEquipItemNotice tMessage;
	tMessage.set_srcindex( vSrcIndex );
	tMessage.set_desindex( vDesIndex );
	tMessage.set_errcode( nErrcode );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendUnEquipItemNotice( CEntity* pPlayer, unsigned short vPart, unsigned int vIndex, int nErrcode )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_UNEQUIPITEM );

	CMessageUnEquipItemNotice tMessage;
	tMessage.set_index( vIndex );
	tMessage.set_part( vPart );
	tMessage.set_errcode( nErrcode );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendClickSkillPointResponse( CEntity* pPlayer, unsigned short vGenerID, unsigned char vCol, unsigned char vRow )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_CLICKSKILLPOINT );

	CMessageClickSkillPointResponse tMessage;
	tMessage.set_generid( vGenerID );
	tMessage.set_col( vCol );
	tMessage.set_row( vRow );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}


void CPropertyModule::SendResetAPPResponse( CEntity* pPlayer, int nRet )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_RESETAPP );

	CMessageResetAPPResponse tMessage;

	tMessage.set_ret( nRet );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendResetTalentResponse( CEntity* pPlayer, int nRet, int nStep, int nPoint )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_RESETTALENT );

	CMessageResetTalentResponse tMessage;

	tMessage.set_ret( nRet );
	tMessage.set_step( nStep );
	tMessage.set_point( nPoint );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendResetSSPResponse( CEntity* pPlayer, unsigned short vGenerID, unsigned char vCol, unsigned char vRow )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_RESETSSP );

	CMessageResetSSPResponse tMessage;
	tMessage.set_generid( vGenerID );
	tMessage.set_col( vCol );
	tMessage.set_row( vRow );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendResetASPResponse( CEntity* pPlayer, int nRet )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_RESETASP );

	CMessageResetASPResponse tMessage;

	tMessage.set_ret( nRet );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendTelePortResponse( CEntity* pPlayer, unsigned short vIndex, int mPosX, int mPosY )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] UN_KNOWN_ERR", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_TELEPORT );

	CMessageTelePortResponse tMessage;
	tMessage.set_index( vIndex );
	tMessage.set_posx( mPosX );
	tMessage.set_posy( mPosY );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendUpgAddItemResponse( CEntity* pPlayer, unsigned short vIndex1, unsigned short vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_UPGADDITEM );

	CMessageUpgAddItemResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendUpgDelItemResponse( CEntity* pPlayer, unsigned short vIndex1, unsigned short vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_UPGDELITEM );

	CMessageUpgDelItemResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendUpgEquipNotice( CEntity* pPlayer, unsigned short vResult, int vType, int nIndex, unsigned short vLevel /* = 0 */ )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Parames Error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_UPGEQUIP );

	CMessageUpgEquipNotice tMessage;
	tMessage.set_result( vResult );
	tMessage.set_type( vType );
	tMessage.set_level( vLevel );
	tMessage.set_eqpidx( nIndex );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendProFinNotice( CEntity* pPlayer, int vResult, int vLeftNum )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]Parames Err", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]Parames Err", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PROFIN );

	CMessageProFinNotice tMessage;
	tMessage.set_result( vResult );
	tMessage.set_leftnum( vLeftNum );
	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendProBreakNotice( CEntity* pPlayer, int vResult )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]Parames Err", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PROBREAK );

	CMessageProBreakNotice tMessage;
	tMessage.set_result( vResult );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendPushRuneResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHRUNE );

	CMessagePushRuneResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendPopRuneResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPRUNE );

	CMessagePopRuneResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendInsertRuneNotice( CEntity* pPlayer, int vResult )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_INSERTRUNE );

	CMessageInsertRuneNotice tMessage;
	tMessage.set_result( vResult );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendInsertPushJewelResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHJEWEL );

	CMessageInsertPushJewelResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendInsertPopJewelResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPJEWEL );

	CMessageInsertPopJewelResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendInsertJewelNotice( CEntity* pPlayer, int vResult, int vBind )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_INSERTJEWEL );

	CMessageInsertJewelNotice tMessage;
	tMessage.set_result( vResult );
	tMessage.set_bind( vBind );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendEatPushEquipResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHEAT );

	CMessageEatPushEquipResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendEatPopEquipResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPEAT );

	CMessageEatPopEquipResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendEatEquipNotice( CEntity* pPlayer, int vIndex, int vNumber )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_EATEQUIP );

	CMessageEatEquipNotice tMessage;
	tMessage.set_index( vIndex );
	tMessage.set_number( vNumber );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendComposePushResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHCOMPOSE );

	CMessageComposePushResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendComposePopResponse( CEntity* pPlayer, int vIndex )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPCOMPOSE );

	CMessageComposePopResponse tMessage;
	tMessage.set_index( vIndex );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendComoseNotice( CEntity* pPlayer, int vIndex, int vItemID, int vNumber1, int vNumber2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_COMPOSE );

	CMessageComposeNotice tMessage;
	tMessage.set_index( vIndex );
	tMessage.set_itemid( vItemID );
	tMessage.set_number1( vNumber1 );
	tMessage.set_number2( vNumber2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendOpenPushResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHSLOT );

	CMessageOpenPushResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendOpenPopResponse( CEntity* pPlayer, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPSLOT );

	CMessageOpenPopResponse tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendOpenSlotNotice( CEntity* pPlayer, int vIndex1, int vIndex2, int vNumber )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_OPENSLOT );

	CMessageOpenSlotNotice tMessage;
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );
	tMessage.set_number( vNumber );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendSyncPosNotice( CEntity* pPlayer, unsigned int vEntityID, int vPosX, int vPosY )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_SYNCPOS );

	CMessageSyncPosNotify tMessage;
	tMessage.set_entityid( vEntityID );
	tMessage.set_posx( vPosX );
	tMessage.set_posy( vPosY );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::SendProExpNotice( CEntity* pPlayer, unsigned int vProLevel, unsigned int vProExp )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PROEXP );

	CMessageProExpNotify tMessage;
	tMessage.set_prolevel( vProLevel );
	tMessage.set_proexp( vProExp );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

bool CPropertyModule::CreateMessageEntityRelifeNotice( CMessage* pTotalMessage, CEntity* pEntity, CMessageEntityRelifeNotice* pMessage )
{
	if ( pEntity == NULL || pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}
	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_ENTITYRELIFE );

	pMessage->set_entityid( pEntity->GetEntityID( ) );
	pMessage->set_posx( pEntity->GetPosX( ) );
	pMessage->set_posy( pEntity->GetPosY( ) );
	pMessage->set_curhp( pProperty->GetCurHP( ) );
	pMessage->set_curmp( pProperty->GetCurMP( ) );
	pMessage->set_maxhp( pProperty->GetMaxHP( ) );
	pMessage->set_maxmp( pProperty->GetMaxMP( ) );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

bool CPropertyModule::CreateMessageEntityDisappearNotice( CMessage* pTotalMessage, CEntity* pEntity, CMessageEntityDisappearNotice* pMessage )
{
	if ( pEntity == NULL || pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_ENTITYDISAPPEAR );

	pMessage->set_entityid( pEntity->GetEntityID( ) );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

bool CPropertyModule::CreateMessagePlayerReliveNotice( CMessage* pTotalMessage, CMessagePlayerReliveNotice* pMessage, unsigned int vEntityID , unsigned short vPosX, unsigned short vPosY, unsigned int vCurHP, unsigned int vCurMP, unsigned int vMaxHP, unsigned int vMaxMP )
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PLAYERRELIVE );

	pMessage->set_entityid( vEntityID );
	pMessage->set_posx( vPosX );
	pMessage->set_posy( vPosY );
	pMessage->set_curhp( vCurHP );
	pMessage->set_curmp( vCurMP );
	pMessage->set_maxhp( vMaxHP );
	pMessage->set_maxmp( vMaxMP );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

void CPropertyModule::AddResultToPB( PBFuncResult* vPBResult, CFuncResult* vResult )
{
	if ( vPBResult == NULL || vResult == NULL )
	{
		return;
	}
	if( vResult->GetResult( ) != 0 )
		vPBResult->set_result( vResult->GetResult( ) );
	if (vResult->GetValue1() != 0)
		vPBResult->set_value1( vResult->GetValue1() );
	if (vResult->GetValue2() != 0)
		vPBResult->set_value2( vResult->GetValue2() );
	if (vResult->GetValue3() != 0)
		vPBResult->set_value3( vResult->GetValue3() );
	if (vResult->GetValue4() != 0)
		vPBResult->set_value4( vResult->GetValue4() );
	if (vResult->GetValue5() != 0)
		vPBResult->set_value5( vResult->GetValue5() );
	if( vResult->GetListID() != 0 )
		vPBResult->set_listid( vResult->GetListID() );
	if( vResult->GetFunc() != 0 )
		vPBResult->set_func( vResult->GetFunc() );
	if( vResult->GetSrcEntityID() != 0 )
		vPBResult->set_srcentityid( vResult->GetSrcEntityID() );
}

int CPropertyModule::ResultListSend( )
{
	if( GetResultList( )->GetEntityCount( ) > 0 || GetSingleList( )->GetEntityCount( ) > 0 )
	{
		CFuncResult*				tpResult = NULL;
		static CMessage 					tMsg;
		static CMessageFuncResultCallBack	tMsgCallBack;

		tMsg.mutable_msghead()->set_messageid( ID_S2C_FUNCRESULT_CALLBACK );
		tMsg.set_msgpara( (long)&tMsgCallBack );

		for( unsigned int i = 0; i < GetResultList( )->GetEntityCount( ); i++ )
		{
			CEntity* tpEntity = GetResultList( )->GetEntityByIndex( i );
			LK_ASSERT_STR( tpEntity != NULL, continue, "FuncResult GetEntity Is NULL, index is %d", i );	

			tMsgCallBack.Clear( );

			tMsgCallBack.set_resultnumber( GetResultList( )->GetResultCount( i ) );			
			tMsgCallBack.set_entityid( tpEntity->GetEntityID( ) );

			for( unsigned int j = 0; j < GetResultList( )->GetResultCount( i ); j++ )
			{
				tpResult = GetResultList( )->GetFuncResult( i, j );
				LK_ASSERT_STR( tpResult != NULL, continue, "FuncResult call GetFunResult is NULL, entity index is %d,"
						" Result index is %d", i, j );

				PBFuncResult* tpPBResult = tMsgCallBack.add_funcresult();
				LK_ASSERT_STR( tpPBResult != NULL, continue, "CMessageFuncResultCallBack call add_funcresult is NULL" );

				AddResultToPB( tpPBResult, tpResult );
			}

			if(tpEntity->IsCharacter() || tpEntity->IsPedal() )
			{
				tMsgCallBack.set_posx( tpEntity->GetPosX() );
				tMsgCallBack.set_posy( tpEntity->GetPosY() );
			}
			
			CMapModule::GetSingletonPtr( )->MessageBroadCast( tpEntity, &tMsg, false, true );				
		}

		// 只有玩家有单发
		for( unsigned int i = 0; i < GetSingleList( )->GetEntityCount( ); i++ )
		{
			CEntity* tpEntity = GetSingleList( )->GetEntityByIndex( i );
			LK_ASSERT_STR( tpEntity != NULL, continue, "FuncResult GetEntity Is NULL, index is %d", i );

			tMsgCallBack.Clear( );
			tMsgCallBack.set_resultnumber( GetSingleList( )->GetResultCount( i ) );			
			tMsgCallBack.set_entityid( tpEntity->GetEntityID( ) );

			for( unsigned int j = 0; j < GetSingleList( )->GetResultCount( i ); j++ )
			{
				tpResult = GetSingleList( )->GetFuncResult( i, j );
				LK_ASSERT_STR( tpResult != NULL, continue, "FuncResult call GetFunResult is NULL, entity index is %d,"
					" Result index is %d", i, j );

				PBFuncResult* tpPBResult = tMsgCallBack.add_funcresult();
				LK_ASSERT_STR( tpPBResult != NULL, continue, "CMessageFuncResultCallBack call add_funcresult is NULL" );

				AddResultToPB( tpPBResult, tpResult );
			}

			tMsgCallBack.set_posx( tpEntity->GetPosX() );
			tMsgCallBack.set_posy( tpEntity->GetPosY() );

			if( tpEntity->IsPlayer() )
			{
				CSceneLogic::GetSingletonPtr( )->Send2Player( ( CEntityPlayer* )tpEntity, &tMsg );
			}
		}

	}

	// 每一个Funcresult都跟一个Send对应,既然已发送,则清楚
	GetResultList()->Initialize();
	GetSingleList()->Initialize();

	return 0;
}

bool CPropertyModule::CreateMessageChangeMetierNotice(
		CMessage* pTotalMessage, 
		CMessageChangeMetierNotice* pMessage,
		unsigned int vEntityID,
		unsigned char vMetierID
		)
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_CHANGEMETIER );

	pMessage->set_entityid( vEntityID );
	pMessage->set_metierid( vMetierID );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}


bool CPropertyModule::CreateMessageInsertItemNotice(
		CMessage* pTotalMessage, 
		CMessageInsertItemNotify* pMessage,
		int vPos,
		int vItemID,
		int *vIndex,
		int *vNumber,
		int vLen,
		int vBind
		)
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_INSERTITEM );

	pMessage->set_pos( vPos );
	pMessage->set_itemid( vItemID );
	pMessage->set_bindstate( vBind );
	for( int i = 0; i < vLen; i++ )
	{
		if ( vNumber[ i ] == 0 )
			break;
		pMessage->add_index( vIndex[ i ] );
		pMessage->add_number( vNumber[ i ] );
	}

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

bool CPropertyModule::CreateMessageInsertEquipNotice(
	CMessage* pTotalMessage, 
	CMessageInsertEquipNotify* pMessage,
	CItemObject* pItemObj,
	int vPos, 
	int nIndex
	)
{
	if ( pMessage == NULL || pTotalMessage == NULL || pItemObj == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_INSERTEQUIP );

	PBItemObject* tpPBItemObj = pMessage->mutable_itemobjet();
	if ( tpPBItemObj == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}
	pItemObj->GetItemBinaryBuffer2( tpPBItemObj, 1 );
	tpPBItemObj->set_index( nIndex );
	pMessage->set_pos( vPos );
	

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

bool CPropertyModule::CreateMessagePlayerChangeEquipNotice(
		CMessage* pTotalMessage, 
		CMessagePlayerChangeEquipNotice* pMessage,
		unsigned int vEntityID,
		unsigned short vPart,
		unsigned int vItemID,
		unsigned int vCurHP,
		unsigned int vCurMP,
		unsigned int vMaxHP,
		unsigned int vMaxMP,
		unsigned int vWeaponLevel,
		unsigned int vChestLevel,
		unsigned int vWeaponJewel,
		unsigned int vChestJewel,
		unsigned int vMWID,
		unsigned int vFashionID,
		unsigned int vMarriageEquipID,
		unsigned int vMWQLID
		)
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PLAYERCHANGEEQUIQ );

	pMessage->set_entityid( vEntityID );
	pMessage->set_part( vPart );
	pMessage->set_itemid( vItemID );
	pMessage->set_curhp( vCurHP );
	pMessage->set_curmp( vCurMP );
	pMessage->set_maxhp( vMaxHP );
	pMessage->set_maxmp( vMaxMP );
	pMessage->set_mwid( vMWID );
	pMessage->set_weaponlevel( vWeaponLevel );
	pMessage->set_chestlevel( vChestLevel );
	pMessage->set_weaponjewel( vWeaponJewel );
	pMessage->set_chestjewel( vChestJewel );
	pMessage->set_fashionid( vFashionID );
	pMessage->set_marriageid( vMarriageEquipID );
	pMessage->set_mwqlid( vMWQLID );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

bool CPropertyModule::CreateMessageEntityRefreshNotice(
		CMessage* pTotalMessage, 
		CMessageEntityRefreshNotice* pMessage,
		unsigned int vEntityID,
		unsigned int vCurHP,
		unsigned int vCurMP,
		unsigned int vMaxHP,
		unsigned int vMaxMP
		)
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_ENTITYREFRESH );

	pMessage->set_entityid( vEntityID );
	pMessage->set_curhp( vCurHP );
	pMessage->set_curmp( vCurMP );
	pMessage->set_maxhp( vMaxHP );
	pMessage->set_maxmp( vMaxMP );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}


bool CPropertyModule::CreateMessageNotifyDirectionCallBack(
		CMessage* pTotalMessage, 
		CMessageNotifyDirectionCallBack* pMessage,
		unsigned int vEntityID,
		int vDirection
		)
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_DIRECTION );

	pMessage->set_entityid( vEntityID );
	pMessage->set_direction( vDirection );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}

bool CPropertyModule::CreateMessageNotifyPetLevelUp(
		CMessage* pTotalMessage, 
		CMessagePetLevelUpNotice* pMessage,
		unsigned int vEntityID,
		int vLevel
		)
{
	if ( pMessage == NULL || pTotalMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	CMessageHead* tpHead = NULL;
	tpHead = pTotalMessage->mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return false;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_PETLEVELUP );

	pMessage->set_entityid( vEntityID );
	pMessage->set_level( vLevel );

	pTotalMessage->set_msgpara( (long)pMessage );
	return true;
}




bool CPropertyModule::PlayerInBusy(unsigned int vEntityID )
{
	return false;
}

// 这个函数根本没用过！！ 所以法宝技能的判断没有改这里。 --by Ly
bool CPropertyModule::CheckSpecialUseCondition( CEntity* pSrcEntity, CTemplateSkill* tpSkill )
{
	LK_ASSERT( pSrcEntity != NULL && tpSkill != NULL, return false );
	CPropertyCharacter* tpSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	// 特殊技能使用条件判断
	for ( int i = 0; i < (int)ARRAY_CNT( tpSkill->mUseCondition ); i++ )
	{
		switch ( tpSkill->mUseCondition[ i ].mConditionType )
		{
			case CTemplateSkill::SKILL_USECONDITION_NONE:
				{
					return true;
				}
			case CTemplateSkill::SKILL_USECONDITION_HPPER:
				{
					CPropertyValue tMaxHPValue = CPropertyFormula::GetMaxHP( tpSrcProperty );
					int tMaxHP = tMaxHPValue.mDeltaValue + tMaxHPValue.mInitValue;
					int tHPPer = (int) ( ( SERVER_PERCENT_FLOAT * tpSrcProperty->GetCurHP( ) ) / tMaxHP );
					if ( tHPPer <= tpSkill->mUseCondition[ i ].mParam )
					{
						SendProErrorNotice( pSrcEntity, ERROR_USESKILL_NEEDMORELIFE );
						return false;
					}
				}
				break;
			case CTemplateSkill::SKILL_USECONDITION_MPPER:
				{
					CPropertyValue tMaxMPValue = CPropertyFormula::GetMaxMP( tpSrcProperty );
					int tMaxMP = tMaxMPValue.mDeltaValue + tMaxMPValue.mInitValue;
					int tMPPer = (int) ( ( SERVER_PERCENT_FLOAT * tpSrcProperty->GetCurMP( ) ) / tMaxMP );
					if ( tMPPer <= tpSkill->mUseCondition[ i ].mParam )
					{
						SendProErrorNotice( pSrcEntity, ERROR_USESKILL_NEEDMOREMANA );
						return false;
					}
				}
				break;
			case CTemplateSkill::SKILL_USECONDITION_ITEM:
				{
					if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PLAYER )
					{
						int tItemNum = ( ( CPropertyPlayer* ) tpSrcProperty )->BaggageHasItem( tpSkill->mUseCondition[ i ].mParam );
						if ( tItemNum <= 0 )
						{
							SendProErrorNotice( pSrcEntity, ERROR_USESKILL_NEEDMOREITEM );
							return false;
						}
					}
				}
				break;
		}
	}
	return true;
}


//
//void CPropertyModule::GetStorageInfo( CEntityPlayer *pPlayer )
//{
//	/*if ( pPlayer == NULL )
//	{
//		return;
//	}
//	CPropertyPlayer *tpProperty  = ( CPropertyPlayer * ) pPlayer->GetProperty();
//	if ( tpProperty == NULL )
//	{
//		return;
//	}
//	CItemBox *tpStorage = tpProperty->GetStorage( );
//	CItemObject *tpObject  = NULL;
//	CTplItem  *tpItem = NULL;
//	char  MsgBuff[ 300 ];
//	for ( unsigned int i = 0 ; i < tpStorage->mReleaseIndex ; i++ )
//	{
//		tpObject = tpStorage->GetItemObjPtr( i );
//		if ( tpObject == NULL )
//		{
//			continue;
//		}
//		memset( MsgBuff , 0 , sizeof( MsgBuff ) );
//		tpItem =( CTplItem * ) CDataStatic::SearchTpl( tpObject->GetItemID() );
//		sprintf( MsgBuff," [Index:%d][ID:%d][NAME:%s] ",i, (int)tpObject->GetItemID(), tpItem->mItemName );
//		CChatModule::GetSingletonPtr()->SendMsgOnChannelCommon( pPlayer , MsgBuff );
//	}*/
//
//}

void CPropertyModule::EntityTeleportBuffer( CEntityCharacter* pSrcEntity, int nTeleType, int nDistance )
{
	LK_ASSERT( pSrcEntity != NULL, return );

	// 默认为实体朝向瞬移
	EDirType vDirection = pSrcEntity->GetDirection( );

	if ( nTeleType == 0 )
	{
		// 随机方向瞬移
		vDirection = (EDirType)( rand( ) % MAX_DIRECTION );
	} 
	

	int tX = pSrcEntity->GetPosX( );
	int tY = pSrcEntity->GetPosY( );

	int tSrcX = pSrcEntity->GetPosX( );
	int tSrcY = pSrcEntity->GetPosY( );

	bool vCanPass = false;

	for ( int i = 0; i < nDistance; i++ )
	{
		switch( vDirection )
		{
		case DIR_DOWN:
			{
				tY = tSrcY + nDistance - i;
			}
			break;
		case DIR_LEFTDOWN:
			{
				tX = tSrcX - nDistance + i;
				tY = tSrcY + nDistance - i;
			}
			break;
		case DIR_LEFT:
			{
				tX = tSrcX - nDistance + i;
			}
			break;
		case DIR_LEFTUP:
			{
				tX = tSrcX - nDistance + i;
				tY = tSrcY - nDistance + i;
			}
			break;
		case DIR_UP:
			{
				tY = tSrcY - nDistance + i;
			}
			break;
		case DIR_RIGHTUP:
			{
				tX = tSrcX + nDistance - i;
				tY = tSrcY - nDistance + i;
			}
			break;
		case DIR_RIGHT:
			{
				tX = tSrcX + nDistance - i;
			}
			break;
		case DIR_RIGHTDOWN:
			{
				tX = tSrcX + nDistance - i;
				tY = tSrcY + nDistance - i;
			}
			break;
		}

		vCanPass = pSrcEntity->CanPass( tX, tY );

		if ( vCanPass == true )
			break;
	}

	if ( vCanPass == false )
	{
		tX = pSrcEntity->GetPosX( );
		tY = pSrcEntity->GetPosY( );
	}

	pSrcEntity->ChangePos( CWTPoint( tX, tY ), RESULT_TELEPORT );

	LOG_DEBUG( "pro", "Entity( %d ) teleport, SrcX = %d, SrcY = %d, X = %d, Y = %d, "
			"vDirection = %d", pSrcEntity->GetEntityID( ), tSrcX, tSrcY, tX, tY, pSrcEntity->GetDirection( ) );

}

void CPropertyModule::SendChangeSpeedToSeenEntity( CEntity* pEntity )
{
	if ( pEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] pEntity or pProperty error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();
	//int tNewSpeed = CPropertyFormula::GetRunSpeed( pProperty );

	CMessage tMessage;
	CMessageSpeedChangedNotify tMessageChangeSpeed;

	CMessageHead* tpHead = NULL;
	tpHead = tMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_SPEEDCHANGED );

	tMessageChangeSpeed.set_entityid( pEntity->GetEntityID() );
	tMessageChangeSpeed.set_speed( pProperty->GetCurSpeed( ) );

	tMessage.set_msgpara( (uint32)&tMessageChangeSpeed );

	// 通知看到自己的客户端自己的速度改变了
	//CMapModule::GetSingleton().SendEntityMessage( pEntity->GetLineID(), pEntity->GetMapID(), pEntity->GetMapIndex(), pEntity, &tMessage );

	CMapModule::GetSingletonPtr()->MessageBroadCast( pEntity, &tMessage, false, true );

}

void CPropertyModule::SendRideHorseNotice( CEntity* pEntity, unsigned int vTempID, int vResult )
{
	LK_ASSERT( pEntity != NULL, return );

	if( pEntity->IsCharacter() == false )
	{
		return ;
	}

	CPropertyCharacter* pProperty = (CPropertyCharacter*) pEntity->GetProperty();
	CMessage tMessage;
	CMessageRideHorseNotice tRideHorse;

	CMessageHead* tpHead = NULL;
	tpHead = tMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_RIDEHORSE );

	tRideHorse.set_entityid( pEntity->GetEntityID() );
	tRideHorse.set_horsetempid( vTempID );
	tRideHorse.set_horseresult( vResult );
	tRideHorse.set_speed( pProperty->GetCurSpeed( ) );

	tMessage.set_msgpara( (uint32)&tRideHorse );

	//// 通知自己
	//CSceneLogic::GetSingleton().Send2Player( pEntity, &tMessage );
	//// 通知看到自己的客户端自己骑马了
	//CMapModule::GetSingleton().SendEntityMessage( pEntity->GetLineID(), pEntity->GetMapID(), pEntity->GetMapIndex(), pEntity, &tMessage );

	CMapModule::GetSingletonPtr()->MessageBroadCast( (CEntityPlayer*)pEntity, &tMessage, false,  true );

}

void CPropertyModule::SendEventNotify( int vEventID, int vCountryID, int *vIntParam, int vSize, char *vStringParam1, char *vStringParam2, int vWorldID )
{
	CMessage tMessage;
	CMessageEventNotify tNotify;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_NOTIFY_EVENT );

	tNotify.set_eventid( vEventID );
	tNotify.set_countryid( vCountryID );
	for( int i = 0; i < vSize; i++ )
	{
		tNotify.add_intparam(vIntParam[ i ]);
	}
	if ( vStringParam1 != NULL )
	{
		tNotify.add_stringparam( vStringParam1 );
	}
	if ( vStringParam2 != NULL )
	{
		tNotify.add_stringparam( vStringParam2 );
	}

	tMessage.set_msgpara( (uint32)&tNotify );
		
	//TODO: 注意， 如果是在中立区，特殊处理刷boss和杀boss
	if( IS_NEUTRAL_LINE_ID( vCountryID )  )
	{
		if(	vEventID == NOTICE_PLAYERKILLBOSS ||
			vEventID == NOTICE_REFRESHBOSS ||
			vEventID == NOTICE_PREREFRESHBOSS )
		{
			CSceneLogic::GetSingleton().SendWorldMessage( &tMessage );
		}
		else
		{
			CSceneLogic::GetSingleton().SendCountryMessage( &tMessage, vCountryID );
		}
	}
	// 副本刷杀BOSS不再广播
	else if ( IS_REPETION_LINE_ID( vCountryID ) )
	{
		if(	vEventID == NOTICE_PLAYERKILLBOSS ||
			vEventID == NOTICE_REFRESHBOSS ||
			vEventID == NOTICE_PREREFRESHBOSS )
		{
			return;
		}
		CSceneLogic::GetSingleton().SendCountryMessage( &tMessage, vCountryID );
	}
	else
	{
		CSceneLogic::GetSingleton().SendCountryMessage( &tMessage, vCountryID );
	}

	if ( vWorldID != 0 && ( IS_GLOBAL_SCENESERVER( CSceneLogic::GetSingleton().GetLineID() ) == true ||
		IS_DUNGEONSERVER_LINE( CSceneLogic::GetSingleton().GetLineID() ) == true ) )
	{
		CSceneLogic::GetSingleton().Send2OtherGate( &tMessage, vWorldID );
	}
}

void CPropertyModule::SendActiveCardNotice( CEntity* pPlayer, int vType, int vPos, int vItemID )
{
	CMessage tMessage;
	CMessageActiveCardNotify tNotify;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_NOTIFY_ACTIVECARD );

	tNotify.set_type( vType );
	tNotify.set_pos( vPos );
	tNotify.set_itemid( vItemID );

	tMessage.set_msgpara( (uint32)&tNotify );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}


// ***********************************************************
//  Function:		学习技能回复
//  Description:	SendStudySkillResponse
//  Input:			CEntityPlayer*		pPlayer			学习技能的实体
//					CPropertyPlayer*	pProperty		学习技能实体的属性
//					int*				tGenerIDList	系别ID列表
//					int*				tColList		横坐标列表
//					int*				tRowList		纵坐标列表
//					int					tCount			坐标数量
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/04/2008
// **********************************************************
void CPropertyModule::SendStudySkillResponse( CEntityPlayer* pPlayer, int* tGenerIDList, int* tColList, int* tRowList, int tCount, unsigned int* tSkillIDList, int* tIndexList )
{
	LK_ASSERT( pPlayer != NULL && tGenerIDList != NULL && tColList != NULL && tRowList != NULL && tSkillIDList != NULL && tIndexList != NULL, return );
	if ( tCount <= 0 )
		return;
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();

	static CMessage tMessage;
	static CMessageStudySkillResponse tStudySkillResponse;

	tMessage.Clear();
	tStudySkillResponse.Clear();

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_RESPONSE_STUDYSKILL );

	for ( int i = 0; i < tCount; i++ )
	{
		CMessageSkillTreeResponse* tpClickSkill = (CMessageSkillTreeResponse*) tStudySkillResponse.add_studyskilllist();
		if ( tpClickSkill == NULL )
			continue;

		tpClickSkill->set_generid( tGenerIDList[ i ] );
		tpClickSkill->set_col( tColList[ i ] );
		tpClickSkill->set_row( tRowList[ i ] );
		tpClickSkill->set_result( ERROR_CLICKSP_SUCCESS );
		tpClickSkill->set_skillid( tSkillIDList[ i ] );
		tpClickSkill->set_index( tIndexList[ i ] );
	}

	tStudySkillResponse.set_curhp( pProperty->GetCurHP( ) );
	tStudySkillResponse.set_curmp( pProperty->GetCurMP( ) );
	tStudySkillResponse.set_maxhp( pProperty->GetMaxHP( ) );
	tStudySkillResponse.set_maxmp( pProperty->GetMaxMP( ) );
	tStudySkillResponse.set_curmoney( pProperty->GetMoney( ) );
	tStudySkillResponse.set_remainskillpoint( pProperty->GetSkillPoint( ) );

	tMessage.set_msgpara( (uint32)&tStudySkillResponse );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// ***********************************************************
//  Function:		发送切换PK模式结果的消息
//  Description:	SendChangePKModeResponse
//  Input:			CEntityPlayer*		pPlayer
//					int					vRet
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/04/2008
// **********************************************************
void CPropertyModule::SendChangePKModeResponse( CEntityPlayer* pPlayer, int vRet )
{
	LK_ASSERT( pPlayer != NULL, return );

	static CMessage tMessage;
	static CMessageChangePKModeResponse tChangePKMode;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_RESPONSE_CHANGEPKMODE );

	tChangePKMode.set_pkmode( pPlayer->GetPKMode() );
	tChangePKMode.set_result( vRet );

	tMessage.set_msgpara( (uint32)&tChangePKMode );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// ***********************************************************
//  Function:		返回查看别人装备的消息
//  Description:	SendLookPropertyResponse
//  Input:			CEntityPlayer*		pPlayer		观察者
//					CEntityPlayer*		pLooker		被观察者
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/05/2008
// **********************************************************
void CPropertyModule::SendLookPropertyResponse( CEntityPlayer* pPlayer, CEntityPlayer* pLooker, int vType )
{
	LK_ASSERT( pPlayer != NULL && pLooker != NULL, return );

	static CMessage tMessage;
	static CMessageLookPropertyResponse tLookEquip;

	tMessage.Clear();
	tLookEquip.Clear();

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_RESPONSE_LOOKPROPERTY );

	tLookEquip.set_metierid( pLooker->GetMetier() );
	tLookEquip.set_facetype( pLooker->GetFaceType() );	
	tLookEquip.set_sex( pLooker->GetSex() );
	tLookEquip.set_countryid( pLooker->GetCountryID() );
	if ( ( vType & LOOK_EQUIPMENT ) == LOOK_EQUIPMENT )
	{		
		tLookEquip.set_nationid( pLooker->GetNationality() );
		tLookEquip.set_level( pLooker->GetLevel() );
		tLookEquip.set_pkvalue( ((CPropertyPlayer*)pLooker->GetProperty())->GetPKValue() );
		tLookEquip.set_name( pLooker->GetCharName() );
		
		if ( pLooker->GetFamilyID() != 0 )
		{
			CFamilyInfo *tpFamilyInfo = CFamilyModule::GetSingleton().GetFamilyInfo( pLooker->GetFamilyID() );
			if ( tpFamilyInfo != NULL )
			{
				tLookEquip.set_family( tpFamilyInfo->GetFamilyName() );
			}
			// tLookEquip.set_family( pLooker->GetFamilyName() );
		}

		if ( pLooker->GetCorpsID() != 0 )
		{
			CFamilyInfo *tpFamilyInfo = CFamilyModule::GetSingleton().GetFamilyInfo( pLooker->GetFamilyID() );
			if ( tpFamilyInfo != NULL )
			{
				if ( tpFamilyInfo->mCorpsID > 0 )
				{
					tLookEquip.set_corps( tpFamilyInfo->GetCorpsName() );
				}			
			}	 		
		}	

		int tTitleID =  ((CPropertyPlayer*)pLooker->GetProperty())->GetCurrentTitle();
		CTitle* tpTitle = ( CTitle* ) CDataStatic::GetTitle( tTitleID );
		if ( tpTitle != NULL )
		{			
			if ( tpTitle->mType == CTplTitleManager::TITLETYPE_SWORN )
			{
				if ( pLooker->GetSwornID() != 0 )
				{
					CSwornTeam *tpSwornTeam = CFriendModule::GetSingleton().GetSwornTeam( pLooker->GetSwornID() );
					if ( tpSwornTeam != NULL )
					{
						tLookEquip.set_title( tpSwornTeam->GetSwornName() );
					}
				}
			}	
			else if( tpTitle->mType == CTplTitleManager::MARRIAGE_SPOUSE )
			{
				CMarriageInfo *tpMarriage = CMarriageManager::GetSingleton().GetMarriageInfo( pLooker->GetMarriageID() );
				if ( tpMarriage != NULL )
				{
					if ( pLooker->GetCharID() == tpMarriage->GetBrideID() )
					{
						tLookEquip.set_mate( tpMarriage->GetGroomName() );
					}
					else
					{
						tLookEquip.set_mate( tpMarriage->GetBrideName() );
					}
				}				
			}
			else
			{
				tLookEquip.set_title( tpTitle->mTitle );
			}
		}

		PBItemBox* tpEquipment = tLookEquip.mutable_equipment();
		CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pLooker->GetProperty();
		if ( tpProPlayer == NULL )
			return;

		tLookEquip.set_honor( tpProPlayer->GetHonor( ) );
		tLookEquip.set_killnum( tpProPlayer->GetKillNumOut( ) + tpProPlayer->GetKillNumIn( ) );

		if ( tpProPlayer->IsVip() )
		{
			tLookEquip.set_vipflag( (int) true );
		}
		
        // 判断是否显示玩家装备信息
        LOG_DEBUG( "pro", "[%s %s:%d] show equip state(%d)", __FUNCTION__, __LK_FILE__, __LINE__, tpProPlayer->GetIsShowEquip() );
        if ( tpProPlayer->GetIsShowEquip() == 0 )
        {
            tLookEquip.set_result( SUCCESS );
            tpProPlayer->GetEquipment( )->GetTlvBuffer2( tpEquipment );
        }else
        {
            tLookEquip.set_result( ERROR_PROPERTY_NOTSHOWEQUIP );
			tpProPlayer->GetEquipment( )->GetTlvBuffer2( tpEquipment );
        }
	}

	if ( ( vType & LOOK_WIZARD ) == LOOK_WIZARD )
	{
		PBWizard *tpPBWizard = tLookEquip.mutable_wizard();
		if ( tpPBWizard != NULL )
		{
			for ( int i = 0; i < WIZARD_NUM; i++ )
			{
				tpPBWizard->add_wizardpoint( ((CPropertyPlayer*)pLooker->GetProperty())->mWizard.GetWizardPoint( i ) );
				tpPBWizard->add_wizardincrease( ((CPropertyPlayer*)pLooker->GetProperty())->mWizard.GetWizardIncrease( i ) + ((CPropertyPlayer*)pLooker->GetProperty())->GetEquipWizard( i ) );
			}
		}
	}

	tLookEquip.set_looktype( vType );
	tLookEquip.set_charid( pLooker->GetCharID() );

	tMessage.set_msgpara( (uint32)&tLookEquip );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::SendLookPropertyRouterRequest( CEntityPlayer* pPlayer, int vCharID, int vType )
{
	LK_ASSERT( pPlayer != NULL, return );

	static CMessage tMessage;
	static CMessageLookPropertyRouterRequest tLookRouter;

	tMessage.Clear();
	tLookRouter.Clear();

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2S_REQUEST_LOOKPROPERTY );

	CMessageRouter* tpRouter = tLookRouter.mutable_router();
	if ( tpRouter == NULL )
		return;

	tpRouter->set_send2player( 0 );
	//tpRouter->set_sendback( 0 );
	tpRouter->set_routertype( CMessageRouter::ROUTER_CHAR );
	tpRouter->set_srccharid( pPlayer->GetCharID() );
	tpRouter->set_descharid( vCharID );
	tLookRouter.set_looktype( vType );

	tMessage.set_msgpara( (uint32)&tLookRouter );

	CSceneLogic::GetSingleton().Send2Player( vCharID, &tMessage );
}

void CPropertyModule::SendLookPropertyRouterResponse( CEntityPlayer* pPlayer, int vCharID, int vType )
{
	LK_ASSERT( pPlayer != NULL, return );

	CPropertyPlayer* pSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	static CMessage tMessage;
	static CMessageLookPropertyRouterResponse tLookRouter;

	tMessage.Clear();
	tLookRouter.Clear();

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2S_RESPONSE_LOOKPROPERTY );

	CMessageRouter* tpRouter = tLookRouter.mutable_router();
	CMessageLookPropertyResponse* tpResponse = tLookRouter.mutable_equipmentinfo();

	tpRouter->set_send2player( 0 );
	//tpRouter->set_sendback( 0 );
	tpRouter->set_routertype( CMessageRouter::ROUTER_CHAR );
	tpRouter->set_srccharid( pPlayer->GetCharID() );
	tpRouter->set_descharid( vCharID );

	tpResponse->set_metierid( pPlayer->GetMetier() );
	tpResponse->set_facetype( pPlayer->GetFaceType() );
	tpResponse->set_sex( pPlayer->GetSex() );
	tpResponse->set_countryid( pPlayer->GetCountryID() );
	if ( ( vType & LOOK_EQUIPMENT ) == LOOK_EQUIPMENT )
	{		
		tpResponse->set_nationid( pPlayer->GetNationality() );
		tpResponse->set_level( pPlayer->GetLevel() );
		tpResponse->set_pkvalue( ((CPropertyPlayer*)pPlayer->GetProperty())->GetPKValue() );		

		int tTitleID =  ((CPropertyPlayer*)pPlayer->GetProperty())->GetCurrentTitle();
		CTitle* tpTitle = ( CTitle* ) CDataStatic::GetTitle( tTitleID );
		if ( tpTitle != NULL )
		{			
			if ( tpTitle->mType == CTplTitleManager::TITLETYPE_SWORN )
			{
				if ( pPlayer->GetSwornID() != 0 )
				{
					CSwornTeam *tpSwornTeam = CFriendModule::GetSingleton().GetSwornTeam( pPlayer->GetSwornID() );
					if ( tpSwornTeam != NULL )
					{
						tpResponse->set_title( tpSwornTeam->GetSwornName() );
					}
				}
			}			
			else if( tpTitle->mType == CTplTitleManager::MARRIAGE_SPOUSE )
			{
				CMarriageInfo *tpMarriage = CMarriageManager::GetSingleton().GetMarriageInfo( pPlayer->GetMarriageID() );
				if ( tpMarriage != NULL )
				{
					if ( pPlayer->GetCharID() == tpMarriage->GetBrideID() )
					{
						tpResponse->set_mate( tpMarriage->GetGroomName() );
					}
					else
					{
						tpResponse->set_mate( tpMarriage->GetBrideName() );
					}
				}				
			}
			else
			{
				tpResponse->set_title( tpTitle->mTitle );
			}			
		}

		CFamilyInfo *tpFamilyInfo = CFamilyModule::GetSingleton().GetFamilyInfo( pPlayer->GetFamilyID() );
		if ( tpFamilyInfo != NULL )
		{
			tpResponse->set_family( tpFamilyInfo->GetFamilyName() );
			tpResponse->set_corps( tpFamilyInfo->GetCorpsName() );	
		}

		tpResponse->set_mate( "" );
		tpResponse->set_individualityidiograph( "" );
		tpResponse->set_name( pPlayer->GetCharName() );		
		tpResponse->set_honor( pSrcProperty->GetHonor( ) );
		tpResponse->set_killnum( pSrcProperty->GetKillNumOut( ) + pSrcProperty->GetKillNumIn( ) );

		PBItemBox* tpEquipment = tpResponse->mutable_equipment();
        // 设置是否显示装备
        
        LOG_DEBUG( "pro", "[%s %s:%d] show equip state(%d)", __FUNCTION__, __LK_FILE__, __LINE__, pSrcProperty->GetIsShowEquip() );
        if ( pSrcProperty->GetIsShowEquip() == 0 )
        {
            tpResponse->set_result(  SUCCESS );
            pSrcProperty->GetEquipment( )->GetTlvBuffer2( tpEquipment );
        }else
        {
            tpResponse->set_result( ERROR_PROPERTY_NOTSHOWEQUIP );
			pSrcProperty->GetEquipment( )->GetTlvBuffer2( tpEquipment );
        }
	}	
	if ( ( vType & LOOK_WIZARD ) == LOOK_WIZARD )
	{
		PBWizard *tpPBWizard = tpResponse->mutable_wizard();
		if ( tpPBWizard != NULL )
		{
			for ( int i = 0; i < WIZARD_NUM; i++ )
			{
				tpPBWizard->add_wizardpoint( pSrcProperty->mWizard.GetWizardPoint( i ) );
				tpPBWizard->add_wizardincrease( pSrcProperty->mWizard.GetWizardIncrease( i ) + pSrcProperty->GetEquipWizard( i ) );
			}
		}
	}
	tpResponse->set_looktype( vType );

	tpResponse->set_charid( pPlayer->GetCharID() );

	tMessage.set_msgpara( (uint32)&tLookRouter );

	CSceneLogic::GetSingleton().Send2Player( vCharID, &tMessage );
}

void CPropertyModule::SendLookPropertyResponse( CEntityPlayer* pPlayer, CMessageLookPropertyResponse* pLookMessage, int vType )
{
	LK_ASSERT( pPlayer != NULL && pLookMessage != NULL, return );

	pLookMessage->set_looktype( vType );

	static CMessage tMessage;

	tMessage.Clear();

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_RESPONSE_LOOKPROPERTY );

	tMessage.set_msgpara( (uint32)pLookMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}


// ***********************************************************
//  Function:		EntityCharge
//  Description:	src 冲锋 des
//  Input:			CEntity* pSrcEntity
//					CEntity* pDesEntity
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/10/2008
// **********************************************************
void CPropertyModule::EntityCharge( CEntityCharacter* pSrcEntity, CEntity* pDesEntity )
{
	if( pSrcEntity == NULL || pDesEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] pSrcEntity or pDesEntity error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	int tPosX = 0;
	int tPosY = 0;

	if ( pDesEntity->GetPosX( ) > pSrcEntity->GetPosX( ) )
	{
		tPosX = pDesEntity->GetPosX( ) - 1;
	}
	else if ( pDesEntity->GetPosX( ) < pSrcEntity->GetPosX( ) )
	{
		tPosX = pDesEntity->GetPosX( ) + 1;
	}
	else
	{
		tPosX = pDesEntity->GetPosX( );
	}

	if ( pDesEntity->GetPosY( ) > pSrcEntity->GetPosY( ) )
	{
		tPosY = pDesEntity->GetPosY( ) - 1;
	}
	else if ( pDesEntity->GetPosY( ) < pSrcEntity->GetPosY( ) )
	{
		tPosY = pDesEntity->GetPosY( ) + 1;
	}
	else
	{
		tPosY = pDesEntity->GetPosY( );
	}

	// TODO: 判断冲锋的目标点是否是阻挡,如果是阻挡,就将角色重合	
	// 以后宠物如果冲锋可能会有问题
	if ( pSrcEntity->IsOgre() || pSrcEntity->IsFunNpc() )
	{
		CPropertyNPC *tpProperty = (CPropertyNPC*)(pSrcEntity->GetProperty() );

		if ( CMapModule::GetSingleton().CanNpcPass( pSrcEntity->GetLineID(), pSrcEntity->GetMapID(), 
					pSrcEntity->GetMapIndex( ), tPosX, tPosY, tpProperty->GetStateParam( STATE_FLY ).mInState ) == false )
		{
			tPosX = pDesEntity->GetPosX( );
			tPosY = pDesEntity->GetPosY( );
			CNpcModule::GetSingleton().OnTeleport( pSrcEntity->GetEntityID(), tPosX, tPosY );
		}
	}
	else if ( pSrcEntity->IsPlayer() )
	{
		CPropertyPlayer *tpProperty = (CPropertyPlayer*)( ((CEntityPlayer*)pSrcEntity)->GetProperty() );
		if ( CMapModule::GetSingleton().CanPlayerPass( pSrcEntity->GetLineID(), pSrcEntity->GetMapID(), 
					pSrcEntity->GetMapIndex( ), tPosX, tPosY, tpProperty->GetStateParam( STATE_FLY ).mInState ) == false )
		{
			tPosX = pDesEntity->GetPosX( );
			tPosY = pDesEntity->GetPosY( );
		}
	}

	CMapModule::GetSingleton().OnEntityMove( (CEntityCharacter*)pSrcEntity, CWTPoint(tPosX, tPosY) );
	pSrcEntity->AddFunResult( 0, FUNC_CHANGEPOS, RESULT_CHARGE, true, tPosX, tPosY );

}

// ***********************************************************
//  Function:		EntityInsertDamageList
//  Description:	插入伤害列表
//  Input:			CEntity* pSrcEntity
//					CPropertyCharacter* pSrcProperty
//					CEntity* pDesEntity
//					CPropertyCharacter* pDesProperty
//					int vDamage
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/11/2008
// **********************************************************
void CPropertyModule::EntityInsertDamageList( CEntity* pSrcEntity, CEntity* pDesEntity, int vDamage )
{
	if ( pSrcEntity == NULL || pDesEntity == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] pSrcEntity, pDesEntity error", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	
	if( !pSrcEntity->IsCharacter() ||  !pDesEntity->IsCharacter() )
	{
		return;
	}

	//CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	CPropertyCharacter* pDesProperty = (CPropertyCharacter*) pDesEntity->GetProperty();

	if ( pDesEntity->IsPet() )
	{
		CEntityPet* pDesEntityPet = (CEntityPet*)pDesEntity;

		CPropertyCharacter* tpDesMstProperty = ( CPropertyCharacter* )CProperty::SearchProByEntityID( 
				pDesEntityPet->GetOwnerID() );
		CDamageList *tpDesMstList = tpDesMstProperty->GetDamageList( );
		if ( tpDesMstProperty != NULL )
		{
			if ( pSrcEntity->IsPet() )
			{
				CEntityPet* pSrcEntityPet = (CEntityPet*)pSrcEntity;
				CPropertyCharacter* tpSrcMstProperty = ( CPropertyCharacter* )CProperty::SearchProByEntityID( 
						pSrcEntityPet->GetOwnerID() );
				if ( tpSrcMstProperty != NULL )
				{
					tpDesMstList->InsertDamage( CDamage( tpSrcMstProperty->GetEntityID() , vDamage ) );
				}
			} 
			else
			{
				tpDesMstList->InsertDamage( CDamage( pSrcEntity->GetEntityID(), vDamage ) );
			}
		}
	} 
	else
	{
		CDamageList *tpDesList = pDesProperty->GetDamageList( );
		if ( pSrcEntity->IsPet() )
		{
			CEntityPet* pSrcEntityPet = (CEntityPet*)pSrcEntity;
			CPropertyCharacter* tpSrcMstProperty = ( CPropertyCharacter* )CProperty::SearchProByEntityID( 
					pSrcEntityPet->GetOwnerID() );
			if ( tpSrcMstProperty != NULL )
			{
				tpDesList->InsertDamage( CDamage( tpSrcMstProperty->GetEntityID() , vDamage ) );
			}
		} 
		else
		{
			if( pSrcEntity != NULL )
			{
				tpDesList->InsertDamage( CDamage( pSrcEntity->GetEntityID(), vDamage ) );
			}
		}
	}
}


// 玩家关闭特定的界面
void CPropertyModule::PlayerCloseWindow( CEntityPlayer* pPlayer, int vType )
{	
	if ( pPlayer == NULL )
	{
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	int tTempIndex = -1;	
	

	if ( ( vType & CLOSE_PRO ) == CLOSE_PRO )
	{
		pProperty->GetProduce( )->Clear( );
	}
	// 如果是关闭交任务对话框
	if ( ( vType & CLOSE_TASK ) == CLOSE_TASK )
	{
		tTempIndex = pProperty->GetBaggage( )->GetTaskLockIndex();
		if ( tTempIndex == -1 )
			return;
		// 解锁对应格子
		if ( pProperty->GetBaggage( )->Lock( tTempIndex, LOCKTYPE_NONE ) == true )
		{
			SendLockItemNotice( pPlayer, tTempIndex, LOCKTYPE_NONE );
			pProperty->GetBaggage( )->SetTaskLockIndex(-1);
		}
	}

	// 关闭传送符的创送表界面
	if ( (vType & CLOSE_TELESYMBOL) == CLOSE_TELESYMBOL )
	{
		tTempIndex = pProperty->GetBaggage()->GetTeleSymbolIndex();
		if ( tTempIndex == -1 )
		{
			return; 
		}
		if ( pProperty->GetBaggage()->Lock( tTempIndex, LOCKTYPE_NONE ) == true )
		{
			SendLockItemNotice( pPlayer, tTempIndex, LOCKTYPE_NONE );
			pProperty->GetBaggage()->SetTeleSymbolIndex( -1 );
		}				
	}	
	
	// 创造配方的界面关闭
	if ( ( vType & CLOSE_COMPOSECREAT ) == CLOSE_COMPOSECREAT )
	{	
		int tIDList[MATERIALINDEXNUM] = { 0 };
		int tNum = MATERIALINDEXNUM;
		pProperty->GetPlayerLifeSkill()->GetMaterialList( tIDList, tNum );	
		for ( int i = 0; i < tNum; ++i )
		{
			if ( tIDList[i] != -1 )
			{			
				pProperty->GetBaggage()->Lock( tIDList[i], LOCKTYPE_NONE );
				SendLockItemNotice( pPlayer, tIDList[i], LOCKTYPE_NONE );
				SendResponseTakeMaterial( pPlayer, SUCCESS, i );
			}	
		}	
		pProperty->GetPlayerLifeSkill()->ClearMaterial();	
	}	
	
	// 点金的界面关闭
	if ( ( vType & CLOSE_DECOMPOUNDEQUIP ) == CLOSE_DECOMPOUNDEQUIP )
	{
		if ( pProperty->GetDecompoundEquipIndex() >= 0 )
		{
			pProperty->GetBaggage()->Lock( pProperty->GetDecompoundEquipIndex(), LOCKTYPE_NONE );
			SendLockItemNotice( pPlayer, pProperty->GetDecompoundEquipIndex(), LOCKTYPE_NONE );
			SendResponseTakerDecompoundEquipResponse( pPlayer, SUCCESS, pProperty->GetDecompoundEquipIndex() );
			pProperty->SetDecompoundEquipIndex( -1 );
		}		
	}
}

//void CPropertyModule::OnMessageAddItemForFreeRequest( CEntityPlayer *pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL )
//	{
//		return;
//	}
//	CMessageAddBindItemRequest *tpMsg = ( CMessageAddBindItemRequest * )pMessage->msgpara();
//	if ( tpMsg == NULL )
//	{
//		return;
//	}
//	int ItemIndex = tpMsg->itemindex();
//	
//	
//}

// 处理客户端绑定物品的请求
void CPropertyModule::OnMessageBindItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessage						MessageHead;
	CMessageBindItemResponse		MsgBindItemResponse;
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageBindItemRequest *tpMsg = ( CMessageBindItemRequest * )pMessage->msgpara(  );
	if ( tpMsg == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	if ( tpProperty == NULL )
	{
		LOG_ERROR("pro","[%s,%d][%s]Error CPropertyPlayer!", __LK_FILE__,__LINE__,__FUNCTION__);
		return;
	}
	
	// 密码安全检查
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	


	int ItemIndex         = tpMsg->itemindex();		
	int ConsumeItemIndex  = tpMsg->bindindex();
	
	// 判断是否放置有装备
	if ( ItemIndex == -1  )
	{
		tpProperty->GetBaggage( )->mBindItemIndex = -1;
		return;
	}
	
	// 判断是否放置有绑定符
	if (  ConsumeItemIndex == -1 )
	{
		tpProperty->GetBaggage( )->mEquipIndex = -1;
		return;
	}
	
	// 绑定位赋空
	tpProperty->GetBaggage()->mEquipIndex    = -1;
	tpProperty->GetBaggage()->mBindItemIndex = -1;
	
	// 给物品解锁
	if ( tpProperty->GetBaggage()->Lock( ItemIndex, LOCKTYPE_NONE ) == true )
	{
		SendLockItemNotice( pPlayer, ItemIndex, LOCKTYPE_NONE );
	}
	if ( tpProperty->GetBaggage()->Lock( ConsumeItemIndex, LOCKTYPE_NONE ) == true )
	{
		SendLockItemNotice( pPlayer, ConsumeItemIndex, LOCKTYPE_NONE );
	}
		
	// 计算绑定需要的金钱
	int  Money		 = 0;
	int  BindMoney	 = 0;	
	CTplBindChargeTable *tpBindChargge = ( CTplBindChargeTable * )CDataStatic::GetTemp( TEMP_BINDCHARGETABLE );
	if ( tpBindChargge != NULL )
	{				
		if ( tpBindChargge->mCanBindUseBM == 1 )
		{
			if ( tpBindChargge->mMoneyBindNeed > tpProperty->GetBindMoney() )
			{
				BindMoney = tpProperty->GetBindMoney();
				Money	  =  tpBindChargge->mMoneyBindNeed - BindMoney;
			}
			else
			{
				BindMoney = tpBindChargge->mMoneyBindNeed;						
			} 							
		}
		else
		{
			Money =	tpBindChargge->mMoneyBindNeed;
		} 		
	}	
	
	// 判断是否有足够的金钱	
	if ( Money > tpProperty->GetMoney() )
	{
		SendProErrorNotice( pPlayer, ITEM_BINDRESULT_MONEYNOTENOUGH );
		if ( tpProperty->GetBaggage()->Lock( ItemIndex, LOCKTYPE_NONE  ) == true )
		{
			SendLockItemNotice( pPlayer, ItemIndex, LOCKTYPE_NONE );
		}
		if ( tpProperty->GetBaggage()->Lock( ConsumeItemIndex, LOCKTYPE_NONE ) == true )
		{
			SendLockItemNotice( pPlayer, ConsumeItemIndex, LOCKTYPE_NONE );
		}																   		
		return;
	} 
	
	// 进行绑定
	CItemObject *tpItemObj =  tpProperty->GetBaggage( )->GetItemObjPtr( ItemIndex );
	CItemObject *tpItemJewelObj =  tpProperty->GetBaggage( )->GetItemObjPtr( ConsumeItemIndex );

	LK_ASSERT( tpItemObj != NULL && tpItemJewelObj != NULL, return )

	int nFrom = tpItemObj->GetBindStatus();
	int BindResult = BindItem ( pPlayer , tpItemObj , ITEM_BINDWAY_BYITEM , ConsumeItemIndex ); 
	if( BindResult == ITEM_BINDRESULT_SUCESS )
	{		
		// 发送绑定消息
		MsgBindItemResponse.set_itemindex( ItemIndex );
		MsgBindItemResponse.set_bindresult( 1 );
		MsgBindItemResponse.set_bindstatus( tpItemObj->GetBindStatus() );
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_BINDITEM );
		MessageHead.set_msgpara( (int)&MsgBindItemResponse );
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
	
		// 删除道具
		uint64_t ullGUID = tpItemObj->GetGUID(); 
		int32 nJewelItemID = tpItemJewelObj->GetItemID();

		if( PlayerRemoveItem( pPlayer, ConsumeItemIndex, BINDITEM_CONSUMENUM) == 0)			
		{
			LogEventLostItemByBound(pPlayer, ullGUID, nJewelItemID, BINDITEM_CONSUMENUM, tpItemObj->GetItemID(), tpItemObj->GetGUID());
		}
			
		// 扣除金钱					
		if ( BindMoney > 0 )
		{
			if (PlayerChangeMoney( pPlayer, BindMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByBindItem(pPlayer, CYuanBao::em_bind_money, BindMoney, tpItemObj->GetItemID(), tpItemObj->GetGUID());
			}
		}				

		if ( Money > 0 )
		{
			if (PlayerChangeMoney( pPlayer, Money, true, false ) == SUCCESS)
			{
				LogEventLostMoneyByBindItem(pPlayer, CYuanBao::em_bind_money, Money, tpItemObj->GetItemID(), tpItemObj->GetGUID());
			}
		}	 		
		
		// 发送错误通知
		MsgBindItemResponse.set_itemindex( ItemIndex );
		MsgBindItemResponse.set_bindresult( 0 );
		MsgBindItemResponse.set_bindstatus( tpItemObj->GetBindStatus() );
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_BINDITEM );
		MessageHead.set_msgpara( (int)&MsgBindItemResponse );
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );		

		// 记录绑定状态改变
		LogEventItemLockAction(pPlayer, tpItemObj->GetItemID(), tpItemObj->GetGUID(), 
				nFrom, tpItemObj->GetBindStatus(), nJewelItemID, tpItemObj->GetBindStatus());
	}
	else
	{
		// 发送错误通知
		SendProErrorNotice( pPlayer, BindResult );
	}			
	
	// 解绑
	if ( tpProperty->GetBaggage()->Lock( ItemIndex, LOCKTYPE_NONE  ) == true )
	{
		SendLockItemNotice( pPlayer, ItemIndex, LOCKTYPE_NONE );
	}
	if ( tpProperty->GetBaggage()->Lock( ConsumeItemIndex, LOCKTYPE_NONE ) == true )
	{
		SendLockItemNotice( pPlayer, ConsumeItemIndex, LOCKTYPE_NONE );
	}							
}

// 添加需要回复绑定的装备
void CPropertyModule::OnMessageAddEqtForResumeBind( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[%s,%d][%s] Empty Pointer! ",__LK_FILE__,__LINE__,__FUNCTION__ );
			return;
	}
	CMessageAddEqtForResumeBindRequest *tpMsg = ( CMessageAddEqtForResumeBindRequest * )pMessage->msgpara();
		if ( tpMsg == NULL )
		{
			LOG_ERROR( "pro", "[%s,%d][%s] Empty Msg! ",__LK_FILE__,__LINE__,__FUNCTION__ );
				return;
		}	
	PlayerAddEqtForResumeBind( pPlayer, tpMsg->eqtindex( ) );
}

// 取下需要恢复手动绑定的物品
void CPropertyModule::OnMessageTakeEqtForResumeBind( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro","[%s,%d][%s] CEntityPlayer , CMessage  or CPropertyPlayer is null ",__LK_FILE__,__LINE__,__FUNCTION__ );
			return;
	}
	CMessageTakeEqtForResumeBindRequest *tpMsg = ( CMessageTakeEqtForResumeBindRequest *  )pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Msg is null! " ,__LK_FILE__,__LINE__,__FUNCTION__ );
			return;
	}
	PlayerTakeEqtForResumeBind( pPlayer );	
}

// 恢复装备的手动绑定状态
void CPropertyModule::OnMessageResumeBind( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_ERROR( "pro","[%s,%d][%s] CEntityPlayer , CMessage  or CPropertyPlayer is null ",__LK_FILE__,__LINE__,__FUNCTION__ );
			return;
	}
	CMessageResumeBindRequest *tpMsg = ( CMessageResumeBindRequest * )pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Msg is null! " ,__LK_FILE__,__LINE__,__FUNCTION__ );
			return;
	}
	PlayerResumeBind( pPlayer, tpMsg->eqtindex() );
}

// 添加绑定物品
void CPropertyModule::OnMessageAddItemRequest( CEntityPlayer * pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageAddBindItemRequest *tpMsg = ( CMessageAddBindItemRequest * )pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		return;
	}
	PlayerInsertBindItem( pPlayer , tpMsg->itemindex() );
}
// 取下绑定物品
void CPropertyModule::OnMessageTakeItemRequest( CEntityPlayer *pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageTakeBindItemRequest *tpMsg = ( CMessageTakeBindItemRequest * )pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		return;
	}
	PlayerTakeBindItem( pPlayer , tpMsg->itemindex() );

}
// 添加解除绑定的物品
void CPropertyModule::OnMessageAddItemForFreeRequest( CEntityPlayer *pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageAddItemForFreeRequest *tpMsg = ( CMessageAddItemForFreeRequest * )pMessage->msgpara();
	if ( tpMsg == NULL )
	{		
		return;
	}
	PlayerInsertItemForFree( pPlayer , tpMsg->itemindex() ); 
}
// 取下待解除绑定物品
void CPropertyModule::OnMessageTakeItemForFreeRequet( CEntityPlayer *pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageTakeItemForFreeRequest *tpMsg = ( CMessageTakeItemForFreeRequest * )pMessage->msgpara();
	if ( tpMsg == NULL )
	{		
		return;
	}
	PlayerTakeItemForFree( pPlayer, tpMsg->itemindex() );
}

// 解除绑定
void CPropertyModule::OnMessageFreeItem( CEntityPlayer *pPlayer, CMessage* pMessage )
{	
	CMessage MessagHead;
	CMessageFreeItemResponse MsgFreeItem;
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageFreeItem *tpMsg = ( CMessageFreeItem * )pMessage->msgpara();
	if ( tpMsg == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	if ( tpMsg == NULL )
	{	
		LOG_ERROR("pro","[%s,%d][%s] Error CPropertyPlayer! ",__LK_FILE__,__LINE__,__FUNCTION__);
		return;
	}
	
	// 检查安全保护时间
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 判断是否放置了装备
	int ItemIndex = tpMsg->itemindex();
	if ( ItemIndex == -1 )
	{	
		return;		
	}
	
	// 给装备解锁
	if ( tpProperty->GetBaggage()->Lock( ItemIndex, LOCKTYPE_NONE ) == true )
	{
		SendLockItemNotice( pPlayer, ItemIndex, LOCKTYPE_NONE );
	}
		
	// 计算取消绑定需要的金钱 
	int  Money		 = 0;
	int  BindMoney	 = 0;	
	CTplBindChargeTable *tpBindChargge = ( CTplBindChargeTable * )CDataStatic::GetTemp( TEMP_BINDCHARGETABLE );
	if ( tpBindChargge != NULL )
	{
		if ( tpBindChargge->mCanUnBindUseBM == 1 )
		{
			if ( tpBindChargge->mMoneyUnBindNeed > tpProperty->GetBindMoney() )
			{
				BindMoney = tpProperty->GetBindMoney();
				Money	  =  tpBindChargge->mMoneyUnBindNeed - BindMoney;
			}
			else
			{
				BindMoney = tpBindChargge->mMoneyUnBindNeed;						
			} 							
		}
		else
		{
			Money =	tpBindChargge->mMoneyUnBindNeed;
		}
	}
	
	// 判断是否有足够的金钱
	if ( Money > tpProperty->GetMoney() )
	{
		SendProErrorNotice( pPlayer, ITEM_FREEBINDRESULT_MONEYNOTENOUGH );
		return;
	}
	
	// 给装备解绑	
	CItemObject *tpItemObject = ( CItemObject * )tpProperty->GetBaggage( )->GetItemObjPtr( ItemIndex );

	int nFrom = 0;
	if ( tpItemObject != NULL) nFrom = tpItemObject->GetBindStatus();

	int  Result = FreeItemBind( tpItemObject , 1 );
		
	// 绑定成功 
	if ( Result == 1 )
	{	
		// 插入到列表中 
		InsertFreeItemIntoList( pPlayer->GetCharID() , tpItemObject );
				 
		// 解绑成功
		MsgFreeItem.set_result( 1 );
		MsgFreeItem.set_bindfreetime( (( CItemEquipment *)tpItemObject)->GetBindFreeTime() );
		MsgFreeItem.set_itemindex( ItemIndex );	
		MessagHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_FREEITEM );
		MessagHead.set_msgpara( ( int )&MsgFreeItem );
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer , &MessagHead );
				
		// 扣除费用
		if ( BindMoney > 0 ) 
		{
			if(PlayerChangeMoney( pPlayer, BindMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByUnBindItem(pPlayer, CYuanBao::em_bind_money, BindMoney, 
						tpItemObject->GetItemID(),  tpItemObject->GetGUID());
			}
		}				
		if ( Money > 0 )
		{
			if(PlayerChangeMoney( pPlayer, Money, true, false ) == SUCCESS)
			{
				LogEventLostMoneyByUnBindItem(pPlayer, CYuanBao::em_unbind_money, BindMoney, 
						tpItemObject->GetItemID(),  tpItemObject->GetGUID());
			}
		}	

		LogEventItemLockAction(pPlayer, tpItemObject->GetItemID(), tpItemObject->GetGUID(), 
				nFrom, tpItemObject->GetBindStatus(), 0, tpItemObject->GetBindStatus());

		return;
	}

	// 发送解绑失败的消息
	MsgFreeItem.set_result( 0 );	
	MsgFreeItem.set_itemindex( ItemIndex );
	MessagHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_FREEITEM );
	MessagHead.set_msgpara( ( int )&MsgFreeItem );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer , &MessagHead );
	
	return;
}

// ***********************************************************
//  Function:		OnMessageStudySkillRequest
//  Description:	处理学习技能的消息
//  Input:			CEntityPlayer*		pPlayer			学习技能的实体
//					CMessage*			pMessage		学习技能的消息
//					CPropertyPlayer*	pSrcProperty	学习技能的实体属性
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/25/2008
// **********************************************************
void CPropertyModule::OnMessageStudySkillRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return );

	CMessageStudySkillRequest* tpMsg = (CMessageStudySkillRequest*) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	int tListCount = tpMsg->studyskilllist_size();

	LK_ASSERT( tListCount > 0, return );

	CMessage tMessage;
	CMessageStudySkillResponse tStudySkillResponse;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_RESPONSE_STUDYSKILL );
	
	CPropertyPlayer* pSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tOldCurHP = pSrcProperty->GetCurHP( );
	int tOldCurMP = pSrcProperty->GetCurMP( );
	int tOldMaxHP = pSrcProperty->GetMaxHP( );
	int tOldMaxMP = pSrcProperty->GetMaxMP( );
	bool bIsRefresh = false, bBindState = false;
	int tnTotalMoney = 0;
	for ( int i = 0; i < tListCount; i++ )
	{
		CMessageClickSkillPointRequest* tpRequestMsg = (CMessageClickSkillPointRequest*) tpMsg->mutable_studyskilllist( i );
		LK_ASSERT( tpRequestMsg != NULL, continue );

		int tGenerID	= tpRequestMsg->generid();
		int tCol		= tpRequestMsg->col();
		int tRow		= tpRequestMsg->row();
		unsigned int tSkillID	= 0;
		int	tIndex				= -1;
		int tBindState			= 0;
		int tRet		= ClickSP( pPlayer, tGenerID, tCol, tRow, tSkillID, tIndex, tnTotalMoney, tBindState );

		if ( ( bool ) tBindState == true )
		{
			bBindState = true;
		}
		

		CMessageSkillTreeResponse* tpMsgCSP = tStudySkillResponse.add_studyskilllist();
		if ( tpMsgCSP == NULL )
			continue;
		tpMsgCSP->set_generid( tGenerID );
		tpMsgCSP->set_col( tCol );
		tpMsgCSP->set_row( tRow );
		tpMsgCSP->set_result( tRet );
		tpMsgCSP->set_skillid( tSkillID );
		tpMsgCSP->set_index( tIndex );
		// 如果加点失败,则跳出循环,返回前面的结果
		if ( tRet != ERROR_CLICKSP_SUCCESS )
			break;

		// 如果加点成功,则继续加点
		bIsRefresh = true;
	}	

	// check if money is enough
	if ( bBindState )
	{
		if ( pSrcProperty->IsMoneyEnough( true, tnTotalMoney ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKSP_NEEDMONEY );
			return ;
		}		

		if (PlayerChangeMoney( pPlayer, tnTotalMoney, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByStudySkill(pPlayer, CYuanBao::em_bind_money, tnTotalMoney);
		}
	}
	else
	{
		if ( pSrcProperty->IsMoneyEnough( false, tnTotalMoney ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKSP_NEEDMONEY );
			return ;
		}		

		if (PlayerChangeMoney( pPlayer, tnTotalMoney, true, false ) == SUCCESS)
		{
			LogEventLostMoneyByStudySkill(pPlayer, CYuanBao::em_unbind_money, tnTotalMoney);
		}
	}
	
	// 给自己发送学习技能的结果
	tStudySkillResponse.set_curhp( pSrcProperty->GetCurHP( ) );
	tStudySkillResponse.set_curmp( pSrcProperty->GetCurMP( ) );
	tStudySkillResponse.set_maxhp( pSrcProperty->GetMaxHP( ) );
	tStudySkillResponse.set_maxmp( pSrcProperty->GetMaxMP( ) );
	tStudySkillResponse.set_remainskillpoint( pSrcProperty->GetSkillPoint( ) );
	//tStudySkillResponse.set_curmoney( pSrcProperty->GetMoney( ) );

	tMessage.set_msgpara( (uint32)&tStudySkillResponse );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );

	if ( bIsRefresh == true )
	{
		pSrcProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		// 刷新属性的消息通知其他可见的客户端
		if ( tOldMaxHP != (int)pSrcProperty->GetMaxHP( ) || tOldMaxMP != (int)pSrcProperty->GetMaxMP( ) || tOldCurHP != (int)pSrcProperty->GetCurHP( ) || tOldCurMP != (int)pSrcProperty->GetCurMP( ) )
		{
			CMessage tEntityRefresh;
			CMessageEntityRefreshNotice tRefreshMessage;
			bool vBool = false;
			vBool = CreateMessageEntityRefreshNotice(
				&tEntityRefresh,
				&tRefreshMessage,
				pPlayer->GetEntityID( ),
				pSrcProperty->GetCurHP( ),
				pSrcProperty->GetCurMP( ),
				pSrcProperty->GetMaxHP( ),
				pSrcProperty->GetMaxMP( )
				);
			if ( vBool == true )
			{
				CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tEntityRefresh  );
			}
		}
	}
}

// ***********************************************************
//  Function:		OnMessageAddPropertyPointRequest
//  Description:	处理客户端加属性点请求的消息
//  Input:			CEntityPlayer*		pPlayer			加点的实体
//					CMessage*			pMessage		消息指针
//  OutPut:			
//  Return:			
//  Others:
//  Date:	11/27/2008
// **********************************************************
void CPropertyModule::OnMessageAddPropertyPointRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageAddPropertyPointRequest* tpMsg = (CMessageAddPropertyPointRequest*) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	int tSTR = tpMsg->addstr();
	int tCON = tpMsg->addcon();
	int tSTA = tpMsg->addsta();
	int tWIS = tpMsg->addwis();
	int tSPR = tpMsg->addspr();

	if ( tSTR <= 0 && tCON <= 0 && tSTA <= 0 && tWIS <= 0 && tSPR <= 0 )
		return;

	CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pPlayer->GetProperty();
	LK_ASSERT( tpProPlayer != NULL, return );

	int tOldCurHP = tpProPlayer->GetCurHP( );
	int tOldCurMP = tpProPlayer->GetCurMP( );
	int tOldMaxHP = tpProPlayer->GetMaxHP( );
	int tOldMaxMP = tpProPlayer->GetMaxMP( );

	int tRet = tpProPlayer->AddPropertyPoint( tSTR, tCON, tSTA, tWIS, tSPR );	

	// 给自己发送加属性点的结果
	CMessage tMessage;
	CMessageAddPropertyPointResponse tAddProPointResponse;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	tpHead->set_messageid( ID_S2C_RESPONSE_ADDPROPERTYPOINT );

	// 如果一个request消息有response. 那么0就表示成功， !0 才是错误码
	tAddProPointResponse.set_result( tRet == ERROR_CLICKPP_SUCCESS ? 0 : tRet );

	tMessage.set_msgpara( (uint32)&tAddProPointResponse );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );

	if ( tRet == ERROR_CLICKPP_SUCCESS )
	{
		tpProPlayer->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		// 刷新属性的消息通知其他可见的客户端
		if ( tOldMaxHP != (int)tpProPlayer->GetMaxHP( ) || tOldMaxMP != (int)tpProPlayer->GetMaxMP( ) || tOldCurHP != (int)tpProPlayer->GetCurHP( ) || tOldCurMP != (int)tpProPlayer->GetCurMP( ) )
		{
			CMessage tEntityRefresh;
			CMessageEntityRefreshNotice tRefreshMessage;
			CreateMessageEntityRefreshNotice(
				&tEntityRefresh,
				&tRefreshMessage,
				pPlayer->GetEntityID( ),
				tpProPlayer->GetCurHP( ),
				tpProPlayer->GetCurMP( ),
				tpProPlayer->GetMaxHP( ),
				tpProPlayer->GetMaxMP( )
				);

			CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tEntityRefresh );
		}
	}
}

//void CPropertyModule::OnMessageClickStudySkillService( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return );
//
//	CMessageClickStudySkillServiceRequest* tpMsg = (CMessageClickStudySkillServiceRequest*) pMessage->msgpara();
//	LK_ASSERT( tpMsg != NULL, return );
//
//	PlayerClickStudySkill( pPlayer, tpMsg->entityid() );
//}

// 处理客户端手动删除BUFF的请求
void CPropertyModule::OnMessageActiveRemoveBuffRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	int i = 0;
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageActiveRemoveBuffRequest* tpMsg = (CMessageActiveRemoveBuffRequest*) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	for( i = 0; i < tpMsg->listid_size( ); i++ )
	{
		pPlayer->ActiveRemoveBuff( tpMsg->buffid( ) );
		LogEventLostBuffBySelf(pPlayer,tpMsg->buffid( )); //手动清除BUFF
	}

	ResultListSend( );
}

// ***********************************************************
//  Function:		OnMessageSetPassWordRequest
//  Description:	设置密码的请求
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	01/26/2010
// **********************************************************
void CPropertyModule::OnMessageSetPassWordRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{	
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageSetPasswordRequest *tpMsg = ( CMessageSetPasswordRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	LK_ASSERT( tpMsg->password().length() < MAX_PASSWORD_LENGTH, return )  
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();		
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed(  EM_PASSWORD_ACTION_SETPASSWORD );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
		
	if ( tpProperty->GetRolePassword()->GetStatus() != EM_PASSWORD_NOTSET )
	{	
		SendSetPasswordResponse( pPlayer, ERR_PASSWORD_PASSWORDSETED, tpProperty->GetRolePassword()->GetStatus() );
		return;
	}
	
	int tRet = tpProperty->GetRolePassword()->SetPassword( tpMsg->mutable_password()->c_str() );
	if ( tRet != SUCCESS )
	{
		SendSetPasswordResponse( pPlayer, tRet, tpProperty->GetRolePassword()->GetStatus() );
		return;
	}	
	tpProperty->GetRolePassword()->SetStatus( EM_PASSWORD_PASSFREE );	   	    
	SendSetPasswordResponse( pPlayer, SUCCESS, EM_PASSWORD_PASSFREE );
	
	SendNotifyChangePasswordStatus( pPlayer, tpProperty->GetRolePassword()->GetStatus(), tpProperty->GetRolePassword()->GetPassword() );
}

// ***********************************************************
//  Function:		OnMessageModifyPasswordRequest
//  Description:	修改密码的请求
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	01/26/2010
// **********************************************************
void CPropertyModule::OnMessageModifyPasswordRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return )
	CMessageModifyPasswordRequest *tpMsg = ( CMessageModifyPasswordRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	LK_ASSERT( tpMsg->origpassword().length() < MAX_PASSWORD_LENGTH && tpMsg->newpassword().length() < MAX_PASSWORD_LENGTH, return );

	// 是否在安全期
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed(  EM_PASSWORD_ACTION_SETPASSWORD );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

	// 检查原始密码是否正确
	if ( tpProperty->GetRolePassword()->CheckPassword( tpMsg->mutable_origpassword()->c_str() ) == false )
	{
		SendModifyPasswordResponse( pPlayer, ERR_PASSWORD_WRONGPASSWORD, tpProperty->GetRolePassword()->GetStatus() );		
		return;
	}
	
	// 设置新密码
	tpProperty->GetRolePassword()->SetPassword( tpMsg->mutable_newpassword()->c_str() );	
	tpProperty->GetRolePassword()->SetStatus( EM_PASSWORD_PASSFREE );

	SendModifyPasswordResponse( pPlayer, SUCCESS, tpProperty->GetRolePassword()->GetStatus() );
	SendNotifyChangePasswordStatus( pPlayer, tpProperty->GetRolePassword()->GetStatus(), tpProperty->GetRolePassword()->GetPassword() );
}

// ***********************************************************
//  Function:		OnMessageSetPasswordOption
//  Description:	设置密码选项
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	05/04/2009
// **********************************************************
//void CPropertyModule::OnMessageSetPasswordOption( CEntityPlayer* pPlayer, CMessage* pMessage )
//{ 
//	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return )
//	CMessageSetPasswordOptionNotify *tpMsg = ( CMessageSetPasswordOptionNotify * )pMessage->msgpara();
//	LK_ASSERT( tpMsg != NULL, return )
//	( ( CPropertyPlayer * )pPlayer->GetProperty() )->SetPasswordOption( tpMsg->option() );
//} 

// ***********************************************************
//  Function:		OnMessageSetPasswordOption
//  Description:	设置密码选项
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	01/26/2010
// **********************************************************
void  CPropertyModule::OnMessageCheckPasswordRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return )
	CMessageCheckPasswordRequest *tpMsg = ( CMessageCheckPasswordRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	LK_ASSERT( tpMsg->password().length() < MAX_PASSWORD_LENGTH, return  )
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	if ( tpProperty->GetRolePassword()->CheckProtectTime() == false )
	{
		SendCheckPasswordResponse( pPlayer, ERR_PASSWORD_INPROTECTTIME, tpProperty->GetRolePassword()->GetStatus() );		
		return;
	}
	if ( tpProperty->GetRolePassword()->CheckPassword( tpMsg->mutable_password()->c_str() ) == false )
	{
		SendCheckPasswordResponse( pPlayer, ERR_PASSWORD_WRONGPASSWORD, tpProperty->GetRolePassword()->GetStatus() );
		return;
	}
	tpProperty->GetRolePassword()->SetStatus( EM_PASSWORD_PASSFREE );
	SendCheckPasswordResponse( pPlayer, SUCCESS, tpProperty->GetRolePassword()->GetStatus() );
	SendNotifyChangePasswordStatus( pPlayer, EM_PASSWORD_PASSFREE );
}

void CPropertyModule::OnMessageClickTeleSymbolRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageClickTeleSymbolRequest* tpMsg = ( CMessageClickTeleSymbolRequest* ) pMessage->msgpara();

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	CItemObject* tpObj = ( CItemObject* ) tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->index() );
	if ( tpObj == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_ITEMNOTEXIST );
		return ;
	}
	
	bool bRes = false;
	LockBaggage( pPlayer->GetEntityID(), tpMsg->index(), (int)LOCKTYPE_LOCKCANUSE, bRes );
	tpProperty->GetBaggage()->SetTeleSymbolIndex( tpMsg->index() );

	CMessage tMessage;
	CMessageClickTeleSymbolResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_CLICKSYMBOL );
	tPara.set_index( tpMsg->index() );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}


//************************************
// Method:    OnMessageInterruptSkill
// FullName:  OnMessageInterruptSkill
// Access:    public 
// Returns:   void
// Qualifier: 处理客户端主动发起的技能被打断请求
// Parameter: CEntityPlayer * pPlayer
// Parameter: CMessage * pMessage
//************************************
void CPropertyModule::OnMessageInterruptSkill( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return );

	CMessageInterruptContiuneSkillRequest* pInterruptContiueSkill = (CMessageInterruptContiuneSkillRequest*) pMessage->msgpara();
	
	// 技能列表肯定能找到
	CSkillList& pSkillList = ((CPropertyPlayer*)pPlayer->GetProperty())->GetSkillList();
	
	CSkillObject* pSkillObj = pSkillList.GetSkillObjectByID( pInterruptContiueSkill->skillid() );
	if( pSkillObj == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find skill %d for player %d", __FUNCTION__, __LINE__,
			pInterruptContiueSkill->skillid(), pPlayer->GetCharID() );
		return;
	}

	if ( pSkillObj->GetSkillID( ) != pInterruptContiueSkill->skillid() )
	{
		pSkillObj = pSkillList.GetSkillObjectByID( pInterruptContiueSkill->skillid() );
	}
	
	LK_ASSERT( pSkillObj != NULL, return );
	
	// 技能停止作用
	pSkillObj->StopContinueSkill();

	
	// 广播打断消息
	CMessage tMessage;
	CMessageInterruptContiuneSkillNotify tInterrutpMsg;

	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_INTERRUPTSKILL );
	tMessage.set_msgpara( (uint32)&tInterrutpMsg );

	tInterrutpMsg.set_entityid( pPlayer->GetEntityID() );
	tInterrutpMsg.set_skillid( pInterruptContiueSkill->skillid() );

	CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tMessage, false, true );
}

// ***********************************************************
//  Function:		存储非绑定金钱的消息请求
//  Description:	OnMessagePutMoneyRequest
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	06/01/2009
// **********************************************************
void CPropertyModule::OnMessageStorMoneyRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL , return )
	CMessageStorMoneyRequest *tpMsg = ( CMessageStorMoneyRequest * ) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return ) 
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	
	
	// 距离和服务的判断
	CEntityNpc* tpEntity = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcid() ) );	
	if ( tpEntity == NULL )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) store money ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}
	if ( tpEntity->GetEntityType() != ENTITYTYPE_FUNCNPC )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) store money ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}

	// 服务判断
	CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
	CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
	if ( tpTmpNpc == NULL )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) store money ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}
	if ( tpTmpNpc->mStorageService == 0 )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) store money ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}
	
	if ( pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) != true )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) store money ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}
	
	// 存储的金钱
	if( tpMsg->stormoney() < 0 || tpMsg->storbindmoney() < 0 ) 
	{
		return;
	}
	
	// 存储的金钱多于玩家身上的金钱
	if ( tpProperty->GetMoney() < (int)tpMsg->stormoney() || tpProperty->GetBindMoney() < (int)tpMsg->storbindmoney() )
	{
		return;
	}
	
	int tRet = 0;

	// 存储后仓库中会不会超过最大金钱上限
	// 最新：不能超过模板配置 否则提示
	CTemplateLevelMoneyLmt* tpMoneyTable = (CTemplateLevelMoneyLmt*)CDataStatic::GetTemp(TEMP_MONEYLMT_CFG);
	LK_ASSERT( tpMoneyTable!=NULL, return );
	LK_ASSERT( pPlayer->GetLevel() >= 0 && pPlayer->GetLevel() < TMP_MAX_GRADE, return );

	bool bRet=false;
	if ( tpMsg->stormoney() > 0 )
	{
		if( ( tpMsg->stormoney() + tpProperty->GetStorageMoney() > MONEY_LIMIT ) || 
			(  tpMsg->stormoney() + tpProperty->GetStorageMoney() > (int)(tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mStorageMoneyLmt )) )
		{
			SendStorMoneyResponse( pPlayer, ERR_STORAGE_MONEY_UPLMT, 0, 0, tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mStorageMoneyLmt );
			bRet = true;
		}
	}

	if ( tpMsg->storbindmoney() > 0 )
	{
		if( ( tpMsg->storbindmoney() + tpProperty->GetStorageBindMoney() > MONEY_LIMIT ) || 
			( (unsigned int)(tpMsg->storbindmoney() + tpProperty->GetStorageBindMoney()) > (unsigned int)tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mStorageBindMoneyLmt ) )
		{
			SendStorMoneyResponse( pPlayer, ERR_STORAGE_BIND_MONEY_UPLMT, 0, 0, tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mStorageBindMoneyLmt );
			bRet = true;
		}
	}

	if (bRet)
		return;

	// 先扣身上的金钱，扣成功再加仓库存储钱
	if ( PlayerChangeMoney( pPlayer, tpMsg->stormoney(), true, false ) == SUCCESS)
	{
		tpProperty->SetStorageMoney( tpProperty->GetStorageMoney() + tpMsg->stormoney() );

		LogEventLostMoneyByStoreMoney(pPlayer,
				CYuanBao::em_unbind_money, tpMsg->stormoney(), tpProperty->GetStorageMoney() );
	}
	else
	{
		return ;
	}


	if (PlayerChangeMoney( pPlayer, tpMsg->storbindmoney(), true, true ) == SUCCESS)
	{
		tpProperty->SetStorageBindMoney( tpProperty->GetStorageBindMoney() + tpMsg->storbindmoney() );

		LogEventLostMoneyByStoreMoney(pPlayer, 
				CYuanBao::em_bind_money, tpMsg->storbindmoney(), tpProperty->GetStorageBindMoney() );
	}
	else
	{
		return ;
	}


	SendStorMoneyResponse( pPlayer, tRet, tpProperty->GetStorageMoney(), tpProperty->GetStorageBindMoney() );
}

// ***********************************************************
//  Function:		从仓库取出非绑定金钱的消息请求
//  Description:	OnMessageTakeMoneyRequest
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	06/01/2009
// **********************************************************
void CPropertyModule::OnMessageTakeStorMoneyRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageTakeStorMoneyRequest *tpMsg = (  CMessageTakeStorMoneyRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	// 安全密码验证
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

		
	if ( tpMsg->money() < 0 || tpMsg->bindmoney() < 0 )
	{
		return;
	}	 
	
	// 距离和服务的判断
	CEntityNpc* tpEntity = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcid() ) );	
	if ( tpEntity == NULL )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) take money from storage ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}
	if ( tpEntity->GetEntityType() != ENTITYTYPE_FUNCNPC )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) take money from storage ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}

	// 服务判断
	CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
	CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
	if ( tpTmpNpc == NULL )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) take money from storage ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}
	if ( tpTmpNpc->mStorageService == 0 )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) take money from storage ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}

	if ( pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) != true )
	{
		LOG_ERROR( "pro","[%s,%d] wrong npcid when player( RoleID:%d ) take money from storage ( NpcID:%d ) ! ",__FUNCTION__,__LINE__, pPlayer->GetCharID(), tpMsg->npcid() );
		return;
	}

	// 取的金钱多余仓库里存储的	
	if( tpMsg->money() > tpProperty->GetStorageMoney() || tpMsg->bindmoney() > tpProperty->GetStorageBindMoney() )
	{
		return;
	}

	// 最新：不能超过模板配置 否则提示
	CTemplateLevelMoneyLmt* tpMoneyTable = (CTemplateLevelMoneyLmt*)CDataStatic::GetTemp(TEMP_MONEYLMT_CFG);
	LK_ASSERT( tpMoneyTable!=NULL, return );
	LK_ASSERT( pPlayer->GetLevel() >= 0 && pPlayer->GetLevel() < TMP_MAX_GRADE, return );

	bool bRet = false;
	// 取钱 就只判断钱
	if ( tpMsg->money() > 0 )
	{
		if ( tpMsg->money() + tpProperty->GetMoney() < 0 
			|| tpMsg->money() + tpProperty->GetMoney() > MONEY_LIMIT
			|| tpMsg->money() + tpProperty->GetMoney() > (int)tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mBagMoneyLmt )
		{
			SendTakeStorMoneyResponse( pPlayer, ERR_BAG_MONEY_UPLMT, 0, 0, tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mBagMoneyLmt );
			bRet = true;
		}
	}

	// 取绑定钱 就只判断绑定钱
	if ( tpMsg->bindmoney() > 0 )
	{
		if ( tpMsg->bindmoney() + tpProperty->GetBindMoney() < 0 
			|| tpMsg->bindmoney() + tpProperty->GetBindMoney() > MONEY_LIMIT
			|| tpMsg->bindmoney() + tpProperty->GetBindMoney() > (int)tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mBagBindMoneyLmt)
		{
			SendTakeStorMoneyResponse( pPlayer, ERR_BAG_BIND_MONEY_UPLMT, 0, 0, tpMoneyTable->mLmtTable[pPlayer->GetLevel()].mBagBindMoneyLmt );
			bRet = true;
		}
	}

	if ( bRet )
		return;

	if ( tpMsg->money()<=0 && tpMsg->bindmoney()<=0 )
		return;

	int tRet = 0;
	
	if (PlayerChangeMoney( pPlayer, tpMsg->money(), false, false ) == SUCCESS)
	{
		tpProperty->SetStorageMoney( tpProperty->GetStorageMoney() - tpMsg->money() );

		LogEventGetMoneyByStoreMoney( pPlayer, 
				CYuanBao::em_unbind_money, tpMsg->money(), tpProperty->GetStorageMoney() );
	}
	else
	{
		return;
	}

	if (PlayerChangeMoney( pPlayer, tpMsg->bindmoney(), false, true ) == SUCCESS)
	{
		tpProperty->SetStorageBindMoney( tpProperty->GetStorageBindMoney() - tpMsg->bindmoney() );

		LogEventGetMoneyByStoreMoney( pPlayer, 
				CYuanBao::em_bind_money, tpMsg->bindmoney(), tpProperty->GetStorageBindMoney() );
	}
	else
	{
		return ;
	}

	SendTakeStorMoneyResponse( pPlayer, tRet, tpProperty->GetStorageMoney(), tpProperty->GetStorageBindMoney() );
	
}

// ***********************************************************
//  Function:		给仓库放置背包的消息请求
//  Description:	OnMessageAddKitBagRequest
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	06/01/2009
// **********************************************************
void CPropertyModule::OnMessageAddKitBagRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{	
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	CMessageAddKitBagRequest *tpMsg = ( CMessageAddKitBagRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	
	// 检查是否有密码保护
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	CItemObject *tpItemObj = NULL; 
	CItemBox *tpSrcItemBox = NULL;
	if ( tpMsg->srcslot() == SLOT_BAGGAGE )
	{
		tpItemObj = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->bagindex() );
		tpSrcItemBox =	tpProperty->GetBaggage();
	}
	else if ( tpMsg->srcslot() == SLOT_STORAGE )
	{
		tpItemObj = tpProperty->GetStorage()->GetItemObjPtr( tpMsg->bagindex() );
		tpSrcItemBox = tpProperty->GetStorage();
	}
	
	if ( tpSrcItemBox == NULL )
	{
		return;
	}
	
	LK_ASSERT( tpItemObj != NULL, return )
	CTplItem *tpKitBag = ( CTplItem * )	CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	LK_ASSERT( tpKitBag != NULL, return )
	if( tpKitBag->mItemType != CTplItem::ITEM_KITBAG )
	{
		return;
	}	
	int tOldKitBagID = 0;
	CItemBox *tpBag = NULL; 
		
	if ( tpMsg->desslot() == SLOT_STORKITBAG )
	{
		tpBag = tpProperty->GetStorage();
	}
	else if ( tpMsg->desslot() == SLOT_BAGGAGEKITBAG )
	{
		tpBag = tpProperty->GetBaggage();
	}
	else
	{
		LOG_ERROR( "default", "[%s,%d][%s] player(id:%d,name:%s) add kitbag to invalid position ",
			__LK_FILE__,__LINE__,__FUNCTION__, pPlayer->GetCharID(), pPlayer->GetCharNameShow() );
		return;
	}

	int tRet = tpBag->AddKitBag( tpMsg->desindex( ), tpItemObj->GetItemID(), tOldKitBagID, tpItemObj->get_id() );
	if( tRet == -1 )
	{
		return;
	}	

	if ( tRet == SUCCESS )
	{
		//// 如果有 有效时间，而且是使用后开启 【扩展包暂时不处理】	
		if ( tpItemObj->GetInvalidTime() == 0 && tpKitBag->mValidTime > 0 && tpKitBag->mValidType == VALIDTYPE_USE )
		{
			tpItemObj->SetInvalidTime( time(NULL) + tpKitBag->mValidTime*60 );
		}

		if ( tpKitBag->mProcessType & CTplItem::PROCESSTYPE_BINDONUSER )
		{
			if ( !( tpItemObj->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
			{					
				SetEquipBindTime( tpItemObj );
			}	
			tpItemObj->SetBindStatus( ITEM_BINDSTATUS_BINDED );
		}
		//tpSrcItemBox->SetIndexNull( tpMsg->bagindex() );
		(*tpSrcItemBox)[tpMsg->bagindex()] = tOldKitBagID;
	}	
	
	SendAddKitBagResponse( pPlayer, tRet, tpMsg->bagindex(), tpMsg->desindex(), tpMsg->desslot(), tpItemObj->GetInvalidTime(), tpItemObj->GetBindStatus() );	
}

// ***********************************************************
//  Function:		给仓库放置背包的消息请求
//  Description:	OnMessageAddKitBagRequest
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	06/01/2009
// **********************************************************
void CPropertyModule::OnMessageOpenKitBag( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	//  暂时不用了
	//LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	//CMessageOpenKitBagRequest *tpMsg = ( CMessageOpenKitBagRequest * )pMessage->msgpara();
	//LK_ASSERT( tpMsg != NULL, return );
	//CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	//
	//CItemBox *tpBag = NULL;
	//if ( tpMsg->desslot() == SLOT_STORKITBAG )
	//{
	//	tpBag = tpProperty->GetStorage( );	
	//}
	//else if ( tpMsg->desslot() == SLOT_BAGGAGEKITBAG )
	//{		
	//	tpBag = tpProperty->GetBaggage( );
	//}
	//else
	//{
	//	LOG_ERROR( "default","[%s,%d][%s]player( %d,%s )  Open kitbag wrong positon  ",
	//		__LK_FILE__,__LINE__,__FUNCTION__, pPlayer->GetCharID(), pPlayer->GetCharNameShow() );
	//	return;
	//}
	//CMessage tMsgHead;
	//CMessageOpenKitBagResponse tMsgOpenKitBag;

	//tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_OPENKITBAG );
	//tMsgHead.set_msgpara( (int)&tMsgOpenKitBag );
	//	
	//// 消息已经发往客户端
	//if ( tpBag->GetKitBagStatus() & ( 1 << tpMsg->index() ) )
	//{		
	//	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );											 
	//	return;	
	//}
	//// tpBag->SetKitBagStatus( STORAGE_STATUS_INITIALIZED );*/

	//
	//tpBag->GetItemInBag( BAGTYPE_KITBAG, tpMsg->index(), *tMsgOpenKitBag.mutable_itembox() );
	//tMsgOpenKitBag.set_desslot( tpMsg->desslot() );
	//tMsgOpenKitBag.set_kitbagindex( tpMsg->index() );
	//
	//// 记录已经发送的标志
	//tpBag->SetKitBagStatus( ( 1 << tpMsg->index() ) | tpBag->GetKitBagStatus() );
	//
	//CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
	//
	//
	//PBItemBox tPBItemBox;
	//PBItemBox *tpPBItemBox = &tPBItemBox;				
	//tpBag->GetTlvBuffer2( tpPBItemBox, BAGGAGE_BASE, tpBag->GetReleaseIndex( ) );
	//tMsgOpenStorKitBag.set_ifclean( KITBAG_STATUS_CLEAN );
	//tMsgOpenStorKitBag.set_ifinfoend( KITBAG_SENDSTATUS_HASLEFTINFO );
	//tMsgOpenStorKitBag.set_desslot( tpMsg->desslot() );
	//	
	//tpPBItemBox	 = tMsgOpenStorKitBag.mutable_itembox( );
	//for ( int i = 0; i < tPBItemBox.itemobjects_size( ) && i < BOX_LIMIT; ++i )
	//{
	//	PBItemObject *tpItemObj = tpPBItemBox->add_itemobjects();
	//	tpItemObj->CopyFrom( tPBItemBox.itemobjects(i) );
	//	if ( tpPBItemBox->itemobjects_size( ) >= MAX_STORAGEITEM  )
	//	{
	//		if ( i == tPBItemBox.itemobjects_size( ) -1 )
	//		{
	//			tMsgOpenStorKitBag.set_ifinfoend( KITBAG_SENDSTATUS_INFOEND );
	//		}
	//		
	//		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
	//		tpPBItemBox->Clear( );
	//		tMsgOpenStorKitBag.set_ifclean( KITBAG_STATUS_NOTCLEAN );
	//		tMsgOpenStorKitBag.set_desslot( tpMsg->desslot() );		
	//	}		
	//} 		
	//if ( tpPBItemBox->itemobjects_size( ) < MAX_STORAGEITEM )
	//{			
	//	tMsgOpenStorKitBag.set_ifinfoend( KITBAG_SENDSTATUS_INFOEND );		
	//	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );	
	//}	
}

// ***********************************************************
//  Function:		拿下背包的消息请求
//  Description:	OnMessageTakeKitBag
//  Input:			
//					
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/16/2009
// **********************************************************
void CPropertyModule::OnMessageTakeKitBag( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	CMessageTakeKitBagRequest *tpMsg = ( CMessageTakeKitBagRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	
	// 检查是否有密码保护
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	CItemBox *tpSrcItemBox = NULL;
	CItemBox *tpDesItemBox = NULL;
	if ( tpMsg->srcslot() == SLOT_BAGGAGEKITBAG )
	{			
		tpSrcItemBox = tpProperty->GetBaggage();
	}
	else if ( tpMsg->srcslot() == SLOT_STORKITBAG )
	{			
		tpSrcItemBox = tpProperty->GetStorage();
	}	
	
	if ( tpMsg->desslot() == SLOT_BAGGAGE )
	{
		tpDesItemBox = tpProperty->GetBaggage();
	}			
	else if( tpMsg->srcslot() == SLOT_STORAGE )
	{
		tpDesItemBox = tpProperty->GetStorage();
	}  	
	
	if ( tpSrcItemBox == NULL || tpDesItemBox == NULL )
	{
		return;
	}
	
	CMessage tMsgHead;
	CMessageTakeKitBagResponse tMsgTakeKitBag;
	tMsgHead.set_msgpara( (int)&tMsgTakeKitBag );
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKEKITBAG );	 
	tMsgTakeKitBag.set_srcindex( tpMsg->srcindex() );
	tMsgTakeKitBag.set_srcslot( tpMsg->srcslot() );
	tMsgTakeKitBag.set_desslot( tpMsg->desslot() );
	tMsgTakeKitBag.set_desindex( tpMsg->desindex() );		
	
	// 检查目标索引的合法性
	if ( !tpDesItemBox->CheckIndexValid( tpMsg->desindex(), true ) )
	{			
		tMsgTakeKitBag.set_errocode( ERROR_MOVEITEM_DESINDEXINVALID );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
		return;
	}
	
	if ( tpDesItemBox->GetItemObjPtr( tpMsg->desindex() ) != NULL )
	{
		return;
	}
	
	// 索引检查，不能把背包放到自己的格子里
	if ( tpSrcItemBox == tpDesItemBox )
	{
		int tBeginIndex = 0;
		int tEndIndex	= 0;
		int tRet = tpSrcItemBox->GetKitBagIndexRange( BAGTYPE_KITBAG, tpMsg->srcindex(), tBeginIndex, tEndIndex );
		if ( tRet != SUCCESS )
		{
			return;
		}  	
		
		if ( (int)tpMsg->desindex() >= tBeginIndex && (int)tpMsg->desindex() <= tEndIndex )
		{
			tMsgTakeKitBag.set_errocode( ERROR_MOVEITEM_DESINDEXINVALID );
			CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
			return;
		}
	}
		
	int tKitBagObjID = -1;
	int tRet = tpSrcItemBox->TakeKitBag( tpMsg->srcindex(), tKitBagObjID );
	if ( tRet == -1 )
	{
		return;
	}

	tMsgTakeKitBag.set_errocode( tRet );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );	
	if ( tRet == SUCCESS )
	{
		CItemObject *tpItemObj = ( CItemObject * )CSceneObjManager::GetSingleton().GetObject( tKitBagObjID );
		LK_ASSERT( tpItemObj != NULL, return )
		tpDesItemBox->InsertItem( tpItemObj, tpMsg->desindex() );
	}
}

// ***********************************************************
//  Function:		客户端改变PK模式的请求
//  Description:	OnMessageChangePKModeRequest
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/04/2008
// **********************************************************
void CPropertyModule::OnMessageChangePKModeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageChangePKModeRequest* tpMsg = (CMessageChangePKModeRequest*) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pPlayer->GetProperty( );
	
	// 检查是否有密码保护
	int tPwdCheckRet = tpProPlayer->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

	int tOldMode = pPlayer->GetPKMode();
	int tNewMode = tpMsg->pkmode();

	if ( tOldMode == tNewMode )
	{
		return ;
	}

	// 如果是齐天大战，不允许修改PK模式
	if ( IS_BATTLE_LINE_ID( CSceneLogic::GetSingleton().GetLineID() ) == true )
	{
		SendChangePKModeResponse( pPlayer, ERROR_CHANGEPKMODE_WORLDWAR );
		return ;
	}

	CTemplateBeginner* tpBeginner = (CTemplateBeginner*) CDataStatic::GetTemp( TEMP_BEGINNER );
	if ( tpBeginner == NULL )
		return ;

	// pk模式等级限制
	if ( (int)pPlayer->GetLevel( ) < tpBeginner->mBeginnerProtectLevel )
	{
		if ( tOldMode == PKMODE_TRAINING && tNewMode == PKMODE_ALL )
		{
			SendChangePKModeResponse( pPlayer, ERROR_CHANGEPKMODE_NEEDMORELEVEL );
			return ;
		}
	}

	// 等级检查之后 [12/7/2009 Macro]
	if ( tOldMode == PKMODE_ALL || tOldMode == PKMODE_CORPS )
	{
		// 原来是屠杀模式
		if ( tpProPlayer->GetYellowTimer() != INVALID_OBJ_ID || tpProPlayer->IsRedPKStatus() )
		{
			// 黄名状态，不然改变屠杀模式
			SendChangePKModeResponse( pPlayer, ERROR_CHANGEPKMODE_BADPK );
			return ;
		}
	}	

	int tRet = pPlayer->ChangePKMode( tpMsg->pkmode( ) );

	// 你老母啊,修改成功了才能换黄名状态
	if ( tRet == ERROR_CHANGEPKMODE_SUCCESS )
	{
		if ( tOldMode == PKMODE_ALL || tOldMode == PKMODE_CORPS )
		{
			SendYellowStateNotice( pPlayer, false );
		}
		if ( tNewMode == PKMODE_ALL || tNewMode == PKMODE_CORPS )
		{
			SendYellowStateNotice( pPlayer, true );
		}
	}

	SendChangePKModeResponse( pPlayer, tRet );

	// 判断玩家是否有宠物,及宠物的攻击对象是否合法
	if ( tpProPlayer->GetPetID( ) != 0 )
	{
		CEntityPet* tpPet = (CEntityPet*) CSceneLogic::GetSingleton( ).GetEntity( tpProPlayer->GetPetID( ) );
		if ( tpPet == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ] [ %s ] cann't find EntityPet PetID = %d", __LK_FILE__, __LINE__, __FUNCTION__, tpProPlayer->GetPetID( ) );
			return;
		}

		CEntity* tpTarget = CSceneLogic::GetSingleton( ).GetEntity( tpPet->GetCurTargetID( ) );
		if ( tpTarget == NULL )
		{
			if( tpPet->GetCurTargetID( ) != 0 )
			{
				LOG_ERROR( "pro", "[ %s : %d ] [ %s ] pet target error, cann't find target, TargetID = %d", __LK_FILE__, __LINE__, __FUNCTION__, tpPet->GetCurTargetID( ) );
			}

			return;
		}

		// 如果当前目标不是召唤兽主人的敌对目标,则通知召唤兽,切换目标
		if ( !pPlayer->IsHostileTo( tpTarget ) )
		{
			// 把召唤兽当前目标设置为0,则NPC模块会从新处理召唤兽相关流程
			tpPet->SetCurTargetID( 0 );
		}
	}
}

// ***********************************************************
//  Function:		处理客户端查看别人装备的请求
//  Description:	OnMessageLookPropertyRequest
//  Input:			CEntityPlayer*			pPlayer
//					CMessage*				pMessage
//					CPropertyPlayer*		pSrcProperty
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/05/2008
// **********************************************************
void CPropertyModule::OnMessageLookPropertyRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageLookPropertyRequest* tpMsg = (CMessageLookPropertyRequest*) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	CEntityPlayer* tpEntity = CSceneLogic::GetSingleton().GetPlayerByCharID( tpMsg->charid() );
	if ( tpEntity != NULL )
	{
		// 如果在本场景找到,那么把消息发给客户端
		SendLookPropertyResponse( pPlayer, tpEntity, tpMsg->looktype() );
	}
	else
	{
		// 如果在当前场景找不到,那么去路由找
		SendLookPropertyRouterRequest( pPlayer, tpMsg->charid(), tpMsg->looktype() );
	}
}


void CPropertyModule::OnMessageLookPropertyRouterRequest( CMessage* pMessage )
{
	LK_ASSERT( pMessage != NULL , return );

	CMessageLookPropertyRouterRequest* tpMsg = (CMessageLookPropertyRouterRequest*) pMessage->msgpara( );
	LK_ASSERT( tpMsg != NULL, return );

	CEntityPlayer* tpPlayer = (CEntityPlayer*) CSceneLogic::GetSingleton( ).GetPlayerByCharID( ( ( tpMsg->router( ) ).descharid( ) ) );
	if ( tpPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d : %s ] cann't find entity by charid( %d ), router request!", __LK_FILE__, __LINE__, __FUNCTION__, ( ( tpMsg->router( ) ).descharid( ) ) );
		return;
	}

	SendLookPropertyRouterResponse( tpPlayer, ( ( tpMsg->router( ) ).srccharid( ) ), tpMsg->looktype() );
}

void CPropertyModule::OnMessageLookPropertyRouterResponse( CMessage* pMessage )
{
	LK_ASSERT( pMessage != NULL , return );

	CMessageLookPropertyRouterResponse* tpMsg = (CMessageLookPropertyRouterResponse*) pMessage->msgpara( );
	LK_ASSERT( tpMsg != NULL, return );

	CEntityPlayer* tpPlayer = (CEntityPlayer*) CSceneLogic::GetSingleton( ).GetPlayerByCharID( ( ( tpMsg->router( ) ).descharid( ) ) );
	if ( tpPlayer == NULL )
	{
		//TODO: 外网错误太多，只好改成DEBUG等级
		LOG_DEBUG( "pro", "[ %s : %d : %s ] cann't find entity by charid( %d ), router request!", __LK_FILE__, __LINE__, __FUNCTION__, ( ( tpMsg->router( ) ).descharid( ) ) );
		return;
	}

	SendLookPropertyResponse( tpPlayer, tpMsg->mutable_equipmentinfo( ), tpMsg->mutable_equipmentinfo( )->looktype() );
}

void CPropertyModule::OnMessageTaskCollectRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageTaskCollectRequest* tpMsg = (CMessageTaskCollectRequest*) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );
	
	// 检查读秒时间
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	if ( tpProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_COLLECT, pPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
#ifdef _DEBUG_
		//TODO: 外网错误太多，只好改成DEBUG等级
		LOG_ERROR( "pro","wrong progresstime when collect, roleid:%d", pPlayer->GetCharID() );
#endif
		return;
	}

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr()->GetObject( 
		tpMsg->entityid( ) ) );
	if ( tpEntity == NULL )
		return;

	CEntityCollect *pCollect = NULL;
	// 如果谈话目标不是NPC  或者距离超过了
	pCollect = (CEntityCollect*)tpEntity;
	if ( tpEntity->GetEntityType() != ENTITYTYPE_COLLECT || pCollect->GetAliveStatus() != ALIVE_NORMAL )
	{
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_TARGETINVALID );
		return;
	}

	if( pPlayer->IsWithinDistance( pCollect, MAX_COLLECT_GRID ) == false )
	{
		SendProErrorNotice( pPlayer, ERROR_CLICKNPC_TARGETINVALID );
		return;
	}

	CTemplateCollect* tpNpcTpl = (CTemplateCollect*) CDataStatic::SearchTpl( pCollect->GetNpcID( ) );
	if ( tpNpcTpl == NULL )
	{
		LOG_ERROR( "pro", "NPC=%d data not found", pCollect->GetNpcID( ) );
		return;
	}

	// 如果是生活技能的采集的话
	CLifeSkill *tpLifeSkill = NULL;
	int tDegreeValue = 0;
	if ( tpNpcTpl->mSkillType == CTemplateCollect::LIFESKILL_LIFESKILL )
	{
		CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
		tpLifeSkill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( LIFESKILL_COLLECT );
		if ( tpLifeSkill == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_LIFESKILL_COLLECTWITHOUTRIGHTSKILL );
			return;
		}
		
		int tAP = 1000;		 
		int tRet = tpLifeSkill->Collect( tAP, tpNpcTpl, tDegreeValue, pPlayer->GetLevel() );
		if ( tRet == -1 )
		{
			return;
		}
		if ( tRet != SUCCESS )
		{
			SendProErrorNotice( pPlayer, tRet );
			return;
		}			
	}
	//for ( int i = 0; i < ARRAY_CNT(tpNpcTpl->mItemID); i++ )
	//{
	//	if ( tpNpcTpl->mItemID[ i ] == 0 )
	//		break;
	//	PlayerInsertItem( pPlayer, (CPropertyPlayer*)pPlayer->GetProperty(), tpNpcTpl->mItemID[ i ], 1, false );
	//}

	bool bRet = false;
	PERF_FUNC( "Task.OnCollectItem", bRet=CTaskModule::GetSingleton().OnCollectItem( pPlayer, tpNpcTpl ) );
	if (bRet)
	{
		pCollect->SetNumber( pCollect->GetNumber( ) + 1 );
		if ( tpLifeSkill != NULL && tDegreeValue > 0 )
		{
			tpLifeSkill->AddSpecializedDegree( tDegreeValue, CLifeSkill::DEGREEADDTYPE_USECOMPOSE );
			SendNotifyLifeSkillAttribute( pPlayer, tpLifeSkill->GetLifeSkillType(), tpLifeSkill->GetSpecializedDegree() );
		}	 			
	}		

	if ( tpNpcTpl->mNumber == -1 )
		return;

	if ( pCollect->GetNumber( ) >= tpNpcTpl->mNumber )
	{
		pCollect->SetAliveStatus( ALIVE_DIE );
		pCollect->AddFunResult( 0, FUNC_DIE, RESULT_NORMAL, true, pCollect->GetPosX(), pCollect->GetPosY() );
		/*pCollect->GetProperty()->mDisappearTimer = pCollect->GetProperty()->mDisappearTime;*/

		// 改为走定时器
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, 0, 0, 0};
		pCollect->GetTimerReciver()->SetTimer( pCollect->get_id(), TIMER_ENTITY_DISAPPER, pCollect->GetProperty()->GetDisapperaTime( ), 1, nTimerOtherInfo );
		//CSceneLogic::GetSingleton( ).DestroyEntity( pCollect, 0 );
	}
}

// 改变新手帮助的状态位
void CPropertyModule::OnMessageChangeHelpStatus( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return;
	}
	CMessageChangeHelpStaus *tpMsg = ( CMessageChangeHelpStaus * )pMessage->msgpara( );
	if ( tpMsg == NULL )
	{
		return;
	}
	CPropertyPlayer *tpPropety =( CPropertyPlayer * ) pPlayer->GetProperty();
	tpPropety->GetShortcut( )->SetHelpStatus(  tpMsg->status(), tpMsg->index()  );
}

// 持续攻击请求
void CPropertyModule::OnMessageUseContinuedSkillRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
		return;

	CMessageUseContinuedSkillRequest* tpMsg = (CMessageUseContinuedSkillRequest*) pMessage->msgpara();
	if ( tpMsg == NULL )
		return;

	CPropertyPlayer* tpProPlayer = (CPropertyPlayer*)pPlayer->GetProperty();
	
	// 客户端上报的技能索引可能错误，改用SkillID直接判断
	CSkillObject* tpSkillObj = tpProPlayer->GetSkillList().GetSkillObjectByID( tpMsg->skillid() );
	if( tpSkillObj == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d]can't find skill %d on player charid %d",__FUNCTION__, __LINE__,
			tpMsg->skillid(), pPlayer->GetCharID() );
		return;
	}

	unsigned short tSkillLevel = tpSkillObj->GetSkillLevel();// + tpProPlayer->GetIncSkillLevel( tpMsg->skillid() );

	CTemplateNormalSkill* tpSkill = (CTemplateNormalSkill*) CDataStatic::SearchSkill( tpMsg->skillid() , tSkillLevel );
	if ( tpSkill == NULL )
		return;


	// 判断技能是否能作用
	if( tpSkillObj->SkillContinue( ) != true )
	{
		return ;
	}

	// ------ 广播消息 ------
	CMessage tMessag;
	CMessageUseContinuedSkillNotify tUseSkillNotify;
	
	tMessag.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_USECONTINUESKILL );
	tMessag.set_msgpara( (uint32)&tUseSkillNotify );

	tUseSkillNotify.set_entityid( pPlayer->GetEntityID() );
	tUseSkillNotify.set_skillid( tpMsg->skillid() );
	tUseSkillNotify.set_posx( tpMsg->posx() );
	tUseSkillNotify.set_posy( tpMsg->posy() );

	CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tMessag );

	// ---------------------
	
	CEntityCharacter* tEntityList[ FUNC_LIMIT ] = { NULL };

	int tCount = tpMsg->entityidlist_size();
	int tEntityListNum = 0;
	for ( int i = 0; i < tCount && i < FUNC_LIMIT; i++ )
	{
//		CEntityCharacter* tpEntity = (CEntityCharacter*) CSceneLogic::GetSingleton().GetEntity( tpMsg->entityidlist( i ) );
		CEntityCharacter* tpEntity = dynamic_cast< CEntityCharacter* >( 
			CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->entityidlist( i ) ) );
		if ( tpEntity == NULL )
			continue;

		tEntityList[ tEntityListNum ] = tpEntity;
		tEntityListNum++;
	}

	if ( tEntityListNum > 0 )
	{
		pPlayer->InitFunResult( tpMsg->listid() );

		CWTPoint tPos( tpMsg->posx(), tpMsg->posy() );

		switch ( tpSkill->mSkillType )
		{
		case CTemplateSkill::SKILLTYPE_CONTINUEDATTACK:
			{
				ContinuedAttackSkill( pPlayer, tpSkill, tPos,tEntityList, tEntityListNum );
			}
			break;
		case CTemplateSkill::SKILLTYPE_CONTINUEDBLESS:
		case CTemplateSkill::SKILLTYPE_CONTINUEDCUSS:
			{
				ContinuedCussOrBlessSkill( pPlayer, tpSkill, tPos, tEntityList, tEntityListNum );
			}
			break;
		case CTemplateSkill::SKILLTYPE_AUREOLE:
			{
				ContinuedAureoleSkill( pPlayer, (CTemplateAureoleSkill*) tpSkill, tPos, tEntityList, tEntityListNum );
			}
			break;
		default:
			break;
		}

		ResultListSend( );	
	}
}

// ***********************************************************
//  Function:		BindItem
//  Description:	如果物品类型符合绑定类型则绑定物品
//  Input:			 CItemObject      *tpItemIbj   带绑定的物品
//                   CEntityPlayer *tpPlayer       玩家
//                   int           BindWay         绑定方式  
//                   int           ItemIndex       绑定石的索引
//  OutPut:			结果码                           
//  Return:			 int             物品的绑定操作码
//  Others:
//  Date:	11/20/2008
// **********************************************************
void CPropertyModule::PlayerInsertBindItem( CEntityPlayer *pPlayer, int ItemIndex )
{
	CMessage                      MessageHead;
	CMessageAddBindItemResponse   MsgInsertBindItem;
	if ( pPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	if ( tpProperty == NULL )
	{
		return;
	}
	
	// TODO:背包索引的检查
	if ( !tpProperty->GetBaggage()->CheckIndexValid( ItemIndex ) )	
	//if ( ItemIndex < 0 || ItemIndex >= (int)tpProperty->GetBaggage( )->mReleaseIndex )
	{
		return;
	}
	CItemObject *tpItemObj = ( CItemObject *)tpProperty->GetBaggage( )->GetItemObjPtr( ItemIndex );
	if ( tpItemObj == NULL )
	{

		// 发送错误信息提示物品不存在
		return;
	}
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );

	if ( tpTplItem == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Item does not exist in template! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	// 判读是不是绑定石
	if ( tpTplItem->mItemType == CTplItem::ITEM_BINDSTONE )
	{
		// 是绑定石		

		// 改变锁定状态
		if ( tpProperty->GetBaggage( )->mBindItemIndex != -1 )
		{
			tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mBindItemIndex , LOCKTYPE_NONE );
			SendLockItemNotice( (CEntity *)pPlayer, tpProperty->GetBaggage( )->mBindItemIndex ,  LOCKTYPE_NONE  );
		}
		tpProperty->GetBaggage( )->Lock( ItemIndex , LOCKTYPE_BIND );
 
		SendLockItemNotice( (CEntity *)pPlayer, ItemIndex ,  LOCKTYPE_BIND  );

		// 记录绑定石
		tpProperty->GetBaggage( )->mBindItemIndex = ItemIndex;

		// 发送通知
		MsgInsertBindItem.set_itemindex( ItemIndex );
		MsgInsertBindItem.set_inputpos( 1 );
		MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDITEMREPONSE );
		MessageHead.set_msgpara( (int)&MsgInsertBindItem );
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
		return;
	}

	if ( ( tpTplItem->mProcessType&CTplItem::PROCESSTYPE_CANBIND) == 0 )
	{	
		// 发送消息该物品不能被绑定
		return;
	}	

	int BindStatus = tpItemObj->GetBindStatus();
	if ( ( BindStatus & ITEM_BINDSTATUS_BYITEM ) != 0 )
	{
		// 发送消息物品已经绑定
		return;
	}
	if ( ( BindStatus & ITEM_BINDSTATUS_FREEBIND ) != 0 )
	{
		// 发送消息物品处于绑定解除期间不能再被绑定
		return;
	}

	// 改变锁定状态
	if ( tpProperty->GetBaggage( )->mEquipIndex != -1 )
	{
		tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mEquipIndex , LOCKTYPE_NONE );
		SendLockItemNotice( (CEntity *)pPlayer, tpProperty->GetBaggage( )->mEquipIndex ,  LOCKTYPE_NONE  );
	}
	tpProperty->GetBaggage( )->Lock( ItemIndex , LOCKTYPE_BIND );

	SendLockItemNotice( (CEntity *)pPlayer, ItemIndex ,  LOCKTYPE_BIND  );

	// 记录装备
	tpProperty->GetBaggage( )->mEquipIndex = ItemIndex;

	// 发送通知	
	MsgInsertBindItem.set_itemindex( ItemIndex );
	MsgInsertBindItem.set_inputpos( 0 );
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDITEMREPONSE );
	MessageHead.set_msgpara( (int)&MsgInsertBindItem );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
	return;

}


// 玩家卸下绑定物品
void CPropertyModule::PlayerTakeBindItem( CEntityPlayer *pPlayer, int ItemIndex )
{
	CMessage                       MessageHead;
	CMessageTakeBindItemResponse   MsgTakeItemRes; 
	if ( pPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = (CPropertyPlayer *) pPlayer->GetProperty();
	if ( tpProperty == NULL )
	{
		return;
	}
	if ( ItemIndex == 0 )
	{
		if ( tpProperty->GetBaggage( )->mEquipIndex == -1 )
		{
			return;
		}		

		tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mEquipIndex, LOCKTYPE_NONE );		
		SendLockItemNotice( pPlayer, tpProperty->GetBaggage( )->mEquipIndex, LOCKTYPE_NONE );		

		MsgTakeItemRes.set_itemindex( tpProperty->GetBaggage( )->mEquipIndex );
		MsgTakeItemRes.set_inputpos( ItemIndex );

		MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKEITEMRESPONSE );
		MessageHead.set_msgpara( (int)&MsgTakeItemRes );
		tpProperty->GetBaggage( )->mEquipIndex = -1;
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
		return;	
	}
	if ( ItemIndex == 1 )
	{

		if ( tpProperty->GetBaggage( )->mBindItemIndex == -1 )
		{
			return;
		}		

		tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mBindItemIndex, LOCKTYPE_NONE );		
		SendLockItemNotice( pPlayer, tpProperty->GetBaggage( )->mBindItemIndex, LOCKTYPE_NONE );		

		MsgTakeItemRes.set_itemindex( tpProperty->GetBaggage( )->mBindItemIndex );
		MsgTakeItemRes.set_inputpos( ItemIndex );

		MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKEITEMRESPONSE );
		MessageHead.set_msgpara( (int)&MsgTakeItemRes );
		tpProperty->GetBaggage( )->mBindItemIndex = -1;
		CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
		return;			
	}

} 


// 放置需要解除绑定的装备
void CPropertyModule::PlayerInsertItemForFree( CEntityPlayer *pPlayer, int ItemIndex )
{
	CMessage                        MessageHead;
	CMessageAddItemForFreeResponse  MsgFreeItemRes;
	if ( pPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	if ( tpProperty == NULL )
	{
		return;
	}

	// 索引判断	
	// TODO:包括背包索引的检查
	if( !tpProperty->GetBaggage()->CheckIndexValid( ItemIndex ) )
	//if ( ItemIndex < 0 || ItemIndex >= (int)tpProperty->GetBaggage( )->mReleaseIndex )
	{
		return;
	}
	// 获取物品
	CItemObject *tpItemObj = (CItemObject *)tpProperty->GetBaggage( )->GetItemObjPtr( ItemIndex );
	if ( tpItemObj == NULL )
	{
		return;
	}
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );

	if ( tpTplItem == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Item does not exist int template! ",__LK_FILE__,__LINE__, __FUNCTION__);
		return;
	}
	if ( tpTplItem->IsEquipable() == false || ( tpTplItem->mProcessType&CTplItem::PROCESSTYPE_CANBIND) == 0  )
	{
		// 该物品不能被手动绑定
		return;
	}

	int BindStatus = tpItemObj->GetBindStatus();
	if ( (BindStatus&ITEM_BINDSTATUS_BYITEM) == 0 )
	{
		// 发送通知物品没有手动绑定
		return;		
	}

	// 如果已经有装备在上面，先解锁
	if ( tpProperty->GetBaggage( )->mEquipIndex != -1 )
	{	
		tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mEquipIndex, LOCKTYPE_NONE );
		SendLockItemNotice( pPlayer, tpProperty->GetBaggage( )->mEquipIndex, LOCKTYPE_NONE );
	}


	// 记录物品索引，并且给物品加锁
	tpProperty->GetBaggage( )->mEquipIndex = ItemIndex;
	tpProperty->GetBaggage( )->Lock( ItemIndex , LOCKTYPE_BIND );
	SendLockItemNotice( pPlayer, ItemIndex, LOCKTYPE_BIND );

	MsgFreeItemRes.set_itemindex( ItemIndex );	
	MessageHead.set_msgpara( (int)&MsgFreeItemRes );
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDITEMFORFREE );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );	
	return;	
}

// 卸下需要解除绑定的物品
void CPropertyModule::PlayerTakeItemForFree( CEntityPlayer *pPlayer, int ItemIndex )
{
	CMessage                         MessageHead;
	CMessageTakeItemForFreeResponse  MsgTakeItemRes;
	if ( pPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	if( tpProperty == NULL )
	{
		LOG_ERROR( "pro","[%s:%d][%d] The CPropertyPlayer of The Player does not exist! ",__LK_FILE__,__LINE__,__FUNCTION__);
		return;
	}
	int EquipIndex = tpProperty->GetBaggage( )->mEquipIndex;

	// 没有放置装备
	if ( EquipIndex == -1 )
	{
		return;
	}	
	// 给物品解锁
	tpProperty->GetBaggage( )->mEquipIndex = -1;
	tpProperty->GetBaggage( )->Lock( EquipIndex , LOCKTYPE_NONE );
	SendLockItemNotice( pPlayer, EquipIndex , LOCKTYPE_NONE );	 

	MsgTakeItemRes.set_itemindex( EquipIndex );
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKEITEMFORFREE );
	MessageHead.set_msgpara( (int)&MsgTakeItemRes );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
} 

// 放置需要恢复手动绑定的物品
void CPropertyModule::PlayerAddEqtForResumeBind( CEntityPlayer *pPlayer, int EqtIndex )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Empty CEntityPlayer or CPropertyPlayer Pointer ", __LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	// 判断索引位置
	// TODO:包括背包索引的检查
	if( !tpProperty->GetBaggage()->CheckIndexValid( EqtIndex ) )
	//if( EqtIndex < 0 || EqtIndex > (int)tpProperty->GetBaggage( )->mReleaseIndex )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Wrong Baggage Index!  ", __LK_FILE__,__LINE__,__FUNCTION__ );
		return;				
	}

	// 检查物品是否具有手动绑定的属性
	CItemObject * tpEqtItem = tpProperty->GetBaggage( )->GetItemObjPtr( EqtIndex );
	if ( tpEqtItem == NULL )
	{
		LOG_ERROR( "pro", "[%s,%d][%s] Baggage Item Wrong! ",__LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}		
	CTplItem *tTplEqt = ( CTplItem * )CDataStatic::SearchTpl( tpEqtItem->GetItemID() );
	if ( tTplEqt == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Item does not exist in template! ", __LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	if ( tTplEqt->IsEquipable() == false || (tTplEqt->mProcessType&CTplItem::PROCESSTYPE_CANBIND )== 0 )
	{
		// 物品不能被手动绑定
		return;
	}

	// 物品是否处于手动绑定解除状态
	if ( (tpEqtItem->GetBindStatus()&ITEM_BINDSTATUS_FREEBIND) == 0	 )
	{
		// 物品没有处于手动解除绑定状态,不能被恢复到手动绑定
		//SendProErrorNotice();
		return;		
	}

	// 已经有装备，先给原物品解锁
	if ( tpProperty->GetBaggage( )->mEqtForReusmBindIndex != -1  )
	{
		tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mEqtForReusmBindIndex, LOCKTYPE_NONE );
		SendLockItemNotice( pPlayer,tpProperty->GetBaggage( )->mEqtForReusmBindIndex, LOCKTYPE_NONE );		
	}	

	// 记录新物品位置，并且锁定物品
	tpProperty->GetBaggage( )->mEqtForReusmBindIndex = EqtIndex;
	tpProperty->GetBaggage( )->Lock( EqtIndex, LOCKTYPE_BIND );
	SendLockItemNotice( pPlayer, EqtIndex, LOCKTYPE_BIND  );

	// 发送放置成功的通知
	CMessageAddEqtForResumeBindResponse MsgAddEqt;
	CMessage					MsgHead;
	MsgAddEqt.set_eqtindex( EqtIndex );
	MsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDEQTFORRESUMEBIND );
	MsgHead.set_msgpara( (int)&MsgAddEqt );
	CSceneLogic::GetSingletonPtr()->Send2Player( ( CEntity * )pPlayer, &MsgHead );	
}

// 取下需要恢复手动绑定的物品
void CPropertyModule::PlayerTakeEqtForResumeBind( CEntityPlayer *pPlayer )
{
	if ( pPlayer == NULL )
	{
		return;
	}

	CPropertyPlayer* tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if ( tpProperty->GetBaggage( )->mEqtForReusmBindIndex == -1 )
	{
		// 该位置没有放置物品
		return;
	}

	CItemObject *tEqtObj = tpProperty->GetBaggage( )->GetItemObjPtr( tpProperty->GetBaggage( )->mEqtForReusmBindIndex );
	if ( tEqtObj == NULL )
	{
		// 获得物品错误
		LOG_ERROR( "pro"," [%s,%d][%s] Get Baggage Item Wrong ! ", __LK_FILE__,__LINE__,__FUNCTION__);
		return;
	}
	// 解锁
	tpProperty->GetBaggage( )->Lock( tpProperty->GetBaggage( )->mEqtForReusmBindIndex, LOCKTYPE_NONE );
	SendLockItemNotice( pPlayer, tpProperty->GetBaggage( )->mEqtForReusmBindIndex, LOCKTYPE_NONE );
	CMessage								MsgHead;
	CMessageTakeEqtForResumeBindResponse	MsgTakeEqt;
	MsgHead.mutable_msghead( )->set_messageid( ID_S2C_RESPONSE_TAKEEQTFORRUMEBIND );
	MsgHead.set_msgpara( (int)&MsgTakeEqt );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MsgHead  );
	tpProperty->GetBaggage( )->mEqtForReusmBindIndex = -1;
}

// 恢复物品的手动绑定
void CPropertyModule::PlayerResumeBind( CEntityPlayer *pPlayer, int vItemIndex )
{
	if ( pPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer* tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();	
	
	CItemObject *tEqtObj = tpProperty->GetBaggage( )->GetItemObjPtr( vItemIndex );
	if ( tEqtObj == NULL )
	{			
		return;
	}
		
	// 取消手动绑定解除状态，恢复手动绑定
	int BindStatus = tEqtObj->GetBindStatus();
	int nFrom = BindStatus;
	if ( ( BindStatus&ITEM_BINDSTATUS_FREEBIND ) == 0 )
	{
		SendProErrorNotice( pPlayer, ITEM_BINDRESULT_ERROR );
		return;
	}
	
	// 计算取消绑定需要的金钱 
	int  Money		 = 0;
	int  BindMoney	 = 0;	
	CTplBindChargeTable *tpBindChargge = ( CTplBindChargeTable * )CDataStatic::GetTemp( TEMP_BINDCHARGETABLE );
	if ( tpBindChargge != NULL )
	{
		if ( tpBindChargge->mCanResumeBindUseBM == 1 )
		{
			if ( tpBindChargge->mMoneyResumeBindNeed > tpProperty->GetBindMoney() )
			{
				BindMoney = tpProperty->GetBindMoney();
				Money	  = tpBindChargge->mMoneyResumeBindNeed - BindMoney;
			}
			else
			{
				BindMoney = tpBindChargge->mMoneyResumeBindNeed;						
			} 							
		}
		else
		{
			Money =	tpBindChargge->mMoneyResumeBindNeed;
		}
	}

	// 判断是否有足够的金钱
	if ( Money > tpProperty->GetMoney() )
	{
		SendProErrorNotice( pPlayer, ITEM_RESUMEBINDRESULT_MONEYNOTENOUGH );
		return;
	} 
	
	// 恢复绑定状态
	BindStatus &= ~ITEM_BINDSTATUS_FREEBIND;
	BindStatus |= ITEM_BINDSTATUS_BYITEM;
	tEqtObj->SetBindStatus( BindStatus );	
	
	// 发送恢复手动绑定成功的消息	
	CMessageResumeBindResponse  MsgResumeBind;
	CMessage					MsgHead;
	MsgResumeBind.set_eqtindex( vItemIndex ); 
	MsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_RESUMEBIND ) ;
	MsgHead.set_msgpara( (int)&MsgResumeBind );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MsgHead );
		
	// 扣除金钱
	if ( BindMoney > 0 )
	{
		if (PlayerChangeMoney( pPlayer, BindMoney, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByResumeBind(pPlayer, CYuanBao::em_bind_money, BindMoney, tEqtObj->GetItemID(), tEqtObj->GetGUID());
		}
	}				
	if ( Money > 0 )
	{
		if (PlayerChangeMoney( pPlayer, Money, true, false ) == SUCCESS)
		{
			LogEventLostMoneyByResumeBind(pPlayer, CYuanBao::em_unbind_money, Money, tEqtObj->GetItemID(), tEqtObj->GetGUID());
		}
	}				

	LogEventItemLockAction(pPlayer, tEqtObj->GetItemID(), tEqtObj->GetGUID(), 
			nFrom, tEqtObj->GetBindStatus(), 0, tEqtObj->GetBindStatus());

	return;	
	
}

// 判断物品是否手动绑定
int CPropertyModule::IfItemBindedByItem( CItemObject *tpItemObj )
{
	if ( tpItemObj == NULL )
	{
		return -1;
	}
	if ( ( tpItemObj->GetBindStatus()&ITEM_BINDSTATUS_BYITEM ) == 0 )
	{
		return 0;
	}
	return 1;
}

// 判断物品是否处于手动解除状态
int CPropertyModule::IfItemBindFree( CItemObject *tpItemObj )
{
	if ( tpItemObj == NULL )
	{
		return -1;
	}
	if ( ( tpItemObj->GetBindStatus()&ITEM_BINDSTATUS_FREEBIND ) == 0 )
	{
		return 0;
	}
	return 1;
}

// 将玩家身上处于绑定解除状态的物品插入列表中
void CPropertyModule::GetItemForFreeFromPlayer( CEntityPlayer *pPlayer )
{
	LK_ASSERT ( pPlayer != NULL, return );

	CPropertyPlayer *tpProperty = ( CPropertyPlayer  *) pPlayer->GetProperty();

	tpProperty->GetItemForFree();
}

// 把玩家处于装备绑定解除状态的物品放入列表中
void  CPropertyModule::InsertFreeItemIntoList( int ChaiId ,  CItemObject *tpItemObj )
{
	CEntityPlayer *tpPlayer = CSceneLogic::GetSingletonPtr()->GetPlayerByCharID( ChaiId );

	if ( tpPlayer == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find charid %d", __FUNCTION__, __LINE__, ChaiId );
		return;
	}

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) tpPlayer->GetProperty();

	tpProperty->InsertItemForFreeIntoList( tpItemObj );

}

// ***********************************************************
//  Function:		BindItem
//  Description:	如果物品类型符合绑定类型则绑定物品
//  Input:			 CItemObject      *tpItemIbj   带绑定的物品
//                   CEntityPlayer *tpPlayer       玩家
//                   int           BindWay         绑定方式  
//                   int           ItemIndex       绑定石的索引
//  OutPut:			结果码                           
//  Return:			 int             物品的绑定操作码
//  Others:
//  Date:	11/20/2008
// **********************************************************
int CPropertyModule::BindItem(  CEntityPlayer *tpPlayer, CItemObject *tpItemObj , int BindWay , int ItemIndex )
{
	if ( tpItemObj == NULL || tpPlayer == NULL )
	{
		return ITEM_BINDRESULT_ERROR;
	}	

	CTplItem *tpItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );

	if ( tpItem == NULL )
	{
		// 物品道具不存在
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Item Dose Not Exist!", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_NOEXIST;
	}	

	if ( BindWay != ITEM_BINDWAY_BYITEM )
	{
		// 不是手动绑定		
		if ( tpItemObj->GetBindStatus() != ITEM_BINDSTATUS_FREE )
		{
			// 物品已经绑定
			LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Item Has Been Binded!", __LK_FILE__, __LINE__, __FUNCTION__ );

			return ITEM_BINDRESULT_BINDED;
		}

		switch( BindWay )
		{
			case ITEM_BINDWAY_BYUSE:
				{

					if ( (tpItem->mProcessType & CTplItem::PROCESSTYPE_BINDONUSER) == 0 )
					{
						return ITEM_BINDRESULT_WRONGBINDWAY;
					}
					tpItemObj->ChangeBindStatus( ITEM_BINDSTATUS_BINDED );
					break;
				}
			case ITEM_BINDWAY_BYPICKUP:
				{
					if ( (tpItem->mProcessType & CTplItem::PROCESSTYPE_BINDONPICK) == 0 )
					{

						return ITEM_BINDRESULT_WRONGBINDWAY;
					}
					tpItemObj->ChangeBindStatus( ITEM_BINDSTATUS_BINDED );

					break;
				}
			case ITEM_BINDWAY_BYEQUIP:
				{
					if ( (tpItem->mProcessType & CTplItem::PROCESSTYPE_BINDONEQUIP) == 0 )
					{
						// 不能装备绑定					
						return ITEM_BINDRESULT_WRONGBINDWAY;
					}
					tpItemObj->ChangeBindStatus( ITEM_BINDSTATUS_BINDED );

					break;
				}

		}
		if ( tpItemObj->GetBindStatus() & ITEM_BINDSTATUS_BINDED )
		{				
			SetEquipBindTime( tpItemObj );
		}
		// 发送物品绑定通知
		return ITEM_BINDRESULT_SUCESS;         
	}
	
	// 是手动绑定	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) tpPlayer->GetProperty();	   
	
	if( ( tpItem->mProcessType & CTplItem::PROCESSTYPE_CANBIND ) == 0 )
	{
		// 不能装备绑定
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Item Can't Be Binded On This Way !", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_WRONGBINDWAY; 
	}
	if ( !tpItem->IsEquipable () && !tpItem->IsMagicWeapon () )
	{
		// 不能装备绑定
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Item Can't Be Binded On This Way !", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_WRONGBINDWAY;     
	}
	int BindStatus = tpItemObj->GetBindStatus();
	if ( ( BindStatus&ITEM_BINDSTATUS_BYITEM ) != 0 )
	{   
		// 已经手动绑定
		return ITEM_BINDSTATUS_BINDED;
	}	

	CItemBox *tpItemBox  = tpProperty->GetBaggage( );

	CItemObject *tpBindItem = tpItemBox->GetItemObjPtr( ItemIndex );
	if ( tpBindItem == NULL )
	{
		LOG_ERROR( "pro","[ %s : %d ] [ %s ] Error BindItem  !", __LK_FILE__, __LINE__, __FUNCTION__);
		return ITEM_BINDRESULT_CONSUMEITEMERROR;
	}
	CTplItem *tpTplBindItem = ( CTplItem * )CDataStatic::SearchTpl( tpBindItem->GetItemID() );
	/*
	   判断是否是绑定石
	 */
	if( tpTplBindItem->mItemType != CTplItem::ITEM_BINDSTONE ) 
	{
		// 绑定道具不对
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Item Can't Be Binded On This Way !", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_CONSUMEITEMERROR;			
	}
	
	CTplItemBindStone *tpTplBindStone = (CTplItemBindStone *)tpTplBindItem;
	if( tpItem->IsEquipable() && (tpTplBindStone->mBindStoneType != CTplItemBindStone::BINDSTONE_EQUIP) )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Item Can't Be Binded On This Way !", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_CONSUMEITEMERROR;
	}

	if ( tpItem->IsMagicWeapon() && (tpTplBindStone->mBindStoneType != CTplItemBindStone::BINDSTONE_MAGICWEAPON) )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Item Can't Be Binded On This Way !", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_CONSUMEITEMERROR;
	}

	if ( tpBindItem->GetItemNum() < BINDITEM_CONSUMENUM )
	{
		LOG_ERROR( "pro","[ %s : %d ] [ %s ]  BindItem Not Enough  !", __LK_FILE__, __LINE__, __FUNCTION__);
		return ITEM_BINDRESULT_CONSUMEITEMERROR;
	}
	BindStatus |= ITEM_BINDSTATUS_BYITEM;
	// 将绑定解除状态置 0
	BindStatus &= ~ITEM_BINDSTATUS_FREEBIND;
	tpItemObj->SetBindStatus( BindStatus );		
	return ITEM_BINDRESULT_SUCESS;
}

// ***********************************************************
//  Function:		FreeItemBind
//  Description:	物品解除绑定
//  Input:			CItemObject      *tpItemIbj      物品指针					
//  OutPut:			                           
//  Return:			int             物品的绑定操作码
//  Others:
//  Date:	11/20/2008
// **********************************************************
int CPropertyModule::FreeItemBind( CItemObject *tpItemObj, int IfBindOnItem /* = 0  */ )
{
	if( tpItemObj == NULL )
	{
		return 0;
	}

	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );

	if ( tpTplItem == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d][%s] Error ItemID!",__LK_FILE__,__LINE__,__FUNCTION__ );
		return 0;
	}

	if ( IfBindOnItem == 0 )
	{
		tpItemObj->SetBindStatus( ITEM_BINDSTATUS_FREE );
		return 1;
	}	

	if ( !tpTplItem->IsEquipable() && !tpTplItem->IsMagicWeapon())
	{
		return 0;
	}
	CItemEquipment *tpEquipItem = (CItemEquipment *)tpItemObj;
	int TimeNow = 0; 

	int BindStatus  = tpItemObj->GetBindStatus( );

	if ( ( BindStatus&ITEM_BINDSTATUS_BYITEM ) != 0 )
	{
		// 将手动绑定置0
		BindStatus &=~ ITEM_BINDSTATUS_BYITEM;
		// 将绑定解除位置1		
		BindStatus |= ITEM_BINDSTATUS_FREEBIND;		
		tpItemObj->SetBindStatus( BindStatus  );	

		BindStatus &= ~(ITEM_BINDSTATUS_BYITEM);	

		TimeNow = time( NULL );
		tpEquipItem->SetBindFreeTime( TimeNow + ITEMBINDFREETIME );	
		return 1;
	}	
	return 0;
}

// ***********************************************************
//  Function:		GetItemObjBindStatus
//  Description:	获取物品的绑定状态
//  Input:			CItemObject      *tpItemIbj      物品指针					
//  OutPut:			                           
//  Return:			int          物品的绑定状态
//  Others:
//  Date:	11/20/2008
// **********************************************************
int  CPropertyModule::GetItemObjBindStatus( CItemObject *tpItemObj )
{
	if ( tpItemObj == NULL )
	{
		return -1;
	}
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	if ( tpTplItem == NULL )
	{
		return -1;
	}
	return tpItemObj->GetBindStatus( );
}

// 判断装备手动绑定解除时间是否已到
int CPropertyModule::CheckItemBindFreeTime( CItemObject *tpItemObject )
{
	if ( tpItemObject == NULL )
	{
		return -1;
	}	

	CTplItem *tpItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObject->GetItemID() );

	if ( tpItem == NULL )
	{
		// 物品道具不存在
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] Item Dose Not Exist!", __LK_FILE__, __LINE__, __FUNCTION__ );
		return ITEM_BINDRESULT_NOEXIST;
	}
	int TimeNow;
	int BindStatus;
	if ( tpItem->IsEquipable () || tpItem->IsMagicWeapon())
	{
		TimeNow = time( NULL );
		CItemEquipment *tpEquipment = ( CItemEquipment * )tpItemObject;
		BindStatus = tpItemObject->GetBindStatus();

		if ( ( BindStatus & ITEM_BINDSTATUS_FREEBIND )== 0 )
		{
			return 0;
		}

		if ( tpEquipment->GetBindFreeTime () <= TimeNow )
		{
			BindStatus &= ~(ITEM_BINDSTATUS_FREEBIND);
			tpEquipment->SetBindStatus( BindStatus );
			tpEquipment->SetBindFreeTime( 0 );
			return 1;		
		}

		return 0;		   
	}
	return -1;
}

// ***********************************************************
//  Function:		SendBindNotice
//  Description:	发送装备绑定的消息
//  Input:			CItemObject      *tpItemIbj      物品指针					
//  OutPut:			                           
//  Return:			int      1表示绑定，0表示没有绑定，-1表示错误
//  Others:
//  Date:	11/20/2008
// **********************************************************
void CPropertyModule::SendBindNotice ( CEntityPlayer * tpPlayer, int BindResult,  int Index , int PackKind , int BindStatus , int BindFreeTime  )
{ 
	CMessageBindItemResponse    MsgBindItemResponse;
	CMessage                    MsgHead;
	MsgBindItemResponse.set_bindresult ( BindResult );
	MsgBindItemResponse.set_itemindex ( Index );   
	// MsgBindItemResponse.set_bindfreetime( BindFreeTime );

	MsgHead.mutable_msghead ()->set_messageid( ID_S2C_RESPONSE_BINDITEM );
	MsgHead.set_msgpara ( ( int )&MsgBindItemResponse );
	CSceneLogic::GetSingletonPtr ()->Send2Player( tpPlayer , &MsgHead );   

}



// ***********************************************************
//  Function:		CheckPKIsYellow
//  Description:	攻击时候会黄名
//  Input:			CEntity*					pSrcEntity		攻击实体
//					CEntity*					pDesEntity		被攻击实体
//					CEntityResultList&			rResultList		结果列表
//					int							vListID			转发客户端的技能序列号
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/20/2008
// **********************************************************
void CPropertyModule::CheckPKIsYellow( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity )
{
	LK_ASSERT( pSrcEntity != NULL && pDesEntity != NULL, return );

	if ( pDesEntity->GetEntityType() != ENTITYTYPE_PLAYER && pDesEntity->GetEntityType() != ENTITYTYPE_PET )
	{
		return;
	}

	if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PLAYER )
	{
		if ( ( ( CEntityPlayer* )pSrcEntity )->PKIsYellow( pDesEntity ) == true )
		{
			pSrcEntity->AddFunResult( 0, FUNC_PKYELLOW, RESULT_NORMAL );
		}
	}
	if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PET )
	{
		CEntityPlayer* tpOwner = (CEntityPlayer*) pSrcEntity->GetOwner();
		if ( tpOwner != NULL )
		{
			if ( tpOwner->PKIsYellow( pDesEntity ) == true )
			{
				tpOwner->AddFunResult( 0, FUNC_PKYELLOW, RESULT_NORMAL );
			}
		}
	}
}

// ***********************************************************
//  Function:		CheckPKIsRed
//  Description:	杀人后是否红名
//  Input:			CEntity*					pSrcEntity		攻击实体
//					CEntity*					pDesEntity		被攻击实体
//					CEntityResultList&			rResultList		结果列表
//					int							vListID			转发客户端的技能序列号
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/20/2008
// **********************************************************
void CPropertyModule::CheckPKIsRed( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity )
{
	LK_ASSERT( pSrcEntity != NULL && pDesEntity != NULL, return );

	if ( pSrcEntity->GetEntityType() != ENTITYTYPE_PLAYER || pDesEntity->GetEntityType() != ENTITYTYPE_PLAYER )
		return;

	if ( ( ( CEntityPlayer* )pSrcEntity )->PKIsRed( pDesEntity ) == true )
	{
		pSrcEntity->AddFunResult( 0, FUNC_PKRED, RESULT_NORMAL );
	}
}

// ***********************************************************
//  Function:		DropItemByNpcDie
//  Description:	NPC死亡,掉落物品
//  Input:			CEntity*			pOwnerEntity		物品所有者实体
//					CEntity*			pDesEntity			掉落物品者实体
//					CTemplateOgre*		pTempOgre			掉落物品的OGRE模板
//  OutPut:			
//  Return:			void
//  Others:
//  Date:	11/22/2008
// **********************************************************
void CPropertyModule::DropItemByNpcDie( CEntity* pOwnerEntity, CEntity* pDesEntity, CTemplateOgre* pTempOgre )
{
	LK_ASSERT( pOwnerEntity != NULL && pDesEntity != NULL && pTempOgre != NULL, return );
	if ( pOwnerEntity->IsPlayer() == false )
	{
		return ;
	}	
	
	if ( pOwnerEntity->IsPlayer() == true && pDesEntity->IsOgre() == true && pTempOgre->mDisplayLevel == CTemplateOgre::OGRESHOW_BOSS )
	{
		CEntityPlayer *tpPlayer = ( CEntityPlayer * )pOwnerEntity;
		CEntityOgre *tpOrge = ( CEntityOgre * )pDesEntity;		
		LogBossOgreDie( tpOrge, tpPlayer, pTempOgre );	
	}
	
	// 子表改完,等待数据加入
	int tDropID = pTempOgre->mDropID;
	int tDropIDAdd = 0;

	int tActivityID = CActivityModule::GetSingleton().GetActivityOgreDropID( tDropID );
	if ( tActivityID != 0 )
	{
		tDropIDAdd = tActivityID;
	}
	tActivityID = CActivityModule::GetSingleton().GetActivityOgreDropID( pTempOgre->mTranID );
	CTemplateOgreTran *pTempOgreTran = (CTemplateOgreTran*)CDataStatic::SearchTpl( tActivityID == 0 ? pTempOgre->mTranID : tActivityID );
	if ( pTempOgreTran != NULL )
	{	
		unsigned int tLevel = 0;
		if( pDesEntity->IsNpc( ) == true )
		{
			//tLevel = ( ( CPropertyCharacter* )( pDesEntity->GetProperty( ) ) )->GetTranChangeLevel( );
			if ( pDesEntity->IsBox() == true )
			{
				tLevel = pOwnerEntity->GetProperty()->GetLevel();
			}
			else
			{
				tLevel = ( ( CPropertyCharacter* )( pDesEntity->GetProperty( ) ) )->GetTranChangeLevel( );
			}	
		}
		else
		{
			tLevel = pDesEntity->GetProperty( )->GetLevel( );
		}
	//	unsigned int tLevel = pDesEntity->GetProperty( )->GetLevel( );
		tDropID = pTempOgreTran->mDrop[ tLevel ];
		tActivityID = CActivityModule::GetSingleton().GetActivityOgreDropID( tDropID );
		if ( tActivityID != 0 )
		{
			tDropIDAdd = tActivityID;
		}
		else
		{
			tDropIDAdd = 0;
		}
	}
	
	// 先获得要替换的掉落表ID
	int nTmpDropID = CActivityModule::GetSingleton().GetReplaceDropID(pDesEntity);
	if ( nTmpDropID != 0 )
		tDropID = nTmpDropID;

	if ( tDropIDAdd != 0 )
		DropItemByID( pOwnerEntity, pDesEntity, tDropIDAdd, CDropFrom(pDesEntity));	

	// 11.23新加：如果也找到了怪物ID追加表，则掉落
	int tDropByOgre = CActivityModule::GetSingleton().GetActivityOgreDropID( pTempOgre->mTempID );
	if ( tDropByOgre != 0 )
		DropItemByID( pOwnerEntity, pDesEntity, tDropByOgre, CDropFrom(pDesEntity));	

	DropItemByID( pOwnerEntity, pDesEntity, tDropID, CDropFrom(pDesEntity));	

	// 再获得追加的掉落表ID列表
	std::vector<int> tAddIDs;
	CActivityModule::GetSingleton().GetAddDropID(pDesEntity, tAddIDs);
	for ( std::vector<int>::iterator it = tAddIDs.begin(); it != tAddIDs.end(); ++it )
	{
		DropItemByID( pOwnerEntity, pDesEntity, *it, CDropFrom(pDesEntity));	
	}

	// 处理任务的死亡逻辑 【注意】如果这个函数【DropItemByNpcDie】也会被功能NPC死亡掉落 则一定要改！因为目前有2个地方调用任务的 entity die 因为功能NPC死亡不会走到这里
	CTaskModule::GetSingleton( ).OnEntityDie( pOwnerEntity, pDesEntity );
}

// ***********************************************************
//  Function:		DropItemByID
//  Description:	根据掉落表掉落物品
//  Input:			CEntity*			pOwnerEntity		物品所有者实体
//					CEntity*			pDesEntity			掉落物品者实体
//					int					vDropID				掉落物品表ID
//  OutPut:			
//  Return:			void
//  Others:
// **********************************************************
void CPropertyModule::DropItemByID( CEntity* pOwnerEntity, CEntity* pDesEntity, int vDropID, const CDropFrom& vDropFrom, int *vNumber, int vDropType, bool vNeedSend )
{
	LK_ASSERT( pOwnerEntity != NULL && pDesEntity != NULL, return );
	if ( pOwnerEntity->IsPlayer() == false )
	{
		return ;
	}

	int tCharIDList[ TEAMNUM ] = { 0 };
	// 如果引发掉落的实体（宝箱或者怪物）被绑了所有者 那么掉落下来的东西只属于这个所有者 无论是否组队
	if (pDesEntity->IsBox() || pDesEntity->IsOgre())
	{
		CEntityNpc* pEntityNpc = (CEntityNpc*)pDesEntity;
		if (pEntityNpc->GetOwnercharID() != 0)
		{
			CEntityPlayer* pPlayer = CSceneLogic::GetSingleton().GetPlayerByCharID(pEntityNpc->GetOwnercharID());
			if ( pPlayer != NULL )
			{
				tCharIDList[0] = pPlayer->GetCharID();
			}
		}
	}

	// 如果目标实体和所有者实体一样 那么掉落只归属这个人 (可能是打开礼包走的掉落表)
	if ( pOwnerEntity->GetEntityID() == pDesEntity->GetEntityID() )
	{
		CEntityPlayer* pPlayer = (CEntityPlayer*)pOwnerEntity;
		tCharIDList[0] = pPlayer->GetCharID();
	}

	// 得到掉落的所有者实体ID
	CEntityPlayer* tpMemberList[ TEAMNUM ] = { NULL };
	// 获得组队成员列表
	int tTeamNum = 0;
	CTeamModule::GetSingleton().OnGetMemberList( (CEntityPlayer*)pOwnerEntity, tpMemberList, TEAMNUM, tTeamNum );

	// 计算掉落
	// 新增修正系数	
	// 区分副本内外
	unsigned int tLevel = 0;
	unsigned int tMaxLevel = 0;
	unsigned int tMinLevel = SERVER_PERCENT_INT;
	int tCount = 0;
	// 得到队伍里人的最高等级
	for ( int i = 0; i < tTeamNum; i++ )
	{
		if ( tpMemberList[ i ] == NULL )
			break;

		// 如果不在范围内，不参与计算
		if ( pDesEntity->IsWithinDistance( tpMemberList[ i ], TEAM_VALID_DISTANCE ) == false )
		{
			continue;
		}
		CPropertyPlayer* pMemberProperty = (CPropertyPlayer*) tpMemberList[ i ]->GetProperty();

		if ( tMaxLevel < pMemberProperty->GetLevel( ) )
		{
			tMaxLevel = pMemberProperty->GetLevel( );
		}
		if ( tMinLevel > pMemberProperty->GetLevel( ) )
		{
			tMinLevel = pMemberProperty->GetLevel( );
		}
		tCount++;
	}

	if ( IS_REPETION_LINE_ID(pDesEntity->GetLineID()) == true )
	{
		tLevel = tMinLevel;
	}
	else
	{
		tLevel = tMaxLevel;
	}

	float tFixValue1 = 1.0f;
	float tFixValue2 = 1.0f;
	CTemplateData* tData = (CTemplateData*)CDataStatic::GetTemp( TEMP_DATA );
	if ( tData == NULL )
	{
		LOG_ERROR( "pro", "GetTemp()failed.Type: TEMP_DATA.[%s : %d]", __LK_FILE__, __LINE__ );
		return ;
	}

	if ( tLevel > pDesEntity->GetProperty( )->GetLevel( ) )
		tFixValue1 = ( tLevel - pDesEntity->GetProperty( )->GetLevel( ) - 1 ) > MAXLEVELDIFF ? 
		tData->mLevelFix[ MAXLEVELDIFF ] / SERVER_PERCENT_FLOAT : 
		tData->mLevelFix[ tLevel - pDesEntity->GetProperty( )->GetLevel( ) - 1 ] / SERVER_PERCENT_FLOAT;
	if ( tCount > 0 )
		tFixValue2 = tData->mTeamFix[ tCount - 1 ] / SERVER_PERCENT_FLOAT;

	// 这里处理防沉迷
	if ( ((CEntityPlayer*)pOwnerEntity)->GetFcmStatus() == em_none_rate )
	{
		return;
	}
	else if ( ((CEntityPlayer*)pOwnerEntity)->GetFcmStatus() == em_half_rate )
	{
		tFixValue1 = tFixValue1 * 0.5;
	}

	CTemplateTotalDrop *totalDrop = (CTemplateTotalDrop*) CDataStatic::SearchTpl( vDropID );
	if( totalDrop == NULL )
	{
		//LOG_ERROR( "default", "[%s:%d] totaldrop template %d not found", __FILE__, __LINE__, vDropID );
		return;
	}

	std::vector<CEntity*> tEntityVec;
	bool tProtect = true;

	bool tReset = false;
	if ( tCharIDList[ 0 ] == 0 )
	{
		tReset = true;
	}

	for ( unsigned int n = 0; n < ARRAY_CNT( totalDrop->mDropCount ); n++ )
	{
		CTemplateDrop* tpDrop = (CTemplateDrop*) CDataStatic::SearchTpl( totalDrop->mDropTableID[ n ] );
		if ( tpDrop == NULL )
		{
			//LOG_ERROR( "default", "[%s:%d] drop table template %d not found", __FILE__, __LINE__, totalDrop->mDropTableID[ n ] );
			break;
		}

		for ( int i = 0; i < totalDrop->mDropCount[ n ]; i ++ )
		{
			int	tRand		= RAND(SERVER_PERCENT_INT);
			int	tLowRan		= SERVER_PERCENT_INT;
			int	tHighRan	= SERVER_PERCENT_INT;
			int		tDropNumber	= 0;					

			if ( vNumber != NULL )
			{
				tDropNumber = vNumber[ n ];
			}
			else
			{
				for ( int j = ARRAY_CNT(tpDrop->mDropNumberProbability) - 1; j >= 1 ; j -- )
				{
					tLowRan		-= ( j == 1 ) ? tLowRan : tpDrop->mDropNumberProbability[ j - 1 ] * tFixValue1 * tFixValue2;
					tHighRan	-= tpDrop->mDropNumberProbability[ j ] * tFixValue1 * tFixValue2;
					if ( tRand >= tLowRan && tRand < tHighRan )
					{
						tDropNumber = j - 1;
						break;
					}
				}
			}

			for ( int j = 0; j < tDropNumber; j ++ )
			{
				int tRand		= RAND(SERVER_PERCENT_INT);								
				int tLowRan		= 0;
				int tHighRan	= 0;
				int	tDropItemID	= 0;
				int tDropLevel	= 0;

				for ( int t = 0; t < (int)ARRAY_CNT(tpDrop->mDrops); t ++ )
				{
					if ( tpDrop->mDrops[ t ].mDropItemID == 0 )
						break;

					tLowRan		+= ( t == 0 ) ? 0 : tpDrop->mDrops[ t - 1 ].mDropItemProbability;
					tHighRan	+= tpDrop->mDrops[ t ].mDropItemProbability;
					if ( tRand >= tLowRan && tRand < tHighRan )
					{
						tDropItemID = tpDrop->mDrops[ t ].mDropItemID;
						tDropLevel  = tpDrop->mDrops[ t ].mLevelProbability;

						if ( tReset == true )
						{
							memset( tCharIDList, 0, sizeof(tCharIDList) );
							CTeamModule::GetSingleton().GetTurnOwner( ( CEntityPlayer* ) pOwnerEntity, tCharIDList, ARRAY_CNT( tCharIDList ), pDesEntity );			
						}

						bool bIfStart = false;
						if ( IfRedStone( tpDrop->mDrops[ t ].mDropItemID, bIfStart ) )
						{
							CTplRedStone * tpTplRedStone = ( CTplRedStone * )CDataStatic::SearchTpl( tpDrop->mDrops[ t ].mDropItemID );
							LK_ASSERT( tpTplRedStone != NULL, return )		   							
							
							unsigned int tEntityID = 0;
							CRedstondeCreator tDropCreator( tpDrop->mDrops[ t ].mDropItemID,5, pDesEntity->mPos.mX, 
								pDesEntity->mPos.mY,tCharIDList );
							CMapModule::GetSingleton().CreateNpc( 
								pDesEntity->GetLineID(),
								pDesEntity->GetMapID(),
								pDesEntity->GetMapIndex(),
								&tDropCreator,
								tEntityID);

							CEntityRedStone *tpRedstone4Log = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tEntityID );
							if( tpRedstone4Log != NULL )
							{
								tEntityVec.push_back( tpRedstone4Log );
							}
							
							if ( bIfStart == true )
							{
								CEntityRedStone *tpRedstone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tEntityID );
								if ( tpRedstone != NULL )
								{
									// 如果是阵营内丹
									if( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_CAMP )
									{
										tpRedstone->SetTeamID( CSceneLogic::GetSingleton().GetLineID( ) );
										BeginRedStoneMagic( tpRedstone, NULL );
									}																		
								}							
							}
							continue;
						}						
						CTemplateLevelMoneyLmt* tpMoneyTable = (CTemplateLevelMoneyLmt*)CDataStatic::GetTemp(TEMP_MONEYLMT_CFG);
						LK_ASSERT( tpMoneyTable!=NULL, continue);
						LK_ASSERT( ((CEntityPlayer*)pOwnerEntity)->GetLevel() >= 0 && ((CEntityPlayer*)pOwnerEntity)->GetLevel() < TMP_MAX_GRADE, continue);

						// 如果适配器 特殊处理
						if ( IsItemAdapter( tpDrop->mDrops[ t ].mDropItemID ) )
						{
							CTplItemAdapter	*tpAdapter = ( CTplItemAdapter* ) CDataStatic::SearchTpl( tpDrop->mDrops[ t ].mDropItemID  );	
							LK_ASSERT_STR ( tpAdapter != NULL, continue, "TempID %d", tpDrop->mDrops[ t ].mDropItemID );
							// 判断适配器是否有效
							// 策划要求这里不动
							if ( tpAdapter->mMaxLevelMinus > 0 && ( int )( tMaxLevel - pDesEntity->GetProperty( )->GetLevel() ) > tpAdapter->mMaxLevelMinus )
								continue;
							switch( tpAdapter->mRealType )
							{
							case ADAPTER_NPC:
								{
									// 掉落一个NPC 要带所有者的
									CWTPoint desPos = pDesEntity->GetPos(); // 防止坐标被改 用临时变量
									CTemplateNpc* pTempNpc = (CTemplateNpc*)CDataStatic::SearchTpl( tpAdapter->mRealTempID  );
									LK_ASSERT_STR( pTempNpc != NULL, continue, "TempID %d", tpAdapter->mRealTempID );
									CreateNpc( (CEntityPlayer*)pOwnerEntity, tpAdapter->mRealTempID, ENTITYTYPE_FUNCNPC
										, desPos, 1000*pTempNpc->mLifeTime, true, true );
									break;
								}
							case ADAPTER_OGRE:
								{
									// 掉落一个怪物 怪物会喊叫开场白 带归属者
									CWTPoint desPos = pDesEntity->GetPos(); // 防止坐标被改 用临时变量
									CTemplateNpc* pTempNpc = (CTemplateNpc*)CDataStatic::SearchTpl( tpAdapter->mRealTempID  );
									LK_ASSERT_STR( pTempNpc != NULL, continue, "TempID %d", tpAdapter->mRealTempID );
									CreateNpc( (CEntityPlayer*)pOwnerEntity, tpAdapter->mRealTempID, ENTITYTYPE_OGRE
										, desPos, 1000*pTempNpc->mLifeTime, true, true );
									break;
								}
							case ADAPTER_HIEROGRAM:
								{
									// 掉落Pedal
									CTplHierogram* pHierogram = ( CTplHierogram* )CDataStatic::SearchTpl( 
										tpAdapter->mRealTempID );
									LK_ASSERT_STR( pHierogram != NULL, continue, "TempID %d", tpAdapter->mRealTempID );
									CMapObject* tpMapObj = CMapObjManager::GetSingletonPtr( )->GetMapObject( 
										pOwnerEntity->GetLineID( ), pOwnerEntity->GetMapID( ), 
										pOwnerEntity->GetMapIndex( ) );
									LK_ASSERT_STR( tpMapObj != NULL, continue, "MapID %d, LineID %d, MapIndex %d",
										pOwnerEntity->GetLineID( ), pOwnerEntity->GetMapID( ), 
										pOwnerEntity->GetMapIndex( ) );
									CreateHierogram( pHierogram, &pDesEntity->GetPos(), tpMapObj );
									break;
								}
								// 可以掉落钱，元宝
							case ADAPTER_MONEY:
								{
									int tRandMoney = RAND(tpAdapter->mMaxValue - tpAdapter->mMinValue);
									int tGetMoney = tpAdapter->mMinValue + tRandMoney;
									// 如果超过携带上限 收回 并提示
									if (  (unsigned int)(((CEntityPlayer*)pOwnerEntity)->GetMoney()+tGetMoney) > tpMoneyTable->mLmtTable[((CEntityPlayer*)pOwnerEntity)->GetLevel()].mBagMoneyLmt)
									{
										tGetMoney = tpMoneyTable->mLmtTable[((CEntityPlayer*)pOwnerEntity)->GetLevel()].mBagMoneyLmt - ((CEntityPlayer*)pOwnerEntity)->GetMoney();
										// 借用仓库取钱的错误码
										SendTakeStorMoneyResponse((CEntityPlayer*)pOwnerEntity, ERR_BAG_MONEY_UPLMT, 0, 0, tpMoneyTable->mLmtTable[((CEntityPlayer*)pOwnerEntity)->GetLevel()].mBagMoneyLmt );
									}
									if ( tGetMoney > 0 && PlayerChangeMoney( (CEntityPlayer*)pOwnerEntity, tGetMoney, false, false ) == SUCCESS )
									{
										LogEventGetMoneyByGift( (CEntityPlayer*)pOwnerEntity, CYuanBao::em_unbind_money, tGetMoney, tpAdapter->mTempID );
										if ( vNeedSend == true )
										{
											pOwnerEntity->AddFunResult( pOwnerEntity->GetEntityID(), FUNC_MONEY, RESULT_GIFT, false, tGetMoney );
										}
										if ( vDropType == 1 && tpDrop->mDrops[ t ].mNotify != NONE_NOTICE )
										{
											SendGetItemNotify( (CEntityPlayer*)pOwnerEntity, EM_MONEY, tGetMoney, tpDrop->mDrops[ t ].mNotify, tpDrop->mDrops[ t ].mSpecial );
										}
									}
									else
									{
										LOG_ERROR( "pro", "[%s:%d] player %d use funcitem %d but not drop money, adapter idx %d, id %d",
											__FUNCTION__, __LINE__, ((CEntityPlayer*)pOwnerEntity)->GetCharID(), vDropID, t, tpDrop->mDrops[ t ].mDropItemID );
									}
									
									break;
								}
							case ADAPTER_BINDMONEY:
								{
									int tRandBindMoney = RAND(tpAdapter->mMaxValue - tpAdapter->mMinValue);
									int tGetBindMoney = tpAdapter->mMinValue + tRandBindMoney;
									// 如果超过携带上限 收回 并提示
									if ( (unsigned int)(((CEntityPlayer*)pOwnerEntity)->GetBindMoney()+tGetBindMoney) > tpMoneyTable->mLmtTable[((CEntityPlayer*)pOwnerEntity)->GetLevel()].mBagBindMoneyLmt)
									{
										tGetBindMoney = tpMoneyTable->mLmtTable[((CEntityPlayer*)pOwnerEntity)->GetLevel()].mBagBindMoneyLmt - ((CEntityPlayer*)pOwnerEntity)->GetBindMoney();
										// 借用仓库取钱的错误码
										SendTakeStorMoneyResponse( (CEntityPlayer*)pOwnerEntity, ERR_BAG_BIND_MONEY_UPLMT, 0, 0, tpMoneyTable->mLmtTable[((CEntityPlayer*)pOwnerEntity)->GetLevel()].mBagBindMoneyLmt );
									}									
									if ( tGetBindMoney > 0 && PlayerChangeMoney( (CEntityPlayer*)pOwnerEntity, tGetBindMoney, false, true ) == SUCCESS )
									{
										LogEventGetMoneyByGift( (CEntityPlayer*)pOwnerEntity, CYuanBao::em_bind_money, tGetBindMoney, tpAdapter->mTempID );
										if ( vNeedSend == true )
										{
											pOwnerEntity->AddFunResult( pOwnerEntity->GetEntityID(), FUNC_BINDMONEY, RESULT_GIFT, false, tGetBindMoney );
										}
										if ( vDropType == 1 && tpDrop->mDrops[ t ].mNotify != NONE_NOTICE )
										{
											SendGetItemNotify( (CEntityPlayer*)pOwnerEntity, EM_BINDMONEY, tGetBindMoney, tpDrop->mDrops[ t ].mNotify, tpDrop->mDrops[ t ].mSpecial );
										}
									}
									else
									{
										LOG_ERROR( "pro", "[%s:%d] player %d use funcitem %d but not drop bindmoney, adapter idx %d id %d",
											__FUNCTION__, __LINE__, ((CEntityPlayer*)pOwnerEntity)->GetCharID(), vDropID, t, tpDrop->mDrops[ t ].mDropItemID );
									}
									break;
								}
							case ADAPTER_YUANBAO:
								{
									int tRandSilverYB = RAND(tpAdapter->mMaxValue - tpAdapter->mMinValue);
									int tGetSilverYB = tpAdapter->mMinValue + tRandSilverYB;
									if ( tGetSilverYB > 0 && PlayerChangeYuanbao( (CEntityPlayer*)pOwnerEntity, tGetSilverYB, true ) == true )
									{
										LogEventGetMoneyByGift( (CEntityPlayer*)pOwnerEntity, CYuanBao::em_silver_yuanbao, tGetSilverYB, tpAdapter->mTempID );
										if ( vNeedSend == true )
										{
											pOwnerEntity->AddFunResult( pOwnerEntity->GetEntityID(), FUNC_YUANBAO, RESULT_GIFT, false, tGetSilverYB );
										}
										if ( vDropType == 1 && tpDrop->mDrops[ t ].mNotify != NONE_NOTICE )
										{
											SendGetItemNotify( (CEntityPlayer*)pOwnerEntity, EM_BINDYUANBAO, tGetSilverYB, tpDrop->mDrops[ t ].mDropItemID );
										}
									}
									else
									{
										LOG_ERROR( "pro", "[%s:%d] player %d use funcitem %d but not drop yuanbao, adapter idx %d id %d",
											__FUNCTION__, __LINE__, ((CEntityPlayer*)pOwnerEntity)->GetCharID(), vDropID, t, tpDrop->mDrops[ t ].mDropItemID);
									}
									break;
								}
							case ADAPTER_EXP:
								{
									int tRandExp = RAND(tpAdapter->mMaxValue - tpAdapter->mMinValue);
									int tGetExp = tpAdapter->mMinValue + tRandExp;
									int tCharID = ((CEntityPlayer*)pOwnerEntity)->GetCharID();
									PlayerObtainExp( (CEntityPlayer*)pOwnerEntity, tGetExp, EXPREASON_ACTIVITY, &tCharID, 1 );
									if ( tGetExp > 0 && vNeedSend == true )
									{
										//pOwnerEntity->AddFunResult( pOwnerEntity->GetEntityID(), FUNC_EXP, RESULT_GIFT, true, tGetExp );
									}
									break;
								}
							default:
								{
									LOG_ERROR( "pro", "error adapter id = %d err type:%d", tpDrop->mDrops[ t ].mDropItemID, tpAdapter->mRealType );
									break;
								}
							}
							continue;
						}
		
						// 如果是礼包，直接进包，如果包满了，掉在地上						
						if ( vDropType == 1 )
						{
							CItemObject *pInsItemPile = PlayerInsertItem( ( CEntityPlayer* )pOwnerEntity, tDropItemID, 1);
							if ( pInsItemPile != NULL)
							{
								if ( vDropFrom.emDropFrom == CDropFrom::em_drop_from_item )
								{
									LogEventGetItemByDirectIns(( CEntityPlayer* )pOwnerEntity, 
										pInsItemPile->GetGUID(), tDropItemID, 1, 
										vDropFrom.emDropFrom, 
										vDropFrom.mFrom.pItemObject->GetItemID(), 
										vDropFrom.mFrom.pItemObject->GetGUID()); 
								} else
								{
									 LogEventGetItemByDirectIns(( CEntityPlayer* )pOwnerEntity, 
										pInsItemPile->GetGUID(), tDropItemID, 1, 
										vDropFrom.emDropFrom, 
										vDropFrom.mFrom.pEntity->IsNpc() ? 
											vDropFrom.mFrom.pEntity->GetNpcID() : 0 , 
										vDropFrom.mFrom.pEntity->GetEntityID());
								}
								if ( vNeedSend == true )
								{
									pOwnerEntity->AddFunResult( pOwnerEntity->GetEntityID(), FUNC_ITEM, RESULT_GIFT, false, tDropItemID );
								}

							}else
							{
								// 新修改，福袋直接不给了
								break;
							}							
						}

						if ( vDropType == 0 )
						{
							CItemCreator tCreator( tDropItemID, 5, pDesEntity->GetPosX( ), pDesEntity->GetPosY( ), tCharIDList, NULL, GetResultList( )->GetListID( ), tDropLevel, DROP_OBJECTIVE, tProtect );
							tCreator.SetShow( false );
							unsigned int tEntityID = 0;
							CMapModule::GetSingleton().CreateNpc( pDesEntity->GetLineID(),
								pDesEntity->GetMapID(),
								pDesEntity->GetMapIndex(),
								&tCreator,
								tEntityID
								);
							CEntity *pEntity = (CEntity *)CSceneObjManager::GetSingleton().GetObject( tEntityID );
							if ( pEntity != NULL )
							{
								tEntityVec.push_back( pEntity );
							}
						}
						
						if ( tpDrop->mDrops[ t ].mNotify != NONE_NOTICE )
						{
							SendGetItemNotify( (CEntityPlayer*)pOwnerEntity, tDropItemID, 1, tpDrop->mDrops[ t ].mNotify, tpDrop->mDrops[ t ].mSpecial );
						}
						break;
					}
				}												
			}
		}
	}

	// 杀怪或者开宝箱掉落
	if ( pDesEntity->IsBox() || pDesEntity->IsOgre() )
	{
		CMapModule::GetSingleton().MessageBroadCast( pDesEntity, BuildCreateNpcProMessage( &tEntityVec ) );

		if ( tEntityVec.size() > 0)
		{
			LogEventNpcDropAction((CEntityNpc*) pDesEntity, tEntityVec);
		}
	}
	else if ( pDesEntity->IsPlayer() ) // 玩家自己操作导致掉落
	{
		CMapModule::GetSingleton().MessageBroadCast( pDesEntity, BuildCreateNpcProMessage( &tEntityVec ), false, true );

		if( (tEntityVec.size()) > 0 && (vDropFrom.emDropFrom == CDropFrom::em_drop_from_item) )
		{
			LogEventUseItemDropAction( static_cast<CEntityPlayer*>(pDesEntity), vDropFrom.mFrom.pItemObject->GetItemID(), tEntityVec );
		}	
	}
	ResultListSend( );
}

// ***********************************************************
//  Function:		PlayerClickStudySkill
//  Description:	与NPC谈话,进入技能学习服务
//  Input:			CEntityPlayer*			pPlayer			
//					CPropertyPlayer*		pProperty		
//					int						vEntityID		
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/02/2008
// **********************************************************
int CPropertyModule::PlayerClickStudySkill( CEntityPlayer* pPlayer, unsigned  int vEntityID )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	pProperty->SetServiceStatus( SERVICE_STUDYSKILL );

	return SUCCESS;
}


// ***********************************************************
//  Function:		ClickTown
//  Description:	玩家点击回城
//  Input:			CEntityPlayer*			pPlayer			
//					CMessage*				pMessage		
//					CPropertyPlayer*		tpSrcProperty		
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/03/2008
// **********************************************************
//void CPropertyModule::OnMessageClickTownServiceRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
//{
//	if ( pPlayer == NULL || pMessage == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	CMessageClickTownServiceRequest* tpTownService = (CMessageClickTownServiceRequest*) pMessage->msgpara( );
//	if ( tpTownService == NULL )
//	{
//		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
//		return;
//	}
//
//	PlayerClickTown( pPlayer, tpTownService->entityid() );
//}

// ***********************************************************
//  Function:		SetTown
//  Description:	设定回城
//  Input:			CEntityPlayer*			pPlayer			
//					CPropertyPlayer*		pProperty		
//					int						vEntityID		
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/03/2008
// **********************************************************
void CPropertyModule::OnMessageSetTownRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageSetTownRequest *pMsg = ( CMessageSetTownRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	if ( pMsg->npcentityid() == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_TELENONPC );
		return;
	}
	CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		pMsg->npcentityid( ) ) );
	if ( pNpc == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_TELENONPC );
		return;
	}
	if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), pMsg->npcentityid(), __FUNCTION__ );
		return;
	}

	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_TELENONPC );
		return;
	}	

	if ( tpNpc->mTownX == 0 || tpNpc->mTownY == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_TELENONPC );
		return;
	}

	tpSrcProperty->GetTownPos( )->mLineID = pNpc->GetLineID();
	tpSrcProperty->GetTownPos( )->mMapID = pNpc->GetMapID();
	tpSrcProperty->GetTownPos( )->mPos = CWTPoint( tpNpc->mTownX, tpNpc->mTownY );

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_RESPONSE_SETTOWN );

	CMessageSetTownResponse tMessage;

	tTotalMessage.set_msgpara( (uint32)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}


// ***********************************************************
//  Function:		因为改变职业,学习技能
//  Description:	StudySkillByChangeMetier
//  Input:			CPropertyPlayer* pProperty
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/04/2008
// **********************************************************
void CPropertyModule::StudySkillByChangeMetier( CPropertyPlayer* pProperty, int vMetierID, int* tGenerIDList, int* tColList, int* tRowList, int& tCount, int vMaxNum, unsigned int* tSkillIDList, int* tIndexList )
{
	LK_ASSERT( pProperty != NULL && tGenerIDList != NULL && tColList != NULL && tRowList != NULL && tSkillIDList != NULL && tIndexList != NULL, return );

	CTemplateBeginner* tpBeginner = (CTemplateBeginner*) CDataStatic::GetTemp( TEMP_BEGINNER );
	if ( tpBeginner == NULL )
		return;

	unsigned int tSkillID = 0;
	int tIndex = -1;

	int* tpSkillIDList = NULL;
	int* tpSkillLevelList = NULL;
	unsigned int tnMaxSkillID = 0;
	unsigned int tnMaxSkillLevel = 0;
	switch ( vMetierID )
	{
		case WARRIOR:// 战士
			{
				tpSkillIDList = tpBeginner->mSkillID1;
				tpSkillLevelList = tpBeginner->mSkillLevel1;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID1 );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel1 );
				break;
			}
		case SWORDMAN:// 剑客
			{
				tpSkillIDList = tpBeginner->mSkillID2;
				tpSkillLevelList = tpBeginner->mSkillLevel2;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID2 );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel2 );
				break;
			}
		case HUNTER:// 猎人
			{
				tpSkillIDList = tpBeginner->mSkillID3;
				tpSkillLevelList = tpBeginner->mSkillLevel3;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID3 );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel3 );
				break;
			}
		case RABBI:// 法师
			{
				tpSkillIDList = tpBeginner->mSkillID4;
				tpSkillLevelList = tpBeginner->mSkillLevel4;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID4 );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel4 );
				break;
			}
		case TAOIST:// 道士
			{
				tpSkillIDList = tpBeginner->mSkillID5;
				tpSkillLevelList = tpBeginner->mSkillLevel5;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID5 );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel5 );
				break;
			}
		case MAGIC:// 幻术师
			{
				tpSkillIDList = tpBeginner->mSkillID6;
				tpSkillLevelList = tpBeginner->mSkillLevel6;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID6 );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel6 );
				break;
			}
		case FRESH:// 新手
			{
				tpSkillIDList = tpBeginner->mSkillID;
				tpSkillLevelList = tpBeginner->mSkillLevel;
				tnMaxSkillID = ARRAY_CNT( tpBeginner->mSkillID );
				tnMaxSkillLevel = ARRAY_CNT( tpBeginner->mSkillLevel );
				break;
			}
	}

	CSkillList&  tpSkill = pProperty->GetSkillList( );
	for ( unsigned int i = 0; i < tnMaxSkillID && i < tnMaxSkillLevel; i++ )
	{
		if ( tpSkillIDList[ i ] <= 0 || tpSkillLevelList[ i ] <= 0 )
			break;

		if( tpSkill.InsertSkill( tpSkillIDList[ i ], tpSkillLevelList[ i ]) == false )
			continue;

		tSkillID = tpSkillIDList[ i ]; 
		tIndex = tpSkill.GetSkillIndexByID( tSkillID );

		CTemplateSkill* tpSkillTpl = ( CTemplateSkill* ) CDataStatic::SearchSkill( tpSkillIDList[ i ], tpSkillLevelList[ i ] );
		if ( tpSkillTpl == NULL )
			continue;

		CTemplateSkillTree* tpSkillTreeTpl = (CTemplateSkillTree*) CDataStatic::SearchGener( tpSkillTpl->mGenerID );
		if ( tpSkillTreeTpl == NULL )
			continue;

		for ( int tCol = 0; tCol < (int)ARRAY_CNT( tpSkillTreeTpl->mLayerNode ); tCol++  )
		{
			bool tIsOut = false;

			for ( int tRow = 0; tRow < (int)ARRAY_CNT( tpSkillTreeTpl->mLayerNode[ 0 ] ); tRow++ )
			{
				if ( tpSkillTreeTpl->mLayerNode[ tCol ][ tRow ].mSkillID == tpSkillIDList[ i ] )
				{
					tGenerIDList[ tCount ] = tpSkillTpl->mGenerID;
					tColList[ tCount ] = tCol;
					tRowList[ tCount ] = tRow;
					tSkillIDList[ tCount ] = tSkillID;
					tIndexList[ tCount ] = tIndex;
					tCount++;

					tIsOut = true;
					break;
				}
			}

			if ( tIsOut == true )
				break;							
		}

		if ( tCount >= vMaxNum )
			break;
	}
}

// ***********************************************************
//  Function:		自身祝福的接口
//  Description:	ActionSelfBless
//  Input:			CEntityCharacter*		pSrcEntity
//					CPropertyCharacter*		pSrcProperty
//					CTemplateNormalSkill*	pNormalSkill
//					int						vDamage
//					CEntityResultList&		rResultList
//					int						vListID
//					int						vSkillType
//					bool&					vbIfSrcDurReduced
//					bool&					vbEntityType
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/12/2008
// **********************************************************
void CPropertyModule::ActionSelfBless( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbIfSrcDurReduced, bool& vbEntityType )
{
	LK_ASSERT( pNormalSkill != NULL, return );

	if ( pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_SINGLE )
	{

		// 被作用
		pSrcEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true, 
			pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );


		//// 减少攻击方的装备耐久度
		vbIfSrcDurReduced = true;
		vbEntityType =  true;

		PERF_FUNC( "EntityBufSkill-Self", EntityBuffSkill( pSrcEntity, pSrcEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType ) );
	}
}

// 可见范围内祝福
void CPropertyModule::ActionSeenBless( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbIfSrcDurReduced, bool& vbEntityType )
{
	LK_ASSERT( pSrcEntity!=NULL && pNormalSkill != NULL, return );
	if ( !pSrcEntity->IsPlayer() )
		return;
	CEntityPlayer* pPlayer=(CEntityPlayer*)pSrcEntity;

	// 取可见表
	CSeenPlayerContainer& rSeenPlayerContainer = pPlayer->GetSeenPlayersContainer();
	CSeenPlayerContainer::SeenPlayerVector::iterator it = rSeenPlayerContainer.mPlayers.begin();
	for ( ; it != rSeenPlayerContainer.mPlayers.end(); ++it)
	{
		CEntityPlayer* pTargetEntity = ( CEntityPlayer* ) CSceneObjManager::GetSingletonPtr()->GetObject( *it );
		if( pTargetEntity == NULL )
		{
			LOG_ERROR("pro", "in use FuncItem, NULL! entity=%d", *it );
			continue;
		}
		// 不是同阵营 不作用
		if ( pPlayer->GetNationality() != pTargetEntity->GetNationality() )
		{
			continue;
		}
		// 能攻击 不作用
		if ( EntityPKValid( pPlayer, pTargetEntity, NULL, false) )
		{
			continue;
		}
		InsertBuff( pTargetEntity, pNormalSkill->mBuffGroupID[4] );		
	}
	InsertBuff( pPlayer, pNormalSkill->mBuffGroupID[4] );		
}

// ***********************************************************
//  Function:		单体攻击的接口
//  Description:	ActionAttackSingle
//  Input:			CEntityCharacter*		pSrcEntity
//					CPropertyCharacter*		pSrcProperty
//					CEntityCharacter*		pDesEntity
//					CPropertyCharacter*		pDesProperty
//					CTemplateNormalSkill*	pNormalSkill
//					CEntityResultList&		rResultList
//					int						vListID
//					int						vSkillType
//					bool&					vbIfSrcDurReduced
//					bool&					vbEntityType
//  OutPut:			
//  Return:			
//  Others:
//  Date:	12/12/2008
// **********************************************************
void CPropertyModule::ActionAttackSingle( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vSkillType, bool& vbIfSrcDurReduced, bool& vbEntityType )
{
	if ( pDesEntity == NULL || pNormalSkill == NULL )
		return;
	// 减少攻击方的装备耐久度
	vbIfSrcDurReduced = true;
	if ( pDesEntity->IsPlayer() && pDesEntity != pSrcEntity )
	{
		vbEntityType = false;
	}

	// 将技能作用于目标
	PERF_FUNC( "EntityAttackSkill", EntityAttackSkill( pSrcEntity, pDesEntity, pNormalSkill, vSkillType ));

	//// 通知召唤兽切换目标
	//if ( pSrcEntity != NULL )
	//{
	//	
	//	if( ((CPropertyCharacter*)(pSrcEntity->GetProperty()))->GetPetID( ) != 0 )
	//		ChangePetTargetSingle( pSrcEntity, pDesEntity );
	//}
}


//************************************
// Method:    ActionAttackRange
// FullName:  CPropertyModule::ActionAttackRange
// Access:    public 
// Returns:   void
// Qualifier: 群攻技能作用
// Parameter: CEntityCharacter * pSrcEntity
// Parameter: CEntityCharacter * pDesEntity		【注意】由调用者保证该指针不为空，
// Parameter: CTemplateNormalSkill * pNormalSkill
// Parameter: int vSkillType
// Parameter: bool & vbIfSrcDurReduced
// Parameter: bool & vbEntityType
// Parameter: CEntityCharacter * * vEntityList
// Parameter: int vEntityListNum
//************************************
void CPropertyModule::ActionAttackRange( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vSkillType, bool& vbIfSrcDurReduced, bool& vbEntityType, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	if ( pDesEntity != NULL )
	{
		if ( pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_TARGETCIRCLE
			&& pSrcEntity->IsWithinDistance( pDesEntity, pNormalSkill->mMinDistance ) == false )
			return;
	}	
	
	// 进来就掉耐久
	vbIfSrcDurReduced = true;
	int vDamageRate = SERVER_PERCENT_INT;

	// 找到真实作用源
	CEntityCharacter* tpParamEntity = 
		( pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_TARGETCIRCLE ) 
		? pDesEntity
		: pSrcEntity ;

	// 如果客户端上报了范围作用列表,那么使用客户端数据,否则服务器去地图模块查找
	// 如果是怪物用群攻技能，也是需要服务器自己查的
	if ( vEntityList == NULL )
	{
		// 搜索敌人, 限定个数, 限定Pkvalid
		MapCellSearchEnemys tSearchEnemys(  pSrcEntity, 
			pNormalSkill->mEffectMaxNumber,
			pNormalSkill->mRandParame[ 0 ],
			(CTemplateSkill*)pNormalSkill );

		tSearchEnemys.Visit();

		// 逐个作用
		for( std::vector<CEntityCharacter*>::iterator it = tSearchEnemys.mEnemys.begin();
			it != tSearchEnemys.mEnemys.end();
			++it )
		{
			if ( *it == NULL )
				continue;

			// 服务器用 mMaxDistance 来判断客户端上报的实体列表是否在技能能达到的范围内
			if ( tpParamEntity->IsWithinDistance( *it, pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			// 判断技能PK模式是否满足
			if ( EntityPKValid( pSrcEntity, *it, pNormalSkill ) == false )
				continue;

			// 将技能作用于目标
			PERF_FUNC( "EntityAttackSkill", EntityAttackSkill( pSrcEntity, *it, pNormalSkill, vSkillType, vDamageRate ) );		
		}

	} 
	else // 有攻击列表的肯定是客户端主动发起的
	{
		// 这个列表主要是查出来给召唤兽切目标用，现在召唤兽功能有问题
		int	tEntityCount = 0;
		//CEntityCharacter* tpEntityList[ FUNC_LIMIT ] = { NULL };
		CEntityCharacter *tpHitList[ FUNC_LIMIT ] = { NULL };

		for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
		{
			if ( vEntityList[ i ] == NULL )
				continue;

			// 服务器用 mMaxDistance 来判断客户端上报的实体列表是否在技能能达到的范围内
			if ( tpParamEntity->IsWithinDistance( vEntityList[ i ], pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			// 判断技能PK模式是否满足
			if ( EntityPKValid( pSrcEntity, vEntityList[ i ], pNormalSkill ) == false )
				continue;

			tpHitList[ tEntityCount ] = vEntityList[ i ];

			// 判断群攻是否达到人数上限
			if( ++tEntityCount > pNormalSkill->mEffectMaxNumber)
				break;
		}

		CTemplateMultiAttackTable *tpTable = (CTemplateMultiAttackTable*)CDataStatic::GetTemp( TEMP_MULTIATTACKTABLE );
		if ( tpTable != NULL )
		{
			if ( (unsigned int)tEntityCount < ARRAY_CNT(tpTable->mReduce) )
			{
				vDamageRate *= tpTable->mReduce[ tEntityCount ] / SERVER_PERCENT_FLOAT;
			}
		}

		for ( int i = 0; i < tEntityCount && i < FUNC_LIMIT; i++ )
		{
			if ( tpHitList[ i ] == NULL )
				continue;
			
			// 将技能作用于目标
			PERF_FUNC( "EntityAttackSkill", EntityAttackSkill( pSrcEntity, tpHitList[ i ], pNormalSkill, vSkillType, vDamageRate ) );

			//tpEntityList[ tEntityCount ] = vEntityList[ i ];			
		}

		// 如果源是玩家, 范围攻击,召唤兽切换目标, -- 这个函数调了也没用，里面没有处理。
		//if( pSrcEntity->IsPlayer() )
		//{
		//	ChangePetTargetUnsingle( pSrcEntity, tpEntityList, tEntityCount );
		//}
	}

}

void CPropertyModule::ActionCussOrBlessSingle( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType )
{
	if ( pSrcEntity == NULL || pDesEntity == NULL || pNormalSkill == NULL )
		return;

	// 被攻击(作用)
	pDesEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
		pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );
	
	// 将技能作用于目标
	PERF_FUNC( "EntityBuffSkill-CussOrBlessSingle", EntityBuffSkill( pSrcEntity, pDesEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType ));

	if ( pNormalSkill->mSkillType == CTemplateSkill::SKILLTYPE_CUSS )
	{
		// 减少被攻击方的装备耐久度
		if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PLAYER )
		{
			EquipmentDurability( pDesEntity , 0 , 0 );
		}
		else
		{
			EquipmentDurability( pDesEntity , 0 , 1 );
		}
		
		if ( pDesEntity->IsPlayer() )
		{
			StopProgress( (CEntityPlayer *)pDesEntity );
		}

		/*ChangePetTargetSingle( pSrcEntity, pDesEntity );*/
	}
}

void CPropertyModule::ActionCussOrBlessRange( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbEntityType, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	// int vDamageRate = SERVER_PERCENT_INT;

	// 如果客户端上报了范围作用列表,那么使用客户端数据,否则服务器去地图模块查找
	// 如果是怪物用群攻技能，也是需要服务器自己查的
	if ( vEntityList == NULL )
	{
		// 搜索敌人, 限定个数, 限定Pkvalid
		MapCellSearchEnemys tSearchEnemys(  pSrcEntity, 
			pNormalSkill->mEffectMaxNumber,
			pNormalSkill->mAttackRange,
			(CTemplateSkill*)pNormalSkill );

		tSearchEnemys.Visit();

		// 逐个作用
		for( std::vector<CEntityCharacter*>::iterator it = tSearchEnemys.mEnemys.begin();
			it != tSearchEnemys.mEnemys.end();
			++it )
		{
			// 被攻击(作用)
			(*it)->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
				pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );

			// 将技能作用于目标
			EntityBuffSkill( pSrcEntity, *it, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );		
		}

	} 
	else // 有攻击列表的肯定是客户端主动发起的
	{
		// 找到真实作用源
		CEntityCharacter* tpParamEntity = 
			( pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_TARGETCIRCLE ) 
			? pDesEntity
			: pSrcEntity ;

		// 这个列表主要是查出来给召唤兽切目标用，现在召唤兽功能有问题
		int	tEntityCount = 0;
		//CEntityCharacter* tpEntityList[ FUNC_LIMIT ] = { NULL };

		for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
		{
			if ( vEntityList[ i ] == NULL )
				continue;

			// 服务器用 mMaxDistance 来判断客户端上报的实体列表是否在技能能达到的范围内
			if ( tpParamEntity->IsWithinDistance( vEntityList[ i ], pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			// 判断技能PK模式是否满足
			if ( EntityPKValid( pSrcEntity, vEntityList[ i ], pNormalSkill ) == false )
				continue;

			// 被攻击(作用)
			vEntityList[ i ]->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
				pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );

			// 将技能作用于目标
			EntityBuffSkill( pSrcEntity, vEntityList[ i ], pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );
			//tpEntityList[ tEntityCount ] = vEntityList[ i ];

			// 判断群攻是否达到人数上限
			if( ++tEntityCount > pNormalSkill->mEffectMaxNumber)
				break;
		}

		// 如果源是玩家, 范围攻击,召唤兽切换目标, -- 这个函数调了也没用，里面没有处理。
		//if( pSrcEntity->IsPlayer() )
		//{
		//	ChangePetTargetUnsingle( pSrcEntity, tpEntityList, tEntityCount );
		//}
	}
}

void CPropertyModule::ActionTeamBless( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbIfSrcDurReduced, bool& vbEntityType )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	if ( pSrcEntity->IsPlayer() == false )
		return;

	// 这里不需要遍历小队列表,因为在EntityBuffSkill里面会做相同的遍历,这里直接插入就行
	EntityBuffSkill( pSrcEntity, pSrcEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT( pNormalSkill->mBuffGroupID ), vDamage, vSkillType );

	//CEntityPlayer* tMemberList[ TEAMNUM ] = { NULL };
	////// 获得组队成员列表
	//int tCount = CTeamModule::GetSingleton().OnGetMemberList( (CEntityPlayer*)pSrcEntity, tMemberList );

	//for ( int i = 0; i < tCount && i < TEAMNUM; i ++ )
	//{
	//	CEntityCharacter* tpDesEntity = (CEntityCharacter*) tMemberList[ i ];
	//	if ( tpDesEntity == NULL )
	//		continue;

	//	// 自己给自己加
	//	if ( tpDesEntity == pSrcEntity )
	//	{
	//		EntityBuffSkill( pSrcEntity, tpDesEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );
	//		continue;
	//	}

	//	// 将技能作用于队友
	//	if ( pSrcEntity->GetPos( ).LimitDistance( tpDesEntity->GetPos( ), pNormalSkill->mRandParame[0] )
	//		&& pSrcEntity->GetMapID() == tpDesEntity->GetMapID() )
	//	{
	//		EntityBuffSkill( pSrcEntity, tpDesEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );
	//	}
	//}
}

void CPropertyModule::ActionTrip( CEntityCharacter* pSrcEntity, CTemplateSkill* pSkill, bool& vbIfSrcDurReduced )
{
	if ( pSrcEntity == NULL || pSkill == NULL )
		return;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();

	// 减少技能释放者的装备耐久度						
	vbIfSrcDurReduced = true;

	// 陷阱放在玩家脚下,所以不需要计算坐标
	CTemplateTrapSkill* tpTrapTpl = (CTemplateTrapSkill*) pSkill;
	CPedalCreator tCreator;
	tCreator.mPedalType		= PEDAL_TRAP;
	int tTouchRange  = tpTrapTpl->mTouchRange - 1;
	int tActionRange = tpTrapTpl->mApplyRange - 1;
	tCreator.mSrcRect		= CWTRect( pSrcEntity->GetPosX( ) - tTouchRange, pSrcEntity->GetPosY( ) - tTouchRange, pSrcEntity->GetPosX( ) + tTouchRange, pSrcEntity->GetPosY( ) + tTouchRange );
	tCreator.mActRect		= CWTRect( pSrcEntity->GetPosX( ) - tActionRange, pSrcEntity->GetPosY( ) - tActionRange, pSrcEntity->GetPosX( ) + tActionRange, pSrcEntity->GetPosY( ) + tActionRange );
	tCreator.mSkillID		= tpTrapTpl->mSkillID;
	tCreator.mSkillLevel	= tpTrapTpl->mSkillLevel;
	tCreator.mSrcEntityID	= pSrcEntity->GetEntityID( );

	//// 记录建立的陷阱实体
	if ( pSrcEntity->GetEntityType() == ENTITYTYPE_PLAYER )
		tCreator.mTeamID = ( (CEntityPlayer*) pSrcEntity )->GetTeamFlag();
	else
		tCreator.mTeamID = 0;
	unsigned int tPedalEntityID = 0;
	bool tBool = CMapModule::GetSingleton().CreateNpc( 
			pSrcEntity->GetLineID(),
			pSrcEntity->GetMapID(),
			pSrcEntity->GetMapIndex(),
			&tCreator,
			tPedalEntityID );

	if ( tBool == true )
	{
		// 记录建立的陷阱实体
		pSrcProperty->NoteAddTripEntityID( tPedalEntityID );
	}
}

void CPropertyModule::ActionPetBless( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbIfSrcDurReduced )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();

	if ( pSrcProperty->GetPetID( ) == 0 )
		return;

	CEntity* tpEntity = CSceneLogic::GetSingletonPtr()->GetEntity( pSrcProperty->GetPetID( ) );
	if ( tpEntity == NULL || tpEntity->IsPet( ) == false )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] tpPetEntity is NULL!\n", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CEntityPet* tpPetEntity = ( CEntityPet* )tpEntity;
	CPropertyPet* tpPetProperty = ( CPropertyPet* )tpPetEntity->GetProperty( );
	if ( tpPetProperty == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] tpPetProperty is NULL!\n", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	// 减少技能释放者的装备耐久度

	vbIfSrcDurReduced = true;

	EntityBuffSkill( pSrcEntity, tpPetEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );				
}

void CPropertyModule::ActionRelive( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbIfSrcDurReduced )
{
	if ( pSrcEntity == NULL || pDesEntity == NULL || pNormalSkill == NULL )
		return;

	if( pDesEntity->GetEntityType() != pSrcEntity->GetEntityType() )
	{
		SendProErrorNotice( pSrcEntity, ERROR_USESKILL_ERRDEST );
	}
	if( pDesEntity->IsAlive() == false )
	{
		// 被攻击(作用)
		pDesEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
			pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );


		// 减少技能释放者的装备耐久度
		vbIfSrcDurReduced = true;

		EntityBuffSkill( pSrcEntity, pDesEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );

		if ( pDesEntity->IsPlayer() &&  pSrcEntity->IsPlayer() )
		{
			LogEventPlayerReliveByPlayer((CEntityPlayer*) pDesEntity, (CEntityPlayer*) pSrcEntity);
		}
	}
	else
	{
		SendProErrorNotice( pSrcEntity, ERROR_USESKILL_ERRDEST );
	}
}

void CPropertyModule::ActionTeleport( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, int vDamage, int vSkillType, bool& vbIfSrcDurReduced )
{
	if ( pNormalSkill == NULL )
		return;

	// 减少技能释放者的装备耐久度
	vbIfSrcDurReduced = true;	

	// 被攻击(作用)
	pDesEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
		pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );

	EntityBuffSkill( pSrcEntity, pDesEntity, pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), vDamage, vSkillType );
}

void CPropertyModule::ActionSummon( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, bool& vbIfSrcDurReduced )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();

	pSrcProperty->DestroyPetEntity();

	if ( pNormalSkill->mBuffGroupID[ 4 ] == 0 )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] SummonBeast ID error!\n", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CWTPoint tPlacePos;
	if ( pSrcEntity->GetDirection( ) == DIR_LEFT )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) + 1 );
	else if ( pSrcEntity->GetDirection( ) == DIR_RIGHT )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) - 1 );
	else if ( pSrcEntity->GetDirection( ) == DIR_UP )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ) + 1, pSrcEntity->GetPosY( ) );
	else if ( pSrcEntity->GetDirection( ) == DIR_DOWN )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ) - 1, pSrcEntity->GetPosY( ) );
	else if ( pSrcEntity->GetDirection( ) == DIR_LEFTUP )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ) + 1, pSrcEntity->GetPosY( ) + 1 );
	else if ( pSrcEntity->GetDirection( ) == DIR_RIGHTUP )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ) + 1, pSrcEntity->GetPosY( ) - 1 );
	else if ( pSrcEntity->GetDirection( ) == DIR_LEFTDOWN )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ) - 1, pSrcEntity->GetPosY( ) + 1 );
	else if ( pSrcEntity->GetDirection( ) == DIR_RIGHTDOWN )
		tPlacePos = CWTPoint( pSrcEntity->GetPosX( ) - 1, pSrcEntity->GetPosY( ) - 1 );

	if ( pSrcEntity->CanPass( tPlacePos.mX, tPlacePos.mY ) == false )
	{
		tPlacePos.mX = pSrcEntity->GetPosX();
		tPlacePos.mY = pSrcEntity->GetPosY();
	}
	CPetCreator tCreator;
	tCreator.mPos = tPlacePos;
	tCreator.mDirection = pSrcEntity->GetDirection( );
	tCreator.mPetID = pNormalSkill->mBuffGroupID[ 4 ];		// 暂时都招马面兽,测试用
	tCreator.mSrcEntityID = pSrcEntity->GetEntityID( );

	// 减少技能释放者的装备耐久度

	vbIfSrcDurReduced = true;

	//// 召唤兽
	unsigned int tEntityID = 0;
	bool tBool = CMapModule::GetSingleton().CreateNpc( 
			pSrcEntity->GetLineID(),
			pSrcEntity->GetMapID(),
			pSrcEntity->GetMapIndex(),
			&tCreator,
			tEntityID );
	if ( tBool == true )
	{
		pSrcProperty->SetPetID( tEntityID );
		// 设置召唤兽等级为玩家等级
		CEntityPet *pPet = (CEntityPet*)CSceneLogic::GetSingletonPtr()->GetEntity( tEntityID );
		if ( pPet != NULL )
		{
			CPropertyPet *tpProPet = (CPropertyPet*)pPet->GetProperty( );
			tpProPet->SetLevel( pSrcProperty->GetLevel( ) );
		}
	}
}

void CPropertyModule::ActionAureole( CEntityCharacter* pSrcEntity, CTemplateSkill* pSkill, bool& vbIfSrcDurReduced, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pSkill == NULL )
		return;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();

	int tTempID = 0;
	CTemplateAureoleSkill* tpAureoleSkill = ( CTemplateAureoleSkill* ) pSkill;

	if( pSrcProperty->GetStateParam( STATE_AUREOLE ).mInState == true )
	{
		tTempID = pSrcProperty->GetStateParam( STATE_AUREOLE ).mParames1;

		// 关闭光环
		CloseAureole( pSrcEntity );	

		if( pSkill->mTempID == tTempID )
		{
			return;
		}
	}

	// 减少技能释放者的装备耐久度
	vbIfSrcDurReduced = true;

	// 打开新光环
	UseAureoleSkill( pSrcEntity, tpAureoleSkill, vEntityList, vEntityListNum );
}

void CPropertyModule::ActionContinuedAttackRange( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	CEntityCharacter* tpEntityList[ FUNC_LIMIT ] = { NULL };

	// 暂时只有自身圆形,目标圆形和弹跳攻击三种范围
	int tEntityCount = 0;
	CEntityCharacter* tParamEntity = NULL;
	if ( pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_TARGETCIRCLE ||
		pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_BOUND )
	{
		if ( pDesEntity == NULL )
			return;
		tParamEntity = pDesEntity;
	}
	else
		tParamEntity = pSrcEntity;

	// 设置后续攻击条件
	//pSrcEntity->SetContinuedCondition( pNormalSkill, tParamEntity->GetPosX( ), tParamEntity->GetPosY( ) );

	// 如果客户端上报了范围作用列表,那么使用客户端数据,否则服务器去地图模块查找
	if ( vEntityList == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] vEntityList is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	} 
	else
	{
		for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
		{
			if ( vEntityList[ i ] == NULL )
				continue;

			if ( tParamEntity->IsWithinDistance( vEntityList[ i ], pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			tpEntityList[ tEntityCount ] = vEntityList[ i ];
			tEntityCount++;
		}
	}

	int tCount = 0;

	// 将技能作用于所有找到的实体
	for ( int i = 0; i < tEntityCount; i ++ )
	{
		if( tpEntityList[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) UseSkill( %d : %d ), Call "
				"Map_GetRangeEntity tResult count error index %d is NULL", __LK_FILE__, __LINE__,
				__FUNCTION__, pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, i );
			continue;
		}

		// 判断技能PK模式是否满足
		if ( EntityPKValid( pSrcEntity, tpEntityList[ i ], pNormalSkill ) == false )
		{
			continue;
		}

		// 将技能作用于目标
		EntityAttackSkill( pSrcEntity, tpEntityList[ i ], pNormalSkill, pNormalSkill->mSkillType );
		++tCount;
		// 判断群攻是否达到人数上限
		if ( tCount >= pNormalSkill->mEffectMaxNumber )
			break;
	}
}

void CPropertyModule::ActionContinuedCussOrBlessRange( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateNormalSkill* pNormalSkill, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	CEntityCharacter* tpEntityList[ FUNC_LIMIT ] = { NULL };

	// 暂时只有自身圆形,目标圆形和弹跳攻击三种范围
	int tEntityCount = 0;
	CEntityCharacter* tParamEntity = NULL;
	if ( pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_TARGETCIRCLE ||
		pNormalSkill->mAttackRange == CTemplateNormalSkill::RANGE_BOUND )
	{
		if ( pDesEntity == NULL )
			return;
		tParamEntity = pDesEntity;
	}
	else
		tParamEntity = pSrcEntity;

	// 设置后续攻击条件
	//pSrcEntity->SetContinuedCondition( pNormalSkill, tParamEntity->GetPosX( ), tParamEntity->GetPosY( ) );

	// 如果客户端上报了范围作用列表,那么使用客户端数据,否则服务器去地图模块查找
	if ( vEntityList == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] vEntityList is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	} 
	else
	{
		for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
		{
			if ( vEntityList[ i ] == NULL )
				continue;

			if ( tParamEntity->IsWithinDistance( vEntityList[ i ], pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			tpEntityList[ tEntityCount ] = vEntityList[ i ];
			tEntityCount++;
		}
	}

	int tCount = 0;

	// 将技能作用于所有找到的实体
	for ( int i = 0; i < tEntityCount; i ++ )
	{
		if( tpEntityList[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) UseSkill( %d : %d ), Call "
				"Map_GetRangeEntity tResult count error index %d is NULL", __LK_FILE__, __LINE__,
				__FUNCTION__, pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, i );
			continue;
		}

		// 判断技能PK模式是否满足
		if ( EntityPKValid( pSrcEntity, tpEntityList[ i ], pNormalSkill ) == false )
		{
			continue;
		}

		// 被攻击(作用)
		tpEntityList[ i ]->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true,
			pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );


		// 将技能作用于目标
		EntityBuffSkill( pSrcEntity, tpEntityList[ i ], pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), 0, pNormalSkill->mSkillType );
		++tCount;
		// 判断群攻是否达到人数上限
		if ( tCount >= pNormalSkill->mEffectMaxNumber )
			break;
	}
}

// 给玩家或者NPC上BUFF
bool CPropertyModule::InsertBuff( CEntityCharacter* pDesEntity, int nBuffID, int nBuffTime  ,int *nResultCode)
{
	CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( nBuffID );
	if ( tpBuffTpl == NULL )
		return false;

	pDesEntity->InitFunResult( );
	int tResultCode = pDesEntity->EntityInsertBuff( pDesEntity, tpBuffTpl, 0, 0,  nBuffTime );
	if(nResultCode != NULL )
	{
		*nResultCode = tResultCode;
	}

	ResultListSend( );

	return true;
}


// 从玩家或者NPC身上干掉BUFF
int CPropertyModule::RemoveBuff( CEntityCharacter* pDesEntity, int nBuffID )
{
	if ( !pDesEntity->EntityHasBuff( nBuffID ) )
	{
		return ERROR_NPCNOBUFF;
	}

	pDesEntity->InitFunResult( );
	pDesEntity->EntityRemoveBuff( nBuffID );
	ResultListSend( );
	return SUCCESS;
}


void CPropertyModule::OnMessageThrowStorItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL)
	{
		LOG_ERROR( "pro","[%s,%d][%s] NULL CEntityPlayer or NULL CMessage or NULLCPropertyPlayer!  ", __LK_FILE__,__LINE__,__FUNCTION__  );
		return;
	}
	CMessageThrowStorItemRequest *tpMsg = ( CMessageThrowStorItemRequest * )pMessage->msgpara( );
	if ( tpMsg == NULL )
	{
		return;
	}

	int Index = tpMsg->index();
	int Num = tpMsg->num();
	PlayerThrowStorItem( pPlayer, Index, Num );		
}
void CPropertyModule::PlayerThrowStorItem( CEntityPlayer* pPlayer, int vItemIndex, int vNumber, bool bForce )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] CEntityPlayer or  CMessage or CPropertyPlayer is NULL!  ", __LK_FILE__,__LINE__,__FUNCTION__  );
		return;		
	}
	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if (!bForce)
	{
		// 判断有没有密码保护
		int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
		if ( tPwdCheckRet != SUCCESS )
		{
			CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
			return;
		}	
	}	  		
	
	// TODO:包括背包索引的检查
	if ( !pProperty->GetStorage()->CheckIndexValid( vItemIndex ) )	
	// if ( vItemIndex < 0 || vItemIndex > (int)pProperty->GetStorage( )->mReleaseIndex )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Stroageindex is invalide!  ", __LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	CItemObject *tpItemObj = ( CItemObject * )pProperty->GetStorage( )->GetItemObjPtr( vItemIndex );

	if ( tpItemObj == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] StroageItem is null! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}	
	if(	vNumber > (int)tpItemObj->GetItemNum() )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Num is invalide! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;		
	}

	if (!bForce)
	{
		if ( IfItemBindFree( tpItemObj ) == 1 )
		{	
			CheckItemBindFreeTime( tpItemObj );	
		}
		// 删除道具时候，道具被绑定了
		if ( tpItemObj->GetBindStatus() != ITEM_BINDSTATUS_FREE )
		{
			// 发送通知，绑定的物品不能被丢弃
			SendProErrorNotice( ( CEntityPlayer* )pPlayer , ITEM_THROW_BINDED  );
			return;
		}
	}
	// unsigned int tEntityNpcID = 0;
	// int tCharID[ TEAMNUM ] = { 0 };
	CItemObject *tpThrowItem = pProperty->GetStorage( )->EraseItem( vItemIndex, vNumber );
	LK_ASSERT( tpThrowItem != NULL, return )

	LogEventLostItemByDestroyItem(pPlayer, tpThrowItem->GetGUID(), tpThrowItem->GetItemID(), vNumber);
	// 记录非堆叠的人民币物品消耗 
	LogIbItemUsed(pPlayer, tpThrowItem);

	// 干掉timer
	if ( tpItemObj->GetValidTimerID() != INVALID_OBJ_ID)
	{
		pPlayer->GetTimerReciver()->ClearTimer(tpItemObj->GetValidTimerID());
	}
	CSceneObjManager::GetSingleton().DestroyObject( tpItemObj->get_id() );
	//CItemCreator tCreator( tpThrowItem->mItemID, 1, pPlayer->GetPosX( ), pPlayer->GetPosY( ), tCharID, tpThrowItem );

	//CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(),
	//		pPlayer->GetMapID(),
	//		pPlayer->GetMapIndex(),
	//		&tCreator,
	//		tEntityNpcID );

	// 发送删除道具
	CMessageRemoveItemNotify MsgThrowItem;
	MsgThrowItem.set_pos( POS_STORAGE );
	MsgThrowItem.set_itemindex( vItemIndex );
	MsgThrowItem.set_number( vNumber );
	CMessage MessageHead;
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_REMOVEITEM );
	MessageHead.set_msgpara( (int)&MsgThrowItem  );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &MessageHead );
}
void CPropertyModule::SendItemBindedNotice( CEntityPlayer *tpPlayer, int ItemIndex, int ItemPos )
{
	CMessageNotifyItemBinded MsgItemBinded;
	CMessage				 MessageHead;
	if ( tpPlayer == NULL )
	{
		return;
	}
	MsgItemBinded.set_itemindex( ItemIndex );
	MsgItemBinded.set_itempos( ItemPos );
	MessageHead.mutable_msghead()->set_messageid( ID_C2S_NOTIFY_ITEMHASBINDED );
	MessageHead.set_msgpara( (int)&MsgItemBinded );
	CSceneLogic::GetSingletonPtr()->Send2Player( tpPlayer, &MessageHead );	
}

void CPropertyModule::SetDefaultValue( CEntityPlayer* pEntity )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();
	CTemplateBeginner *pBeginner = (CTemplateBeginner*)CDataStatic::GetTemp( TEMP_BEGINNER );
	LK_ASSERT ( pBeginner != NULL, return  );

	// 插入装备，并且装备上
	for( int i = 0; i < (int)ARRAY_CNT( pBeginner->mEquipItemID ); i++ )
	{
		if ( pBeginner->mEquipItemID[ i ] == 0 )
			continue;  	
		
		CItemObject * pInsItemPile = 
			PlayerInsertItem( (CEntityPlayer*)pEntity, pBeginner->mEquipItemID[ i ], pBeginner->mEquipItemNum[ i ], true);

		if ( pInsItemPile != NULL)
		{
			LogEventGetItemByDefault((CEntityPlayer*)pEntity, 
					pInsItemPile->GetGUID(), pBeginner->mEquipItemID[ i ], pBeginner->mEquipItemNum[ i ]);
		}

		unsigned int tTempIndex = ~0;
		pProperty->Equip( 0, tTempIndex );

		if ( pBeginner->mSkillID[ i ] > 0 )
		{
			CSkillList& tpSkill = pProperty->GetSkillList( );
			tpSkill.InsertSkill( pBeginner->mSkillID[ i ], pBeginner->mSkillLevel[ i ] );

			pProperty->GetShortcut( )->SetShortcut( i, 1, i, -1, -1, 0 );			
		}	
	}

	// 插入包裹道具
	for( int i = 0; i < (int)ARRAY_CNT( pBeginner->mBaggageItemID ); i++ )
	{
		if ( pBeginner->mBaggageItemID[ i ] == 0 )
			continue;

		CItemObject* pInsItemPile = 
			PlayerInsertItem( (CEntityPlayer*)pEntity, pBeginner->mBaggageItemID[ i ], pBeginner->mBaggageItemNum[ i ], true);

		if (pInsItemPile != NULL)
		{
			LogEventGetItemByDefault((CEntityPlayer*)pEntity, 
					pInsItemPile->GetGUID(), pBeginner->mBaggageItemID[ i ], pBeginner->mBaggageItemNum[ i ]);
		}
	}

	// 判断是否是新手卡用户
	// 以‘lk’开头，且不以‘lkt’开头的是新手卡帐号，注意此字符串比较不区分大小写;
	// 非新手卡用户增加礼包
	if ( !(strncasecmp(pEntity->GetUserName(), "lk", 2) == 0
	&&   strncasecmp(pEntity->GetUserName(), "lkt", 3) != 0))
	{
		//int nBeginerPkgID = 59610;
		// int nBeginerPkgID = 61427;
		int nBeginerPkgID =  CSceneCfgManager::GetSingletonPtr()->GetProperty_cfg()->mNewuserpkgid;
		
		// pkgid > 0才插入，否则就是不送
		if( nBeginerPkgID > 0 )
		{
			CItemObject* pInsItemPile = PlayerInsertItem( pEntity, nBeginerPkgID, 1, true);
			if (pInsItemPile != NULL)
			{
				LogEventGetItemByDefault((CEntityPlayer*)pEntity, pInsItemPile->GetGUID(), nBeginerPkgID, 1);
			}
		}
	}

	pProperty->SetCurSta( CDataStatic::GetMetierProperty( pEntity->GetMetier(), 1, CUR_TOTAL_PROPERTY, OPTION_STA ) );
	pProperty->SetCurWis( CDataStatic::GetMetierProperty( pEntity->GetMetier(), 1, CUR_TOTAL_PROPERTY, OPTION_WIS ) );
	pProperty->SetCurStr( CDataStatic::GetMetierProperty( pEntity->GetMetier(), 1, CUR_TOTAL_PROPERTY, OPTION_STR ) );
	pProperty->SetCurCon( CDataStatic::GetMetierProperty( pEntity->GetMetier(), 1, CUR_TOTAL_PROPERTY, OPTION_CON ) );
	pProperty->SetCurSpr( CDataStatic::GetMetierProperty( pEntity->GetMetier(), 1, CUR_TOTAL_PROPERTY, OPTION_SPR ) );

	pProperty->SetRemainPoint( CDataStatic::GetLevelProperty( 1, CUR_TOTAL_PROPERTY ) );
	pProperty->SetSkillPoint( pBeginner->mSkillNum );
	pProperty->SetCurAP( pBeginner->mBeginnerAP );
	pProperty->GetMaxAP().mInitValue = pBeginner->mBeginnerAP;
	pProperty->GetMaxAP().mDeltaValue = 0;
	pProperty->SetMoney( 0 );

	// 刷新一次
	pProperty->Refresh( );
	pEntity->NotifyPropertyRefresh( );

	pProperty->SetCurHP( pProperty->GetMaxHP( ) );
	pProperty->SetCurMP( pProperty->GetMaxMP( ) );

	// 设置回程点
	pProperty->GetTownPos( )->mLineID = 100;
	pProperty->GetTownPos( )->mMapID = 1;
	pProperty->GetTownPos( )->mPos = CWTPoint( pBeginner->mPosX1, pBeginner->mPosY1 );

	pProperty->SetSaveDate( CSceneLogic::GetSingletonPtr()->GetCurrentDay() );

	// 出生的时候挂任务
	CTaskModule::GetSingleton().SetDefaultTask( pEntity, "start_task" );

	// 出生的时候为第一次刷新双倍的时间点
	time_t tNow = time( NULL );
	pProperty->SetLastRefreshTime( (int) tNow );

	// ap刷新时间
	pProperty->SetLastRefreshAPTime( (int) tNow );

	pProperty->SetProLevel( MAXPROLEVEL );

	return ;
}

void CPropertyModule::BuffByDamage( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, EResultType vResultType, int vSkillType, int& vDamage, int& tDesDamage, int& tShieldDamage, bool& tMagicShield )
{
	if ( pDesEntity == NULL )
		return;

	CPropertyCharacter* pDesProperty = (CPropertyCharacter*) pDesEntity->GetProperty();

	//受到伤害删除Buff		
	int i = 0;
	int j = 0;
	CBuffList *tpBuff = pDesProperty->GetBuffList( );
	for( i = tpBuff->mBuffNumber - 1; ( i >= 0 ) && ( pDesEntity->IsAlive() == true ); i-- )
	{
		CTemplateBuff* tpBuffTpl = ( CTemplateBuff* )CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mBuffID );
		if( tpBuffTpl == NULL )
			continue;

		for( j = 0; j < (int)ARRAY_CNT( tpBuffTpl->mBuff ); j++ )
		{
			bool tIsBreak = false;
			int tRtn = -1;
			switch( tpBuffTpl->mBuff[ j ].mBuffFunc )
			{
				case CTemplateBuff::BUFFINC_NONE:
					{
						tIsBreak = true;
					}
					break;
				case CTemplateBuff::BUFFFUNC_DAMAGEDEVENT:
					{
						// 如果是反弹伤害,不触发该效果
						if ( vSkillType == 0 )
							break;

						if( pSrcEntity == NULL )
							break;

						CTemplateBuff* tpBuffObjTpl = ( CTemplateBuff* )CDataStatic::SearchTpl( tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] );
						if( tpBuffObjTpl == NULL )
							break;

						if ( RAND( SERVER_PERCENT_INT ) > tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ] )
							break;

						// 因为BUFF是从后往前遍历,新加BUFF不需要检查,所以可以插入BUFF
						pSrcEntity->EntityInsertBuff( pDesEntity, tpBuffObjTpl );
					}
					break;
				case CTemplateBuff::BUFFFUNC_OBLITERATEDAMAGE:
					{
						tRtn = pDesEntity->EntityRemoveBuff( tpBuffTpl->mTempID, tpBuff->mBuffList[ i ].mListID );
						LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
					}
					break;
				case CTemplateBuff::BUFFFUNC_REBOUNDDAMAGE:
					{
						if ( pSrcEntity != NULL )
						{
							// 陷阱攻击不会被反弹
							if ( pSrcEntity->GetEntityType() != ENTITYTYPE_PEDAL )
							{
								// TODO 判断伤害类型,只反弹技能攻击,诅咒,普通攻击
								if ( vSkillType == CTemplateSkill::SKILLTYPE_ATTACK
										|| vSkillType == CTemplateSkill::SKILLTYPE_CUSS
										|| vSkillType == CTemplateSkill::SKILLTYPE_NORMALATTACK )
								{
									if( RAND( SERVER_PERCENT_INT ) <= tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ] )
									{
										EntityDamaged( pDesEntity, pSrcEntity, (int) ( vDamage * tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] / SERVER_PERCENT_FLOAT ), RESULT_REBOUND );						
									}
								}
							}
						}
					}
					break;
				case CTemplateBuff::BUFFFUNC_MAGICSHIELD:
					{
						// 如果有魔法盾
						if ( tDesDamage > 0 )
						{
							int tRemain;
							if( tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] > 0 )
							{
								// 消耗蓝,则取出当前能够吸收伤害的数值
								tRemain = std::min( tpBuff->mBuffList[ i ].mParames[ j ], (int)( pDesProperty->GetCurMP( ) / tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] ) );
							}
							else
							{
								// 吸收伤害量为剩余量
								tRemain = tpBuff->mBuffList[ i ].mParames[ j ];
							}

							int tnDesMP = 0;
							if( tDesDamage >= tRemain )
							{
								// 如果总伤害大于等于能够吸收的伤害
								if ( tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] > 0 )
									tnDesMP = tRemain * tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ];
							}
							else
							{
								// 如果总伤害量小于能够吸收的伤害
								tRemain = tDesDamage;
								if( tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] > 0 )
									tnDesMP = tDesDamage * tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ];
							}
							
							// buff中剩余吸收值处理
							tpBuff->mBuffList[ i ].mParames[ j ] -= tRemain;
							tDesDamage -= tRemain;
							pDesEntity->AddFunResult( pDesEntity->GetEntityID(), FUNC_NONE, RESULT_OBSORB, true, tRemain );
							
							// 处理蓝消耗
							pDesEntity->ExpendMP( tnDesMP );
							
							// 如果buff中剩余量<=0,那么删除魔法盾
							if ( tpBuff->mBuffList[ i ].mParames[ j ] <= 0 )
							{
								pDesEntity->EntityRemoveBuff( tpBuff->mBuffList[ i ].mBuffID );
								LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
							}
						}
					}
					break;
				case CTemplateBuff::BUFFFUNC_DAMAGELESS:
					{
						// 抵消N次伤害
						if ( tDesDamage > 0 )
						{
							if( tpBuff->mBuffList[ i ].mParames[ j ] > 0 )
							{						
								tDesDamage = 0;
								pDesEntity->AddFunResult( ( ( pSrcEntity == NULL ) ? 0 : pSrcEntity->GetEntityID() ), FUNC_NONE, RESULT_DAMAGELESS );
								tpBuff->mBuffList[ i ].mParames[ j ]--;
							}
							if( tpBuff->mBuffList[ i ].mParames[ j ] == 0 )
							{
								pDesEntity->EntityRemoveBuff( tpBuffTpl->mTempID );
								LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
							}
						}
					}
					break;
				case CTemplateBuff::BUFFFUNC_PROTECTED:
					{
						if ( vResultType != RESULT_PROTECTED && tDesDamage > 0 )
						{
							int tEntityID = tpBuff->mBuffList[ i ].mParames2[ j ];
							CEntity* tpProtecter = CSceneLogic::GetSingleton( ).GetEntity( tEntityID );
							// 如果找到了实体，并且实体是活着的
							if ( tpProtecter != NULL && tpProtecter->IsAlive( ) == true )
							{
								CEntityCharacter* tpEntityCharacter = ( CEntityCharacter* )tpProtecter;
								CPropertyCharacter* tpProtecterProperty = ( CPropertyCharacter* ) tpEntityCharacter->GetProperty();
								if ( tpProtecterProperty != NULL )
								{
									int tDamage = (int) ( ( tpBuff->mBuffList[ i ].mParames[ j ] / SERVER_PERCENT_FLOAT ) * tDesDamage );
									tDesDamage -= tDamage;
									EntityDamaged( pSrcEntity, tpEntityCharacter, tDamage, RESULT_PROTECTED, vSkillType );
								}
							}
						}
					}
					break;
				case CTemplateBuff::BUFFFUNC_DAMAGEDEVENTSELF:
					{
						// 受到伤害令自己产生特殊效果
						if ( tDesDamage > 0 )
						{
							if ( RAND(SERVER_PERCENT_INT) < tpBuff->mBuffList[ i ].mParames[ j ] )
							{
								CTemplateBuff* tpBuffTpl2 = (CTemplateBuff*) CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mParames2[ j ] );
								if ( tpBuffTpl2 == NULL )
								{
									LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Buff Template Error! TempID = %d", __LK_FILE__, __LINE__, __FUNCTION__, tpBuff->mBuffList[ i ].mParames2[ j ] );
									break;
								}

								pDesEntity->EntityInsertBuff( pDesEntity, tpBuffTpl2 );
							}
						}
					}
					break;
				case CTemplateBuff::BUFFFUNC_SAVEDAMAGE:
					{
						if ( tDesDamage > 0 )
						{
							int tSaveDamage = std::max( (int)( tDesDamage * tpBuff->mBuffList[ i ].mParames[ j ] / SERVER_PERCENT_FLOAT ), 1 );
							tpBuff->mBuffList[ i ].mBackDamage += tSaveDamage;
							tDesDamage -= tSaveDamage;
						}
					}
					break;
				default:
					break;
			}
			if ( pDesProperty->GetCurHP( ) <= 0 )
			{
				tDesDamage = 0;
				return;
			}

			//TODO: 如果删除中间删除buff. 那么这里不能减i. 否则会减2次。
			if( tRtn >= 0 )
				//i--;
			if ( tIsBreak == true )
				break;
		}		
	} 
}

//***************************************
// Function Name : OnMessageObtainDiploidRequest
// Description 	 : 领取双倍时间
// Input Params  :
// Output Params :
// Return Type   :
// Modified Time : 2/16/2009
//***************************************

void CPropertyModule::OnMessageObtainDiploidRequest(CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessageObtainDiploidTimeRequest* tpRequest = ( CMessageObtainDiploidTimeRequest* ) pMessage->msgpara();
	LK_ASSERT( tpRequest != NULL, return );
	
	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpRequest->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpRequest->npcentityid(), __FUNCTION__ );
		return;
	}

	if ( tpEntity->IsFunNpc() == false )
	{
		return ;
	}
	
	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	CTemplateDiploidTimeTable* tpTplDiploid = ( CTemplateDiploidTimeTable* ) CDataStatic::SearchTpl( tpTplNpc->mDiploidTime );
	LK_ASSERT( tpTplDiploid != NULL, return );
	
	// 检查越界
	if ( tpRequest->index() >= MAX_DIPLOID_WAYS || tpRequest->index() >= ARRAY_CNT(tpTplDiploid->mBuffID) )
	{
		LOG_ERROR( "pro", "player %s:%d get diploid index %d overfolw", pPlayer->GetCharNameShow(), pPlayer->GetCharID(), tpRequest->index() );
		return ;
	}

	CMessage tMessage;
	CMessageObtainDiploidResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_OBTAINDIPLOID );
	tMessage.set_msgpara( (long) &tPara );

	// 检查剩余的领双时间
	int tTotalTime = tpSrcProperty->GetTotalDiploid();
	int tLeftTime = tTotalTime - tpSrcProperty->GetDiploid();
	
	// 检查是否有冻结时间
	if ( tpSrcProperty->IsFreezeDouble() )
	{
		tPara.set_rtncode( ERROR_PROPERTY_HASFREEZE );
		tPara.set_time( tLeftTime );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return ;
	}
	
	// 将要领取的时间
	int tTime = tpTplDiploid->mBuffID[ tpRequest->index() ];
	if ( tTime <= LK_ZERO )
	{
		tPara.set_rtncode( ERROR_PROPERTY_NOTVALIDDIPLOID );
		tPara.set_time( tLeftTime );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return ;
	}

	// 剩余的双倍不够此次领取
	if ( tTime > tLeftTime )
	{
		tPara.set_rtncode( ERROR_PROPERTY_DIPLOIDLESS );
		tPara.set_time( tLeftTime );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return ;
	}	

	// 身上还有的双倍时间
	int tLeftDiploid = tpSrcProperty->GetValidDiploid();	

	// 领取上限
	int tMaxDiploid = tTime + tLeftDiploid;
	if ( tMaxDiploid > tpTplDiploid->mValidMax )
	{
		tPara.set_rtncode( ERROR_PROPERTY_OVERFLOWOBTAIN );
		tPara.set_time( tLeftTime );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return ;
	}	

	// 记录累计已经领取的双倍时间
	int tDiploidTime = std::min( ( tTime + tpSrcProperty->GetDiploid() ), tTotalTime );
	tpSrcProperty->SetDiploid( tDiploidTime );

	// 如果已有领取，清除计时器，重新设置
	int tTimerID = 0;
	tTimerID = tpSrcProperty->GetDiploidTimerID();
	if ( tTimerID != 0 )
	{
		pPlayer->GetTimerReciver()->TimeOutOneTimer( tTimerID );
		pPlayer->GetTimerReciver()->ClearTimer( tTimerID );	
		tpSrcProperty->SetDoubleTimerID( LK_ZERO );
	}

	int tValidTime = std::min( (tTime + tLeftDiploid), tpTplDiploid->mValidMax );
	tpSrcProperty->SetValidDiploid( tValidTime );

	// 如果有系统双倍，这里跳过
	if( tpSrcProperty->IsActivityDouble() )
	{
		; // do sth
	}
	else
	{
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY,0,0,0};
		tTimerID = pPlayer->GetTimerReciver()->SetTimer( pPlayer->get_id(), TIMER_DIPLOID_TIME, tValidTime, 1, nTimerOtherInfo );
		tpSrcProperty->SetDoubleTimerID( tTimerID );
	}

	// 将TimerID维护起来，用来冻结时，清除计时器
	tpSrcProperty->SetDoubleTimeState( true );	// 处于双倍经验状态
	tpSrcProperty->SetDoubleFreezeState( false );	// 非冻结状态


	// 领取成功
	tPara.set_rtncode( ERROR_PROPERTY_DIPLOIDSUCCESS );
	tPara.set_time( tValidTime );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

//***********************************
// FunctionName : OnMessageFreezeDiploidRequest 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/27/2009]
//***********************************

void CPropertyModule::OnMessageFreezeDiploidRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	CMessageFreezeDiploidRequest* tpRequest = ( CMessageFreezeDiploidRequest* ) pMessage->msgpara();
	LK_ASSERT( tpRequest != NULL, return );

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
//	CEntity* tpEntity = ( CEntity* ) CSceneObjManager::GetSingleton().GetObject( tpRequest->npcentityid() );
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		tpRequest->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}
	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpRequest->npcentityid(), __FUNCTION__ );
		return;
	}

	if ( tpEntity->IsFunNpc() == false )
	{
		return ;
	}

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	LK_ASSERT( tpTplNpc != NULL, return );

	CTemplateDiploidTimeTable* tpTplDiploid = ( CTemplateDiploidTimeTable* ) CDataStatic::SearchTpl( tpTplNpc->mDiploidTime );
	LK_ASSERT( tpTplDiploid != NULL, return );

	// 冻结
	if ( tpRequest->type() == true )
	{
		if ( tpSrcProperty->IsFreezeDouble() )
		{
			// 已经冻结，不需要
			SendProErrorNotice( pPlayer, ERROR_PROPERTY_NOTNEEDFREEZE );
			return ;
		}		

		// 如果处于系统双状态,不判断timerid,因为timerid之前肯定已经被强制超时后删除了
		int tTimerID = tpSrcProperty->GetDiploidTimerID();
		if ( tTimerID != LK_ZERO )
		{
			pPlayer->GetTimerReciver()->TimeOutOneTimer( tTimerID );
			pPlayer->GetTimerReciver()->ClearTimer( tTimerID );
		}	

		tpSrcProperty->SetDoubleTimerID( 0 );
		tpSrcProperty->SetDoubleTimeState( true );
		tpSrcProperty->SetDoubleFreezeState( true );
	}
	// 解冻
	else
	{
		if ( tpSrcProperty->UnFreezeDouble() )
		{
			// 非冻结状态，不需要解冻
			SendProErrorNotice( pPlayer, ERROR_PROPERTY_NOTFREEZE );
			return ;
		}
		// 计时器开始工作，设置状态
		tpSrcProperty->SetDoubleTimeState( true );
		tpSrcProperty->SetDoubleFreezeState( false );


		// 如果处于系统双状态，只响应请求，不开启定时器
		if( tpSrcProperty->IsActivityDouble() )
		{
			; // do sth
		}
		else
		{
			int nOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, 0, 0, 0 };
			int tTimerID = pPlayer->GetTimerReciver()->SetTimer( pPlayer->get_id(), TIMER_DIPLOID_TIME, tpSrcProperty->GetValidDiploid(), 1, nOtherInfo );
			if ( tTimerID == LK_ZERO )
			{
				LOG_ERROR( "pro", "create diploid timer failed.[%s : %d]", __LK_FILE__, __LINE__ );
				return ;
			}		
			tpSrcProperty->SetDoubleTimerID( tTimerID );
		}

	}	

	CMessage tMessage;
	CMessageFreezeDiploidResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_FREEZEDIPLOID );
	tPara.set_type( tpRequest->type() );
	tPara.set_time( tpSrcProperty->GetValidDiploid() );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

//***************************************
// Function Name : OnMessageQueryDiploidTimeRequest
// Description 	 : 查询剩余的领双时间
// Input Params  :
// Output Params :
// Return Type   :
// Modified Time : 2/19/2009
//***************************************

void CPropertyModule::OnMessageQueryDiploidTimeRequest(CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessageQueryRemainDiploid* tpRequest = ( CMessageQueryRemainDiploid* ) pMessage->msgpara();
	LK_ASSERT( tpRequest != NULL, return );

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
//	CEntity* tpEntity = ( CEntity* ) CSceneObjManager::GetSingleton().GetObject( tpRequest->npcentityid() );
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpRequest->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}
	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpRequest->npcentityid(), __FUNCTION__ );
		return;
	}

	if ( tpEntity->IsFunNpc() == false )
	{
		return ;
	}
	
	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "领双服务NPC不存在！" );
		return ;
	}

	CTemplateDiploidTimeTable* tpTplDiploid = ( CTemplateDiploidTimeTable* ) CDataStatic::SearchTpl( tpTplNpc->mDiploidTime );
	LK_ASSERT( tpTplDiploid != NULL, return );

	int tTotalTime = tpSrcProperty->GetTotalDiploid();
	int tLeftTime = std::max( LK_ZERO, tTotalTime - tpSrcProperty->GetDiploid() );

	CMessage tMessage;
	CMessageRemainDiploidNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_REMAINTIMENOTICE );
	tPara.set_time( tLeftTime );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

void CPropertyModule::CheckBuffEntityUseSkill( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity )
{
	if ( pSrcEntity == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ] pSrcEntity or pSrcProperty is NULL!", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	int tRemoveBuffIDList[ CBuffList::MAX_BUFF_NUM ] = { 0 };
	int tRemoveListIDList[ CBuffList::MAX_BUFF_NUM ] = { 0 }; 
	int tRemoveBuffCount = 0;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	CBuffList *tpBuffList = pSrcProperty->GetBuffList( );
	
	for ( int i = ( tpBuffList->mBuffNumber - 1 ); ( i >= 0 ) && ( pSrcEntity->IsAlive() ); i-- )
	{
		CTemplateBuff* tpBuff = (CTemplateBuff*)CDataStatic::SearchTpl( tpBuffList->mBuffList[i].mBuffID );
		if ( tpBuff != NULL )
		{
			for ( int j = 0; j < (int)ARRAY_CNT( tpBuff->mBuff ); j++ )
			{
				if ( tpBuff->mBuff[j].mBuffFunc == 0 )
					continue;

				switch ( tpBuff->mBuff[j].mBuffFunc )
				{
					// 判断有没有成功施法，获得一个DEBUFF的状态
				case CTemplateBuff::BUFFFUNC_FIREEVENT:
					{
						CTemplateBuff* tpBuffInsert = (CTemplateBuff*)CDataStatic::SearchTpl( tpBuff->mBuff[j].mBuffParam[0] );
						if ( tpBuffInsert == NULL )
						{
							LOG_DEBUG( "pro", "[ %s : %d ][ %s ] can't find CTemplateBuff : BuffID ( %d )", 
								__LK_FILE__, __LINE__, __FUNCTION__, tpBuff->mBuff[j].mBuffParam[0] );
							continue;
						}

						pSrcEntity->EntityInsertBuff( pSrcEntity, tpBuffInsert );

						if ( tpBuffList->mBuffList[i].mParames[ j ] != 0 )
						{
							tpBuffList->mBuffList[i].mParames[ j ]--;

							if ( tpBuffList->mBuffList[i].mParames <= 0 )
							{
								int tRtn = pSrcEntity->EntityRemoveBuff( tpBuff->mTempID );
								LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
								if( tRtn >= 0 )
									continue;
							}
						} 
					}
					break;
					// 攻击时有几率附带特殊效果
				case CTemplateBuff::BUFFFUNC_ATTACKEVENT:
					{
						if ( pDesEntity == NULL )
							break;
						
						int tRate = RAND(SERVER_PERCENT_INT);
						if ( tRate < tpBuff->mBuff[j].mBuffParam[0] )
						{
							CTemplateBuff* tpBuffInsert = (CTemplateBuff*)CDataStatic::SearchTpl( tpBuff->mBuff[j].mBuffParam[1] );
							if ( tpBuffInsert == NULL )
							{
								LOG_DEBUG( "pro", "ATTACKEVENT : can't find CTemplateBuff : BuffID ( %d )\n", tpBuff->mBuff[j].mBuffParam[1] );
								continue;
							}

							CPropertyCharacter* tpDesProperty = ( CPropertyCharacter* )pDesEntity->GetProperty();
							if ( tpDesProperty == NULL )
							{
								LOG_DEBUG( "pro", "ATTACKEVENT : can't find tpDesProperty : PropertyID ( %d )\n", pDesEntity->GetEntityID( ) );
								continue;
							}
							pDesEntity->EntityInsertBuff( pSrcEntity, tpBuffInsert );
						}
					}
					break;
				case CTemplateBuff::BUFFFUNC_USESKILL_REMOVE:
					{
						if( tRemoveBuffCount >= ( int )ARRAY_CNT( tRemoveBuffIDList ) )
						{
							continue;
						}
						tRemoveBuffIDList[ tRemoveBuffCount ] = tpBuffList->mBuffList[i].mBuffID;
						tRemoveListIDList[ tRemoveBuffCount ] = tpBuffList->mBuffList[i].mListID;	
						tRemoveBuffCount++;
					}
					break;

				default:
					break;
				}
			}
		}
	}

	for( int i = 0; i < tRemoveBuffCount && i < ( int )ARRAY_CNT( tRemoveBuffIDList ); i++ )
	{
		pSrcEntity->EntityRemoveBuff( tRemoveBuffIDList[ i ], tRemoveListIDList[ i ] );
	} 
}

// 获得功勋
// Src为杀死者， Des为被杀者
void CPropertyModule::PlayerObtainHonor( CEntityPlayer* pSrcEntity, CEntityPlayer* pDesEntity, int* pMemberList, int vMemberCount )
{
	if ( pSrcEntity == NULL || pDesEntity == NULL )
		return;

	CPropertyPlayer* pSrcProperty = (CPropertyPlayer*) pSrcEntity->GetProperty();
	CPropertyPlayer* pDesProperty = (CPropertyPlayer*) pDesEntity->GetProperty();

	CTemplateHonorObtain *tpHonor = (CTemplateHonorObtain*)CDataStatic::GetTemp( TEMP_HONOROBTAIN );
	if ( tpHonor == NULL )
		return;

	// 如果被杀者等级 < 30, 无功勋
	if ( pDesProperty->GetLevel( ) < MIN_HONOR_LEVEL )
		return;
	// 如果杀死本国玩家，无功勋
	if ( pSrcEntity->GetNationality( ) == pDesEntity->GetNationality( ) )
		return;

	if( ( pSrcEntity->IsHandle( UN_HANDLE_HONOR ) == false ) || ( pDesEntity->IsHandle( UN_HANDLE_HONOR ) == false ) )
	{
		return;
	}
	// 如果最近杀过，无功勋
	int tNowTime = time( NULL );
	bool tFull = true;
	int i = 0;
	int tLastTime = tNowTime;
	int tLastIndex = 0;
	for ( ; i < pDesProperty->GetKillSize( ); i++ )
	{
		KillData *tKill = pDesProperty->GetKill( i );
		if ( tKill->mKillID == 0 )
		{
			tFull = false;
			break;
		}
		if ( tKill->mKillID == (int)pSrcEntity->GetCharID( ) )			 
		{
			int tOldTime = tKill->mKillTime;
			if ( tNowTime - tOldTime <= HONOR_REFRESHTIME )
				return;
		}
		if ( tLastTime > tKill->mKillTime )
		{
			tLastTime = tKill->mKillTime;
			tLastIndex = i;
		}
	}	
	// 如果满了，替换最久的为当前的
	if ( tFull == true )
	{
		pDesProperty->GetKill( tLastIndex )->mKillID = pSrcEntity->GetCharID( );
		pDesProperty->GetKill( tLastIndex )->mKillTime = tNowTime;
	}
	else
	{
		pDesProperty->GetKill( i )->mKillID = pSrcEntity->GetCharID( );
		pDesProperty->GetKill( i )->mKillTime = tNowTime;
	}

	// 记录国战击杀
	if ( IS_BATTLE_LINE_ID( CSceneLogic::GetSingleton().GetLineID() ) == true )
	{
		pSrcProperty->SetWarKill( pSrcProperty->GetWarKill() + 1 );
		CMessage tGateMessage;
		CMessageObtainWarHonorNotify tGateNotify;
		tGateMessage.mutable_msghead()->set_messageid( ID_S2G_NOTIFY_OBTAINWARHONOR );
		tGateMessage.set_msgpara( (uint32)&tGateNotify );

		WarHonorData *pHonorData = tGateNotify.add_warhonor();
		pHonorData->set_charid( pSrcEntity->GetCharID() );
		pHonorData->set_warhonor( pSrcProperty->GetTodayWar() );
		pHonorData->set_warkill( pSrcProperty->GetWarKill() );
		tGateNotify.set_iskill( 1 );
		CSceneLogic::GetSingleton().Send2Gate( &tGateMessage );
	}
	
	//CMessageChangeHonorNotify    MsgChangeHonor;
	//CMessage                    MsgHead;

	unsigned int tTotalLevel = pSrcProperty->GetLevel( );		// 队伍中的等级和
	unsigned int tMaxLevel	 = pSrcProperty->GetLevel( );		// 队伍中的最大等级
	CPropertyPlayer*		tpMemberProperty[ TEAMNUM ]		= { NULL };
	CEntityPlayer*			tpMemberEntity[ TEAMNUM ]		= { NULL };
	// 如果玩家在队伍中
	int tCount = 0;
	if ( pMemberList != NULL )
	{		
		for ( int i = 0; i < vMemberCount && i < TEAMNUM; i ++ )
		{
			CEntityPlayer* tpEntity = (CEntityPlayer*) CSceneLogic::GetSingleton().GetPlayerByCharID( pMemberList[ i ] );
			if ( tpEntity == NULL )
			{
				continue;
			}

			CPropertyPlayer* tpProperty = (CPropertyPlayer*) tpEntity->GetProperty();
			if ( tpProperty == NULL )
			{
				continue;
			}

			// 如果该成员超过的分配距离，那么不参与分配计算
			if ( pDesEntity->IsWithinDistance( tpEntity, TEAM_VALID_DISTANCE ) == false  )
			{
				continue;
			}

			if ( tpEntity->IsAlive() == false )
			{
				continue;
			}

			tpMemberProperty[ tCount ]	= tpProperty;
			tpMemberEntity[ tCount ]	= tpEntity;	
			tCount++;

			if ( tpProperty == pSrcProperty )
				continue;

			tTotalLevel += tpProperty->GetLevel( );
			if ( tMaxLevel < tpProperty->GetLevel( ) )
				tMaxLevel = tpProperty->GetLevel( );
		}
	}

	int tChangeHonor = 0;
	int tLevelDiff = pSrcProperty->GetLevel( ) - pDesProperty->GetLevel( );
	// 如果是在本国
	if ( pSrcEntity->GetNationality( ) == pSrcEntity->GetLineID( ) )
	{
		if ( tLevelDiff < 0 )
		{
			tChangeHonor = tpHonor->mInLowExp[ -1 * tLevelDiff ];
		}
		else
		{
			tChangeHonor = tpHonor->mInHighExp[ tLevelDiff ];
		}
	}
	else if ( pSrcEntity->GetNationality( ) != pSrcEntity->GetLineID( ) )
	{
		if ( tLevelDiff < 0 )
		{
			tChangeHonor = tpHonor->mOutLowExp[ -1 * tLevelDiff ];
		}
		else
		{
			tChangeHonor = tpHonor->mOutHighExp[ tLevelDiff ];
		}
	}	

	tChangeHonor += tpHonor->mBasicExp[ pDesProperty->GetLevel( ) ];

	tChangeHonor = (int)( tChangeHonor * ( 1.0 + ( tCount - 1 ) * 0.1 ) );

	// 如果被杀者不能提供功勋
	if ( pDesProperty->GetOutHonPerDay( ) >= tpHonor->mOutLimit )
		tChangeHonor = 0;

	CTemplateAddPKTable *pTable = (CTemplateAddPKTable*)CDataStatic::GetTemp( TEMP_ADDPKTABLE );
	int tStatus = CWorldModule::GetSingleton().GetNationStatus( pSrcEntity->GetLineID() - 1, pDesEntity->GetLineID() - 1 );
	float tRate = 0.0;
	if ( pTable != NULL )
	{		
		if ( tStatus == WORLD_STATUS_NONE )
		{
			tRate = pTable->mKPChangeHonor / SERVER_PERCENT_FLOAT;
		}
		else if ( tStatus == WORLD_STATUS_FRIEND )
		{
			tRate = pTable->mKFChangeHonor / SERVER_PERCENT_FLOAT;
		}
		else if ( tStatus == WORLD_STATUS_WAR )
		{
			tRate = pTable->mKWChangeHonor / SERVER_PERCENT_FLOAT;
		}
	}
	tChangeHonor *= tRate;
	
	// 不管有没有队伍，所有的成员都在tpMemberProperty这个数组中，就算没有队伍，该数组就一项成员
	for ( int i = 0; i < tCount; i ++ )
	{
		CEntityPlayer* tpEntity = tpMemberEntity[ i ];
		CPropertyPlayer* tpProperty = tpMemberProperty[ i ];
		if ( tpEntity == NULL || tpProperty == NULL )
			continue;
		int tSrcOldHonor = tpProperty->GetHonor( );

		int tTempHonor = std::max ( (int)( tChangeHonor * ( ( tpProperty->GetLevel( ) + 10.0 ) / ( tTotalLevel + 10 * tCount ) ) ), 1 );

		int tAddPercent = 0;

		if ( ( CWorldModule::GetSingleton().IsInGT( pSrcEntity->GetNationality(), pDesEntity->GetNationality() ) || 
			 CWorldModule::GetSingleton().IsInLW( pSrcEntity->GetNationality(), pDesEntity->GetNationality() ) ) &&
			 ( CSceneLogic::GetSingleton().GetLineID() == pSrcEntity->GetNationality() ) )
		{
			tAddPercent += SERVER_PERCENT_INT;
		}

		// 如果有增加功勋获得百分比状态(通过buff添加)
		if ( tpProperty->GetStateParam( STATE_INCHONORSCALE ).mInState == true )
		{
			tAddPercent += tpProperty->GetStateParam( STATE_INCHONORSCALE ).mParames1;
		}

		tTempHonor = tTempHonor * 
				( ( SERVER_PERCENT_INT + tAddPercent ) / SERVER_PERCENT_INT );

		bool tOverFlow = false;
		// 如果超出总上限
		if ( tTempHonor > 0 && ( tpProperty->GetHonor( ) + tTempHonor ) > tpHonor->mInLimit )
		{
			tTempHonor = std::max( tpHonor->mInLimit - tpProperty->GetHonor( ), 0 );
			tOverFlow = true;
		}		

		tpProperty->SetHonor( tpProperty->GetHonor( ) + tTempHonor );
		tpProperty->SetTodayHonor( tpProperty->GetTodayHonor( ) + tTempHonor );
		if ( tTempHonor > 0 )
		{
			tpProperty->SetInHonPerDay( tpProperty->GetInHonPerDay( ) + tTempHonor );
		}		

		if ( tpProperty->GetHonor( ) < 0 )
		{
			tpProperty->SetHonor( 0 );
		}		

		// 如果变化不为0，发送
		// 超出上限也要记人头
		if ( tpProperty->GetHonor( ) - tSrcOldHonor != 0 || tOverFlow == true )
		{

			// 记录排行榜
			// 判断杀敌
			// 是否杀了外国人
			if ( tpEntity->GetNationality() != pDesEntity->GetNationality() )
			{
				int DiffLevel = tpEntity->GetLevel() - pDesEntity->GetLevel();
				if ( !tpEntity->IsOverseas() ) // 在国内
				{
					if (DiffLevel <= MIN_HONOR_LEVEL)      // 等级差在30以内
					{
						tpProperty->SetKillNumIn( tpProperty->GetKillNumIn() + 1);
						tpProperty->SetTodayKillEnemyNumIn( tpProperty->GetTodayKillEnemyNumIn() + 1);
					}
				}
				else
				{
					if ( DiffLevel <= MIN_HONOR_LEVEL )
					{
						tpProperty->SetKillNumOut( tpProperty->GetKillNumOut() + 1);
						tpProperty->SetTodayKillEnemyNumOut( tpProperty->GetTodayKillEnemyNumOut() + 1);
					}
					
					// 在其他阵营
					if (tTempHonor > 0)
					{
						// 发送弱势阵营计算所需的荣誉积分
						CWorldModule::GetSingleton().m_WeakProtecter.Send2GatePlayerGetHonerScoreNotify(
							tpEntity->GetNationality(),
							tpEntity->GetEntityID(),
							tTempHonor);
					}

				}
			}

			// 通知任务<荣誉击杀>
			CTaskModule::GetSingleton().FireEvent( tpEntity, EVENT_KILLFOREIGNER, SPECIALID_KILLFOREIGNER );


			SendObtainHonorNotice( tpEntity, tpProperty->GetHonor( ) - tSrcOldHonor );
	
		}

	}	

	int tDesOldHonor = pDesProperty->GetHonor( );
	// 被杀者扣功勋
	if ( tLevelDiff < 0 )
	{
		pDesProperty->SetHonor( pDesProperty->GetHonor( ) + tpHonor->mLostHighExp[ -1 * tLevelDiff ] * tRate );		
	}
	else
	{
		pDesProperty->SetHonor( pDesProperty->GetHonor( ) +  tpHonor->mLostLowExp[ tLevelDiff ] * tRate );
	}
	pDesProperty->SetOutHonPerDay( pDesProperty->GetOutHonPerDay( ) + 1 );

	if ( pDesProperty->GetHonor( ) < 0 )
	{
		pDesProperty->SetHonor( 0 );
	}

	if ( pDesProperty->GetHonor( ) - tDesOldHonor != 0 )
	{
		SendObtainHonorNotice( pDesEntity, pDesProperty->GetHonor( ) - tDesOldHonor );
	}
	
}

// 玩家得到功勋
void CPropertyModule::OnPlayerObtainHonor( CEntityPlayer* pPlayer, int vHonor )
{
	if ( vHonor <= 0 || pPlayer == NULL )
		return;

	CTemplateHonorObtain *tpHonor = (CTemplateHonorObtain*)CDataStatic::GetTemp( TEMP_HONOROBTAIN );
	if ( tpHonor == NULL )
		return;

	// 如果有家族记录荣耀值增长所需要的ap值
	if ( pPlayer->GetFamilyID() > 0 )
	{
		CMemberInfo *tpMemberInfo = CFamilyModule::GetSingleton().GetFamilyMemberInfo( pPlayer );
		if ( tpMemberInfo != NULL )
		{
			tpMemberInfo->mApGloryNeeded += vHonor;
		}
		//pPlayer->SetApGloryNeeded( pPlayer->GetApGloryNeeded() + vHonor );
	}
	
	CPropertyPlayer* tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	if ( vHonor > 0 && ( tpProperty->GetHonor( ) + vHonor ) > tpHonor->mInLimit )
	{
		vHonor = std::max( tpHonor->mInLimit - tpProperty->GetHonor( ), 0 );
	}
	
	tpProperty->SetHonor( tpProperty->GetHonor() + vHonor );
	tpProperty->SetTodayHonor( tpProperty->GetTodayHonor( ) + vHonor );

	SendObtainHonorNotice( pPlayer, vHonor );
}

// 功勋换经验
void CPropertyModule::PlayerChangeHonorToExp( CEntityPlayer *pPlayer, int vHonor )
{
	if ( pPlayer == NULL )
		return;
	CPropertyPlayer *pProperty = (CPropertyPlayer*)pPlayer->GetProperty( );
	if ( pProperty == NULL )
		return;
	CEntityNpc *pNpc = (CEntityNpc*)CSceneObjManager::GetSingletonPtr()->GetObject( pProperty->GetTalkNpcEntityID( ) );
	if( pNpc == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find obj %d", __LK_FILE__, __FUNCTION__, __LINE__,  pProperty->GetTalkNpcEntityID( ) );
		return ;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mHonorService == 0 )
	{
		return;
	}

	if ( pProperty->GetServiceStatus( ) != SERVICE_HONOR )
	{
		return;
	}
	// 修改为-功勋不能兑换经验
	if ( vHonor <= 0 || vHonor > pProperty->GetHonor( ) )
		return;
	CTemplateHonorToExp *tpHonor = (CTemplateHonorToExp*)CDataStatic::GetTemp( TEMP_HONORTOEXP );
	if ( tpHonor == NULL )
		return;

	// 超过每日上限不能兑换
	if ( vHonor + pProperty->GetExpHonor() > tpHonor->mExpLimit )
	{
		return;
	}
	
	int tCharID = pPlayer->GetCharID( );

	pPlayer->InitFunResult( );
	int nFinalExp = PlayerObtainExp( pPlayer, tpHonor->mExp[ pProperty->GetLevel( ) ] * vHonor, EXPREASON_EXCHANGE, &tCharID, 1 );
	if ( nFinalExp > 0)
	{
		LogEventGetExpByHornor(pPlayer, 
				tpHonor->mExp[ pProperty->GetLevel( ) ] * vHonor, nFinalExp, vHonor, tpHonor->mTempID);	
	}	

	ResultListSend( );

	pProperty->SetHonor( pProperty->GetHonor( ) - vHonor );
	pProperty->SetExpHonor( pProperty->GetExpHonor() + vHonor );

	SendObtainHonorNotice( pPlayer, -1 * vHonor );
}

void CPropertyModule::PlayerReliveHonor( CEntityPlayer* pPlayer, CPropertyPlayer* pProperty )
{
	CTemplateHonorObtain *tpHonor = (CTemplateHonorObtain*)CDataStatic::GetTemp( TEMP_HONOROBTAIN );
	if ( tpHonor == NULL )
		return;
	CPropertyPlayer *pProPlayer = (CPropertyPlayer*)pProperty;
	int tHonor = 0;
	if ( pPlayer->GetNationality( ) == pPlayer->GetLineID( ) )
		tHonor = tpHonor->mInDieExp;
	else if ( pPlayer->GetNationality( ) != pPlayer->GetLineID( ) )
		tHonor = tpHonor->mOutDieExp;
	else
		tHonor = tpHonor->mBorderDieExp;
	// 如果超出每日获得上限
	if ( ( pProPlayer->GetHonor( ) + tHonor ) > tpHonor->mInLimit )
	{
		tHonor = std::max( tpHonor->mInLimit - pProPlayer->GetHonor( ), 0 );
	}
	pProPlayer->SetHonor( pProPlayer->GetHonor( ) + tHonor );
	pProPlayer->SetTodayHonor( pProPlayer->GetTodayHonor( ) + tHonor );
	pProPlayer->SetInHonPerDay( pProPlayer->GetInHonPerDay( ) + tHonor );

	if ( tHonor > 0 )
	{
		SendObtainHonorNotice( pPlayer, tHonor );
	}
}

void CPropertyModule::CheckBuffGetSkillAttackDesEntity( CEntityCharacter* pDesEntity, CTemplateSkill* vpSkill, int& tDesBuffFix, int& tDesBuffPer )
{
	if ( pDesEntity == NULL || vpSkill == NULL )
		return;

	CPropertyCharacter* pDesProperty = (CPropertyCharacter*) pDesEntity->GetProperty();
	CBuffList *tpBuff = pDesProperty->GetBuffList( );

	for( size_t i = 0; i < tpBuff->mBuffNumber; i++ )
	{
		CTemplateBuff* tpBuffTpl = (CTemplateBuff*)CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mBuffID );
		if( tpBuffTpl == NULL )
			continue;
		for( int j = 0; j < (int)ARRAY_CNT( tpBuffTpl->mBuff ); j++ )
		{
			switch( tpBuffTpl->mBuff[ j ].mBuffFunc )
			{
			case CTemplateBuff::BUFFFUNC_INCGENERDAMAGEPER:
				{
					if( vpSkill->mGenerID == tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] )
						tDesBuffPer += tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ];
				}
				break;
			//case CTemplateBuff::BUFFFUNC_INCGENERDAMAGEFIX:
			//	{
			//		if( vpSkill->mGenerID == tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] )
			//			tDesBuffFix += tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ];
			//	}
			//	break;
			default:
				break;
			}
		}
	}
}

void CPropertyModule::CheckBuffGetSkillAttackSrcEntity( CEntityCharacter* pSrcEntity, CTemplateSkill* vpSkill, int& tDeathRate, int& tDeathValue, int& tIgnoreRate, int tIgnoreType )
{
	if ( pSrcEntity == NULL || vpSkill == NULL )
		return;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	CBuffList *tpBuff = pSrcProperty->GetBuffList( );

	tIgnoreRate = 0;

	for ( size_t i = 0; i < tpBuff->mBuffNumber; i++  )
	{
		CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mBuffID );
		if ( tpBuffTpl == NULL )
			continue;
		for ( int j = 0; j < (int)ARRAY_CNT( tpBuffTpl->mBuff ); j++ )
		{
			int buff_continue = 1;
			switch ( tpBuffTpl->mBuff[ j ].mBuffFunc )
			{
			case CTemplateBuff::BUFFFUNC_NEXTDEATHHITFIX:
				{
					// 增加下一次攻击的致命等级固定值
					tDeathRate += tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ];
					// 增加次数减1
					tpBuff->mBuffList[ i ].mParames[ j ]--;

					// 如果次数为0了,则删除BUFF
					if ( tpBuff->mBuffList[ i ].mParames[ j ] <= 0 )
					{
						pSrcEntity->EntityRemoveBuff( tpBuffTpl->mTempID );
						LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
						buff_continue = 0;
						
					}
				}
				break;
			case CTemplateBuff::BUFFFUNC_NEXTDEATHRATEFIX:
				{
					// 增加下一次攻击的致命伤害固定值
					tDeathValue += tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ];
					// 增加次数减1
					tpBuff->mBuffList[ i ].mParames[ j ]--;

					// 如果次数为0了,则删除BUFF
					if ( tpBuff->mBuffList[ i ].mParames[ j ] <= 0 )
					{
						pSrcEntity->EntityRemoveBuff( tpBuffTpl->mTempID );
						LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
						buff_continue  = 0;
					}
				}
				break;
			case CTemplateBuff::BUFFFUNC_IGNOREPDEFENCE:
			case CTemplateBuff::BUFFFUNC_IGNOREMDEFENCE:
				{
					if ( tpBuffTpl->mBuff[ j ].mBuffFunc == tIgnoreType && tIgnoreRate < tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ] )
					{
						int tRand = RAND(SERVER_PERCENT_INT);
						if ( tRand < tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ] )
						{
							tIgnoreRate = tpBuffTpl->mBuff[ j ].mBuffParam[ 1 ];
						}
					}
				}
				break;
			default:
				break;
			}
			if( buff_continue != 1 )
			{
				break;
			}
		}
	}
}

void CPropertyModule::CheckBuffGetNormalAttackSrcEntity( CEntityCharacter* pSrcEntity, int& tDeathRate, int& tDeathValue )
{
	if ( pSrcEntity == NULL )
		return;

	CPropertyCharacter* pSrcProperty = (CPropertyCharacter*) pSrcEntity->GetProperty();
	CBuffList *tpBuff = pSrcProperty->GetBuffList( );

	for ( size_t i = 0; i < tpBuff->mBuffNumber; i++  )
	{
		CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( tpBuff->mBuffList[ i ].mBuffID );
		if ( tpBuffTpl == NULL )
			continue;
		for ( int j = 0; j < (int)ARRAY_CNT( tpBuffTpl->mBuff ); j++ )
		{
			switch ( tpBuffTpl->mBuff[ j ].mBuffFunc )
			{
			case CTemplateBuff::BUFFFUNC_NEXTDEATHHITFIX:
				{
					// 增加下一次攻击的致命等级固定值
					tDeathRate += tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ];
					// 增加次数减1
					tpBuff->mBuffList[ i ].mParames[ j ]--;

					// 如果次数为0了,则删除BUFF
					if ( tpBuff->mBuffList[ i ].mParames[ j ] <= 0 )
					{
						pSrcEntity->EntityRemoveBuff( tpBuffTpl->mTempID );
						LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
					}
				}
				break;
			case CTemplateBuff::BUFFFUNC_NEXTDEATHRATEFIX:
				{
					// 增加下一次攻击的致命伤害固定值
					tDeathValue += tpBuffTpl->mBuff[ j ].mBuffParam[ 0 ];
					// 增加次数减1
					tpBuff->mBuffList[ i ].mParames[ j ]--;

					// 如果次数为0了,则删除BUFF
					if ( tpBuff->mBuffList[ i ].mParames[ j ] <= 0 )
					{
						pSrcEntity->EntityRemoveBuff( tpBuffTpl->mTempID );
						LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
					}
				}
				break;
			default:
				break;
			}
		}
	}
}

//***********************************
// FunctionName : WeekRefresh 
// Description  : 每L刷新一次
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/26/2009]
//***********************************

void CPropertyModule::WeekRefresh()
{	
	//time_t tval;
	//struct tm *now;        
	//time(&tval);
	//now = localtime(&tval);
	//static int tLastSec = 0;

	//CSceneObjManagerImp::ObjMng_EntityPlayer::iterator tPlayerIt;
	//CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp;
	//for (	tPlayerIt = pSceneneObjManagerImp->mEntityPlayerPool.begin();
	//		tPlayerIt != pSceneneObjManagerImp->mEntityPlayerPool.end();
	//		++ tPlayerIt )
	//{
	//	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) &( *tPlayerIt );
	//	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();
	//	int tValTime = CSceneLogic::GetSingleton().mCurrentDay - tpProperty->mSaveDate;
	//	struct tm *tpKey;
	//	tpKey = localtime( (time_t) tpProperty->GetSaveDate() );
	//	if ( tValTime >= ( 7 * 24 * 60 * 60 * 1000) )
	//	{
	//		// 超^一周rg]有刷新
	//		RefreshPlayer( tpProperty );
	//	}
	//	else if ( now->tm_wday  )
	//	{
	//		
	//	}
	//	
	//}
	//
	//if ( now->tm_wday == CSceneCfgManager::GetSingleton().GetProperty_cfg()->mRefresh_week
	//	&& now->tm_hour == CSceneCfgManager::GetSingleton().GetProperty_cfg()->mRefresh_hour
	//	&& now->tm_min == CSceneCfgManager::GetSingleton().GetProperty_cfg()->mRefresh_minute
	//	&& now->tm_sec == 0 )
	//{
	//
	//}

	
}

//***********************************
// FunctionName : ContinuedAttackSkill
// Description  : 持m攻
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/26/2009]
//***********************************

void CPropertyModule::ContinuedAttackSkill( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, CWTPoint& vPos, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	//// 判断攻击是否被打断
	//if ( pSrcEntity->CheckContinuedConditon( pNormalSkill, vPos.mX, vPos.mY ) == false )
	//	return;

	CEntityCharacter* tpEntityList[ FUNC_LIMIT ] = { NULL };

	int tEntityCount = 0;

	// 如果客户端上报了范围作用列表,那么使用客户端数据,否则服务器去地图模块查找
	if ( vEntityList == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] vEntityList is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	} 
	else
	{
		for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
		{
			if ( vEntityList[ i ] == NULL )
				continue;

			if ( vPos.LimitDistance( vEntityList[ i ]->GetPos( ), pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			tpEntityList[ tEntityCount ] = vEntityList[ i ];
			tEntityCount++;
		}
	}

	int tCount = 0;

	// 将技能作用于所有找到的实体
	for ( int i = 0; i < tEntityCount; i ++ )
	{
		if( tpEntityList[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) UseSkill( %d : %d ), Call "
				"Map_GetRangeEntity tResult count error index %d is NULL", __LK_FILE__, __LINE__,
				__FUNCTION__, pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, i );
			continue;
		}

		// 判断技能PK模式是否满足
		if ( EntityPKValid( pSrcEntity, tpEntityList[ i ], pNormalSkill ) == false )
		{
			continue;
		}

		// 将技能作用于目标
		EntityAttackSkill( pSrcEntity, tpEntityList[ i ], pNormalSkill, pNormalSkill->mSkillType );
		++tCount;
		// 判断群攻是否达到人数上限
		if ( tCount >= pNormalSkill->mEffectMaxNumber )
			break;
	}
}

//***********************************
// FunctionName : ContinuedCussOrBlessSkill 
// Description  : 持续诅咒或祝福
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [2/26/2009]
//***********************************

void CPropertyModule::ContinuedCussOrBlessSkill( CEntityCharacter* pSrcEntity, CTemplateNormalSkill* pNormalSkill, CWTPoint& vPos, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pNormalSkill == NULL )
		return;

	//// 判断攻击是否被打断
	//if ( pSrcEntity->CheckContinuedConditon( pNormalSkill, vPos.mX, vPos.mY ) == false )
	//	return;

	CEntityCharacter* tpEntityList[ FUNC_LIMIT ] = { NULL };

	int tEntityCount = 0;

	// 如果客户端上报了范围作用列表,那么使用客户端数据,否则服务器去地图模块查找
	if ( vEntityList == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] vEntityList is NULL", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	} 
	else
	{
		for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
		{
			if ( vEntityList[ i ] == NULL )
				continue;

			if ( vPos.LimitDistance( vEntityList[ i ]->GetPos( ), pNormalSkill->mRandParame[ 0 ] ) == false )
				continue;

			tpEntityList[ tEntityCount ] = vEntityList[ i ];
			tEntityCount++;
		}
	}

	int tCount = 0;

	// 将技能作用于所有找到的实体
	for ( int i = 0; i < tEntityCount; i ++ )
	{
		if( tpEntityList[ i ] == NULL )
		{
			LOG_ERROR( "pro", "[ %s : %d ][ %s ]Entity( %d ) UseSkill( %d : %d ), Call "
				"Map_GetRangeEntity tResult count error index %d is NULL", __LK_FILE__, __LINE__,
				__FUNCTION__, pSrcEntity->GetEntityID( ), pNormalSkill->mSkillID, pNormalSkill->mSkillLevel, i );
			continue;
		}

		// 判断技能PK模式是否满足
		if ( EntityPKValid( pSrcEntity, tpEntityList[ i ], pNormalSkill ) == false )
		{
			continue;
		}

		// 将技能作用于目标
		EntityBuffSkill( pSrcEntity, tpEntityList[ i ], pNormalSkill->mBuffGroupID, ARRAY_CNT(pNormalSkill->mBuffGroupID), 0, pNormalSkill->mSkillType );
		++tCount;
		// 判断群攻是否达到人数上限
		if ( tCount >= pNormalSkill->mEffectMaxNumber )
			break;
	}
}

// ***************************************************************
//  Function:	 IfRedStone
//  Description: 判断是否是内丹
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
bool  CPropertyModule::IfRedStone( int ItemID, bool &bIfStart )
{
	CTplItem *tpItem =( CTplItem* ) CDataStatic::SearchTpl( ItemID  );	
	if ( tpItem == NULL )
	{
		return false;
	}
	if ( tpItem->mItemType != ITEM_REDSTONE ) 
	{			
		return false;
	}
	
	CTplRedStone * tpObjRedStone = ( CTplRedStone * )tpItem; 
	if ( tpObjRedStone->mRedStoneType == CTplRedStone::TYPE_CAMP )
	{
		bIfStart = true;
	}
	return true;		 
}


// ***************************************************************
//  Function:	 IsItemAdapter
//  Description: 判断是否是适配器
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
bool  CPropertyModule::IsItemAdapter( int nTempID )
{
	CTplItemAdapter	*tpAdapter = ( CTplItemAdapter* ) CDataStatic::SearchTpl( nTempID  );	
	if ( tpAdapter == NULL )
	{
		return false;
	}
	return tpAdapter->mItemType == CTplItem::ITEM_ADAPTER;
}


// ***************************************************************
//  Function:	 CheckItemType
//  Description: 检查物品类型
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
bool  CPropertyModule::CheckItemType( int nTempID, int vType )
{
	CTplItem	*tpAdapter = ( CTplItem* ) CDataStatic::SearchTpl( nTempID  );	
	if ( tpAdapter == NULL )
	{
		return false;
	}
	return tpAdapter->mItemType == vType;
}


// ***************************************************************
//  Function:	 EndRedStoneProtect
//  Description: 结束内丹的保护状态
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::EndRedStoneProtect( CTimerItem *tpTimer )
{
	
	if ( tpTimer == NULL )
	{
		return;
	}
		
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tpTimer->mOwnerID );
	if ( tpRedStone == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, tpTimer->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( tpTimer->get_id() );
		return;
	}

	// 如果还没有人使用则设置时间为掉落消失时间				
	if ( tpRedStone->GetStatus() == REDSTONE_STATUS_PROTECT )
	{	
		// 内丹状态为掉落并且任何人可拾取状态
		tpRedStone->SetStatus( REDSTONE_STATUS_DROP );		
	}		
	
	// 删除定时器
	tpRedStone->GetTimerReciver()->ClearTimer( tpTimer->get_id() );
}


// 
// ***************************************************************
//  Function:	 ClearRedStone
//  Description: 内丹的消失时间到
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// ***************************************************************
void CPropertyModule::ClearRedStone( CTimerItem *tpTimer )
{
	
	if ( tpTimer == NULL )
	{
		return;
	}
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tpTimer->mOwnerID );
	if ( tpRedStone == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] can't find entity %d", __FUNCTION__, __LINE__, tpTimer->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( tpTimer->get_id() );
		return;
	}	
	
	// 销毁计时器
	tpRedStone->GetTimerReciver( )->ClearTimer( tpTimer->get_id() );
	
	// 如果内丹没有处于噬炼状态则销毁内丹
	if ( tpRedStone->GetStatus() != REDSTONE_STATUS_USED )
	{
		CSceneLogic::GetSingleton().DestroyEntity( tpRedStone, 1 );
	}
}


// ***************************************************************
//  Function:	 RedStoneMagicTime
//  Description: 内丹的噬炼时间到
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 

void CPropertyModule::RedStoneMagicTime( CTimerItem *tpTimer )
{
	if ( tpTimer == NULL )
	{
		return;
	}
	CRedstoneController *tpRedStoneController = dynamic_cast< CRedstoneController * >( CSceneObjManager::GetSingletonPtr()->GetObject( tpTimer->mOwnerID ) );
	if ( tpRedStoneController == NULL )
	{
		LOG_ERROR( "npc", "Constroller NULL: %d", tpTimer->mOwnerID );
		CTimerMng::GetSingleton().ClearTimer( tpTimer->get_id() );
		return;
	}
	
	CEntity *tpRedstone = CSceneLogic::GetSingleton().GetEntity( tpRedStoneController->GetEntityID() );
	if ( tpRedstone == NULL )
	{
		CTimerMng::GetSingleton().ClearTimer( tpTimer->get_id() );
		CSceneObjManager::GetSingleton().DestroyObject( tpRedStoneController->get_id() );
		return;
	}
	
	// 判断状态是否出错
	/*if ( tpRedStone->GetStatus() != REDSTONE_STATUS_USED )
	{
		tpRedStone->GetTimerReciver()->ClearAllTimer();
		CSceneLogic::GetSingleton().DestroyEntity( tpRedStone, 1 );
		return;
	}		*/
	int tLastNum = tpRedStoneController->GetLastNumber();
	RedStoneAllotExp( tpRedstone, tpRedStoneController->GetOwnerID(), tpRedStoneController->GetRedstoneTmpID(), tpTimer->mCalledNum, tLastNum );
	tpTimer->mMillSeconds = tpTimer->mOtherInfo[1];
	tpRedStoneController->SetLastNumber( tLastNum );

	// 如果是最后一次分配经验则销毁内丹和内丹的计时器
	if ( tpTimer->mCalledNum == 0 )
	{	
		// 清除玩家身上的内丹ID	
		if ( tpRedstone->IsRedStone() )
		{
			CEntityRedStone *tpEntityRedstone = ( CEntityRedStone * )tpRedstone;
			SetRedstoneEffect( tpEntityRedstone->GetTeamID(), 0 );		
		}

		// 如果是国战内丹要通知网关
		bool bDestroy = true;
		CTplRedStone *tplStone = (CTplRedStone*)CDataStatic::SearchTpl( tpRedStoneController->GetRedstoneTmpID() );
		if ( tplStone != NULL )
		{
			if ( IS_BATTLE_LINE_ID( CSceneLogic::GetSingleton().GetLineID() ) == true && tplStone->mRedStoneType == CTplRedStone::TYPE_SERVER )
			{
				CWorldModule::GetSingleton().SendWarStoneOverNotify( tpRedstone->GetMapID() );
			}
			if ( tplStone->mIsEternal != 0 )
			{
				bDestroy = false;
				StartRedstone( tpRedstone, tpRedStoneController->GetOwnerID(), tpRedStoneController->GetRedstoneTmpID(), false );
			}
		}
		
		if ( bDestroy )
		{
			LOG_NOTICE( "npc", "Destroy Constroller: %d", tpRedStoneController->get_id() );				
			if ( tpRedStoneController->GetDestroyEntity() == true )
			{
				CSceneLogic::GetSingleton().DestroyEntity( tpRedstone, 1 );
			}
			CSceneObjManager::GetSingleton().DestroyObject( tpRedStoneController->get_id() );
		}
		CTimerMng::GetSingleton().ClearTimer( tpTimer->get_id() );	
		
		return;
	} 	
}

// ***************************************************************
//  Function:	 PlayerClickRedStone
//  Description: 玩家点击内丹
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::PlayerClickRedStone( CEntityPlayer *pPlayer, int RedStoneEnittyID )
{
	if ( pPlayer == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Empty CEntityPlayer or CPropertyPlayer!!!  ",
		__LK_FILE__,__LINE__,__FUNCTION__ );			
		return;
	}
	
	//CPropertyPlayer* tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();	
	
	// 获取实体
//	CEntity *tpEntity = CSceneLogic::GetSingletonPtr()->GetEntity( RedStoneEnittyID );
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( RedStoneEnittyID ) );
	if ( tpEntity == NULL )
	{
		return;
	}
	// 判断实体类型是否是内丹
	if ( tpEntity->GetEntityType() != ENTITYTYPE_REDSTONE )
	{
		return;		
	}	
	
	// 判断是否已经处于读秒或者噬炼状态
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )tpEntity;
	CPropertyRedStone *tpProRedstone = ( CPropertyRedStone * )tpRedStone->GetProperty();	
	CTplRedStone *tpTplRedstone = ( CTplRedStone * )CDataStatic::SearchTpl( tpProRedstone->GetPropertyTempID() );
	if ( tpTplRedstone == NULL )
	{
		return;
	}
	
	if ( tpTplRedstone->mRedStoneType != CTplRedStone::TYPE_TEAM )
	{
		return;
	}
		
	// 是否有队伍,没有队伍不能使用内丹	
	int tTeamID  = CTeamModule::GetSingleton().InTeam( pPlayer->GetCharID() );
	if ( tTeamID == INVALID_OBJ_ID )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_NOTINTEAM );
		return;				
	}		
	
	//if ( tpRedStone->GetStatus() != REDSTONE_STATUS_PROTECT 
	//	&& tpRedStone->GetStatus() != REDSTONE_STATUS_DROP )
	//{
	//	// TODO:已经处于读秒状态
	//	if ( tpRedStone->GetStatus() == REDSTONE_STATUS_PROCESSTIMEER && tpRedStone->GetTeamID() != tTeamID )
	//	{
	//		SendProErrorNotice( pPlayer, ERR_REDSTONE_PROCESSTIMER );
	//		return;
	//		
	//	}		
	//	else if ( tpRedStone->GetStatus() == REDSTONE_STATUS_USED )
	//	{
	//		SendProErrorNotice( pPlayer, ERR_REDSTONE_STARTED );			
	//		return;
	//	}	 		
	//}		
	if ( tpRedStone->GetStatus() == REDSTONE_STATUS_USED )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_STARTED );			
		return;
	}
	
	if ( CheckTeamRedstoneEffect( tTeamID ) == true )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_REDSTONEEFFECT );					
		return;
	}
	
	bool bResult = false;	
	if ( tpRedStone->GetStatus() == REDSTONE_STATUS_PROTECT )
	{
		// 查看是否有队伍玩家属于内丹拥有者	
		CEntityPlayer *TeamPlayer[TEAMNUM] = { 0 };
		int tRtn = 0, TeamNum = 0;				   	
		tRtn = CTeamModule::GetSingletonPtr()->OnGetMemberList( pPlayer, TeamPlayer, ARRAY_CNT( TeamPlayer ), TeamNum );
		LK_ASSERT( tRtn >= 0, return )		
		for ( int i = 0; i < TeamNum && i < TEAMNUM; i++ )
		{		
			LK_ASSERT( TeamPlayer[i] != NULL, continue )
			bResult = tpRedStone->CheckIfOwner( TeamPlayer[i]->GetCharID() );
			if ( bResult == true )
			{
				break;
			}	 
		}		
	}
	else if ( tpRedStone->GetStatus() == REDSTONE_STATUS_DROP )
	{
		bResult = true;
	}
	
	// 说明已经被开启
	if ( tpRedStone->GetTeamID() != 0 && tpRedStone->GetTeamID() != tTeamID )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_PROCESSTIMER );
		return;
	}
			

	// 玩家可以使用内丹
	if( bResult == true )
	{			
		// 玩家点击内丹后处于读秒状态
		//tpProperty->SetRedStoneID( tpRedStone->GetEntityID() );
		//tpRedStone->SetStatus( REDSTONE_STATUS_PROCESSTIMEER );
		SendClickRedStone( pPlayer, RedStoneEnittyID, 1 );				 
				
		// 设置内丹绑定的队伍ID
		tpRedStone->SetTeamID( tTeamID );		
		
		// 如果有读秒定时器先清除该读秒定时器
		if ( tpRedStone->GetProcessTimerID() != 0 )
		{
			tpRedStone->GetTimerReciver()->ClearTimer( tpRedStone->GetProcessTimerID(), true );
		}
		
		//	设置客户端读秒的超时计时器
		int OtherInfo[ 3 ]={0};
		OtherInfo[0]=MESSAGE_PROPERTY; 	
		int tTimerID = tpRedStone->GetTimerReciver()->SetTimer( tpRedStone->get_id(), TIMER_REDSTONE_PRECESSTIMEOUT, REDSTONE_PROCESSTIMER_OUTTIME, 1, OtherInfo );
		tpRedStone->SetProcessTimerID( tTimerID );
	}
	
	// 玩家不能使用内丹
	else
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_PROTECTED );
	}
}

// 判断队伍成员是否已经成功开启过内丹
bool CPropertyModule::CheckTeamRedstoneEffect( int nTeamID )
{		
	
	CEntityPlayer *TeamPlayer[TEAMNUM] = { 0 };
	int tRtn = 0, TeamNum = 0;				   	
	tRtn = CTeamModule::GetSingletonPtr()->OnGetMemberList( nTeamID, TeamPlayer, ARRAY_CNT( TeamPlayer ), TeamNum );
	LK_ASSERT( tRtn >= 0, return  false )		
	for ( int i = 0; i < TeamNum && i < TEAMNUM; i++ )
	{		
		LK_ASSERT( TeamPlayer[i] != NULL, continue )
		CPropertyPlayer *tpProperty = ( CPropertyPlayer * )TeamPlayer[i]->GetProperty();
		if ( tpProperty->GetRedStoneID() != 0 )
		{
			return true;
		}
	}		
	return false;
}

// 设置队伍成员已经开启过内丹
void CPropertyModule::SetRedstoneEffect( int nTeamID, int nRedstoneID )
{
	CEntityPlayer *TeamPlayer[TEAMNUM] = { 0 };
	int tRtn = 0, TeamNum = 0;				   	
	tRtn = CTeamModule::GetSingletonPtr()->OnGetMemberList( nTeamID, TeamPlayer, ARRAY_CNT( TeamPlayer ), TeamNum );
	LK_ASSERT( tRtn >= 0, return )		
	for ( int i = 0; i < TeamNum && i < TEAMNUM; i++ )
	{		
		LK_ASSERT( TeamPlayer[i] != NULL, continue )
		CPropertyPlayer *tpProperty = ( CPropertyPlayer * )TeamPlayer[i]->GetProperty();
		tpProperty->SetRedStoneID( nRedstoneID ); 
	}		
}



// ***************************************************************
//  Function:	 StopRedStonTimer
//  Description: 读秒结束
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 

void CPropertyModule::StopRedStonTimer( CEntityPlayer *pPlayer, int RedStoneEnittyID )
{
	LK_ASSERT( pPlayer != NULL, return );

	// 获取实体
//	CEntity *tpEntity = CSceneLogic::GetSingletonPtr()->GetEntity( RedStoneEnittyID );
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( RedStoneEnittyID ) );
	if ( tpEntity == NULL )
	{	
		/*不是错误，有可能时间到了被销毁了*/ 
		return;
	}
		
	// 判读实体类型
	if ( tpEntity->GetEntityType() != ENTITYTYPE_REDSTONE )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Wrong EntityTye! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )tpEntity;

	// 判读内丹状态是否正确
	if( tpRedStone->GetStatus() == REDSTONE_STATUS_USED )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_STARTED ); 		
		return;	
	}	
	
	// 是否有队伍,没有队伍不能使用内丹	
	int tTeamID  = CTeamModule::GetSingleton().InTeam( pPlayer->GetCharID() );
	if ( tTeamID == INVALID_OBJ_ID )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_NOTINTEAM );
		return;				
	}		

	// 判断内丹所属 		
	if ( tTeamID != tpRedStone->GetTeamID() )
	{
		SendProErrorNotice( pPlayer, ERR_REDSTONE_PROTECTED );
		return; 
	}
	
	// 判断是否已经收到内丹作用
	if ( CheckTeamRedstoneEffect( tTeamID ) == true )
	{
		tpRedStone->SetTeamID( 0 );			
		return;
	}
	
	// 设置已经开启过内丹
	SetRedstoneEffect( tTeamID, tpRedStone->GetEntityID() );
	
	// 开始噬炼			
	BeginRedStoneMagic( tpRedStone, pPlayer );
}

// ***************************************************************
//  Function:	 BeginRedStoneMagic
//  Description: 开始噬练
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::BeginRedStoneMagic( CEntityRedStone *tpRedStone, CEntityPlayer *pPlayer )
{		
	if ( tpRedStone == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Empty CEntityRedStone Pointer!!!  ", __LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	
	// 清除内丹身上的保护和消失计时器
	tpRedStone->GetTimerReciver()->ClearAllTimer();		
	
	// 获取模板配置文件信息
	CPropertyRedStone *tpPropertyRedStone =( CPropertyRedStone * )tpRedStone->GetProperty();
	CTplRedStone *tpTplRedStone = ( CTplRedStone * )CDataStatic::SearchTpl( tpPropertyRedStone->GetPropertyTempID() );
	if ( tpTplRedStone == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s] Template of CTemplateRedStoneExpTable is wrong !!! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	
	// 设置内丹状态为噬炼状态
	tpRedStone->SetStatus( REDSTONE_STATUS_USED );
	
	// 如果是队伍内丹则发送噬炼成功的消息
	if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_TEAM )
	{		
		if ( pPlayer != NULL )
		{
			SendMsgRedstoneStarted( pPlayer, tpRedStone->GetTeamID() );
		}	
	}	
	
	
	// 发送内丹开始噬炼的通知
	SendMsgBeginRedstoneMagic( tpRedStone );
	
	// 开始噬炼计时器
	int vCount = 0;
	if ( tpTplRedStone->mExpTime == 0 )
	{
		vCount = 1;
		LOG_ERROR( "pro","[%s,%d] Redstone tempate wrong !( Template ID :%d ) ", __FUNCTION__, __LINE__, tpTplRedStone->mTempID );
	}
	else
	{
		vCount = tpTplRedStone->mMagicSustainTime / tpTplRedStone->mExpTime;
	}
	
	//int OtherInfo[ 3 ]={0};
	//OtherInfo[0]=MESSAGE_PROPERTY;
	//OtherInfo[1]=tpTplRedStone->mExpTime;
	//tpRedStone->GetTimerReciver()->SetTimer( tpRedStone->GetEntityID(),TIMER_REDSTONE_EXPMAGIC,
	//( int )tpTplRedStone->mExpTime,2, OtherInfo, vCount );	  
		
	// 立即施放一次内丹效果		
	int tLastNum = 0;
	RedStoneAllotExp( tpRedStone, tpRedStone->GetTeamID(), tpTplRedStone->mTempID, 1, tLastNum );
	StartRedstone( tpRedStone, tpRedStone->GetTeamID(), tpTplRedStone->mTempID, true );
}

// ***************************************************************
//  Function:	 SendMsgBeginRedstoneMagic
//  Description: 发送内丹开始噬炼的通知
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************
void CPropertyModule::SendMsgBeginRedstoneMagic( CEntityRedStone *tpRedstone )
{
	LK_ASSERT( tpRedstone != NULL, return );
	CMessage MessageHead;
	CMessageBeginRedstoneMagicNotify MsgBeginMagic;
	MsgBeginMagic.set_entityid( tpRedstone->GetEntityID() );
	MessageHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_BEGINREDSTONEMAGIC );
	MessageHead.set_msgpara( (int)&MsgBeginMagic );
	CMapModule::GetSingletonPtr()->MessageBroadCast( tpRedstone, &MessageHead, false );
}

// ***************************************************************
//  Function:	 SendSetPasswordResponse
//  Description: 设置2级密码的回复消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		 05-04-2009
// 
// *************************************************************
void CPropertyModule::SendSetPasswordResponse( CEntityPlayer *pPlayer, int Errcode, int nStatus )
{
	LK_ASSERT( pPlayer != NULL, return );
	CMessage MsgHead;
	CMessageSetPasswordResponse MsgSetPassword;
	MsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_SETPASSWORD );
	MsgHead.set_msgpara( (int)&MsgSetPassword );
	MsgSetPassword.set_errcode( Errcode );
	MsgSetPassword.set_status( nStatus );		
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &MsgHead );
}

// ***************************************************************
//  Function:	 SendCheckPasswordResponse
//  Description: 检查密码的回复消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		05-04-2009
// 
// *************************************************************
void CPropertyModule::SendCheckPasswordResponse( CEntityPlayer *pPlayer, int Errcode, int nStatus )
{
	LK_ASSERT( pPlayer != NULL, return ); 
	CMessage MsgHead;
	CMessageCheckPasswordResponse MsgCheckPassword;
	MsgHead.set_msgpara( (int)&MsgCheckPassword );
	MsgHead.mutable_msghead( )->set_messageid( ID_S2C_RESPONSE_CHECKPASSWORD );
	
	MsgCheckPassword.set_errcode( Errcode );
	MsgCheckPassword.set_status( nStatus );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &MsgHead );
}

// ***************************************************************
//  Function:	 SendPutMoneyResponse
//  Description: 存储非绑定金钱的回应消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		06/01/2009
// 
// *************************************************************
void CPropertyModule::SendStorMoneyResponse( CEntityPlayer* pPlayer, int nErrcode, int nMoney, int nBindMoney, int nLmtMoney )
{	
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage tMsgHead;
	CMessageStorMoneyResponse tMsgStorMoney;
	
	tMsgStorMoney.set_bindmoney( nBindMoney );
	tMsgStorMoney.set_errcode( nErrcode );
	tMsgStorMoney.set_money( nMoney );
	tMsgStorMoney.set_moneylmt(nLmtMoney);
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_STORMONEY );
	tMsgHead.set_msgpara( (int)&tMsgStorMoney );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );	
}

// ***************************************************************
//  Function:	 SendTakeMoneyResponse
//  Description: 从仓库取出非绑定金钱的回应消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		06/01/2009
// 
// *************************************************************
void CPropertyModule::SendTakeStorMoneyResponse( CEntityPlayer* pPlayer, int nErrcode, int nMoney, int nBindMoney, int nLmtMoney )
{
	LK_ASSERT( pPlayer != NULL , return )	
	CMessage tMsgHead;
	CMessageTakeStorMoneyResponse tMsgTakeStorMoney;
	
	tMsgTakeStorMoney.set_money( nMoney );
	tMsgTakeStorMoney.set_bindmoney( nBindMoney );
	tMsgTakeStorMoney.set_errcode( nErrcode );	
	tMsgTakeStorMoney.set_moneylmt(nLmtMoney);

	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKESTORMONEY );
	tMsgHead.set_msgpara( (int)&tMsgTakeStorMoney );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// ***************************************************************
//  Function:	 SendTakeMoneyResponse
//  Description: 从仓库取出非绑定金钱的回应消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		06/01/2009
// 
// *************************************************************
void CPropertyModule::SendAddKitBagResponse( CEntityPlayer* pPlayer, int nErrcode, int nBagIndex, int nDesIndex, int nDestSlot, int nExpiredTime, int nBindStatus )
{
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage MsgHead;
	CMessageAddKitBagResponse MsgAddKitBag;		
	MsgAddKitBag.set_errocode( nErrcode );
	MsgAddKitBag.set_bagindex( nBagIndex );
	MsgAddKitBag.set_desindex( nDesIndex );
	MsgAddKitBag.set_desslot( nDestSlot );
	MsgAddKitBag.set_expiredtime( nExpiredTime );
	MsgAddKitBag.set_bindstatus( nBindStatus );
	
	MsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDKITBAG ); 
	MsgHead.set_msgpara( (int)&MsgAddKitBag );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &MsgHead );
}

// ***************************************************************
//  Function:	 SendAddDecompoundEquipResponse
//  Description: 发送添加待分解装备的回应消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		10/10/2009
// 
// *************************************************************
void CPropertyModule::SendAddDecompoundEquipResponse( CEntityPlayer* pPlayer, int nErrcode, int nEquipIndex )
{	
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage tMsgHead;
	CMessageAddEcompoundEquipResponse tMsgAddDecompoundEquip;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDDECOMPOUNDEQUIP );
	tMsgHead.set_msgpara( ( int )&tMsgAddDecompoundEquip );
	
	tMsgAddDecompoundEquip.set_errcode( nErrcode );
	tMsgAddDecompoundEquip.set_equipmentindex( nEquipIndex );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// ***************************************************************
//  Function:	 SendTakeDecompoundEquipResponse
//  Description: 发送拿下待分解装备的回应消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		10/10/2009
// 
// *************************************************************
void CPropertyModule::SendTakeDecompoundEquipResponse( CEntityPlayer* pPlayer, int nErrcode, int nEquipIndex )
{
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage tMsgHead;
	CMessageTakeDecompoundEquipResponse tMsgTakeDecompoundEquip;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKERDECOMPOUNDEQUIP );
	tMsgHead.set_msgpara( (int)&tMsgTakeDecompoundEquip );
	
	tMsgTakeDecompoundEquip.set_errcode( nErrcode );
	tMsgTakeDecompoundEquip.set_equipindex( nEquipIndex );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}


// ***************************************************************
//  Function:	 SendCheckPasswordResponse
//  Description: 检查密码的回复消息
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		05-04-2009
// 
// *************************************************************
void CPropertyModule::SendModifyPasswordResponse( CEntityPlayer *pPlayer, int Errcode, int nStatus )
{
	LK_ASSERT( pPlayer != NULL, return ); 
	CMessage MsgHead;
	CMessageModifyPasswordResponse MsgModifyPassword;
	MsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_MODIFYPASSWORD );
	MsgHead.set_msgpara( (int)&MsgModifyPassword );
	
	MsgModifyPassword.set_errcode( Errcode );
	MsgModifyPassword.set_status( nStatus );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &MsgHead );
}


// ***************************************************************
//  Function:	 RedStoneAllotExp
//  Description: 分配内丹经验
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::RedStoneAllotExp( CEntity *tpRedStone, int nOwenerID, int nRedStoneTmpID, int LeftTime, int &rLastNum )
{
	if ( tpRedStone == NULL )
	{
		LOG_ERROR( "pro"," [%s,%d][%s]  CEntityRedStone pointer is null!!! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	
	//int tLastAllotNum = rLastNum;
	// 判断内丹状态
	//if ( tpRedStone->GetStatus() != REDSTONE_STATUS_USED )
	//{
	//	LOG_ERROR( "pro"," [%s,%d][%s]  CEntityRedStone pointer is null!!! ",__LK_FILE__,__LINE__,__FUNCTION__ );
	//	/*销毁内丹*/
	//	CSceneLogic::GetSingleton().DestroyEntity( tpRedStone, 1 );
	//	return;
	//} 			
		
	// 获取内丹模板	
	CTplRedStone *tpTplRedStone = ( CTplRedStone * )CDataStatic::SearchTpl( nRedStoneTmpID ) ;
	if ( tpTplRedStone == NULL )
	{
		LOG_ERROR( "pro","[%s,%d][%s]  Wrong Template of CTemplateRedStoneExpTable!!! ",__LK_FILE__,__LINE__,__FUNCTION__ );
		return;
	}
	
	// 如果是家族内丹则走家族内丹经验分配方式
	/*if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_FAMILY )
	{
		AllotFamilyExp( tpRedStone, LeftTime, tpTplRedStone );
		return;			
	}*/			
	
	
	CEntityPlayer  *tRoleIDList[MAX_REDSTONE_ROLENUM] ={ NULL };	
	int tRtn = 0, tCount = 0;
	//bool bCountEffected = false;	// 人数是否影响经验	
	
	// 队伍内丹
	if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_TEAM )
	{
		int tTeamID = nOwenerID;
		tRtn = CTeamModule::GetSingletonPtr()->OnGetMemberList( tTeamID,tRoleIDList, ARRAY_CNT( tRoleIDList ), tCount );
		if ( tRtn < 0 || tCount <= 0 )
		{
			return ;
		}  	 
	}
	
	// 家族内丹或者家族副本内丹
	else if( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_FAMILY || tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_FAMILYREPETION )
	{
		// 获取本场景家族成员的实体ID列表
		int tFamilyID = nOwenerID;		
		int tMemberList[MAX_FAMILYMEMBER_NUM] = { 0 };
		tCount = MAX_FAMILYMEMBER_NUM; 		
		CFamilyModule::GetSingleton().GetFamilyMemberList( tFamilyID, tMemberList, tCount );
		
		for ( int i = 0; i < tCount && i < MAX_FAMILYMEMBER_NUM && i < MAX_REDSTONE_ROLENUM ;  ++i )
		{ 
			tRoleIDList[i] = ( CEntityPlayer * )CSceneLogic::GetSingleton().GetEntity( tMemberList[i] );								
		}	
		//bCountEffected = true;
	}
	
	// 阵营内丹
	else if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_CAMP || tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_MARRIAGE
		|| tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_SERVER || tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_METIER )
	{
		tCount = MAX_REDSTONE_ROLENUM; 		
		int tCampID = nOwenerID;
		int tMetierID = 0;		
		if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_SERVER )
		{
			tCampID = 0;
		}
		
		if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_METIER )
		{
			tMetierID = tpTplRedStone->mMetierID;
			tCampID = 0;
		}
			
		
		MapCellRedStoneSearcher tRedStoneVisit( tpRedStone, ( int )tpTplRedStone->mRadius, tCampID, tRoleIDList, tCount, tMetierID );
		tRedStoneVisit.Visit();	
		tCount = tRedStoneVisit.mPlayerCount;	
	}	
	else if( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_COUNTRY )
	{
		tCount = MAX_REDSTONE_ROLENUM; 		
		int tCountryID = nOwenerID;
		
		MapCellCountryRedStoneSearcher tRedStoneVisit( tpRedStone, ( int )tpTplRedStone->mRadius, tCountryID, tRoleIDList, tCount );
		tRedStoneVisit.Visit();	
		tCount = tRedStoneVisit.mPlayerCount;			
	}	
	
	// 获取内丹经验表
	CTemplateRedStoneExpTable * tpRedStonExpTable = ( CTemplateRedStoneExpTable * )CDataStatic::SearchTpl( tpTplRedStone->mExpTableID );
	if ( tpRedStonExpTable == NULL )
	{
		return;
	}
	
	// 对在内丹作用范围里面的玩家增加经验	  
	int PlayerCharID = 0;
	int Exp			 = 0;
	int IfGetExp	 = 1;
	CPropertyPlayer *tpProperty = NULL;	
	for ( int i =0 ; i < MAX_REDSTONE_ROLENUM && i < tCount ; i++ )
	{		
		IfGetExp	 = 1;
		if ( tRoleIDList[i] == NULL )
		{
			continue;
		}

		// 这个判断要在基础判断之前，如果没有必需的buff，不能获得经验
		for ( unsigned int j = 0; j < ARRAY_CNT(tpTplRedStone->mKeyBuffID); ++j )
		{
			if ( tpTplRedStone->mKeyBuffID[ j ] != 0 )
			{
				if ( tRoleIDList[i]->EntityHasBuff( tpTplRedStone->mKeyBuffID[ j ] ) == false )
				{
					IfGetExp = 0;
				}
				else
				{
					IfGetExp = 1;
					break;
				}
			}
			else
			{
				break;
			}
		}

		if ( !tpRedStone->IsWithinDistance( tRoleIDList[i], tpTplRedStone->mRadius ) )
		{
			IfGetExp = 0;
		}			 
				
		if ( !tRoleIDList[i]->IsAlive() )
		{
			IfGetExp = 0;
		}		
		
		// 如果应该获得经验，则分配经验
		if ( IfGetExp == 1 )
		{
			PlayerCharID = tRoleIDList[i]->GetCharID();
			if( tpTplRedStone->mNumberEffected ) 
			{
				int tExtralExp = 0;
				if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_FAMILY )
				{					
					tExtralExp = ( tCount - 3 )*5;
					tExtralExp = ( tExtralExp > 50 ) ? 50 : tExtralExp;					
				}
				else if( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_COUNTRY )
				{
					tExtralExp = tCount/10*5;
					tExtralExp = ( tExtralExp > 50 ) ? 50 : tExtralExp;
					
				}	
				else if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_SERVER )
				{
					if ( tCount > 180 )
					{
						tExtralExp = 0;
					}
					
					if ( tCount <= 180 && tCount > 20 )
					{
						tExtralExp = ( 180 - tCount )/2 + 10;
					}
					
					if ( tCount <= 20 && tCount > 10 )
					{
						tExtralExp = 90;
					}
					
					if ( tCount <= 10 && tCount > 5 )
					{
						tExtralExp = 100;
					}
					
					if ( tCount <= 5 && tCount > 2 )
					{
						tExtralExp = 110;
					}
					
					if ( tCount <= 2 && tCount > 1 )
					{
						tExtralExp = 120;
					}
													
					if ( tCount == 1 )
					{
						tExtralExp = 130;
					}
				}
							
				Exp = tpRedStonExpTable->mExp[tRoleIDList[i]->GetLevel()]*( 100 + tExtralExp  )/100;//*tpTplRedStone->mFamilyExpRate;			
			}
			else
			{
				Exp = tpRedStonExpTable->mExp[tRoleIDList[i]->GetLevel()];
			}	

			// 增加奖励buff加成
			int tPercent = SERVER_PERCENT_INT;
			for ( unsigned int j = 0; j < ARRAY_CNT(tpTplRedStone->mEncBuffID) && j < ARRAY_CNT(tpTplRedStone->mEncPercent); ++j )
			{
				if ( tpTplRedStone->mEncBuffID[ j ] != 0 )
				{
					if ( tRoleIDList[i]->EntityHasBuff( tpTplRedStone->mEncBuffID[ j ] ) == true )
					{
						tPercent += tpTplRedStone->mEncPercent[ j ];
					}
				}
				else
				{
					break;
				}
			}

			Exp = Exp / SERVER_PERCENT_FLOAT * tPercent;
			
			int nFinalExp = PlayerObtainExp2( tRoleIDList[i],Exp,0, EXPREASON_REDSTONE,&PlayerCharID,1 );

			if ( nFinalExp > 0)
			{
				LogEventGetExpByTeamAllot( tRoleIDList[i], Exp, nFinalExp, tCount, nRedStoneTmpID ); 
			}
		}
		
		// 如果是阵营内丹，则不加特效
		if ( tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_CAMP ||  tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_COUNTRY
			|| tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_MARRIAGE || tpTplRedStone->mRedStoneType == CTplRedStone::TYPE_METIER )
		{
			continue;
		}
		
		// 如果玩家的内丹状态发生变化则通知所有可见玩家
		tpProperty = ( CPropertyPlayer * )tRoleIDList[i]->GetProperty();
		
		// 如果是最后一次分配经验，则清除玩家状态
		if ( LeftTime == 0 )
		{
			tpProperty->SetHasRestoneStatus( 0 );
			SendChangeStatus( tRoleIDList[i], 0 );
			continue;
		}			
		if ( IfGetExp != tpProperty->GetHasRestoneStatus() )
		{
			tpProperty->SetHasRestoneStatus( IfGetExp );
			SendChangeStatus( tRoleIDList[i], IfGetExp );
		}			
	} 		
}

// ***************************************************************
//  Function:	 AllotFamilyExp
//  Description: 家族内丹获取经验
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:	 09/03/2009	
// 
// *************************************************************** 
void CPropertyModule::AllotFamilyExp( CEntityRedStone *tpRedStone, int nLeftTime, CTplRedStone *tpTplRedStone )
{	
	LK_ASSERT( tpRedStone != NULL && tpTplRedStone != NULL, return )	
				
	int nFamilyID = tpRedStone->GetTeamID();		
	int tMemberList[MAX_FAMILYMEMBER_NUM] = { 0 };
	int	tNum = MAX_FAMILYMEMBER_NUM; 	
	CFamilyModule::GetSingleton().GetFamilyMemberList( nFamilyID, tMemberList, tNum );
	
	CEntityPlayer *tExpMemberList[MAX_FAMILYMEMBER_NUM] = { NULL };
	int tExpNum	= 0;
	
	for ( int i =0 ; i < tNum ; i++ )
	{		
		int IfGetExp = 1;
		CEntityPlayer *tpPlayer = ( CEntityPlayer * )CSceneLogic::GetSingleton().GetEntity( tMemberList[i] );		
		if ( tpPlayer == NULL )
		{
			continue;
		}						

		if ( !tpRedStone->IsWithinDistance( tpPlayer, tpTplRedStone->mRadius ) )
		{
			IfGetExp = 0;
		}			 

		if ( !tpPlayer->IsAlive() )
		{
			IfGetExp = 0;
		}	

		// 如果应该获得经验，先记录玩家
		if ( IfGetExp == 1 )
		{
			tExpMemberList[tExpNum] = tpPlayer;
			++tExpNum;			
		}

		// 如果玩家的内丹状态发生变化则通知所有可见玩家
		 CPropertyPlayer * tpProperty = ( CPropertyPlayer * )tpPlayer->GetProperty();

		// 如果是最后一次分配经验，则清除玩家状态
		if ( nLeftTime == 0 )
		{
			tpProperty->SetHasRestoneStatus( 0 );;
			SendChangeStatus( tpPlayer, 0 );
			continue;
		}			
		if ( IfGetExp != tpProperty->GetHasRestoneStatus() )
		{
			tpProperty->SetHasRestoneStatus( IfGetExp );
			SendChangeStatus( tpPlayer, IfGetExp );
		}		
	} 
	
	// 分配经验
	for( int i = 0; i < tExpNum; ++i )
	{
		if ( tExpMemberList[i] == NULL )
		{
			continue;
		}
		int PlayerCharID = tExpMemberList[i]->GetCharID();
		int Exp =( ( CTemplateRedStoneExpTable * )CDataStatic::spRedStoneExpTable)->mExp[tExpMemberList[i]->GetLevel()]*( 6 + tExpNum  )/10;//*tpTplRedStone->mFamilyExpRate;
		int nFinalExp = PlayerObtainExp2( tExpMemberList[i], Exp, 0, EXPREASON_REDSTONE, &PlayerCharID, 1 );

		if ( nFinalExp > 0)
		{
			LogEventGetExpByFimalyAllot(tExpMemberList[i], Exp, nFinalExp, tExpNum, tpTplRedStone->mTempID);
		}
	}
	
}

// ***************************************************************
//  Function:	 CreatFamilyRedStone
//  Description: 创建家族内丹
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:	 09/03/2009	
// 
// *************************************************************** 
void CPropertyModule::CreatFamilyRedStone( CEntityPlayer *pPlayer, int nRedStoneTmpID )
{ 
	LK_ASSERT( pPlayer != NULL, return )
	if ( pPlayer->GetFamilyID() == 0 )
	{									
		return;
	} 	
	CTplRedStone *tpTplRedStone = ( CTplRedStone * )CDataStatic::SearchTpl( nRedStoneTmpID );
	LK_ASSERT( tpTplRedStone != NULL, return )
	
	// 如果不是家族内丹就返回
	if ( tpTplRedStone->mRedStoneType != CTplRedStone::TYPE_FAMILY )
	{
		return;
	}
	
	CMessage tMsgHead;
	CMessageUseFamilyExpCardNotify tMsgUseFamilyExpCard;
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_USEFAMILYEXPCARD );
	tMsgHead.set_msgpara( (int)&tMsgUseFamilyExpCard );
	tMsgUseFamilyExpCard.set_lineid( pPlayer->GetLineID() );
	tMsgUseFamilyExpCard.set_managerid( pPlayer->GetCharID() );
	tMsgUseFamilyExpCard.set_managername( pPlayer->GetCharName() );
	tMsgUseFamilyExpCard.set_mapid( pPlayer->GetMapID() );
	tMsgUseFamilyExpCard.set_posx( pPlayer->GetPosX() );
	tMsgUseFamilyExpCard.set_posy( pPlayer->GetPosY() );
	CSceneLogic::GetSingleton().SendFamilyMessage( &tMsgHead, pPlayer->GetFamilyID() );	
		
	unsigned int tEntityID = 0;
	int tCharIDList[TEAMNUM] = { 0 };
	CRedstondeCreator tDropCreator( nRedStoneTmpID,5, pPlayer->mPos.mX, pPlayer->mPos.mY,tCharIDList );
	CMapModule::GetSingleton().CreateNpc( pPlayer->GetLineID(),	pPlayer->GetMapID(), pPlayer->GetMapIndex(), &tDropCreator,	tEntityID );
	
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tEntityID );
	LK_ASSERT( tpRedStone != NULL, return )	
	tpRedStone->SetTeamID( pPlayer->GetFamilyID() );
	
	BeginRedStoneMagic( tpRedStone, pPlayer );
}

// ***************************************************************
//  Function:	 CreatCountryRedstone
//  Description: 创建国家内丹
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:	 01/06/2010	
// 
// ***************************************************************
void CPropertyModule::CreateCountryRedstone( int nLineID, int nMapID, int nMapIndex, int nPosX, int nPosY, int nCountryID, int nRedstoneTmpID )
{
	CTplItem *tpTplItem = ( CTplItem * ) CDataStatic::SearchTpl( nRedstoneTmpID );
	if ( tpTplItem == NULL )
	{
		return;
	}
	
	if ( tpTplItem->mItemType != CTplItem::ITEM_REDSTONE )
	{
		return;
	}
	
	// 不是国家内丹就返回
	unsigned int tEntityID = 0;
	int tCharIDList[TEAMNUM] = { 0 };	
	CRedstondeCreator tDropCreator( nRedstoneTmpID, 5, nPosX, nPosY, tCharIDList );
	CMapModule::GetSingleton().CreateNpc( nLineID,	nMapID, nMapIndex, &tDropCreator, tEntityID );
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tEntityID );
	LK_ASSERT( tpRedStone != NULL, return )	
	tpRedStone->SetTeamID( nCountryID );
	BeginRedStoneMagic( tpRedStone, NULL );
}

// ***************************************************************
//  Function:	 CreatFamilyRepetionRedstone
//  Description: 创建家族副本内丹
//	Input:			
//	OutPut:			
//	Return:			
//	Others:
//  Date:	 12/01/2009	
// 
// ***************************************************************
void CPropertyModule::CreatFamilyRepetionRedstone( int nRedStoneTmpID, int nFamilyID, int nLineID, int nMapID, int nPosX, int nPosY, int nMapIndex, KEY_TYPE nRepetionKey )
{  
	CTplRedStone *tpTplRedStone = ( CTplRedStone * )CDataStatic::SearchTpl( nRedStoneTmpID );
	LK_ASSERT( tpTplRedStone != NULL, return )
	
	
	CMapObject *tpMapObj =   CMapObjManager::GetSingleton().GetMapObject( nLineID, nMapID, nMapIndex, nRepetionKey );
	if ( tpMapObj == NULL )
	{
		return;
	}
	
	// 家族	
	int tCharIDList[TEAMNUM] = { 0 };	
	CRedstondeCreator tDropCreator( nRedStoneTmpID,5, nPosX, nPosY,tCharIDList ); 	
	unsigned int tEntityID = tpMapObj->CreateNpc( &tDropCreator, false );	
	
	CEntityRedStone *tpRedStone = ( CEntityRedStone * )CSceneLogic::GetSingleton().GetEntity( tEntityID );
	LK_ASSERT( tpRedStone != NULL, return )	
	tpRedStone->SetTeamID( nFamilyID );
	BeginRedStoneMagic( tpRedStone, NULL );
}

// ***************************************************************
//  Function:	 ChangeTeamLeaverStatus
//  Description: 队伍成员离队时改变队伍内丹状态
//	Input:		 CEntityPlayer *pPlayer							
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::ChangeTeamLeaverStatus( CEntityPlayer *pPlayer )
{
	if ( pPlayer == NULL )
	{
		return;
	}
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty( );
	if ( tpProperty->GetHasRestoneStatus( ) == 1 )
	{
		tpProperty->SetHasRestoneStatus( 0 );		
		SendChangeStatus( pPlayer, 0 );
	}	
	tpProperty->SetRedStoneID( 0 );
}  

// ***************************************************************
//  Function:	 ClearRedstoneStatus
//  Description: 队伍成员离队时改变队伍内丹状态
//	Input:		 CEntityPlayer *pPlayer							
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::ClearRedstoneStatus( CEntityRedStone* tpRestone )
{
	LK_ASSERT( tpRestone != NULL, return );
	
	// 只有处于读秒状态的内丹可以恢复到未读秒状态	
	tpRestone->SetTeamID( 0 );
} 

// ***************************************************************
//  Function:	 SendNotifyCountryRedstoneStarted
//  Description: 发送国家内丹开启的消息通知
//	Input:		 CEntityPlayer *pPlayer							
//	OutPut:			
//	Return:			
//	Others:
//  Date:		
// 
// *************************************************************** 
void CPropertyModule::SendNotifyCountryRedstoneStarted( CEntityPlayer *pPlayer, int nRedstoneType )
{
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage tMsgHead;
	CMessageStartCountryRedstoneNotify tMsgStartCountryRestone;	
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_STARTCOUNTRYREDSTONE );
	tMsgHead.set_msgpara( (int)&tMsgStartCountryRestone );
	tMsgStartCountryRestone.set_countryid( pPlayer->GetCountryID() );
	tMsgStartCountryRestone.set_lineid( pPlayer->GetLineID() );
	tMsgStartCountryRestone.set_managerid( pPlayer->GetCharID() );
	tMsgStartCountryRestone.set_managername( pPlayer->GetCharName() );
	tMsgStartCountryRestone.set_mapid( pPlayer->GetMapID() );
	tMsgStartCountryRestone.set_posx( pPlayer->GetPosX() );
	tMsgStartCountryRestone.set_posy( pPlayer->GetPosY() );
	tMsgStartCountryRestone.set_redstonetype( nRedstoneType );
	
	CSceneLogic::GetSingleton().SendCountryMessage( &tMsgHead, pPlayer->GetNationality() );
}

int CPropertyModule::OnUsePhysics( CEntity *pEntity, CTplItem *tpItem, CItemObject* tpSrcItem, int vIndex, int &vRemainHP, int &vRemainMP, int &vRemainAP )
{
	LK_ASSERT( pEntity != NULL && tpItem != NULL && tpSrcItem != NULL, return -1 )
	CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );
	CTplItemPhysic *tpPhysic = (CTplItemPhysic *)tpItem;
	CItemPhysic *pItemPhysic = (CItemPhysic *)tpSrcItem;
	// 如果处于无法吃药状态
	if ( pProperty->GetStateParam( STATE_FASTING ).mInState == true )
	{
		return ERROR_UNUSEITEM;
	}
	if ( (int)pProperty->GetLevel( ) < tpPhysic->mLevelRequire )
	{
		return ERROR_LEVELLOW;
	}
	
	// 红名状态，不能使用护法金丹特殊类药品
	if ( pProperty->IsRedPKStatus() )
	{
		if ( tpPhysic->mPhysicType == CTplItemPhysic::PHISICTYPE_SPECIAL )
		{
			return ERROR_REDNOUSE;
		}
	}

	// 生活技能药品
	if ( tpPhysic->mPhysicType == CTplItemPhysic::PHISICTYPE_LIFESKILL )
	{		
		CLifeSkill *tpLifeSkill = NULL;	
		if ( tpPhysic->mLifeSkillType == LIFESKILL_MAILSKILL )
		{
			tpLifeSkill = pProperty->GetPlayerLifeSkill()->GetLifeSkillByKind( LIEFSKILLKIND_MAINSKILL );
		}
		else if( tpPhysic->mLifeSkillType == LIFESKILL_SUBSKILL )
		{
			tpLifeSkill = pProperty->GetPlayerLifeSkill()->GetLifeSkillByKind( LIEFSKILLKIND_SUBSKILL );
		}
		else
		{
			tpLifeSkill = pProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpPhysic->mLifeSkillType );
		}
		
		if ( tpLifeSkill == NULL )
		{				
			return ERROR_LIFESKILL_USELIFESKILLPHISICWRONG;
		}
		
		if ( tpLifeSkill->GetLifeSkillType() == LIFESKILL_NONE )
		{		
			return ERROR_LIFESKILL_USELIFESKILLPHISICWRONG;
		}				   						
		
		if ( !tpLifeSkill->CheckDegree( tpLifeSkill->GetSpecializedDegree() ) )
		{ 			
			return ERROR_LIFESKILL_SPECIALIZEDEGREEFULL;
		}
		
		tpLifeSkill->AddSpecializedDegree( tpPhysic->mDegreeValue, CLifeSkill::DEGREEADDTYPE_BYITEM );
		SendNotifyLifeSkillAttribute( (CEntityPlayer *)pEntity, tpLifeSkill->GetLifeSkillType(), tpLifeSkill->GetSpecializedDegree() );

		uint64_t ullGUID = tpSrcItem->GetGUID(); 
		int nItemID = tpSrcItem->GetItemID();
		int nItemNum = tpSrcItem->GetItemNum();

		if (PlayerRemoveItem( (CEntityPlayer *)pEntity, vIndex, 1) == 0)
		{
			LogEventLostItemByUse((CEntityPlayer *)pEntity, ullGUID, nItemID, nItemNum );
		}

		return SUCCESS;
	}				
	
	
	// 普通药品	
	unsigned int tOldHP = pProperty->GetCurHP( );
	unsigned int tOldMP = pProperty->GetCurMP( );
	unsigned int tMaxHP = CPropertyFormula::GetMaxHP( pProperty );
	unsigned int tMaxMP = CPropertyFormula::GetMaxMP( pProperty );

	uint64_t ullGUID = pItemPhysic->GetGUID(); 
	int nItemID = pItemPhysic->GetItemID();

	// 如果不是buff药
	if ( tpPhysic->mHPValue > 0 && tOldHP == tMaxHP )
		return ERROR_FULLHP;
	if ( tpPhysic->mMPValue > 0 && tOldMP == tMaxMP )
		return ERROR_FULLMP;

	CTemplateBuff* tpBuffTpl = (CTemplateBuff*) CDataStatic::SearchTpl( ( (CTplItemPhysic*) tpItem )->mBuffID );
	if ( tpBuffTpl != NULL )
	{
		int nRetCode = ( (CEntityCharacter*) pEntity )->EntityInsertBuff( (CEntityCharacter*)pEntity, tpBuffTpl );
		int pTime = tpBuffTpl->mLastTime/1000;
		if (pTime >= 60)
		{
			LogEventGetBuffByItem((CEntityPlayer *)pEntity,((CTplItemPhysic*) tpItem )->mBuffID,pTime ,nItemID);
		}
		if( nRetCode != SUCCESS )
		{
			return nRetCode;
		}
	}
	// 如果是人民币道具
	if ( (tpPhysic->mProcessType & CTplItem::PROCESSTYPE_ISRMBITEM) == CTplItem::PROCESSTYPE_ISRMBITEM )
	{
		// 恢复的量不能超过模板配置的最大百分比
		unsigned int tCureHP = std::min( tMaxHP - pProperty->GetCurHP( ), (unsigned int)( ( tpPhysic->mMaxHPPercent == 0 ) ? SERVER_PERCENT_FLOAT : tpPhysic->mMaxHPPercent / SERVER_PERCENT_FLOAT * tMaxHP ) );
		unsigned int tCureMP = std::min( tMaxMP - pProperty->GetCurMP( ), (unsigned int)( ( tpPhysic->mMaxMPPercent == 0 ) ? SERVER_PERCENT_FLOAT : tpPhysic->mMaxMPPercent / SERVER_PERCENT_FLOAT * tMaxMP ) );
		tCureHP = std::min( pItemPhysic->GetRemainHP(), tCureHP );
		tCureMP = std::min( pItemPhysic->GetRemainMP(), tCureMP );
		((CEntityCharacter*)pEntity)->CureHP( tCureHP, pEntity->GetEntityID(), RESULT_USEITEM, false );
		((CEntityCharacter*)pEntity)->CureMP( tCureMP, pEntity->GetEntityID(), RESULT_USEITEM, false );
		pItemPhysic->SetRemainHP( std::max( 0, (int)( pItemPhysic->GetRemainHP() - tCureHP ) ) );
		pItemPhysic->SetRemainMP( std::max( 0, (int)( pItemPhysic->GetRemainMP() - tCureMP ) ) );
		vRemainHP = pItemPhysic->GetRemainHP();
		vRemainMP = pItemPhysic->GetRemainMP();

		if ( tpPhysic->mPhysicType == CTplItemPhysic::PHISICTYPE_AP )
		{
			int tAp = pProperty->GetCurAP();
			int tCureAP = std::min( ( (int)pProperty->GetMaxAP() - tAp ), (int)pItemPhysic->GetRemainAP() );
			if( tCureAP > 0 )
			{
				((CEntityCharacter*)pEntity)->CureAP( tCureAP, pEntity->GetEntityID(), RESULT_USEITEM, true );
				pItemPhysic->SetRemainAP( std::max( 0, (int)( pItemPhysic->GetRemainAP() - tCureAP ) ) );

				if ( pItemPhysic->GetRemainAP() == 0 )
				{
					if (PlayerRemoveItem( (CEntityPlayer*)pEntity, vIndex, 1 ) == 0)
					{
						LogEventLostItemByUse((CEntityPlayer *)pEntity, ullGUID, nItemID, 1);
					}
				}
			}
			else
			{
				SendProErrorNotice( (CEntityPlayer*)pEntity, ERROR_APFULL );
			}
			vRemainAP = pItemPhysic->GetRemainAP();
		}
		else if ( pItemPhysic->GetRemainHP() == 0 && pItemPhysic->GetRemainMP() == 0 )
		{
			if ( PlayerRemoveItem( (CEntityPlayer*)pEntity, vIndex, 1 ) == 0)
			{
				LogEventLostItemByUse((CEntityPlayer *)pEntity, ullGUID, nItemID, 1);
			}
		}
	}
	// 如果是普通道具
	else
	{
		// 如果正在恢复中
		//if ( pProperty->GetPhysicID( ) > 0 )
		//	return ERROR_RECOVERING;
		//pProperty->SetCurHP( min( ( tOldHP + tpPhysic->mHPValue ), tMaxHP ) );
		//pProperty->SetCurMP( min( ( tOldMP + tpPhysic->mMPValue ), tMaxMP ) );
		if ( tpPhysic->mHPValue > 0 )
		{
			((CEntityCharacter*)pEntity)->CureHP( tpPhysic->mHPValue, pEntity->GetEntityID(), RESULT_USEITEM, false );
		}
		if ( tpPhysic->mMPValue > 0 )
		{
			((CEntityCharacter*)pEntity)->CureMP( tpPhysic->mMPValue, pEntity->GetEntityID(), RESULT_USEITEM, false );
		}
		
		//pProperty->SetPhysicID( tpSrcItem->mItemID );
		//pProperty->SetRecoverTimer( tpPhysic->mHPTime * 1000 );

		if ( PlayerRemoveItem( (CEntityPlayer*)pEntity, vIndex, 1) == 0) 
		{
			LogEventLostItemByUse((CEntityPlayer *)pEntity, ullGUID, nItemID, 1);
		}
	}


	if ( pProperty->GetCurHP( ) - tOldHP > 0 )
	{
		pEntity->AddFunResult( 0, FUNC_INCHP, RESULT_USEITEM, true, pProperty->GetCurHP( ) - tOldHP, pProperty->GetCurHP( ), pProperty->GetMaxHP( ) );
		if ( pProperty->GetCurMP( ) - tOldMP > 0 )
		{
			pEntity->AddFunResult( 0, FUNC_INCMP, RESULT_USEITEM, true, pProperty->GetCurMP( ) - tOldMP, pProperty->GetCurMP( ), pProperty->GetMaxMP( ) );
		}
	}
	else
	{
		if ( pProperty->GetCurMP( ) - tOldMP > 0 )
		{
			pEntity->AddFunResult( 0, FUNC_INCMP, RESULT_USEITEM, true, pProperty->GetCurMP( ) - tOldMP, pProperty->GetCurMP( ), pProperty->GetMaxMP( ) );
		}
	}
	ResultListSend( );
	return SUCCESS;
}

int CPropertyModule::OnUseRandomTP( CEntity *pEntity, int vIndex )
{
	CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );	
	CItemTeleport* tpSrcItem = (CItemTeleport *)pProperty->GetBaggage( )->GetItemObjPtr( vIndex );
	LK_ASSERT( tpSrcItem != NULL, return -1 );
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	
	// 检查进度条时间	
	if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use RandomTP, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}
	
	// 如果是副本，不能使用云游符
	if( IS_REPETION_LINE_ID( pEntity->GetLineID( ) ) == true )
		return ERROR_ITEM_INWEDDINGHALL;
		
	// 如果在礼堂，不能使用云游符
	if ( CDataStatic::IsWeddingHall( tpPlayer->GetMapID() ) == true )
	{
		return ERROR_INWEDDINGHALL;
	}
		
	// 如果是在他国，不能使用云游符
	if ( pEntity->GetLineID( ) != pEntity->GetNationality( ) )
	{
		return ERROR_FOREIGNUSE;
	}

	CWTPoint tPos;
	while( 1 )
	{
		tPos = CMapModule::GetSingleton().GetRandomPos( (CEntityCharacter*)pEntity );

		if ( tPos == pEntity->GetPos( ) )
			tPos = CWTPoint( );

		bool tbCellValid = CMapModule::GetSingleton().IsCellValid( pEntity, tPos.mX, tPos.mY );
		if( tbCellValid == false )
		{
			LOG_WARN( "map", "[%s:%d] pos(%d,%d) out of map %d", __FUNCTION__, __LINE__, tPos.mX, tPos.mY, pEntity->GetMapID() );
			continue;
		}

		bool vbCanPass = CMapModule::GetSingleton().CanPlayerPass( pEntity->GetLineID(), pEntity->GetMapID(), pEntity->GetMapIndex(), tPos.mX, tPos.mY, pProperty->GetStateParam( STATE_FLY ).mInState );

		if ( vbCanPass == true )
			break;
	}	

	SendTelePortResponse( pEntity, vIndex, tPos.mX, tPos.mY );


	uint64_t ullGUID = tpSrcItem->GetGUID();
	int  nSrcTempID = tpSrcItem->GetItemID();

	if( PlayerRemoveItem( (CEntityPlayer*)pEntity, vIndex, 1) != 0 )
	{
		return ERROR_ITEMNOTEXIST;
	}else
	{
		LogEventLostItemByUse( (CEntityPlayer*) pEntity, ullGUID, nSrcTempID, 1);
	}

	if( CMapModule::GetSingleton().Teleport( pEntity->GetLineID(), pEntity->GetMapID(),	tPos.mX, tPos.mY, pEntity ) == false )
	{
		CItemObject* pInsItemPile = PlayerInsertItem( (CEntityPlayer*)pEntity, tpSrcItem->GetItemID(), 1, false );
		if ( pInsItemPile)
		{
			LogEventGetItemByRollBack((CEntityPlayer*)pEntity, ullGUID, nSrcTempID, 1,
				((CEntityPlayer*)pEntity)->GetPosX(), ((CEntityPlayer*)pEntity)->GetPosY());
		}

	}

	return SUCCESS;
}

int CPropertyModule::OnUseRemberTP( CEntity *pEntity, int vIndex )
{
	CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );	
	CItemTeleport* tpSrcItem = (CItemTeleport *)pProperty->GetBaggage( )->GetItemObjPtr( vIndex );
	LK_ASSERT( tpSrcItem != NULL, return -1 );
	CEntityPlayer *tpPlayer	= ( CEntityPlayer * )pEntity;
	
	// 检查进度条时间	
	if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use RemberTP, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}
	
	if ( CDataStatic::IsWeddingHall( tpPlayer->GetMapID() ) == true )
	{			
		return ERROR_INWEDDINGHALL;
	}

	// 如果尚未使用
	if ( tpSrcItem->GetLineID() == 0 && tpSrcItem->GetMapID() == 0 )
	{
		if ( pEntity->GetLineID( ) != pEntity->GetNationality( ) )
			return ERROR_FOREIGNUSE;
		tpSrcItem->SetLineID( pEntity->GetLineID( ) );
		tpSrcItem->SetMapID( pEntity->GetMapID( ) );
		tpSrcItem->SetPosX( pEntity->GetPosX( ) );
		tpSrcItem->SetPosY( pEntity->GetPosY( ));
	}
	// 如果使用过，传送到记忆的地点
	else
	{
		uint64_t ullGUID = tpSrcItem->GetGUID();
		int nSrcTplID = tpSrcItem->GetItemID();

		// 从包裹里删除这个道具
		if( PlayerRemoveItem( ( CEntityPlayer* )pEntity, vIndex, 1 ) != 0 )
		{
			return ERROR_ITEMNOTEXIST;
		}else
		{
			LogEventLostItemByUse( (CEntityPlayer*) pEntity, ullGUID, nSrcTplID, 1);
		}

		if( CMapModule::GetSingleton().Teleport( tpSrcItem->GetLineID(),
			tpSrcItem->GetMapID(), 
			tpSrcItem->GetPosX(), 
			tpSrcItem->GetPosY(), 
			pEntity ) == false )
		{
			// 如果传送失败，再给玩家恢复道具
			CItemObject* pInsItemPile = PlayerInsertItem( (CEntityPlayer*)pEntity, tpSrcItem->GetItemID(), 1, false );
			if ( pInsItemPile)
			{
				LogEventGetItemByRollBack((CEntityPlayer*)pEntity, ullGUID, nSrcTplID, 1,
						((CEntityPlayer*)pEntity)->GetPosX(), ((CEntityPlayer*)pEntity)->GetPosY());
			}
		}
	}
	return SUCCESS;
}

int CPropertyModule::OnUseTownTP( CEntity *pEntity, int vIndex )
{
	CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );	
	CItemTeleport* tpSrcItem = (CItemTeleport *)pProperty->GetBaggage( )->GetItemObjPtr( vIndex );
	LK_ASSERT( tpSrcItem != NULL, return -1 );
	
	CEntityPlayer *tpPlayer = (CEntityPlayer *)pEntity;
	
	// 检查读条时间	
	if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when OnUseTownTP, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}
	
	// 在礼堂不能使用传送类道具
	if ( CDataStatic::IsWeddingHall( tpPlayer->GetMapID() ) == true )
	{
		return ERROR_INWEDDINGHALL;
	}

	// 一定要先消耗道具，再传
	uint64_t ullGUID = tpSrcItem->GetGUID();
	int nSrcTplID = tpSrcItem->GetItemID();

	if( PlayerRemoveItem( ( CEntityPlayer* )pEntity, vIndex, 1 ) != 0 )
	{
		return ERROR_ITEMNOTEXIST;
	}else
	{
		LogEventLostItemByUse( (CEntityPlayer*) pEntity, ullGUID, nSrcTplID, 1);
	}

	if( CMapModule::GetSingleton().Teleport( pProperty->GetTownPos( )->mLineID, pProperty->GetTownPos( )->mMapID, 
		pProperty->GetTownPos( )->mPos.mX, pProperty->GetTownPos( )->mPos.mY, pEntity ) == false )
	{
		LOG_ERROR( "pro", "[%s:%d] Use TownTP , but teleport failed", __FUNCTION__, __LINE__ );
		
		CItemObject* pInsItemPile = PlayerInsertItem( (CEntityPlayer*)pEntity, tpSrcItem->GetItemID(), 1, false );
		if ( pInsItemPile)
		{
			LogEventGetItemByRollBack((CEntityPlayer*)pEntity, ullGUID, nSrcTplID, 1,
					((CEntityPlayer*)pEntity)->GetPosX(), ((CEntityPlayer*)pEntity)->GetPosY());
		}

		return ERROR_TOWNTP;
	}

	return SUCCESS;
}

int CPropertyModule::OnUseHorse( CEntity *pEntity, CTplItem *tpItem, CItemObject* tpSrcItem )
{
	if ( pEntity == NULL )
	{
		return -1;
	}
	
	CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );
	CTplItemHorse *tpHorse = (CTplItemHorse *)tpItem;
	
	// 职业是否符合
	if ( tpHorse->mMetierRequire != METIER_NONE )
	{
		switch ( pProperty->GetPropertyTempID() )
		{
		case METIER_WARRIOR:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_WARRIOR ) != BLOCK_WARRIOR )
					return ERROR_METIERDIF;
				break;
			}
		case METIER_ROGUE:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_ROGUE ) != BLOCK_ROGUE )
					return ERROR_METIERDIF;
				break;
			}
		case METIER_HUNTER:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_HUNTER ) != BLOCK_HUNTER )
					return ERROR_METIERDIF;
				break;
			}
		case METIER_SORCERER:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_SORCERER ) != BLOCK_SORCERER )
					return ERROR_METIERDIF;
				break;
			}
		case METIER_PRIEST:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_PRIEST ) != BLOCK_PRIEST )
					return ERROR_METIERDIF;
				break;
			}
		case METIER_DRUID:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_DRUID ) != BLOCK_DRUID )
					return ERROR_METIERDIF;
				break;
			}
		case METIER_NOVICE:
			{
				if ( ( tpHorse->mMetierRequire & BLOCK_NOVICE ) != BLOCK_NOVICE )
					return ERROR_METIERDIF;
				break;
			}
		}
	}


	// 等级是否符合
	if ( (int)pProperty->GetLevel( ) < tpHorse->mLevelRequire )
	{
		return ERROR_LEVELLOW;
	}

	return SUCCESS;
}

//************************************
// Method:    OnUseReturnPaper
// FullName:  CPropertyModule::OnUseReturnPaper
// Access:    public 
// Returns:   int
// Qualifier: 使用门派回程符
// Parameter: CEntity * pEntity
// Parameter: CTplItem * tpItem
// Parameter: int vIndex
//************************************
int CPropertyModule::OnUseReturnPaper( CEntity *pEntity, CTplItem *tpItem, int vIndex )
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}
	
	// 检查读条时间	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pEntity->GetProperty();
	CEntityPlayer * tpPlayer = ( CEntityPlayer * )pEntity;
	if ( tpProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use telesymbol, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}
	
	// 在礼堂不能使用传送类道具
	if ( CDataStatic::IsWeddingHall( tpPlayer->GetMapID() ) == true )
	{
		return ERROR_INWEDDINGHALL;
	}
	
	//TODO: 先扣除道具，如果后面传送失败，暂时只记录下来
	uint64_t ullGUID = 0;
	if ( PlayerRemoveItem( (CEntityPlayer*) pEntity, vIndex, 1, &ullGUID) == 0)
	{
		LogEventLostItemByUse( (CEntityPlayer*) pEntity, ullGUID, tpItem->mTempID, 1);
	}

	CTplReturnPaper* tpRPaper = ( CTplReturnPaper* ) tpItem;
	if ( CMapModule::GetSingleton().Teleport( tpRPaper->mLineID, tpRPaper->mMapID, tpRPaper->mPosX, tpRPaper->mPosY, pEntity, 0 ) == false )
	{
		LOG_ERROR( "pro", "[%s:%d] UseReturn Paper %d, but teleport failed", __FUNCTION__, __LINE__, tpRPaper->mTempID );
		
		// 如果传送失败，再给玩家恢复道具
		CItemObject* pInsItemPile = PlayerInsertItem( (CEntityPlayer*)pEntity, tpItem->mTempID, 1, false );
		if ( pInsItemPile)
		{
			LogEventGetItemByRollBack((CEntityPlayer*)pEntity, ullGUID, tpItem->mTempID, 1,
					((CEntityPlayer*)pEntity)->GetPosX(), ((CEntityPlayer*)pEntity)->GetPosY());
		}

		return ERROR_TOWNTP;
	}
	return SUCCESS;
}

//************************************
// Method:    OnUseTeleSymbol
// FullName:  CPropertyModule::OnUseTeleSymbol
// Access:    public 
// Returns:   int
// Qualifier: 使用回程卷轴，有使用次数，如果为0，则销毁道具
// Parameter: CEntity * pEntity
// Parameter: CTplItem * tpItem
// Parameter: int vIndex
// Parameter: unsigned short vTeleOrder
//************************************
int CPropertyModule::OnUseTeleSymbol( CEntity *pEntity, CTplItem *tpItem, int vIndex, unsigned short vTeleOrder, int& nUsedTimes )
{
	if( pEntity == NULL )
	{
		return -1;
	}
	
	CPropertyPlayer *pProperty = (CPropertyPlayer *)pEntity->GetProperty( );
	CTplTeleSymbol* tpTeleSymbol = ( CTplTeleSymbol* )tpItem;	
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	
	// 检查读条时间	
	if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use telesymbol, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}
	
	// 在礼堂不能使用传送类道具
	if ( CDataStatic::IsWeddingHall( tpPlayer->GetMapID() ) == true )
	{
		return ERROR_INWEDDINGHALL;
	}
	
	if ( tpTeleSymbol->mUseTimes > LK_ZERO )
	{
		// 次数型
		CItemTeleSymbol* tpSymbolItem = ( CItemTeleSymbol* )pProperty->GetBaggage( )->GetItemObjPtr( vIndex );
		tpSymbolItem->SetUsedTimes( tpSymbolItem->GetUsedTimes( ) + 1 );
		nUsedTimes = tpSymbolItem->GetUsedTimes();
		if ( (int)tpSymbolItem->GetUsedTimes( ) >= tpTeleSymbol->mUseTimes )
		{
			uint64_t ullGUID = tpSymbolItem->GetGUID();
			int nSymbolID = tpSymbolItem->GetItemID();

			if ( PlayerRemoveItem((CEntityPlayer*) pEntity, vIndex, 1 ) == 0)
			{
				LogEventLostItemByUse( (CEntityPlayer*) pEntity, ullGUID, nSymbolID, 1);
			}
		}
	}
	CTemplateTeleTable* tpTable = ( CTemplateTeleTable* ) CDataStatic::SearchTpl( tpTeleSymbol->mTeleTable );
	if ( tpTable != NULL )
	{
		if ( vTeleOrder < LK_ZERO )
		{
			return -1;
		}
		
		if ( vTeleOrder < ARRAY_CNT( tpTable->mLineID ) 
			&& vTeleOrder < ARRAY_CNT( tpTable->mMapID )
			&& vTeleOrder < ARRAY_CNT( tpTable->mPosX )
			&& vTeleOrder < ARRAY_CNT( tpTable->mPosY )
			)
		{
			CGlobalMapData tMapData;
			tMapData.mMapID = tpTable->mMapID[ vTeleOrder ];
			tMapData.mPosX = tpTable->mPosX[ vTeleOrder ];
			tMapData.mPosY = tpTable->mPosY[ vTeleOrder ];
			if ( IS_GLOBAL_SCENESERVER( tpTable->mLineID[ vTeleOrder ] ) == true )
			{
				if ( IS_GLOBAL_SCENESERVER( tpPlayer->GetLineID() ) == false )
				{
					CGlobalModule::GetSingleton().GlobalTelePort( tpPlayer, EGLOBALTELE_TYPE_GLOBALSERVER, ESERVERTYPE_SCENESER, &tMapData );
					return SUCCESS;	
				}
			}
			else if ( IS_GLOBAL_SCENESERVER( tpPlayer->GetLineID() ) == true )
			{
				CGlobalModule::GetSingleton().GlobalTelePort( tpPlayer, EGLOBALTELE_TYPE_RETURNTOGAME, ESERVERTYPE_SCENESER, &tMapData );
				return SUCCESS;
			}
			
			if ( CMapModule::GetSingleton().Teleport( 
				tpTable->mLineID[ vTeleOrder ], 
				tpTable->mMapID[ vTeleOrder ], 
				tpTable->mPosX[ vTeleOrder ],
				tpTable->mPosY[ vTeleOrder ], 
				pEntity, 0 ) == false )
			{
				// 如果传送失败，再给玩家恢复道具
				CItemObject* pInsItemPile = PlayerInsertItem( (CEntityPlayer*)pEntity, tpItem->mTempID, 1, false );
				if ( pInsItemPile)
				{
					LogEventGetItemByRollBack((CEntityPlayer*)pEntity, pInsItemPile->GetGUID(), tpItem->mTempID, 1,
							((CEntityPlayer*)pEntity)->GetPosX(), ((CEntityPlayer*)pEntity)->GetPosY());
				}
			}
		}
	}
	return SUCCESS;
}

//************************************
// Method:    OnUseStove
// FullName:  CPropertyModule::OnUseStove
// Access:    public 
// Returns:   int
// Qualifier: 使用炉石，会判断玩家等级，职业是否符合，成功移除道具
// Parameter: CEntity * pEntity
// Parameter: CTplItem * tpItem
// Parameter: int vIndex
//************************************
int CPropertyModule::OnUseStove( CEntity *pEntity, CTplItem *tpItem, CItemObject* tpSrcItem, int vIndex )
{
	CTplStove* tpTplStove = ( CTplStove* ) tpItem;

	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) pEntity;
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();
	
	// 检查读条时间	
	if ( tpProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use telesymbol, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}
	
	// 在礼堂不能使用传送类道具
	if ( CDataStatic::IsWeddingHall( tpPlayer->GetMapID() ) == true )
	{
		return ERROR_INWEDDINGHALL;
	}

	if ( tpTplStove->mLevelRequire > MAX_GRADE || tpTplStove <= LK_ZERO )
	{
		return ERROR_ITEMNOTEXIST;
	}

	if ( tpPlayer->GetLevel() < tpTplStove->mLevelRequire )
	{
		return ERROR_LEVELLOW;
	}

	if ( ( 1 <<  ( tpPlayer->GetMetier() - 1 ) ) != tpTplStove->mMetierRequire )
	{
		return ERROR_METIERDIF;
	}

	// 先设置cd组，如果失败再重置回去
	((CEntityPlayer*)pEntity)->RefreshCDGroup( tpItem->mCDGroup, ARRAY_CNT( tpItem->mCDGroup ) );

	// 先设置cd,如果失败在重置回去
	CItemStove* tpItemStove = (CItemStove*)tpSrcItem;
	tpItemStove->SetCooldown( tpTplStove->mCoolTime );

	if( CMapModule::GetSingleton().Teleport( tpTplStove->mLineID, tpTplStove->mMapID, tpTplStove->mPosX, tpTplStove->mPosY, pEntity, 0 ) != true )
	{
		tpItemStove->SetCooldown( 0 );
		((CEntityPlayer*)pEntity)->ClearCDGroup( tpItem->mCDGroup, ARRAY_CNT( tpItem->mCDGroup ) );
	}

	return SUCCESS;
}

//************************************
// Method:    OnUseMineMap
// FullName:  CPropertyModule::OnUseMineMap
// Access:    public 
// Returns:   int
// Qualifier: 使用藏宝图，概率事件处理
// Parameter: CEntity * pEntity
// Parameter: CTplItem * tpItem
// Parameter: int vIndex
//************************************

int CPropertyModule::OnUseMineMap( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{
	CTplMineMap* tpMineMap = ( CTplMineMap* ) tpItem;

	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}

	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) pEntity;	
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();	   	
	

	// 检查读条时间	
	if ( tpProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_MINMAP, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use minmap, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}

	// 检查是否到达宝藏挖掘点范围
	CItemMineMap* tpItemMap = ( CItemMineMap* ) tpProperty->GetBaggage( )->GetItemObjPtr( vIndex );
	if ( tpItemMap == NULL )
	{
		return ERROR_ITEM_DATANOTEXIST;
	}

	bool bRes = false;
	CWTPoint tPos( tpItemMap->GetPosX(), tpItemMap->GetPosY());
	if ( tpItemMap->GetMapID() == tpPlayer->GetMapID()
		&& tPos.LimitDistance( tpPlayer->GetPos(), tpMineMap->mRadius ) )
	{
		bRes = true;
	}
	
	int tRtnCode = 0;
	if ( bRes )
	{
		// 到达挖掘点，触发事件
		int tRandom = RAND( SERVER_PERCENT_INT ), tRet = 0, tTotalRate = 0;
		int i = 0;
		for (  i = 0; i < (int)ARRAY_CNT( tpMineMap->mEvent ); i ++ )
		{
			if ( tpMineMap->mEvent[ i ].mTouchRate == 0 )
			{
				continue;
			}
			tTotalRate += tpMineMap->mEvent[ i ].mTouchRate;
			if ( tRandom <= tTotalRate )
			{
				tRet = ( int ) tpMineMap->mEvent[ i ].mEventID;
				break ;
			}			
		}
		
		switch ( tRet )
		{
		case CTplMineMap::EVENT_DROPITEM:
			{
				tRtnCode = RandomDropItem( tpPlayer, tpMineMap->mDropTable, CDropFrom(tpItemMap), tpMineMap->mSpecial );
				if ( tRtnCode != SUCCESS )
				{
					return tRtnCode;
				}
				break;
			}
		case CTplMineMap::EVENT_BRUSHOGRE:
			{
				tRtnCode = BrushOgre( tpPlayer, tpMineMap->mOgreID, tpMineMap->mOgreNum, false, true );
				break;
			}
		case CTplMineMap::EVENT_BRUSHOGREANDNOTIFY:
			{
				tRtnCode = BrushOgre( tpPlayer, tpMineMap->mOgreID, tpMineMap->mOgreNum, true, true );
				break;
			}
		case CTplMineMap::EVENT_DESBUFF:
			{
				tRtnCode = RandomHitBuff( tpPlayer, tpMineMap->mDecBuff );
				break;
			}
		case CTplMineMap::EVENT_BRUSHSPECIALOGRE:
			{
				tRtnCode = BrushOgre( tpPlayer, tpMineMap->mOgreID, tpMineMap->mOgreNum, true, false );
				break;
			}
		case CTplMineMap::EVENT_LOGINREPETION:
			{
				tRtnCode = LoginRepetion( tpPlayer, tpMineMap );
				break;
			}
		default:
			{
				tRtnCode = ERROR_ITEM_NOTEVENT;
				LOG_ERROR( "pro", "[%s:%d] player %d can't find minemap %d, event %d  eventidx %d", 
					__FUNCTION__, __LINE__, tpPlayer->GetCharID(), tpMineMap->mTempID, tRet, i );
				break;
			}
		}

		uint64_t ullGUID = tpItemMap->GetGUID();
		int nItemID = tpItemMap->GetItemID();

		// remove item
		if ( PlayerRemoveItem( tpPlayer, vIndex, 1) == 0)
		{
			LogEventLostItemByUse( tpPlayer, ullGUID, nItemID, 1);
		}
	}
	else
	{
		// 通知客户端，继续前进，希望就在前方
		tRtnCode = ERROR_ITEM_MINEINFRONT;
	}

	return tRtnCode;
}

//***********************************
// FunctionName : OnUseToken
// Description  : 使用令牌
// Input Params : 玩家pEntity,道具tpItem,包裹索引vIndex
// Output Params: 
// Return Types : 
// Modified Time: [5/12/2009]
//***********************************

int CPropertyModule::OnUseToken(CEntity *pEntity, CTplItem *tpItem, int vIndex)
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}
	
	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}
	
	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) pEntity;
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();
	CTplToken* tpTplToken = ( CTplToken* ) tpItem;	   	
	

	CItemToken* tpToken = ( CItemToken* ) tpProperty->GetTaskBaggage()->GetItemObjPtr( vIndex );
	if ( tpToken == NULL )
	{
		return -1;
	}
	
	// 检查读条时间	
	if ( tpProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TOKEN, tpPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use token, roleid:%d", tpPlayer->GetCharID() );
		return -1;
	}

	// check scope
	int tRet = 0;
	CWTPoint tPos( tpToken->GetPosX(), tpToken->GetPosY() );
	if ( tPos.LimitDistance( tpPlayer->GetPos(), tpTplToken->mRadius )
		&& tpToken->GetMapID() == tpPlayer->GetMapID() )
	{
		// summon ogres
		BrushOgre( tpPlayer, tpTplToken->mOgreID, tpTplToken->mOgreNum, true, true );

		uint64_t ullGUID = tpToken->GetGUID();
		int nTokenItemID = tpToken->GetItemID();
		if (PlayerRemoveItem( ( CEntityPlayer* )pEntity, vIndex, 1, &ullGUID, true) == 0)
		{
			LogEventLostItemByUse( ( CEntityPlayer* )pEntity, ullGUID, nTokenItemID, 1);
		}

		tRet = SUCCESS;		
	}
	else
	{
		tRet = ERROR_ITEM_MINEINFRONT;
	}
	return tRet;
}

int CPropertyModule::OnUseCard( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}

	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}

	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) pEntity;
	CTplItemCard* tpCard = ( CTplItemCard* ) tpItem;

	CItemObject *pItemObject = ((CPropertyPlayer*) tpPlayer->GetProperty())->GetBaggage( )->GetItemObjPtr( vIndex );
	if ( pItemObject == NULL) return -1;

	uint64_t ullGUID = pItemObject->GetGUID();

	int tEntityID = tpPlayer->GetCharID( );
	int nFinalExp = PlayerObtainExp( tpPlayer, tpCard->mExp, EXPREASON_EXPITEM, &tEntityID, 1 );

	if ( nFinalExp > 0)
	{
		LogEventGetExpByCard( tpPlayer, tpCard->mExp, nFinalExp, tpItem->mTempID, ullGUID);
	}

	if ( PlayerRemoveItem( tpPlayer, vIndex, 1) == 0)
	{
		LogEventLostItemByUse(tpPlayer, ullGUID, tpItem->mTempID, 1);
	}
	
	return SUCCESS;
}

int CPropertyModule::OnUseGiftBag( CEntity* pEntity, CTplItem* tpItem, int vIndex, int vParam )
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}

	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}

	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) pEntity;
	CTplGiftBag* tpGiftBag = ( CTplGiftBag* ) tpItem;
	CPropertyPlayer *tpProperty = (CPropertyPlayer*) tpPlayer->GetProperty();

	if ( tpPlayer->GetLevel() < tpGiftBag->mMinLevel )
	{
		return ERROR_LEVELLOW;
	}	

	CItemObject *pItemObject = tpProperty->GetBaggage( )->GetItemObjPtr( vIndex );

	// 先计算空格
	int tDropNumber[ MAX_DROP_TURN ] = { 0 };
	int tTotalNum = 0;

	if ( tpPlayer->GetLevel() >= ARRAY_CNT(tpGiftBag->mLevelTableID) )
	{
		return ERROR_LEVELLOW;
	}

	// 如果需要钥匙

	int tOpenTableID = 0;
	int tIndex = -1;
	if ( tpGiftBag->mOpenItemID[ 0 ] != 0 )
	{
		for ( int i = 0; i < ARRAY_CNT(tpGiftBag->mOpenItemID); i++ )
		{
			if ( HasItemOnIndex( tpPlayer->GetEntityID(), vParam, tpGiftBag->mOpenItemID[ i ], 1 ) == true )
			{
				tOpenTableID = tpGiftBag->mOpenTableID[ i ];
				tIndex = i;
				break;
			}
		}
		if ( tIndex == -1 )
		{
			return ERROR_NOITEM;
		}
	}

	int tDropTableID = tpGiftBag->mDropTableID == 0 ? tpGiftBag->mLevelTableID[ tpPlayer->GetLevel() ] : tpGiftBag->mDropTableID;

	if ( tOpenTableID != 0 )
	{
		tDropTableID = tOpenTableID;
	}

	CTemplateTotalDrop *totalDrop = (CTemplateTotalDrop*) CDataStatic::SearchTpl( tDropTableID );
	if( totalDrop == NULL )
	{
		return ERROR_TPLNOTEXIST;
	}
	for ( unsigned int n = 0; n < ARRAY_CNT( totalDrop->mDropCount ); n++ )
	{
		CTemplateDrop* tpDrop = (CTemplateDrop*) CDataStatic::SearchTpl( totalDrop->mDropTableID[ n ] );
		if ( tpDrop == NULL )
		{
			break;
		}
		int	tRand		= RAND(SERVER_PERCENT_INT);
		int	tLowRan		= SERVER_PERCENT_INT;
		int	tHighRan	= SERVER_PERCENT_INT;	
		for ( int j = ARRAY_CNT(tpDrop->mDropNumberProbability) - 1; j >= 1 ; j -- )
		{
			tLowRan		-= ( j == 1 ) ? tLowRan : tpDrop->mDropNumberProbability[ j - 1 ];
			tHighRan	-= tpDrop->mDropNumberProbability[ j ];
			if ( tRand >= tLowRan && tRand < tHighRan )
			{
				tDropNumber[ n ] = j - 1;
				tTotalNum ++;
				break;
			}
		}
	}

	// 只有福袋检查次数
	if ( tpGiftBag->mCheckBag != 0 )
	{
		CItemBoxToolkit tItemBoxTooKit( tpProperty->GetBaggage() );
		if ( tItemBoxTooKit.GetLeftPileNum( -1 ) < tTotalNum - 1 )
		{			
			return ERROR_INSERTITEM_NOSPACE;
		}
	}	

	// 改为先扣物品
	uint64_t ullGUID = 0;
	if ( PlayerRemoveItem( tpPlayer, vIndex, 1, &ullGUID) == 0 ) 
	{
		LogEventLostItemByUse(tpPlayer, ullGUID, tpItem->mTempID, 1);
	}

	if ( tpGiftBag->mOpenItemID[ 0 ] != 0 )
	{
		if ( PlayerRemoveItem( tpPlayer, vParam, 1, &ullGUID ) == 0 ) 
		{
			LogEventLostItemByUse(tpPlayer, ullGUID, tpGiftBag->mOpenItemID[ tIndex ], 1);
		}
	}
	
	
	int tRandMoney = RAND(tpGiftBag->mMaxMoney - tpGiftBag->mMinMoney);
	int tGetMoney = tpGiftBag->mMinMoney + tRandMoney;
	if ( tGetMoney > 0 && PlayerChangeMoney( tpPlayer, tGetMoney, false, false ) == SUCCESS )
	{
		LogEventGetMoneyByGift( tpPlayer, CYuanBao::em_unbind_money, tGetMoney, tpGiftBag->mTempID );
	}

	//int tRandBindMoney = RAND(tpGiftBag->mMaxBindMoney - tpGiftBag->mMinBindMoney);
	int tGetBindMoney = tpGiftBag->mMinBindMoney + tRandMoney;
	if ( tGetBindMoney > 0 && PlayerChangeMoney( tpPlayer, tGetBindMoney, false, true ) == SUCCESS )
	{
		LogEventGetMoneyByGift( tpPlayer, CYuanBao::em_bind_money, tGetBindMoney, tpGiftBag->mTempID );
	}

	//int tRandSilverYB = RAND(tpGiftBag->mMaxSilverYB - tpGiftBag->mMinSilverYB);
	int tGetSilverYB = tpGiftBag->mMinSilverYB + tRandMoney;
	if ( tGetSilverYB > 0 && PlayerChangeYuanbao( tpPlayer, tGetSilverYB, true ) == true )
	{
		LogEventGetMoneyByGift( tpPlayer, CYuanBao::em_silver_yuanbao, tGetSilverYB, tpGiftBag->mTempID );
	}

	int tRandExp = RAND(tpGiftBag->mMaxExp - tpGiftBag->mMinExp);
	int tGetExp = tpGiftBag->mMinExp + tRandExp;
	if ( tGetExp > 0 )
	{
		PlayerObtainExp( tpPlayer, tGetExp, EXPREASON_EXPITEM );
	}	

	DropItemByID( pEntity, pEntity, tDropTableID, CDropFrom(pItemObject), tDropNumber, 1, tpGiftBag->mCheckBag == 0 ? true: false );

	SendUseItemNotify( tpPlayer, tpGiftBag->mLiHuaID );

	return SUCCESS;
}

int CPropertyModule::OnUseLifeSkillScroll( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{
	LK_ASSERT( pEntity != NULL && tpItem != NULL, return -1 )	
	if ( !pEntity->IsPlayer() )
	{		
		return -1;
	}
	
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	if ( tpItem->mItemType != CTplItem::ITEM_LIFESKILLSCROLL )
	{
		return -1;		
	}
	
	CTplItemLifeSkillScroll *tpLifeSkillScroll = ( CTplItemLifeSkillScroll * )tpItem;
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )tpPlayer->GetProperty();
	
	CTemplateMultiCompose *tpCompose = ( CTemplateMultiCompose * )CDataStatic::SearchTpl( tpLifeSkillScroll->mComposeID );
	LK_ASSERT( tpCompose != NULL, return  -1 )
	
	CLifeSkill *tpLifeSkill = ( CLifeSkill * )tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpCompose->mLifeSkillType );
	if ( tpLifeSkill == NULL )
	{			
		return ERROR_LIFESKILL_WRONGLIFESKILL;
	}	
	
	// TODO:改成宏
	int tAP = 100;
	unsigned int tPlayerMoney = 100000; 
	
	int tRet = tpLifeSkill->StudyCompose( tpLifeSkillScroll->mComposeID, COMPOSEGETWAY_BYSCROLL, tAP, tPlayerMoney );
	
	SendResponseStudyCompose( tpPlayer, tRet, tpLifeSkill->GetSpecializedDegree(), tpLifeSkillScroll->mComposeID, tpLifeSkill->GetLifeSkillType(), COMPOSEGETWAY_BYSCROLL );	
		 
	if ( tRet == SUCCESS )
	{
		uint64_t ullGUID = 0;
		if ( PlayerRemoveItem( tpPlayer, vIndex, 1, &ullGUID) == 0)
		{
			LogEventLostItemByUse(tpPlayer, ullGUID, tpItem->mTempID, 1);	
		}
	    LogLifeSkillAction( tpPlayer->GetCharID(), tpLifeSkill, EM_LIFESKILLACTION_USECOMPOSESCROLL, tpLifeSkillScroll->mComposeID );
	}
	return SUCCESS;
}
	

// 使用 功能性物品 处理
int CPropertyModule::OnUseFuncItem( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}

	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}
	
	bool bTaskItem = false;
	CEntityPlayer* tpPlayer  = ( CEntityPlayer* ) pEntity;
	CPropertyPlayer* tpPro   = ( CPropertyPlayer* ) tpPlayer->GetProperty();
	CTplFuncItem* tpFuncItem = ( CTplFuncItem* ) tpItem;	

	switch( tpFuncItem->mFuncCode )
	{
	case FUNCCODE_RECVMWHP:
		{
			CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
			if ( tpMW == NULL )
				return ERROR_MW_NOTEQUIP;
			int tOldHP = tpMW->GetHp();
			if ( tpMW->GetHp() >= tpMW->GetMaxHp() )
				return ERROR_MW_FULLHP;	// 灵气已满
			tpMW->OnIncHp( tpFuncItem->mParams[0] );
			NotifyRefreshMagicWeaponProperty( tpPlayer, MAGIC_WEAPON_HP, -1 );
			if (tOldHP <= 0 ) // 要刷人
				RefreshPlayerProperty(tpPlayer);
			break;
		}
	case FUNCCODE_RECVMWMP:
		{
			CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
			if ( tpMW == NULL )
				return ERROR_MW_NOTEQUIP;
			if ( tpMW->GetMp() >= tpMW->GetMaxMp() )
				return ERROR_MW_FULLMP;	// 法力已满
			tpMW->OnIncMp( tpFuncItem->mParams[0] );
			NotifyRefreshMagicWeaponProperty( tpPlayer, MAGIC_WEAPON_MP, -1 );
			break;
		}
	case FUNCCODE_FAMILYEXPCARD:
		{
			CreatFamilyRedStone( tpPlayer, tpItem->mTempID );
			bTaskItem = true;
			break;
		}

	case FUNCCODE_WIZARDVALUE:
		{
			int tRet = PlayerObtainWizardValue( tpPlayer, tpFuncItem->mParams[0], tpFuncItem->mParams[1] );
			if ( tRet != SUCCESS )
			{
				return tRet;
			}
			break;
		}

	case FUNCCODE_GETTITLE:
		{
			// 百花仙子最新改动：如果卷轴有到期时间，则出来的称号使用这个到期时间！
			// 2011-2-17 最新改动：模板标示了是百花仙子卷轴才这么干
			int nTm=0;
			CItemObject* tpObj = tpPro->GetBaggage()->GetItemObjPtr(vIndex);
			LK_ASSERT(tpObj != NULL, return -1);

			// 潜规则：参数1：1，百花仙子 0 普通
			if (tpFuncItem->mParams[1] == 1)
			{
				if ( tpObj->GetInvalidTime() != 0 )
					nTm = tpObj->GetInvalidTime();
			}

			if ( SUCCESS != OnPlayerAddTitleEvent( tpPlayer, tpFuncItem->mParams[0], nTm ) )
				return ERROR_CANNUSEITEM;
			break;
		}
	case FUNCCODE_LIHUA:
		{
            // add by yucx  20100707 节庆礼花
            CTemplateBuff* tpBuffTpl  = ( CTemplateBuff * )CDataStatic::SearchTpl( tpFuncItem->mParams[4]);
            if( tpBuffTpl != NULL)
            {
                int tCharID = tpPlayer->GetCharID();

                if(tpPlayer->EntityInsertBuff(tpPlayer, tpBuffTpl) != SUCCESS )   
                {
                    return ERROR_ITEM_NOTEVENT;
                }
				int pTime = tpBuffTpl->mLastTime/1000;
				if (pTime >=60)
				{
					LogEventGetBuffByItem(tpPlayer,tpBuffTpl->mTempID,pTime ,tpFuncItem->mParams[4]);
				}


                CTemplateLevelExp* tpLevelExp = (CTemplateLevelExp*) CDataStatic::SearchTpl( tpFuncItem->mParams[6]);

                if( tpLevelExp != NULL)
                {
                    int tExp = ( int ) (tpLevelExp->mLevelExp[ tpPro->GetLevel( ) ] * ( tpFuncItem->mParams[5] /SERVER_PERCENT_FLOAT ));

                    PlayerObtainExp( tpPlayer, tExp, EXPREASON_EXPITEM, &tCharID, 1 );
                }

            }   
			SendUseItemNotify( tpPlayer, tpFuncItem->mTempID );
			break;
		}
	case FUNCCODE_MATRIX:
		{
			int tIndex = tpFuncItem->mParams[ 0 ];
			int tValue = tpFuncItem->mParams[ 1 ];
			int tSlavePoint = tpFuncItem->mParams[ 2 ];
			int tMasterPoint = tpFuncItem->mParams[ 3 ];
			tpPro->AddSlaveValue( tValue, tIndex );
			tpPro->SetSlavePoint( tpPro->GetSlavePoint() + tSlavePoint );
			tpPro->SetMasterPoint( tpPro->GetMasterPoint() + tMasterPoint );
			tpPro->SetSlaveTotal( tpPro->GetSlaveTotal() + tSlavePoint );
			tpPro->SetMasterTotal( tpPro->GetMasterTotal() + tMasterPoint );
			CFriendModule::GetSingleton().SendSlaveValueNotify( tpPlayer );
			CTemplateMatrixTable *tpTable = (CTemplateMatrixTable*)CDataStatic::GetTemp( TEMP_MATRIXTABLE );
			if ( tpTable != NULL )
			{
							
			}
			break;
		}
	case FUNCCODE_LEVEL:
		{
			if ( (int)(tpPro->GetLevel()) > tpFuncItem->mParams[ 0 ] )
			{
				return ERROR_LEVELHIGH;
			}
			//tpPro->SetLevel( tpPro->GetLevel() + 1 );
			tpPro->LevelUp();
			tpPro->SetExp( 0 );
			OnPlayerLevelUp( tpPlayer, 1 );
			SendObtainExpNotice( tpPlayer, 0, tpPro->GetExp( ), 0, true, 0, 0 );
			ResultListSend( );
			break;
		}
	case FUNCCODE_REPAIR:
		{
			if ( MendAllEquipment( tpPlayer ) == false )
			{
				return SUCCESS;
			}
			break;
		}
	case FUNCCODE_LUCKYBAG:
		{
			int nRet = CActivityModule::GetSingleton().OnUseLuckyBag( tpPlayer, tpFuncItem, vIndex );
			if ( nRet == SUCCESS )
				break;
			else
				return nRet;
		}
	case FUNCCODE_CLEARRED:
		{
			if ( tpPro->GetPKValue() == 0 )
			{
				return ERROR_NOTRED;
			}
			if ( tpPlayer->GetLevel() > tpFuncItem->mParams[ 0 ] )
			{
				return ERROR_LEVELHIGH;
			}
			if ( tpPlayer->GetLineID() != tpPlayer->GetNationality()
			|| tpPlayer->GetMapID() != tpFuncItem->mParams[ 1 ] 
			|| tpPlayer->GetPosX() != tpFuncItem->mParams[ 2 ]
			|| tpPlayer->GetPosY() != tpFuncItem->mParams[ 3 ])
			{
				return ERROR_USERED;
			}
			tpPro->SetPKValue( 0 );
			SendPKValueMessage( tpPlayer, 0 );
			break;
		}
	case FUNCCODE_FAMILY_MONEY:
		{
			CFamilyModule::GetSingletonPtr()->ChangeFamilyMoney( tpPlayer, tpFuncItem->mParams[0], false, REASON_USEMONEYITEM );
			break;
		}
	case FUNCCODE_CORPS_MONEY:
		{
			CCorpsModule::GetSingletonPtr()->ChangeCorpsMoney( tpPlayer, tpFuncItem->mParams[0], false, REASON_USEMONEYITEM );
			break;
		}
	case FUNCCODE_DUNGEON_TIME_DEL:
		{
			CRepetionModule::GetSingletonPtr()->DelteRepetionCount( tpPlayer, tpFuncItem->mParams[0] );
			break;
		}
	case FUNCCODE_POINT:
		{
			tpPro->SetRemainPoint( tpPro->GetRemainPoint() + tpFuncItem->mParams[0] );
			tpPro->SetSkillPoint( tpPro->GetSkillPoint() + tpFuncItem->mParams[1] );
			tpPlayer->NotifyPropertyRefresh( );
			break;
		}
	case FUNCCODE_EXP:
		{

            //经验性物品, 按经验表获得经验 add by yucx 20100713

            int tExp = 0;
            CTemplateLevelExp* tpLevelExp = (CTemplateLevelExp*) CDataStatic::SearchTpl( tpFuncItem->mParams[1]); 
            if(NULL != tpLevelExp)
            {     
                tExp =(int) ( tpLevelExp->mLevelExp[ tpPro->GetLevel( ) ]* ( tpFuncItem->mParams[2] /SERVER_PERCENT_FLOAT ) );    
            }else{
                tExp = tpFuncItem->mParams[0];
            }    

			int tCharID = tpPlayer->GetCharID();
			PlayerObtainExp( tpPlayer, tExp, EXPREASON_EXPITEM, &tCharID, 1 );

			LogEventGetExpByExpItem( tpPlayer, tExp,  tpFuncItem->mParams[0] );

			break;
		}
	case FUNCCODE_ACTIVITY:
		{
			// int 附加参数0：物品GUID中创建时的时间戳
			CItemObject* tpObj = tpPro->GetBaggage()->GetItemObjPtr(vIndex);
			LK_ASSERT(tpObj != NULL, return -1);
				
			int nCretm = tpObj->GetGUIDObj().a.st.tmstmp;
			std::vector<int> tInts;
			tInts.push_back(nCretm); 
			tInts.push_back(tpPlayer->GetEntityID()); // 参数2 玩家实体ID
			std::vector<std::string> tStrs;
			if ( 0 != CActivityModule::GetSingleton().FireActivityEvent( tpFuncItem->mParams[0], tpFuncItem->mParams[1], 
				tInts, tStrs ) )
			{
				return SUCCESS; // 这种情况不干掉物品
			}
			break;
		}
	case FUNCCODE_CLEARMWSP: // 清除法宝技能点
		{
			// 检查安全保护时间
			int tPwdCheckRet = tpPro->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
			if ( tPwdCheckRet != SUCCESS )
			{
				return tPwdCheckRet;
			}	

			CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
			if ( tpMW == NULL )
				return ERROR_MW_CANT_CLEARSP;

			// 先获得总加点数 如果是0 则不让用
			if ( tpMW->GetTotalAddSP() <= 0 )
				return ERROR_MW_SP_NOADD;

			tpMW->ClearMWSkillPoint();

			CMessageMagicWeaponClearPointResponse msg;
			msg.set_cleartype(CLEARTYPE_SP);
			msg.set_mwbagindex(-1);
			PBItemObject* tpObj = msg.mutable_mwobj();
			tpMW->GetItemBinaryBuffer2( tpObj );
			CMessage tMessage;
			tMessage.set_msgpara((uint32_t) &msg);
			tMessage.mutable_msghead()->set_messageid(ID_S2C_MAGICWEAPONCLEARPOINTRESPONSE);
			CSceneLogic::GetSingleton( ).Send2Player( tpPlayer, &tMessage );
			RefreshPlayerProperty( tpPlayer );
			break;
		}
	case FUNCCODE_MWGETEXP:
		{
			CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
			if ( tpMW == NULL )
				return ERROR_MW_NOTEQUIP;

			int tExp = 0;
			CTemplateLevelExp* tpLevelExp = (CTemplateLevelExp*) CDataStatic::SearchTpl( tpFuncItem->mParams[0]); 
			if(NULL != tpLevelExp)
			{     
				tExp =(int)tpLevelExp->mLevelExp[ tpMW->GetMWLevel( ) ];    
			}
			else
			{
				tExp = tpFuncItem->mParams[0];
			}    
			if ( OnMagicWeaponObtainExp( tpPlayer, tExp, true ) < 0 )
			{
				return ERROR_MW_LEVEL_FULL;
			}
			break;
		}
	case FUNCCODE_FAME:
		{
			int tType = tpFuncItem->mParams[0];
			int tValue = tpFuncItem->mParams[1];
			if ( tType == 1 )
			{
				if ( tpPro->mWizard.GetCombatFame() + tValue > FAME_TOTAL_LIMIT )
					return ERROR_FAME_LIMIT;
				// 要先减少今日上限
				tpPro->mWizard.SetCombatToday( tpPro->mWizard.GetCombatToday() - tValue );
				ChangeCombatFame( tpPlayer, tValue );
			}
			else if ( tType == 2 )
			{
				if ( tpPro->mWizard.GetRepeFame() + tValue > FAME_TOTAL_LIMIT )
					return ERROR_FAME_LIMIT;
				// 要先减少今日上限
				tpPro->mWizard.SetRepeToday( tpPro->mWizard.GetRepeToday() - tValue );
				ChangeRepeFame( tpPlayer, tValue );
			}
			else if ( tType == 3 )
			{
				if ( tpPro->mWizard.GetCommonFame() + tValue > FAME_TOTAL_LIMIT )
					return ERROR_FAME_LIMIT;
				// 要先减少今日上限
				tpPro->mWizard.SetCommonToday( tpPro->mWizard.GetCommonToday() - tValue );
				ChangeCommonFame( tpPlayer, tValue );
			}
			break;
		}
	case FUNCCODE_CORPCRYSTAL:
		{

			int tCharID = tpPlayer->GetCharID();
			int tFinalExp = PlayerObtainExp( tpPlayer, tpFuncItem->mParams[1], EXPREASON_EXPITEM, &tCharID, 1 );

			LogEventGetExpByExpItem( tpPlayer, tpFuncItem->mParams[1],  tFinalExp);

			CCorpsModule::GetSingletonPtr()->ChangeCorpsBossTimes( tpPlayer, tpFuncItem->mParams[0],1 ,REASON_USECORPCRYSTAL );
			CCorpsModule::GetSingletonPtr()->ChangeCorpsGlory(tpPlayer, tpFuncItem->mParams[2]  );
			break;
		}
	case FUNCCODE_CORPBOSSSTONE:
		{
			CCorpsModule::GetSingletonPtr()->ChangeCorpsBOSSRefineValue( tpPlayer, tpFuncItem->mParams[0],REASON_USECORPBOSSSTONE );

			break;
		}
	default:
		{
			LOG_ERROR("pro", "error funccode = %d  temp id=%d", tpFuncItem->mFuncCode, tpFuncItem->mTempID );
			return SUCCESS;
		}
	}

	uint64_t ullGUID = 0;
	if ( PlayerRemoveItem( tpPlayer, vIndex, 1, &ullGUID, bTaskItem) == 0)
	{
		LogEventLostItemByUse( tpPlayer, ullGUID, tpItem->mTempID, 1);
	}

	return SUCCESS;
}

// 使用红包
int CPropertyModule::OnUseRedPaper( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{
	LK_ASSERT( pEntity != NULL && tpItem != NULL, return -1 )	
	LK_ASSERT( tpItem->mItemType == CTplItem::ITEM_REDPAPER, return -1  ) 	
	if ( !pEntity->IsPlayer() )
	{		
		return -1;
	}
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	
	CTplItemRedPaper *tpRedPaper = ( CTplItemRedPaper * )tpItem;


	CItemObject *pItemObject = ((CPropertyPlayer*) tpPlayer->GetProperty())->GetBaggage( )->GetItemObjPtr( vIndex );
	if ( pItemObject == NULL) return -1;
	
	// 计算开取的非绑定金							
	int tTotalNum = 0;
	for ( size_t i = 0; i < ARRAY_CNT(tpRedPaper->mMoney); ++i )
	{
		tTotalNum += tpRedPaper->mMoney[i].mProbality;	
	}
	if ( tTotalNum <= 0 )
	{
		LOG_ERROR( "pro","  template CTplItemRedPaper error: money probality not correct " );
		return -1;
	}
	int tRandNum = rand()%tTotalNum;
	tTotalNum = 0;
	size_t tMoneyIndex = 0;	
	for ( ; tMoneyIndex < ARRAY_CNT( tpRedPaper->mMoney ); ++tMoneyIndex )
	{
		if ( tRandNum >= tTotalNum && tRandNum < ( tTotalNum + tpRedPaper->mMoney[tMoneyIndex].mProbality ) )
		{
			break;
		}		
		tTotalNum +=  tpRedPaper->mMoney[tMoneyIndex].mProbality;
	}
	
	if ( tpRedPaper->mMoney[tMoneyIndex].mValue > 0 )
	{
		if (PlayerChangeMoney( tpPlayer, tpRedPaper->mMoney[tMoneyIndex].mValue, false, false ) == SUCCESS)
		{
			LogEventGetMoneyByRedBag(tpPlayer, CYuanBao::em_unbind_money, 
					tpRedPaper->mMoney[tMoneyIndex].mValue, pItemObject->GetItemID(), pItemObject->GetGUID());
		}
	}	
	
	// 计算开取的非绑定金
	tTotalNum = 0;
	for ( size_t i = 0; i < ARRAY_CNT(tpRedPaper->mBindMoney); ++i )
	{
		tTotalNum += tpRedPaper->mBindMoney[i].mProbality;	
	}
	if ( tTotalNum > 0 )
	{
		tRandNum = rand()%tTotalNum;
		tTotalNum = 0;
		tMoneyIndex = 0;	
		for ( ; tMoneyIndex < ARRAY_CNT( tpRedPaper->mBindMoney ); ++tMoneyIndex )
		{
			if ( tRandNum >= tTotalNum && tRandNum < ( tTotalNum + tpRedPaper->mBindMoney[tMoneyIndex].mProbality ) )
			{
				break;
			}		
			tTotalNum +=  tpRedPaper->mBindMoney[tMoneyIndex].mProbality;
		} 

		if ( tpRedPaper->mBindMoney[tMoneyIndex].mValue > 0 )
		{
			if (PlayerChangeMoney( tpPlayer, tpRedPaper->mBindMoney[tMoneyIndex].mValue, false, true ) == SUCCESS)
			{
				LogEventGetMoneyByRedBag(tpPlayer, CYuanBao::em_bind_money, 
					tpRedPaper->mBindMoney[tMoneyIndex].mValue, pItemObject->GetItemID(), pItemObject->GetGUID());
			}
		}
		
	}  
	
	PlayerRemoveItem( tpPlayer, vIndex, 1, false );
	return SUCCESS;
}

// 使用黑狗丸
int CPropertyModule::OnUseBlackPills( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{
	LK_ASSERT( pEntity != NULL && tpItem != NULL, return -1 )	 
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	ChangeOffLineTimeToExp( tpPlayer, vIndex );
	return SUCCESS;
}

// 计算玩家的离线经验
int CPropertyModule::ChangeOffLineTimeToExp( CEntityPlayer *pPlayer, int nIndex , int nTemplateID )
{
	LK_ASSERT( pPlayer != NULL, return -1 )
	int tBlackPillID = 0;
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	if ( nIndex >= 0 )
	{
		CItemObject *tpItemObj = tpProperty->GetBaggage()->GetItemObjPtr( nIndex );
		LK_ASSERT( tpItemObj != NULL, return -1 )
		CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
		LK_ASSERT( tpTplItem != NULL, return -1 )
		if ( tpTplItem->mItemType != CTplItem::ITEM_BLACKPILLS )
		{
			return -1;
		}
		tBlackPillID = tpItemObj->GetItemID();	
	}
	
	if( nTemplateID != -1 ){

		CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( nTemplateID );
		LK_ASSERT( tpTplItem != NULL, return -1 )
		if ( tpTplItem->mItemType != CTplItem::ITEM_BLACKPILLS )
		{
			return -1;
		}
		tBlackPillID = tpTplItem->mTempID;	
	}
	
	int tExp = 0;
	int tOffLineTimeConsumed = 0;
	
	if ( pPlayer->GetLevel() >= MAX_GRADE && nIndex >= 0 )
	{		
		SendUseBlackPillsNotify( pPlayer, tpProperty->GetExpTimeInfo()->GetOffLineTimeLength(), tpProperty->GetExpTimeInfo()->GetBlackPillTime()
			, nIndex, tExp, tOffLineTimeConsumed, tpProperty->GetExpTimeInfo()->GetBlackPillID(), ERROR_BLACKPILLS_MAXLEVEL );
		return SUCCESS;
	}
	

	int tRet = tpProperty->GetExpTimeInfo()->ExchangeOffLineTimeToExp( pPlayer->GetLevel(), tExp, tOffLineTimeConsumed, tBlackPillID );	
	SendUseBlackPillsNotify( pPlayer, tpProperty->GetExpTimeInfo()->GetOffLineTimeLength(), tpProperty->GetExpTimeInfo()->GetBlackPillTime()
		, nIndex, tExp, tOffLineTimeConsumed, tpProperty->GetExpTimeInfo()->GetBlackPillID(), tRet );
	if ( tExp > 0 )
	{
		int tCharID = pPlayer->GetCharID();
		PlayerObtainExp2( pPlayer, tExp, 0, EXPREASON_EXPITEM, &tCharID, 1 );
		
		// 记录经验
		LogEventGetExpByBlackPill( pPlayer, tExp, tpProperty->GetExpTimeInfo()->GetBlackPillID() );
	}
	
	if ( nIndex >= 0 && tRet == SUCCESS )
	{
		PlayerRemoveItem( pPlayer, nIndex,  1 );
		uint64_t tGuID = 0;
		LogEventLostItemByUse( pPlayer, tGuID, tBlackPillID, 1  );
	}
	return SUCCESS;
}

int CPropertyModule::RandomDropItem(CEntityPlayer *pEntity, int vDropID, const CDropFrom& vDropFrom, int vDropType)
{
	if ( pEntity == NULL )
	{
		return -1;
	}

	CPropertyPlayer *tpProperty = (CPropertyPlayer*)pEntity->GetProperty();

	CItemBoxToolkit tItemBoxTooKit( tpProperty->GetBaggage() );
	if ( vDropType == 1 && tItemBoxTooKit.GetLeftPileNum( -1 ) < 1 )
	{			
		return ERROR_INSERTITEM_NOSPACE;
	}
		
	DropItemByID( pEntity, pEntity, vDropID, vDropFrom, NULL, vDropType, false );

	return SUCCESS;
}

int CPropertyModule::RandomHitBuff( CEntityPlayer* pEntity, int vBuffID )
{
	if ( pEntity == NULL )
	{
		return -1;
	}
	CTemplateBuff* tpBuff = ( CTemplateBuff* ) CDataStatic::SearchTpl( vBuffID );
	if ( tpBuff == NULL )
	{
		return ERROR_USESKILL_SKILLNOTFOUND;
	}

	pEntity->EntityInsertBuff( pEntity, tpBuff );
	int pTime = tpBuff->mLastTime/1000;
	if (pTime >= 60)
	{
		LogEventGetBuffBySystem(pEntity,vBuffID,pTime);
	}
	
	return SUCCESS;
}

int CPropertyModule::BrushOgre( CEntityPlayer* pEntity, int vOgreID, int vNum, bool bNotify, bool bNormal )
{
	if ( pEntity == NULL )
	{
		return -1;
	}
	
	int tStep = -1, j = 1;
	for ( int i = 0; i < vNum; i ++ )
	{
		if ( ( j % 4 ) == 0 )
		{
			tStep += 1;
			j = j % 4 + 1;
		}
		if ( tStep == 0 && j == 2 )
		{
			j ++;
			continue;
		}
		else
		{
			CTemplateOgre* tpOgre = ( CTemplateOgre* )CDataStatic::SearchTpl( vOgreID );
			CWTPoint tPos = CWTPoint( pEntity->GetPosX() + tStep, pEntity->GetPosY() + ( j - 2 ) );
			CreateNpc( pEntity, vOgreID, ENTITYTYPE_OGRE, tPos, 
					( tpOgre == NULL ) ? 300000 : ( tpOgre->mLifeTime * 1000 ), true, true );
		}
		j ++;
	}
	
	/*if ( bNotify )
	{		
		char tNotice[ NAME_LENGTH * 4 + 1 ] = { 0 };
		const char* tpNotify = CSceneLogic::GetSingleton().GetLangText( LANG_PRO_BRUSHOGRE );
		if ( tpNotify == NULL )
		{
			return -1;
		}
		sprintf( tNotice, "%s(%d,%d),%s", pEntity->GetMapObject()->GetMapName(), pEntity->GetPosX(), pEntity->GetPosY(), tpNotify );
		CChatModule::GetSingleton().SendSysNotice( tNotice, 3 );
	}*/

	return SUCCESS;
}

int CPropertyModule::LoginRepetion(CEntityPlayer *pEntity, CTplMineMap* tpMap)
{
	if ( pEntity == NULL || tpMap == NULL )
	{
		return -1;
	}

	CRepetionModule::GetSingleton().RedirectRepetionMap( pEntity, tpMap->mMapID, tpMap->mPosX, tpMap->mPosY, NULL );

	return SUCCESS;
}

// 光环持续上报
void CPropertyModule::ContinuedAureoleSkill( CEntityCharacter* pSrcEntity, CTemplateAureoleSkill* pAureoleSkill, CWTPoint& vPos, CEntityCharacter** vEntityList, int vEntityListNum )
{
	if ( pSrcEntity == NULL || pAureoleSkill == NULL || vEntityList == NULL )
		return;

	CEntityCharacter* tpEntityList[ TEAMNUM ] = { NULL };
	int tEntityCount = 0;
	
	for ( int i = 0; i < vEntityListNum && i < FUNC_LIMIT; i++ )
	{
		if ( vEntityList[ i ] == NULL )
			continue;

		if ( vEntityList[ i ]->GetEntityType() != ENTITYTYPE_PLAYER )
			continue;

		CEntityPlayer* tpPlayer = (CEntityPlayer*) vEntityList[ i ];
		if ( tpPlayer->IsTeamTo( pSrcEntity ) == false )
			continue;

		if ( pSrcEntity->IsWithinDistance( tpPlayer, pAureoleSkill->mAureoleDistance ) == false )
			continue;

		pSrcEntity->AddAureoEntityList( vEntityList[ i ] );
		tpEntityList[ tEntityCount ] = vEntityList[ i ];
		tEntityCount++;

		if ( tEntityCount >= TEAMNUM )
			break;
	}

	CEntityCharacter* tpAddEntityList[ TEAMNUM ] = { NULL };
	CEntityCharacter* tpRemoveEntityList[ TEAMNUM ] = { NULL };
	int tAddEntityCount = 0;
	int tRemoveEntityCount = 0;

	pSrcEntity->CheckAureoEntityList( vEntityList, vEntityListNum, tpAddEntityList, tAddEntityCount, tpRemoveEntityList, tRemoveEntityCount );

	for ( int i = 0; i < (int)ARRAY_CNT( pAureoleSkill->mAureoleType ); i++ )
	{
		if( pAureoleSkill->mAureoleType[ i ].mAureoleArea == CTemplateAureoleSkill::AUREOLE_NONE )
		{
			continue;
		}
		CTemplateBuff* tpBuffTpl = ( CTemplateBuff* )CDataStatic::SearchTpl( pAureoleSkill->mAureoleType[ i ].mBuffID );
		if( tpBuffTpl == NULL )
		{
			LOG_DEBUG( "pro", "[ %d : %s ][ %d ]Entity( %d ) Fiout Open Aureole, cannt find buff( TempID is %d, index"
				" is %d )", __LK_FILE__, __LINE__, __FUNCTION__, pSrcEntity->GetEntityID( ), 
				pAureoleSkill->mAureoleType[ i ].mBuffID, i );
			continue;
		}

		// 给添加列表中添加BUFF
		for ( int j = 0; j < tAddEntityCount && j < (int)ARRAY_CNT( tpAddEntityList ); j++ )
		{
			tpAddEntityList[ j ]->EntityInsertBuff( pSrcEntity, tpBuffTpl );
		}
		// 给删除列表中,去掉BUFF
		for ( int j = 0; j < tRemoveEntityCount && j < (int)ARRAY_CNT( tpRemoveEntityList ); j++ )
		{
			tpRemoveEntityList[ j ]->EntityRemoveBuff( tpBuffTpl->mTempID );
			LOG_DEBUG( "pro", "[ %s : %d ] [ %s ] Remove Buff! for ActiveRemoveBuff error test!", __LK_FILE__, __LINE__, __FUNCTION__ );
		}
	}
}

void CPropertyModule::SendUseItemResponse( CEntityPlayer *pPlayer, int vResult, int vPos, int vIndex, int vItemID, int vParam1, int vParam2, int vParam3 )
{
	static CMessageUseItemResponse tUseItemResponse;
	static CMessage tMessage;

	tUseItemResponse.Clear();
	tMessage.Clear();

	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_USEITEM );
	tMessage.set_msgpara( (uint32)&tUseItemResponse );

	tUseItemResponse.set_result( vResult );
	tUseItemResponse.set_pos( vPos );
	tUseItemResponse.set_index( vIndex );
	tUseItemResponse.set_itemid( vItemID );
	tUseItemResponse.set_param1( vParam1 );
	tUseItemResponse.set_param2( vParam2 );
	tUseItemResponse.set_param3( vParam3 );
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

int CPropertyModule::ChangeNationality( CEntityPlayer* vpPlayer, CampDef vCampDef )
{
	if( vCampDef == Zero )
	{
		return ERR_INVALID_PARAMETER;
	}

	if( vCampDef != One && vCampDef != Two && vCampDef != Three && vCampDef != Four && vCampDef != Five 
		&& vCampDef != Six )
	{
		return ERR_INVALID_PARAMETER;
	}

	if( vpPlayer->GetNationality( ) != Zero )
	{
		return ERR_UNKNOWN;
	}
	
	CTaskModule::GetSingletonPtr( )->ClearTasks( vpPlayer );
	
	vpPlayer->SetNationality( vCampDef );
	// 玉宇要求 自动挂任务
	CTaskModule::GetSingleton().SetDefaultTask( vpPlayer, "start_task_in_xsc" );

	CMessage tMsg;

	//send camp change notice to gateserver
	CMessageRoleChangeCampNotice tNoticeMsg;		
	tNoticeMsg.set_roleid(vpPlayer->GetCharID());
	tNoticeMsg.set_camp(vCampDef);

	tMsg.set_msgpara((uint32_t) &tNoticeMsg);
	pbmsg_sethead(&tMsg, ID_S2G_ROLECHANGECAMP_NOTICE, 0, 0, 0, 0, 0, 0);
	CSceneLogic::GetSingletonPtr()->Send2Gate( &tMsg );


	//send response to client.
	CMessageChangeCampResponse tMsgFact;

	tMsgFact.set_campid( ( unsigned int )vCampDef );
	
	tMsg.mutable_msghead( )->set_messageid( ID_S2C_CHANGE_CAMP_RESPONSE );
	tMsg.set_msgpara( ( int )&tMsgFact );

	CSceneLogic::GetSingletonPtr( )->Send2Player( vpPlayer, &tMsg );

	return SUCCESS;
}

// 犀哥专用
void CPropertyModule::UseSkillForServer( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity, CTemplateSkill* pSkill, CEntityCharacter** vEntityList, int vEntityListNum )
{
	LK_ASSERT( pSrcEntity != NULL && pDesEntity != NULL && pSkill != NULL, return );

	if( pSrcEntity->IsCharacter() == false
		&& pSrcEntity->IsPedal() == false )
	{
		LOG_ERROR( "pro", "[ %s : %d ][ %s ] Entity( %d ) Is not Character, cannt use Skill, type is %d",
			__LK_FILE__, __LINE__, __FUNCTION__, pSrcEntity->GetEntityID( ), pSrcEntity->GetEntityType() );
		return;
	}

	// 技能所有的结果集和影响实体列表,都放在下面这个类中
	pSrcEntity->InitFunResult( );	

	pSrcEntity->AddFunResult( pSrcEntity->GetEntityID( ), FUNC_ATTACK, RESULT_NONE, true,  
		pDesEntity->GetEntityID( ), pSkill->mSkillID, pSkill->mSkillLevel, pDesEntity->GetPosX( ), pDesEntity->GetPosY( ) ); 
	pDesEntity->AddFunResult( pDesEntity->GetEntityID( ), FUNC_ATTACKED, RESULT_NONE, true, 
		pSrcEntity->GetEntityID( ), pSkill->mSkillID, pSkill->mSkillLevel, pSrcEntity->GetPosX( ), pSrcEntity->GetPosY( ) );

	// 如果技能不需要施法时间
	if ( pSkill->mTimeType == CTemplateSkill::TIMETYPE_INSTANT )
		FireSkill( pSrcEntity, pDesEntity, pSkill, vEntityList, vEntityListNum );

	// 使用技能,对BUFF的相关处理
	CheckBuffEntityUseSkill( pSrcEntity, pDesEntity );	

	// 发送技能使用结果
	PERF_FUNC( "UseSkill_ResultListSend",  ResultListSend( ) );	
}



// 处理客户端打开服务器请求消息
void CPropertyModule::OnMessageOpenServiceRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );

	CMessageOpenServiceRequest* pOpenServiceRequest = (CMessageOpenServiceRequest*)pMessage->msgpara();

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();

	// 如果玩家没有谈话对象，不能进入商店服务
	// 这里不用判断 在使用具体服务的时候会判断的
	//if ( pProperty->GetTalkNpcEntityID( ) == 0 )
	//{
	//	return ;
	//}

	//TODO: 不验证玩家处于什么状态，每次都刷新
	//// 如果玩家已经处于商店服务状态
	//if ( pProperty->GetServiceStatus( ) == SERVICE_SHOP )
	//{
	//	SendProErrorNotice( pPlayer, ERROR_CLICKNPC_STATEINVALID );
	//	return;
	//}

	unsigned int unNpcID = pOpenServiceRequest->entityid();
	CEntity* tpDesEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( unNpcID ) );
//	CProperty* tpDesProperty = CProperty::SearchProByEntityID( unNpcID );
	CProperty* tpDesProperty = ( tpDesEntity != NULL ) ? tpDesEntity->GetProperty( ) : NULL;
	if ( tpDesProperty == NULL )
		return ;

	// 如果谈话目标不是NPC
	if ( tpDesProperty->GetEntityType( ) != ENTITYTYPE_FUNCNPC )
	{
		return ;
	}

	if ( pProperty->GetServiceStatus() == SERVICE_STALL || pProperty->GetServiceStatus() == SERVICE_TRADE )
	{
		return ;
	}
	

	CTemplateNpc* tpNpcTpl = (CTemplateNpc*) CDataStatic::SearchTpl( tpDesProperty->GetPropertyTempID( ) );
	if ( tpNpcTpl == NULL )
	{
		LOG_ERROR( "pro", "NPC=%d data not found", tpDesProperty->GetPropertyTempID( ) );
		return ;
	}

	int nResult = 0;
	 
	switch( pOpenServiceRequest->serviceid() )
	{
	case SERVICE_SHOP:
		{
			CTemplateSellTable* tpSellTable = (CTemplateSellTable*) CDataStatic::SearchTpl( tpNpcTpl->mSellServiceID );
			if ( tpSellTable == NULL )
			{
				// NPC没有商店服务
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}

			nResult = PlayerClickShop( pPlayer, unNpcID );
			break;
		}
	case SERVICE_MAIL:
		{
			if ( tpNpcTpl->mMailService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}

			nResult = PlayerClickMail( pPlayer, unNpcID );
			break;
		}
	case SERVICE_STORAGE:
		{
			if ( tpNpcTpl->mStorageService == 0 )
			{
				nResult =  ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickStorage( pPlayer, unNpcID );
			break;
		}
	case SERVICE_UPG:
		{
			if ( tpNpcTpl->mUpgService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickUpg( pPlayer, unNpcID );
			break;
		}
	case SERVICE_TELE:
		{
			// 如果NPC没有传送服务
			if ( tpNpcTpl->mStageID == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickTele( pPlayer, unNpcID );
			break;
		}
	case SERVICE_STUDYSKILL:
		{
			// 判断学习技能的玩家职业是否是功能npc所提供的学习技能的职业
			if ( tpNpcTpl->mStudySkillMetierID != pPlayer->GetMetier() )
			{
				nResult = ERROR_CLICKNPC_NOTMETIER;
				break;
			}

			nResult = PlayerClickStudySkill( pPlayer, unNpcID );
			break;
		}
	case SERVICE_TOWN:
		{
			// 如果NPC没有回城服务
			if ( tpNpcTpl->mTownX == 0 || tpNpcTpl->mTownY == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}

			nResult = PlayerClickTown( pPlayer, unNpcID );
			break;
		}
	case SERVICE_BIND:
		{
			// 如果NPC绑定服务
			if ( tpNpcTpl->mEqtBindService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}

			nResult = PlayerClickBind( pPlayer, unNpcID );
			break;
		}
	case SERVICE_WELFARE:
		{
			if ( tpNpcTpl->mWelfareService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}	
			nResult = PlayerClickWelfare( pPlayer, unNpcID );
			break;
		}
	case SERVICE_CHANGE:
		{
			if ( tpNpcTpl->mChangeService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickChange( pPlayer, unNpcID );
			break;
		}
	case SERVICE_JUDGE:
		{
			if ( tpNpcTpl->mJudgeService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickJudge( pPlayer, unNpcID );
			break;
		}
	case SERVICE_EXCHANGE:
		{
			if ( tpNpcTpl->mExchangeService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickExchange( pPlayer, unNpcID );
			break;
		}
	case SERVICE_HONOR:
		{
			if ( tpNpcTpl->mHonorService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			nResult = PlayerClickHonor( pPlayer, unNpcID );
			break;
		}
	case SERVICE_MWJUDGEPRO:
		{
			if ( tpNpcTpl->mMWProJudgeService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			pProperty->SetServiceStatus( SERVICE_MWJUDGEPRO );
			nResult = SUCCESS;
			break;
		}
	case SERVICE_MWJUDGESKILL:  // 法宝相关服务 就不写单独的函数了 就设置个服务状态！没必要！
		{
			if ( tpNpcTpl->mMWSkillJudgeService == 0 )
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}
			pProperty->SetServiceStatus( SERVICE_MWJUDGESKILL );
			nResult = SUCCESS;
			break;
		}

	case SERVICE_GOLDENYB:
		{
			if ( tpNpcTpl->mGoldenYBService == 0)
			{
				nResult = ERROR_CLICKNPC_TARGETINVALID;
				break;
			}

			pProperty->SetServiceStatus( SERVICE_GOLDENYB );
			nResult = SUCCESS;
			break;
		}
	default:
		{
			break;
		}
	}	

	CMessage tMessage;
	CMessageOpenServiceResponse tResMessage;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_OPEN_SERVICE );
	tMessage.set_msgpara( uint32(&tResMessage) );
	tResMessage.set_errorcode( nResult );
	tResMessage.set_serviceid( pOpenServiceRequest->serviceid() );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &tMessage );
}

//***********************************
// FunctionName : RefreshDiploid 
// Description  : 刷新领双状态
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [3/19/2009]
//***********************************

int CPropertyModule::RefreshDiploid(CEntityPlayer *pEntity, bool bOnLine )
{
	if ( pEntity == NULL )
	{
		return LK_IERROR;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* )pEntity->GetProperty();

	int tLastTime = tpProperty->GetLastRefreshTime();
	time_t tNow = time( NULL );

	if ( IsANewWeek( (time_t) tLastTime, tNow ) == true )
	{
		tpProperty->SetDiploid( LK_ZERO );
		tpProperty->SetLastRefreshTime( tNow );
	}	
	return LK_ISUCCESS;
}

// 初始化实体删除列表
void CPropertyModule::InitDeleteList( )
{ 
	mDeleteListCount = 0;
	memset( mEntityDeleteList, 0, sizeof( mEntityDeleteList ) );
}

// 获得实体删除列表
void CPropertyModule::AddDeleteList( unsigned int nEntityID )
{
	// 判断列表是否已满
	if ( mDeleteListCount < 0 || mDeleteListCount >= ARRAY_CNT( mEntityDeleteList ) )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s } mDeleteListCount( %d ) error!", __LK_FILE__, __LINE__, __FUNCTION__, mDeleteListCount );
		return;
	}

	mEntityDeleteList[ mDeleteListCount ] = nEntityID;
	mDeleteListCount++;
}

// 清空实体删除列表中的实体
void CPropertyModule::ClearDeleteList( )
{
	for ( unsigned int i = 0; i < mDeleteListCount && i < ARRAY_CNT( mEntityDeleteList ); i++ )
	{
		CEntity* tpEntity = CSceneLogic::GetSingleton().GetEntity( mEntityDeleteList[ i ] );
		if ( tpEntity == NULL )
			continue;
		
		CSceneLogic::GetSingleton().DestroyEntity( tpEntity, 0 );
	}

	// 计数器重置
	mDeleteListCount = 0;
}

// 功能NPC变怪物 变了以后马上攻击玩家
int CPropertyModule::FuncNpcChange2Ogre( CEntityPlayer* pPlayer, CEntityNpc* pEntityNpc, unsigned short vTaskID /*=0*/ )
{
	LK_ASSERT( pPlayer && pEntityNpc, return -1);

	if( pEntityNpc->GetEntityType() != ENTITYTYPE_FUNCNPC )
		return -1;

	pEntityNpc->SetPKType( ENEMY_WITH_SC|ENEMY_TO_SC|ENEMY_WITH_FC|ENEMY_TO_FC );
	pEntityNpc->SetOwnerCharID( pPlayer->GetCharID() );
	pEntityNpc->SetTaskID( vTaskID );
	pEntityNpc->SetNpcChangeState( 1 );

	NotifyClientNpcPKTypeChanged( pEntityNpc ); // 通知客户端 NPC PK类型改了
	// 加个仇恨 让他攻击玩家
	CNpcModule::GetSingleton().OnAttacked( pPlayer, pEntityNpc, 1 );
	return 0;
}


// NPC变身后恢复NPC功能(玩家攻击失败 或者NPC死亡后复活 跑回出生点以后)
void CPropertyModule::RecoverNpcState( CEntityNpc* pEntity )
{
	LK_ASSERT( pEntity, return );
	if( pEntity->GetEntityType() != ENTITYTYPE_FUNCNPC )
		return;
	
	// 通知任务模块
	CTaskModule::GetSingleton().OnNpcRecoverdState( pEntity->GetOwnercharID(), pEntity->GetTaskID(), pEntity->GetNpcID() );
	ResetFuncNpc(pEntity);
}

// 重置功能NPC状态 (在变成怪物后重置回去)
void CPropertyModule::ResetFuncNpc( CEntityNpc* pEntity )
{
	CTemplateNpc* tplNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pEntity->GetNpcID() );
	LK_ASSERT( tplNpc != NULL, return  );
	pEntity->SetPKType( tplNpc->mPKType );
	pEntity->SetOwnerCharID( 0 );
	pEntity->SetTaskID( 0 );
	pEntity->SetNpcChangeState( 0 );
	// 通知客户端 群发
	NotifyClientNpcPKTypeChanged( pEntity );
}

void CPropertyModule::NotifyClientNpcPKTypeChanged( CEntityNpc* pEntityNpc )
{
	// 通知客户端 群发
	CMessageChangeEntityPKTypeNotify msg;
	msg.set_entityid(pEntityNpc->GetEntityID()); // 设置NPC的实体ID
	msg.set_newtype( pEntityNpc->GetPKType() );
	CMessage   tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_CHANGEENTITYPKTYPE);
	CMapModule::GetSingletonPtr()->MessageBroadCast( pEntityNpc, &tMessage );
}

// 玩家增加装备凹槽
void CPropertyModule::PlayerAddSlot( CEntityPlayer *pPlayer, int vIndex1, int vIndex2 )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}		

		
	// 防止缓冲区溢出
	// TODO:包括背包索引的检查
	if ( (!pProperty->GetBaggage()->CheckIndexValid( vIndex1 )) || ( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) ) )	
	//if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex || vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送增加装备凹槽的错误通知
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		//// 发送增加装备凹槽的错误通知
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	
	// 检查装备是否滴血
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOT_EQUIPBINDEDBYITEM, 0 );
		return;
	}
	
	//int tItemID2 = tItem2->mItemID ;
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		//// 发送增加装备凹槽的错误通知
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	// 如果第一件不是装备
	if ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR )
	{
		//// 发送增加装备凹槽的错误通知
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	// 如果第二件不是加槽石
	if ( tpItem2->mItemType != CTplItem::ITEM_BOOK )
	{
		//// 发送增加装备凹槽的错误通知
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	else
	{
		CTplItemBook *tpBook = (CTplItemBook*)tpItem2;
		if ( tpBook->mOPType != CTplItemBook::TYPE_ADDSLOT )
		{
			SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
			return;
		}
	}
	
	CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
	CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem1;

	// 如果已经加过槽
	if ( tpEquip->GetMaxSlotNumber().mDeltaValue != 0 )
	{
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tplEquip->mAddCharge )
	{
		SendAddSlotResponse( pPlayer, ERROR_ADDSLOTERROR, 0 );
		return;
	}
	tpEquip->GetMaxSlotNumber().mDeltaValue = tplEquip->mSlotNumber2;

	SendAddSlotResponse( pPlayer, SUCCESS, tplEquip->mSlotNumber2 );
	if (PlayerChangeMoney( pPlayer, tplEquip->mAddCharge, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByOpenSlot(pPlayer, CYuanBao::em_bind_money, tplEquip->mAddCharge, tpEquip->GetItemID(), tpEquip->GetGUID());
	}
	if ( ( tItem2->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED
		&& ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
	{
		if ( !( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{		
			SetEquipBindTime( tItem1 );
		}	
		tItem1->SetBindStatus( tItem1->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, vIndex1, tItem1->GetBindStatus( ) );
	}

	uint64_t ullGUID2 = tItem2->GetGUID();
	int nItem2ID = tItem2->GetItemID();
	if( PlayerRemoveItem( pPlayer, vIndex2, 1 ) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID2, nItem2ID, 1);
	}

	return;
}

// 玩家摘除宝石
void CPropertyModule::PlayerRemoveJewel( CEntityPlayer *pPlayer, int vIndex1, int vIndex2, int vIndex3 )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	// 防止缓冲区溢出
	// TODO:包裹背包索引的检查
	if ( ( !pProperty->GetBaggage()->CheckIndexValid( vIndex1 ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) ) )			
	// if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex || vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送摘除宝石的错误通知
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	if ( vIndex3 < 0 || vIndex3 >= JEWELNUM )
	{
		//// 发送摘除宝石的错误通知
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		//// 发送摘除宝石的错误通知
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	
	// 检查装备是否滴血
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendRemoveJewelResponse( pPlayer, ERROR_JEWREMOVE_EQUIPBINDEDBYITEM );
		return;
	}
	
	//int tItemID2 = tItem2->mItemID ;
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		//// 发送摘除宝石的错误通知
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	// 如果第一件不是装备
	if ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR )
	{
		//// 发送摘除宝石的错误通知
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	// 如果第二件不是宝石摘除符
	if ( tpItem2->mItemType != CTplItem::ITEM_REMOVE )
	{
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
	//CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem1;
	CTplItemRemove *tplRemove = (CTplItemRemove*)tpItem2;

	CTplItemJewel *tpJewel = (CTplItemJewel*)CDataStatic::SearchTpl( tpEquip->GetSlotValue( vIndex3 ) );
	if ( tpJewel == NULL )
	{
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	// 如果档次不同
	if ( tpJewel->mLevel != tplRemove->mLevel )
	{
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tpJewel->mRemoveCharge )
	{
		SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
		return;
	}


	int tRand = RAND(SERVER_PERCENT_INT);
	int tLowRan = 0;
	int tHighRan = 0;
	int tDropLevel = 0;

	int tJewelID = 0;
	int tJewelNum = 1;

	// 没有一个空格，不能摘
	if( pProperty->GetBaggage()->Space( -1, 1 ) == false )
	{
		SendRemoveJewelResponse( pPlayer, ERROR_INSERTITEM_NOSPACE );
		return;
	}

	// 原有逻辑
	if ( tplRemove->mLow == 0 )
	{
		for ( unsigned int t = 0; t < ARRAY_CNT(tplRemove->mRand); t ++ )
		{
			tLowRan		+= ( t == 0 ) ? 0 : tplRemove->mRand[ t - 1 ];
			tHighRan	+= tplRemove->mRand[ t ];
			if ( tRand >= tLowRan && tRand < tHighRan )
			{
				tDropLevel = t;
				break;
			}
		}		
		tJewelID = tpJewel->mJewelID[ tDropLevel ];
	}
	// 新加的
	else
	{		
		tJewelID = tpJewel->mNewJewelID;
		for ( unsigned int t = 0; t < ARRAY_CNT(tpJewel->mNewRand); t ++ )
		{
			tLowRan		+= ( t == 0 ) ? 0 : tpJewel->mNewRand[ t - 1 ];
			tHighRan	+= tpJewel->mNewRand[ t ];
			if ( tRand >= tLowRan && tRand < tHighRan )
			{
				tJewelNum = t;
				break;
			}
		}
	}	

	if ( tJewelID != 0 )
	{
		CItemJewel *tpNewJewel = (CItemJewel*)  CSceneObjManager::GetSingletonPtr( )->CreateObject ( OBJTYPE_ITEM_JEWEL );
		if ( tpNewJewel == NULL )
		{
			SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
			return;
		}
		tpNewJewel->SetItemID( tJewelID );
		tpNewJewel->SetItemNum( tJewelNum );

		if ( tplRemove->mBind == 1 || (tItem1->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED 
			|| (tItem2->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
		{
			if ( !( tpNewJewel->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
			{					
				SetEquipBindTime( tpNewJewel );
			}	
			tpNewJewel->SetBindStatus( tpNewJewel->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
			SendBindItemNotify( pPlayer, pProperty->GetIndexByID( tpNewJewel->get_id() ), tpEquip->GetBindStatus( ) );
		}

		CItemObject* pInsItemPile =  PlayerInsertItem( pPlayer, tpNewJewel );
		if ( pInsItemPile == NULL )
		{
			CSceneObjManager::GetSingletonPtr( )->DestroyObject( tpNewJewel->get_id() );
			SendRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELERROR );
			return;
		}else
		{
			LogEventGetItemByUnBound(pPlayer, pInsItemPile->GetGUID(), 
					tJewelID, tJewelNum, tItem1->GetItemID(), tItem1->GetGUID());			
		}		
	}	
	
	tpEquip->SetSlotValue( vIndex3, 0 );

	if(PlayerChangeMoney( pPlayer, tpJewel->mRemoveCharge, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByRemoveJewel(pPlayer, 
				CYuanBao::em_bind_money, tpJewel->mRemoveCharge, tItem1->GetItemID(), tItem1->GetGUID());
	}
	/*if ( ( tItem2->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED
		&& ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
	{
		tItem1->SetBindStatus( tItem1->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, vIndex1, tItem1->GetBindStatus( ) );
	}*/

	uint64_t ullGUID2 = tItem2->GetGUID();
	int nItem2ID = tItem2->GetItemID();
	if ( PlayerRemoveItem( pPlayer, vIndex2, 1 ) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID2, nItem2ID, 1);
	}
	SendRemoveJewelResponse( pPlayer, SUCCESS );

	return;
}

// 玩家鉴定装备
void CPropertyModule::PlayerJudge( CEntityPlayer *pPlayer, int vIndex1, int vIndex2 )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();	
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	CEntityNpc *pNpc = (CEntityNpc*)CSceneObjManager::GetSingletonPtr()->GetObject( pProperty->GetTalkNpcEntityID( ) );
	if( pNpc == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find obj %d", __LK_FILE__, __FUNCTION__, __LINE__,  pProperty->GetTalkNpcEntityID( ) );
		return ;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL )
	{
		return;
	}
	if ( tpNpc->mJudgeService == 0 )
	{
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}

	if ( pProperty->GetServiceStatus( ) != SERVICE_JUDGE )
	{
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}
	// 防止缓冲区溢出
	// TODO:包裹背包索引的检查
	if( !pProperty->GetBaggage()->CheckIndexValid( vIndex1 ) )
	// if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送鉴定装备的错误通知
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );	
	if ( tItem1 == NULL )
	{
		//// 发送鉴定装备的错误通知
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}
	
	// 检查装备是否滴血
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		//// 发送鉴定装备的错误通知
		SendJudgeResponse( pPlayer, ERROR_JUDGE_EQUIPBINDEDBYITEM, 0, 0, 0 );
		return;
	}
	
	int tItemID2 = 0 ;
	uint64_t ullGUID = 0;

	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );	
	if ( tpItem1 == NULL )
	{
		//// 发送鉴定装备的错误通知
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}
	// 如果第一件不是装备
	if ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR )
	{
		//// 发送鉴定装备的错误通知
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}
	CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
	CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem1;	
	int *Percent = NULL;
	unsigned int tFee = 0;
	// 如果是第一次鉴定
	if ( tpEquip->GetJuge( 0 ) == 0 )
	{
		if ( ( tpNpc->mJudgeService & 0x01 ) != 0x01 )
		{
			SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
			return;
		}
		Percent = tplEquip->mJudgePercent1;
		tFee = tplEquip->mJudgeCharge;
	}
	// 如果是第二次鉴定
	else
	{
		if ( ( tpNpc->mJudgeService & 0x02 ) != 0x02 )
		{
			SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
			return;
		}
		
		// TODO::包裹背包索引的检查
		if( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) )
		// if ( vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
		{
			//// 发送鉴定装备的错误通知
			SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
			return;
		}
		CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
		if ( tItem2 == NULL )
		{
			//// 发送鉴定装备的错误通知
			SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
			return;
		}
		CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
		if ( tpItem2 == NULL )
		{
			//// 发送鉴定装备的错误通知
			SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
			return;
		}
		// 如果第二件不是加槽石
		if ( tpItem2->mItemType != CTplItem::ITEM_BOOK )
		{
			SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
			return;
		}
		else
		{
			CTplItemBook *tpBook = (CTplItemBook*)tpItem2;
			if ( tpBook->mOPType != CTplItemBook::TYPE_JUDGE )
			{
				SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
				return;
			}
		}

		tItemID2 = tItem2->GetItemID();
		ullGUID = tItem2->GetGUID();

		Percent = tplEquip->mJudgePercent2;
		tFee = tplEquip->mReJudgeCharge;
	}
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < tFee )
	{
		SendJudgeResponse( pPlayer, ERROR_JUDGEERROR, 0, 0, 0 );
		return;
	}

	// 取得鉴定之前的数值
	int nFrom = tpEquip->GetJuge( 0 ) * 100 + tpEquip->GetJuge(1) +  tpEquip->GetJuge(2)/100;
		
	for ( int i = 0; i < UPGVALUENUM; i++ )
	{
		int tRand = RAND(SERVER_PERCENT_INT);
		int tLowRan = 0;
		int tHighRan = 0;
		for ( unsigned int t = 0; t < ARRAY_CNT( tplEquip->mJudgePercent1 ); t ++ )
		{
			tLowRan		+= ( t == 0 ) ? 0 : Percent[ t - 1 ];
			tHighRan	+= Percent[ t ];
			if ( tRand >= tLowRan && tRand < tHighRan )
			{
				tpEquip->SetJuge( i, t * 100 );
				break;
			}
		}
	}	

	// 取得鉴定之后的数值
	int nTo = tpEquip->GetJuge(0) * 100 + tpEquip->GetJuge(1) +  tpEquip->GetJuge(2)/100;

	//记录鉴定日志
	LogEventItemJudgeAction(pPlayer, tpEquip->GetItemID(), tpEquip->GetGUID(), nFrom, nTo, tItemID2, tpEquip->GetBindStatus());

	if (PlayerChangeMoney( pPlayer, tFee, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByJudgeEquip(pPlayer, CYuanBao::em_bind_money, tFee, tpEquip->GetItemID(), tpEquip->GetGUID());
	}

	if ( tItemID2 != 0 )
	{
		if ( PlayerRemoveItem( pPlayer, vIndex2, 1 ) == 0)
		{
			LogEventLostItemByJudge(pPlayer, ullGUID, tItemID2, 1, tpEquip->GetItemID(), nTo, tpEquip->GetGUID());
		}
	}

	SendJudgeResponse( pPlayer, SUCCESS, tpEquip->GetJuge( 0 ), tpEquip->GetJuge( 1 ), tpEquip->GetJuge( 2 ) );
	
	return;
}

// 玩家转换抗性
void CPropertyModule::PlayerChangeRes( CEntityPlayer *pPlayer, int vIndex1, int vIndex2 )
{
	LK_ASSERT( pPlayer != NULL, return )
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 玩家密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	CEntityNpc *pNpc = (CEntityNpc*)CSceneObjManager::GetSingletonPtr()->GetObject( pProperty->GetTalkNpcEntityID( ) );
	if( pNpc == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find obj %d", __LK_FILE__, __FUNCTION__, __LINE__,  pProperty->GetTalkNpcEntityID( ) );
		return ;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL )
	{
		return;
	}
	if ( tpNpc->mChangeService == 0 )
	{
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}

	if ( pProperty->GetServiceStatus( ) != SERVICE_CHANGE )
	{
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	// 防止缓冲区溢出
	// TODO:背包索引的检查
	if( ( !pProperty->GetBaggage()->CheckIndexValid( vIndex1 ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( vIndex2 ) ) )
	// if ( vIndex1 < 0 || vIndex1 >= (int)pProperty->GetBaggage( )->mReleaseIndex || vIndex2 < 0 || vIndex2 >= (int)pProperty->GetBaggage( )->mReleaseIndex )
	{
		//// 发送转换抗性的错误通知
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		//// 发送转换抗性的错误通知
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	
	// 检查装备是否已经滴血
	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		//// 发送转换抗性的错误通知
		SendChangeResponse( pPlayer, ERROR_CHANGERES_EQUIPBINDEDBYITEM, 0 );
		return;
	}

	//int tItemID2 = tItem2->mItemID ;
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		//// 发送转换抗性的错误通知
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	// 如果第一件不是装备
	if ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR )
	{
		//// 发送转换抗性的错误通知
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	// 如果第二件不是转化石
	if ( tpItem2->mItemType != CTplItem::ITEM_CHANGE )
	{
		//// 发送转换抗性的错误通知
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
	CTemplateEquipment *tplEquip = (CTemplateEquipment*)tpItem1;
	CTplItemChange *tplChange = (CTplItemChange*)tpItem2;
	
	unsigned int tFee = 0;
	if ( tplChange->mType == 0 )
	{
		if ( ( tpNpc->mChangeService & 0x01 ) != 0x01 )
		{
			SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
			return;
		}
		if ( tpEquip->GetResDef() == RES_NONE )
		{
			SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
			return;
		}
		tFee = tplEquip->mDefChangeCharge;
	}
	else if ( tplChange->mType == 1 )
	{
		if ( ( tpNpc->mChangeService & 0x02 ) != 0x02 )
		{
			SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
			return;
		}
		// 如果职业限制不符
		if ( tplChange->mMetierRequire != 0 && ( tplChange->mMetierRequire & tplEquip->mMetierRequire ) == 0 )
		{
			//// 发送转换抗性的错误通知
			SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
			return;
		}
		if ( tpEquip->GetResAtt() == RES_NONE )
		{
			SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
			return;
		}
		tFee = tplEquip->mAttChangeCharge;
	}
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < tFee )
	{
		SendChangeResponse( pPlayer, ERROR_CHANGEERROR, 0 );
		return;
	}
	int tResType[ 3 ] = { 0 };
	int tNum = 0;
	// 抗性需要单独处理
	int tResDef = 0;
	for ( int i = 0; i < RES_NUM; i++ )
	{
		int tRes = 1 << i;
		if ( ( tRes & tplChange->mRes ) == tRes )
		{
			// 属性赋值
			tResType[ tNum++ ] = i + 1;
			// 抗性赋值
			tResDef = i + 1;
			if ( tNum >=(int) ARRAY_CNT(tResType) )
				break;
		}
	}
	int tRes = 0;
	if ( tplChange->mType == 0 )
	{
		int nFrom =  tpEquip->GetResDef();

		tpEquip->SetResDef( tResDef );
		tRes = tpEquip->GetResDef();

		// 记录属性转换 
		LogEventItemResistAction(pPlayer, tpEquip->GetItemID(), 
				tpEquip->GetGUID(), nFrom, tRes, tItem1->GetItemID(), tpEquip->GetDefLevel(), tpEquip->GetBindStatus());	
	}
	else if ( tplChange->mType == 1 )
	{
		int nFrom =  tpEquip->GetResAtt();

		tpEquip->SetResAtt( tResType[ RAND(3) ] );
		tRes = tpEquip->GetResAtt();

		// 记录属性转换 
		LogEventItemAttackAction(pPlayer, tpEquip->GetItemID(), 
				tpEquip->GetGUID(), nFrom, tRes, tItem1->GetItemID(), tpEquip->GetAttLevel(), tpEquip->GetBindStatus());	
	}

	if (PlayerChangeMoney( pPlayer, tFee, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByChangeResist(pPlayer, CYuanBao::em_bind_money, tFee, tItem1->GetItemID(), tItem1->GetGUID());
	}

	uint64_t ullGUID2 = tItem2->GetGUID();
	int nItem2ID = tItem2->GetItemID();
	if (PlayerRemoveItem( pPlayer, vIndex2, 1 ) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID2, nItem2ID, 1);
	}

	SendChangeResponse( pPlayer, SUCCESS, tRes );	
	
	return;
}

void CPropertyModule::PlayerJewCom(CEntityPlayer *pPlayer, int *vJewIndex, int vCardIndex)
{
	CItemObject *tItem[ COMPOSENUM ] = { NULL };
	CTplItem *tpItem[ COMPOSENUM ] = { NULL };

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	bool tBind = false;
	unsigned int tItemID = 0;
	int tJewNum = 0;
	int tComLevel = 0;
	// 决定产出结果的索引，默认第一个，如果有绑定的则取绑定的
	int tResultIndex = -1;

	for ( int i = 0; i < COMPOSENUM; i++ )
	{
		if ( vJewIndex[ i ] == -1 )
			continue;
		tItem[ i ] = pProperty->GetBaggage( )->GetItemObjPtr( vJewIndex[ i ] );
		if ( tItem[ i ] == NULL )
		{
			SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
			return;
		}
		tpItem[ i ] = (CTplItem*)CDataStatic::SearchTpl( tItem[ i ]->GetItemID() );
		if ( tpItem[ i ] == NULL )
		{
			SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
			return;
		}	
		if ( tpItem[ i ]->mItemType != CTplItem::ITEM_JEWEL )
		{
			SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
			return;
		}
		CTplItemJewel *tplJewel = (CTplItemJewel*)tpItem[ i ];
		if ( tItem[ i ]->GetItemID() != tItemID && tItemID != 0 )
		{
			CTplItemJewel *tplItem = (CTplItemJewel*)CDataStatic::SearchTpl( tItemID );			
			if ( tplItem == NULL )
			{
				SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
				return;
			}			
			else if ( tplItem->mJewComID == 0 || tplItem->mJewComID != tplJewel->mJewComID )
			{
				SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
				return;
			}
		}

		if ( tResultIndex == -1 )
		{
			tResultIndex = i;
		}
		if ( tplJewel->mComLevel >= tComLevel )
		{
			tResultIndex = i;
			tComLevel = tplJewel->mComLevel;
		}

		if ( ( tItem[ i ]->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
		{
			tBind = true;
		}	
			
		for ( int j = 0; j < i; j++ )
		{
			if ( vJewIndex[ j ] == vJewIndex[ i ] )
			{
				SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
				return;
			}
		}		
		
		tItemID = tItem[ i ]->GetItemID();
		tJewNum += tItem[ i ]->GetItemNum();

		if ( tJewNum >= COMPOSENUM )
		{
			tJewNum = COMPOSENUM;
			break;
		}
	}

	if ( tResultIndex >= 0 )
		tItemID = tItem[ tResultIndex ]->GetItemID();

	CTplItemJewel *tplJewel = (CTplItemJewel*)CDataStatic::SearchTpl( tItemID );
	if ( tplJewel == NULL )
	{
		SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
		return;
	}

	CTemplateCompose *tpCompose = (CTemplateCompose*)CDataStatic::SearchTpl( tplJewel->mComposeID );
	if ( tpCompose == NULL )
	{
		SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
		return;
	}

	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tplJewel->mComposeCharge )
	{
		SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
		return;
	}
	int tComID = tpCompose->mItemID;
	int tComNum = tpCompose->mItemNum;
	if ( tJewNum < MIN_JEWCOM_NUM )
	{
		SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
		return;
	}

	int tAddRand = 0;
	CItemObject *tpCard = pProperty->GetBaggage( )->GetItemObjPtr( vCardIndex );
	if ( tpCard != NULL )
	{
		CTplItem *tplCard = (CTplItem*)CDataStatic::SearchTpl( tpCard->GetItemID() );
		if ( tplCard != NULL )
		{
			if ( tplCard->mItemType == ITEM_UPGLEAST )
			{
				CTplUpgLeast *tplLeast = (CTplUpgLeast*)tplCard;
				if ( tplLeast->mType == 1 )
				{
					if ( tplLeast->mIncLuck2 < tplJewel->mLevel )
					{
						SendJewComResponse( pPlayer, ERROR_JEWCOM_LOWLEVEL );
						return;
					}
					tAddRand = tplLeast->mIncLuck1;
				}
			}
		}
		if ( tAddRand != 0 )
		{
			uint64_t ullGUID = tpCard->GetGUID();
			int nItemID = tpCard->GetItemID();

			if ( PlayerRemoveItem( pPlayer, vCardIndex, 1 ) == 0)
			{
				LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);
			}
		}
		if ( ( tpCard->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
		{
			tBind = true;
		}
	}

	int tRemoveCount = 0;
	for ( int i = 0; i < COMPOSENUM; i++ )
	{
		if ( tpItem[ i ] == NULL )
			continue; 

		uint64_t ullGUID = tItem[i]->GetGUID();
		int nItemID = tItem[ i ]->GetItemID();
		int tRemoveNum = 0;
		// 还没达到上限，就全扣掉
		if ( (int)tItem[ i ]->GetItemNum() + tRemoveCount <= tJewNum )
		{
			tRemoveNum = tItem[ i ]->GetItemNum();
		}
		else
		{
			tRemoveNum = tJewNum - tRemoveCount;
		}
		if ( PlayerRemoveItem( pPlayer, vJewIndex[ i ], tRemoveNum ) == 0)
		{
			LogEventLostItemByUse(pPlayer, ullGUID, nItemID, tRemoveNum);
		}
		tRemoveCount += tRemoveNum;
		if ( tRemoveCount >= tJewNum )
			break;
	}

	int tRand = tplJewel->mRand[ tJewNum - MIN_JEWCOM_NUM ] + tAddRand;

	if (PlayerChangeMoney( pPlayer, tplJewel->mComposeCharge, true, true ) == SUCCESS)
	{
		
	}

	if ( tRand < RAND(SERVER_PERCENT_INT) )
	{
		SendJewComResponse( pPlayer, ERROR_JEWCOMFAIL );
		LogEventLostMoneyByComposeJewel(pPlayer, CYuanBao::em_bind_money, tplJewel->mComposeCharge,
			0, 0);
		return;
	}

	SendJewComResponse( pPlayer, SUCCESS );	

	CItemObject *pInsItemPile = PlayerInsertItem( pPlayer, tComID, tComNum, false, 0, NULL, tBind );
	if ( pInsItemPile == NULL)
	{
		SendJewComResponse( pPlayer, ERROR_JEWCOMERROR );
		return;	
	}else
	{
		LogEventGetItemByCompose(pPlayer, pInsItemPile->GetGUID(), tComID, tComNum, tItemID, tJewNum);
		LogEventLostMoneyByComposeJewel(pPlayer, CYuanBao::em_bind_money, tplJewel->mComposeCharge,
			pInsItemPile->GetItemID(), pInsItemPile->GetGUID());
	}	
	CTplItemJewel *tpComJewel = (CTplItemJewel*)CDataStatic::SearchTpl( tComID );
	if ( tpComJewel != NULL && tpComJewel->mLevel >= NOTICE_JEW_FIRST )
	{
		SendUpgAndJewNotice( pPlayer, JEW_NOTICE, NOTICE_JEW_FIRST, pInsItemPile );
	}
		
	return;
}

void CPropertyModule::PlayerMultiCom( CEntityPlayer *pPlayer, int vComposeID, int vComposeType, int vEquipIndex )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	CTemplateMultiCompose *tpCompose = (CTemplateMultiCompose*) CDataStatic::SearchTpl( vComposeID );
	if ( tpCompose == NULL )
	{
		SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR );
		return;
	}	
	
	CLifeSkill *tpLifeSkill = NULL;
	int tDegreeValue = 0;
	if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_LIFESKILL )
	{ 
		tpLifeSkill = pProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpCompose->mLifeSkillType );
		if ( tpLifeSkill == NULL )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_LIFESKILL_USECOMPOSEWITHOUTLIFESKILL );
			return;
		}			
		
		int tRet = tpLifeSkill->UseCompose( vComposeID, tDegreeValue, false );
		LK_ASSERT( tRet != -1, return )								
		if ( tRet != SUCCESS )
		{
			SendMultiComResponse( pPlayer, vComposeID, tRet );
			return;
		}
				
	} 
	else if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_CARDEXCHANGE )
	{
		// 卡片兑换的处理
	}
	else if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_EQUIPMENTCHANGE )
	{
		// 装备兑换的处理
	}	
	else if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_FAMILYEXCHANGE )
	{
		// 判断家族个人贡献度
		if ( pPlayer->GetFamilyID() == 0 )
		{	
			SendMultiComResponse( pPlayer, vComposeID, ERROR_FAMILY_EXCHANGE_HASONFAMILY );			
			return;
		}
		CMemberInfo *tpMemberInfo = CFamilyModule::GetSingleton().GetFamilyMemberInfo( pPlayer );
		if ( tpMemberInfo == NULL )
		{
			return;
		}
		if ( tpMemberInfo->mFamilyContribute < tpCompose->mContribute )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_FAMILY_REDPAPER_CONTRIBUTENOTENOUGH );
			return;
		}
	}
	else if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_CORPSEXCHANGE )	
	{
		// 判断军团个人贡献度
		if ( pPlayer->GetCorpsID() == 0 )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_CORPS_EXCHANGE_HASNOCORPS );
			return;
		}
		
		CMemberInfo *tpMemberInfo = CFamilyModule::GetSingleton().GetFamilyMemberInfo( pPlayer );
		if ( tpMemberInfo == NULL )
		{
			return;
		}
		
		if ( tpMemberInfo->mCorpsContribute < tpCompose->mContribute )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_CORPS_BUYREDPAPER_CONTRIBUTENOTENOUGH );
			return;
		}
		
		/*if ( pPlayer->GetCorpsContribute() < tpCompose->mContribute )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_CORPS_BUYREDPAPER_CONTRIBUTENOTENOUGH );
			return;
		}			*/
	}		 	
	
	// 这里判断的漏洞,配有两种相同物品的话,只能判断出当前总数是否满足最多的个数,而不是总和
	// 比如物品A数量5+物品A数量7,如果7<总数<12,就会有问题,但配成物品A数量12就可以了
	// 目前只能这样解决,代码上解决很繁琐
	for ( unsigned int i = 0; i < ARRAY_CNT( tpCompose->mMaterialID ); i++ )
	{
		if ( tpCompose->mMaterialID[ i ] == 0 )
			break;
		int tBackType = 0;
		HasItem( pPlayer->GetEntityID( ), tpCompose->mMaterialID[ i ], tpCompose->mMaterialNum[ i ], tBackType, 0, vComposeType );
		if ( tBackType == 0 )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMNOTENOUGH );
			return;
		}
	}

	// 检查所需的数值是否满足
	for ( unsigned int i = 0; i < ARRAY_CNT( tpCompose->mNeedValueType ); i++ )
	{
		if ( tpCompose->mNeedValueType[ i ] == 0 )
			break;

		switch(tpCompose->mNeedValueType[ i ])
		{
		case CTemplateMultiCompose::NEEDVALUETYPE_CHARM:
			{
				if ( pProperty->GetCharmValue() < tpCompose->mNeedValue[i] )
				{
					SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMNOTENOUGH );
					return;
				}
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_SLAVE:
			{
				if ( pProperty->GetSlavePoint() < tpCompose->mNeedValue[i] )
				{
					SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMNOTENOUGH );
					return;
				}
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_MASTER:
			{
				if ( pProperty->GetMasterPoint() < tpCompose->mNeedValue[i] )
				{
					SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMNOTENOUGH );
					return;
				}
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_LASTONE:
			{
				int tLastOneMark = 0;
				pProperty->GetRepetion()->GetIntData(_REPE_LASTONE_INDEX_,6, &tLastOneMark);
				if( tLastOneMark < tpCompose->mNeedValue[i] )
				{
					SendMultiComResponse( pPlayer, vComposeID,ERROR_MULTICOMNOTENOUGH );
					return;
				}
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_MARRYINTIMACY:
			{
				if ( pPlayer->GetMarriageID() <= 0 )
				{
					SendMultiComResponse( pPlayer, vComposeID,ERROR_HASNOMARRINTIMACY );
					return;
				}
				CMarriageInfo *tpInfo = CMarriageManager::GetSingleton().GetMarriageInfoByMarriageID( pPlayer->GetMarriageID() );
				if ( tpInfo == NULL )
				{
					SendMultiComResponse( pPlayer, vComposeID,ERROR_HASNOMARRINTIMACY );
					return;	
				}
				int tSpouseID[2] = { tpInfo->GetBrideID(), tpInfo->GetGroomID() };
				bool tRet = CFriendModule::GetSingleton().JudgeIntimacyDegree( tSpouseID, ARRAY_CNT(tSpouseID),  tpCompose->mNeedValue[i] );
				if ( tRet != true )
				{
					SendMultiComResponse( pPlayer, vComposeID, ERROR_MARRINTIMACYNOTENOUGH );
					return;	
				}
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_SWORNINTIMACY:
			{
				int tRet = CFriendModule::GetSingleton().CheckTeamSwornIntimacy( pPlayer, tpCompose->mNeedValue[i] );
				if ( tRet != SUCCESS )
				{
					SendMultiComResponse( pPlayer, vComposeID, tRet );
					return;	
				}
				break;
			}
		default:
			{
				LOG_ERROR("pro", "err value type:%d", tpCompose->mNeedValueType[ i ]);
				return;
			}
		}
	}

	// 如果包裹满
	if ( pProperty->TestBaggageSpace( tpCompose->mItemID, tpCompose->mItemNum, ARRAY_CNT( tpCompose->mItemID ) ) == false )
	{
		SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMFULL );
		return;
	}

	bool tBind = false;
	if ( vEquipIndex != -1 )
	{
		CItemObject *tpItem = pProperty->GetBaggage()->GetItemObjPtr( vEquipIndex );
		if ( tpItem == NULL )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR, vEquipIndex );
			return;
		}
		CTplItem *tplItem = (CTplItem*)CDataStatic::SearchTpl( tpItem->GetItemID() );
		if ( tplItem == NULL )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR, vEquipIndex );
			return;
		}
		if ( tplItem->mItemType != ITEM_WEAPON && tplItem->mItemType != ITEM_ARMOR )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR, vEquipIndex );
			return;
		}
		
		if ( tpItem->IsSameItemGroup(tpCompose->mSrcEquipID, BIND_ALL ) == false )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR, vEquipIndex );
			return;
		}
		CItemEquipment *tpEquip = (CItemEquipment*)tpItem;		
		if ( (unsigned int)(tpEquip->GetLevel()) >= ARRAY_ROW( tpCompose->mUpgItemID ) )
		{
			SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR, vEquipIndex );
			return;
		}
		for ( unsigned int i = 0; i < ARRAY_COL( tpCompose->mUpgItemID ); i++ )
		{
			if ( tpCompose->mUpgItemID[ i ] == 0 )
				break;
			int tBackType = 0;								
			HasItem( pPlayer->GetEntityID( ), tpCompose->mUpgItemID[ tpEquip->GetLevel()][ i ], tpCompose->mUpgItemNum[ tpEquip->GetLevel() ][ i ], tBackType, 0, vComposeType );
			if ( tBackType == 0 )
			{
				SendMultiComResponse( pPlayer, vComposeID, ERROR_MULTICOMERROR, vEquipIndex );
				return;
			}
		}
		for ( unsigned int i = 0; i < ARRAY_COL( tpCompose->mUpgItemID ); i++ )
		{
			if ( tpCompose->mUpgItemID[ i ] == 0 )
				break;
			if (PlayerRemoveItemByID( pPlayer, tpCompose->mUpgItemID[ tpEquip->GetLevel() ][ i ], 
						tpCompose->mUpgItemNum[ tpEquip->GetLevel() ][ i ], tBind, NULL, vComposeType )== 0)		
			{
				LogEventLostItemByCompose ( pPlayer, 0, 
						tpCompose->mUpgItemID[ tpEquip->GetLevel() ][ i ], 
						tpCompose->mUpgItemNum[ tpEquip->GetLevel() ][ i ],
						tpCompose->mItemID[ 0 ], tpCompose->mItemNum[ 0 ], 0 );

			}
		}
		tpItem->SetItemID( tpCompose->mDesEquipID );		
	}

	for ( unsigned int i = 0; i < ARRAY_CNT( tpCompose->mMaterialID ); i++ )
	{
		if ( tpCompose->mMaterialID[ i ] == 0 )
			break;
		if (PlayerRemoveItemByID( pPlayer, tpCompose->mMaterialID[ i ], tpCompose->mMaterialNum[ i ], tBind, NULL, vComposeType ) == 0)
		{
			LogEventLostItemByCompose ( pPlayer, 0, tpCompose->mMaterialID[ i ], tpCompose->mMaterialNum[ i ],
					tpCompose->mItemID[ 0 ], tpCompose->mItemNum[ 0 ], 0 );
		}
	}
	//if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_USEVALUES )	
	//{
	// 带数值的兑换
	// 先扣除各种数值
	for ( unsigned int i = 0; i < ARRAY_CNT( tpCompose->mNeedValueType ); i++ )
	{
		if ( tpCompose->mNeedValueType[ i ] == 0 )
			break;

		switch(tpCompose->mNeedValueType[ i ])
		{
		case CTemplateMultiCompose::NEEDVALUETYPE_CHARM:
			{
				pProperty->SetCharmValue( pProperty->GetCharmValue() - tpCompose->mNeedValue[i] ) ;
				pPlayer->AddFunResult( 0, FUNC_CHARM, RESULT_NORMAL, false, pProperty->GetCharmValue(), 0, 0, 0 );
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_SLAVE:
			{
				pProperty->SetSlavePoint( pProperty->GetSlavePoint() - tpCompose->mNeedValue[i] ) ;
				CFriendModule::GetSingleton().SendSlaveValueNotify( pPlayer );
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_MASTER:
			{
				pProperty->SetMasterPoint( pProperty->GetMasterPoint() - tpCompose->mNeedValue[i] ) ;
				CFriendModule::GetSingleton().SendSlaveValueNotify( pPlayer );
				break;
			}
		case CTemplateMultiCompose::NEEDVALUETYPE_LASTONE:
			{

				int tLastOneMark = 0;
				//这里的 6有点潜了。6存放消耗的大乱斗积分
				pProperty->GetRepetion()->GetIntData(_REPE_LASTONE_INDEX_,6, &tLastOneMark);

				pProperty->GetRepetion()->SetIntData(_REPE_LASTONE_INDEX_,6,tLastOneMark - tpCompose->mNeedValue[i]);
				CPropertyModule::GetSingleton().SendPlayerRepetData( pPlayer, _REPE_LASTONE_INDEX_ , 6 );
				break;
			}
		default:
			{
				LOG_ERROR("pro", "k err value type:%d", tpCompose->mNeedValueType[ i ]);
				break;
			}
		}
	}
	//}
	for ( unsigned int i = 0; i < ARRAY_CNT( tpCompose->mItemID ); i++ )
	{
		if ( tpCompose->mItemID[ i ] == 0 )
			break;

		//bool tBind = ( ( vComposeType == BIND_ALL ) ? true : false );
		CItemObject * pInsItemPile = PlayerInsertItem( pPlayer, tpCompose->mItemID[ i ], tpCompose->mItemNum[ i ], false, 0, NULL, tBind );		
		if ( pInsItemPile != NULL)
		{
			LogEventGetItemByCompose( pPlayer, pInsItemPile->GetGUID(), tpCompose->mItemID[ i ], tpCompose->mItemNum[ i ],
					tpCompose->mMaterialID[ i ], tpCompose->mMaterialNum[ i ]);
		}
	}
	
	if ( tpCompose->mExp > 0 )
	{
		int tCharID = pPlayer->GetCharID( );
		int nFinalExp = PlayerObtainExp( pPlayer, tpCompose->mExp, EXPREASON_EXCHANGE, &tCharID, 1 );

		if ( nFinalExp > 0)
		{
			LogEventGetExpByMultiComp(pPlayer, tpCompose->mExp, nFinalExp, vComposeID);
		}
	}
	
	if ( tpLifeSkill != NULL && tDegreeValue > 0 )
	{
		tpLifeSkill->AddSpecializedDegree( tDegreeValue, CLifeSkill::DEGREEADDTYPE_USECOMPOSE );
		SendNotifyLifeSkillAttribute( pPlayer, tpLifeSkill->GetLifeSkillType(), tpLifeSkill->GetSpecializedDegree() );
	}
	
	if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_FAMILYEXCHANGE )
	{
		// 发往网关减少个人家族贡献度
		CFamilyModule::GetSingleton().AddPlayerFamilyContribute( pPlayer->GetCharID(), tpCompose->mContribute, 1 );						
		
		// 场景个人贡献度先计为0,等到网关返回后才可以进行下次兑换
		//pPlayer->SetFamilyContribute( 0 );
		CMemberInfo *tpMemberInfo = CFamilyModule::GetSingleton().GetFamilyMemberInfo( pPlayer );
		if ( tpMemberInfo != NULL )
		{
			tpMemberInfo->mFamilyContribute = 0;
		}
		
	}
	else if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_CORPSEXCHANGE )	
	{
		// 发往网关减少个人军团贡献度
		CCorpsModule::GetSingleton().AddPlayerCorpsContribute( pPlayer->GetCharID(), tpCompose->mContribute, 1 );				

		// 场景个人贡献度先计为0,等到网关返回后才可以进行下次兑换
		CMemberInfo *tpMemberInfo = CFamilyModule::GetSingleton().GetFamilyMemberInfo( pPlayer );
		if ( tpMemberInfo != NULL )
		{
			tpMemberInfo->mCorpsContribute = 0;
		}
		//pPlayer->SetCorpsContribute( 0 );
	}	

	SendMultiComResponse( pPlayer, vComposeID, SUCCESS, vEquipIndex );
}

void CPropertyModule::SendPlayerRepetData(CEntityPlayer * pPlayer, int vRepetionIndex, int vDataIndex )
{
	if( pPlayer == NULL)
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	int tLastOneMark = 0;
	pProperty->GetRepetion()->GetIntData( vRepetionIndex, vDataIndex, &tLastOneMark);
	
	CMessagePlayerRepetData tPlayerRepetData;
	CMessage tMessage;

	tPlayerRepetData.set_repetindex( vRepetionIndex );
	
	tPlayerRepetData.set_repetdata( tLastOneMark );
	tMessage.mutable_msghead()->set_messageid( ID_S2C_PLAYER_REPETION_DATA );
	tMessage.set_msgpara((uint32_t) &tPlayerRepetData);

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );


}

// 处理玩家增加凹槽放入请求
void CPropertyModule::OnMessagePushAddSlotRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushAddSlotRequest *pMsg = ( CMessagePushAddSlotRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex1 = tpSrcProperty->GetBaggage( )->mAddIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mAddIndex2;
	int tResult = tpSrcProperty->GetBaggage( )->AddAddItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPushAddSlotResponse( pPlayer, ERROR_ADDSLOTPUSHERROR, pMsg->index(), tResult );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_ADD ) == true )
		{
			SendPushAddSlotResponse( pPlayer, SUCCESS, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_ADD );
		}
	}
}
// 处理玩家增加凹槽拿出请求
void CPropertyModule::OnMessagePopAddSlotRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopAddSlotRequest *pMsg = ( CMessagePopAddSlotRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tResult = tpSrcProperty->GetBaggage( )->DelAddItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPopAddSlotResponse( pPlayer, ERROR_ADDSLOTPOPERROR, tResult, pMsg->index() );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{

			SendPopAddSlotResponse( pPlayer, SUCCESS, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}
// 处理玩家增加凹槽请求
void CPropertyModule::OnMessageAddSlotRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageAddSlotRequest *pMsg = (CMessageAddSlotRequest*)pMessage->msgpara( );
	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	PlayerAddSlot( pPlayer, pMsg->equipindex(), pMsg->itemindex() );
}
// 处理玩家摘除宝石放入请求
void CPropertyModule::OnMessagePushRemoveJewelRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushRemoveJewelRequest *pMsg = ( CMessagePushRemoveJewelRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex1 = tpSrcProperty->GetBaggage( )->mRemoveIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mRemoveIndex2;
	int tResult = tpSrcProperty->GetBaggage( )->AddRemoveItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPushRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELPUSHERROR, pMsg->index(), tResult );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_REMOVE ) == true )
		{
			SendPushRemoveJewelResponse( pPlayer, SUCCESS, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_REMOVE );
		}
	}
}
// 处理玩家摘除宝石拿出请求
void CPropertyModule::OnMessagePopRemoveJewelRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopRemoveJewelRequest *pMsg = ( CMessagePopRemoveJewelRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tResult = tpSrcProperty->GetBaggage( )->DelRemoveItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPopRemoveJewelResponse( pPlayer, ERROR_REMOVEJEWELPOPERROR, tResult, pMsg->index() );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{

			SendPopRemoveJewelResponse( pPlayer, SUCCESS, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}
// 处理玩家摘除宝石请求
void CPropertyModule::OnMessageRemoveJewelRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CMessageRemoveJewelRequest *pMsg = ( CMessageRemoveJewelRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	PlayerRemoveJewel( pPlayer, pMsg->equipindex(), pMsg->itemindex(), pMsg->jewelindex() );
}
// 处理玩家鉴定装备放入请求
void CPropertyModule::OnMessagePushJudgeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushJudgeRequest *pMsg = ( CMessagePushJudgeRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex1 = tpSrcProperty->GetBaggage( )->mJudgeIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mJudgeIndex2;
	int tResult = tpSrcProperty->GetBaggage( )->AddJudgeItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPushJudgeResponse( pPlayer, ERROR_JUDGEPUSHERROR, pMsg->index(), tResult );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_JUDGE ) == true )
		{
			SendPushJudgeResponse( pPlayer, SUCCESS, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_JUDGE );
		}
	}
}
// 处理玩家鉴定装备拿出请求
void CPropertyModule::OnMessagePopJudgeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopJudgeRequest *pMsg = ( CMessagePopJudgeRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tResult = tpSrcProperty->GetBaggage( )->DelJudgeItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPopJudgeResponse( pPlayer, ERROR_JUDGEPOPERROR, tResult, pMsg->index() );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{

			SendPopJudgeResponse( pPlayer, SUCCESS, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}
// 处理玩家鉴定装备请求
void CPropertyModule::OnMessageJudgeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageJudgeRequest *pMsg = (CMessageJudgeRequest*)pMessage->msgpara( );
	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	PlayerJudge( pPlayer, pMsg->equipindex(), pMsg->itemindex() );
}

// 处理玩家转换抗性放入请求
void CPropertyModule::OnMessagePushChangeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushChangeRequest *pMsg = ( CMessagePushChangeRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex1 = tpSrcProperty->GetBaggage( )->mChangeIndex1;
	int tIndex2 = tpSrcProperty->GetBaggage( )->mChangeIndex2;
	int tResult = tpSrcProperty->GetBaggage( )->AddChangeItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPushChangeResponse( pPlayer, ERROR_CHANGEPUSHERROR, pMsg->index(), tResult );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex1 >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex1, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex1, LOCKTYPE_NONE );
			}
		}
		if ( tIndex2 >= 0 && tResult == 1 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex2, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex2, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_CHANGE ) == true )
		{
			SendPushChangeResponse( pPlayer, SUCCESS, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_CHANGE );
		}
	}
}
// 处理玩家转换抗性拿出请求
void CPropertyModule::OnMessagePopChangeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopChangeRequest *pMsg = ( CMessagePopChangeRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tResult = tpSrcProperty->GetBaggage( )->DelChangeItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPopChangeResponse( pPlayer, ERROR_CHANGEPOPERROR, tResult, pMsg->index() );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{

			SendPopChangeResponse( pPlayer, SUCCESS, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}
// 处理玩家转换抗性请求
void CPropertyModule::OnMessageChangeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageChangeRequest *pMsg = ( CMessageChangeRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	//CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	PlayerChangeRes( pPlayer, pMsg->equipindex(), pMsg->itemindex() );
}

// 处理玩家合成宝石放入请求
void CPropertyModule::OnMessagePushJewComRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushJewComRequest *pMsg = ( CMessagePushJewComRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	// 如果已经放了东西，返回
	CItemObject *tItem = tpSrcProperty->GetBaggage( )->GetItemObjPtr( pMsg->index() );
	if ( tItem != NULL )
	{
		if ( tItem->GetLockStatus() != LOCKTYPE_NONE )
		{
			return;
		}
	}

	int tIndex[ COMPOSENUM ] = { -1 };
	for( int i = 0; i < COMPOSENUM; i++ )
	{
		tIndex[ i ] = tpSrcProperty->GetBaggage( )->mJewComIndex[ i ];
	}
	int tResult = tpSrcProperty->GetBaggage( )->AddJewComItem( pMsg->index() );

	if ( tResult < 0 )
	{
		SendPushJewComResponse( pPlayer, ERROR_JEWCOMPUSHERROR, pMsg->index(), tResult );
	}
	else
	{
		for ( int i = 0; i < COMPOSENUM; i++ )
		{
			if ( tIndex[ i ] >= 0 && tResult == i )
			{
				if ( tpSrcProperty->GetBaggage( )->Lock( tIndex[ i ], LOCKTYPE_NONE ) == true )
				{		
					SendLockItemNotice( pPlayer, tIndex[ i ], LOCKTYPE_NONE );
				}
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_JEWCOM ) == true )
		{

			SendPushJewComResponse( pPlayer, SUCCESS, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_JEWCOM );
		}
	}
}
// 处理玩家合成宝石拿出请求
void CPropertyModule::OnMessagePopJewComRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopJewComRequest *pMsg = ( CMessagePopJewComRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tResult = tpSrcProperty->GetBaggage( )->DelJewComItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPopJewComResponse( pPlayer, ERROR_JEWCOMPOPERROR, tResult, pMsg->index() );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{
			SendPopJewComResponse( pPlayer, SUCCESS, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}
// 处理玩家合成宝石请求
void CPropertyModule::OnMessageJewComRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}	
	
	// 安全密码检查
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		SendJewComResponse( pPlayer, EM_PASSWORD_ACTION_GAMEACTION );
		return;
	}	
	

	CMessageJewComRequest *pMsg = ( CMessageJewComRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	int tIndex[ COMPOSENUM ] = { -1 };
	for ( size_t i = 0; i < ARRAY_CNT(tIndex) && i < (size_t)pMsg->jewelindex_size(); i++ )
	{
		tIndex[ i ] = pMsg->jewelindex( i );
	}
	PlayerJewCom( pPlayer, tIndex, pMsg->itemindex() );
}

// 处理玩家复杂合成放入请求
void CPropertyModule::OnMessagePushMultiComRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushMultiRequest *pMsg = ( CMessagePushMultiRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex = tpSrcProperty->GetBaggage( )->mMultiIndex;
	int tResult = tpSrcProperty->GetBaggage( )->AddMultiItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPushMultiComResponse( pPlayer, ERROR_MULTIPUSHERROR, pMsg->index(), tResult );
	}
	else
	{
		// 如果原来有东西，解锁原来的
		if ( tIndex >= 0 && tResult == 0 )
		{
			if ( tpSrcProperty->GetBaggage( )->Lock( tIndex, LOCKTYPE_NONE ) == true )
			{		
				SendLockItemNotice( pPlayer, tIndex, LOCKTYPE_NONE );
			}
		}
		if ( tpSrcProperty->GetBaggage( )->Lock( pMsg->index(), LOCKTYPE_ADD ) == true )
		{
			SendPushMultiComResponse( pPlayer, SUCCESS, pMsg->index(), tResult );
			SendLockItemNotice( pPlayer, pMsg->index(), LOCKTYPE_MULTI );
		}
	}
}
// 处理玩家复杂合成拿出请求
void CPropertyModule::OnMessagePopMultiComRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePopMultiRequest *pMsg = ( CMessagePopMultiRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	int tResult = tpSrcProperty->GetBaggage( )->DelMultiItem( pMsg->index() );
	if ( tResult < 0 )
	{
		SendPopMultiComResponse( pPlayer, ERROR_MULTIPOPERROR, tResult, pMsg->index() );
	}
	else
	{
		if ( tpSrcProperty->GetBaggage( )->Lock( tResult, LOCKTYPE_NONE ) == true )
		{

			SendPopMultiComResponse( pPlayer, SUCCESS, tResult, pMsg->index() );
			SendLockItemNotice( pPlayer, tResult, LOCKTYPE_NONE );
		}
	}
}

// 处理玩家复杂合成请求
void CPropertyModule::OnMessageMultiComRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageMultiComRequest *pMsg = ( CMessageMultiComRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	
	// 安全密码检查
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

	
	CTemplateMultiCompose *tpCompose = static_cast< CTemplateMultiCompose* > ( CDataStatic::SearchTpl( pMsg->composeid() ) );
	if ( tpCompose == NULL )
	{
		SendMultiComResponse( pPlayer, pMsg->composeid(), ERROR_MULTICOMERROR );
		return;
	}		
	
	if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_CORPSEXCHANGE )
	{
		CCorpsModule::GetSingleton().CorpsExchange( pPlayer, pMsg->composeid(), pMsg->entityid(), pMsg->itemnum() );
		return;	
	}
	
	if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_FAMILYEXCHANGE )
	{
		CFamilyModule::GetSingleton().FamilyExchange( pPlayer, pMsg->composeid(), pMsg->entityid(), pMsg->itemnum() );
		return;
	}

	if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_EQUIPMENTCHANGE )
	{
		// 如果贡献度大于0就说明有亲密度的要求
		if ( tpCompose->mContribute > 0 )
		{
			
		}
	}

	int tIndex = -1;
	if ( tpCompose->mComposeType == CTemplateMultiCompose::COMPOSETYPE_EQUIPUPGRADE )
	{
		// 检查npc服务
		CEntityNpc* tpEntity = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( pMsg->entityid() ) );
		LK_ASSERT( tpEntity != NULL, return  )
		if ( tpEntity->GetEntityType() != ENTITYTYPE_FUNCNPC )
		{
			return;
		}

		// 服务判断
		CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
		CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
		LK_ASSERT( tpTmpNpc != NULL, return )
		if ( tpTmpNpc->mEquipLevelService != 1 )
		{
			return;
		}
		
		if ( pMsg->equipindex() < 0 )
		{
			return;
		}
		
		tIndex = pMsg->equipindex();
	}  	
	
	PlayerMultiCom( pPlayer, pMsg->composeid(), pMsg->composetype(), tIndex );
}

// 处理玩家放入卡片请求
void CPropertyModule::OnMessagePushCardRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessagePushCardRequest *pMsg = ( CMessagePushCardRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	CPropertyPlayer* tpSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	unsigned int tIndex = pMsg->index();
	/*if ( tIndex < 0 || tIndex > tpSrcProperty->GetBaggage()->mReleaseIndex )
		return;*/
	// TODO: 玩家包裹背包索引的检查
	if ( !tpSrcProperty->GetBaggage()->CheckIndexValid( tIndex ) )
	{
		return;
	}
	
	CItemObject *tpObject = (CItemObject*)tpSrcProperty->GetBaggage()->GetItemObjPtr( tIndex );
	if ( tpObject == NULL )
		return;
	CTplItem *tplItem = (CTplItem*)CDataStatic::SearchTpl( tpObject->GetItemID( ) );
	if ( tplItem == NULL )
		return;
	if ( tplItem->mItemType != CTplItem::ITEM_CARD )
		return;
	CTplItemCard *tplCard = (CTplItemCard*)tplItem;
	CPropertyPlayer::CardList::_Pairib tPair = tpSrcProperty->mActiveCardList.insert( tplCard->mTempID );
	if ( tPair.second == true )
	{
		SendPushCardResponse( pPlayer, SUCCESS, tplCard->mTempID );

		uint64_t ullGUID = tpObject->GetGUID();
		int nItemID = tpObject->GetItemID();

		if (PlayerRemoveItem( pPlayer, tIndex, 1 ) == 0)
		{
			LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);
		}

		CPropertyPlayer::CardList::iterator it = tpSrcProperty->mOwnCardList.find( tplCard->mTempID );
		tpSrcProperty->mOwnCardList.erase( it );
	}	
	// 如果已经有了这个卡片
	else
	{
		SendPushCardResponse( pPlayer, ERROR_ITEM_HASCARD, tplCard->mTempID );
	}
}

// 处理玩家点击造化点请求
void CPropertyModule::OnMessageClickTalentPointRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageClickTalentPointRequest *pMsg = ( CMessageClickTalentPointRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	int tRet = PlayerClickTalentPoint( pPlayer, pMsg->row(), pMsg->col() );
	CPropertyPlayer* tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	SendClickTalentPointResponse( pPlayer, tRet, pMsg->row(), pMsg->col(), tpProperty->GetTalentExp( ), tpProperty->GetTalentPoint( ), tpProperty->GetTalentStep( ) );
}

// 处理玩家造化进阶请求
void CPropertyModule::OnMessageIncreaseTalentRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL  )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageIncreaseTalentRequest *pMsg = ( CMessageIncreaseTalentRequest* )pMessage->msgpara( );
	if ( pMsg == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	int tRet = PlayerIncreaseTalent( pPlayer, pMsg->talentstep() );
	CPropertyPlayer* tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	SendIncreaseTalentResponse( pPlayer, tRet, tpProperty->GetTalentExp( ), tpProperty->GetTalentPoint( ), tpProperty->GetTalentStep( ) );
}


// 处理玩家学习生活技能的请求
void CPropertyModule::OnMessageInitialLifeSkillRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageInitialLifeSkillRequest *tpMsg = ( CMessageInitialLifeSkillRequest * )pMessage->msgpara();	
	LK_ASSERT( tpMsg != NULL, return )	
	
	// npc类型检查
//	CEntity *tpEntity = ( CEntity * )CSceneLogic::GetSingleton().GetEntity( tpMsg->entityid() );	
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		tpMsg->entityid( ) ) );
	LK_ASSERT( tpEntity != NULL, return )
	if ( !tpEntity->IsFunNpc() )
	{
		return;
	}
	
	// npc服务功能检查
	CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
	CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
	LK_ASSERT( tpTmpNpc != NULL, return  )	
	if ( tpTmpNpc->mLifeSkillService != (int)tpMsg->lifeskilltype() )
	{
		return;
	}
	
	if ( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) )
	{
		return;		
	}
	
	// 初始化生活技能		
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty( );	
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
		
	CLifeSkill *tpLifeSkill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpMsg->lifeskilltype() );
	if ( tpLifeSkill != NULL )
	{
		SendResponseInitializeLifeSkill( pPlayer, ERROR_LIFESKILL_SKILLFULL, tpMsg->lifeskilltype(), 0, 0, 0 );
		return;
	}
	
	CPlayerLifeSkill *tpPlayerLifeSkill = tpProperty->GetPlayerLifeSkill();
	int tStudySkillKind = tpPlayerLifeSkill->GetCurrentSkillKind( );
	if ( tStudySkillKind == LIFESKILLKIND_NONE )
	{
		SendResponseInitializeLifeSkill( pPlayer, ERROR_LIFESKILL_SKILLFULL, tpMsg->lifeskilltype(), 0, 0, 0 );
		return;
	}
	
	// 生活技能条件检查
	CTemplateLifeSkill *tpLifeSkillTable = ( CTemplateLifeSkill * )CDataStatic::GetSkillLifeTable( tpMsg->lifeskilltype() );
	LK_ASSERT( tpLifeSkillTable != NULL, return )
	
	// 玩家等级检查
	if ( pPlayer->GetLevel() < tpLifeSkillTable->mLevel[0] )
	{	  
		SendResponseInitializeLifeSkill( pPlayer, ERROR_LIFESKILL_INITIALLEVELLOW, tpMsg->lifeskilltype(), 0, 0, 0 );
		return;
	}	 
	
	// 金钱检查
	if ( ( unsigned int ) ( tpProperty->GetBindMoney() + tpProperty->GetMoney() ) < (unsigned int)tpLifeSkillTable->mStudyMoney[0] )
	{
		SendResponseInitializeLifeSkill( pPlayer, ERROR_LIFESKILL_STUDYMONEYNOTENOUGH, tpMsg->lifeskilltype(), 0, 0, 0 );
		return;
	}
	
	int tBindMoney = tpLifeSkillTable->mStudyMoney[0];
	int tMoney	   = 0;
	if ( tpProperty->GetBindMoney() < tpLifeSkillTable->mStudyMoney[0] )
	{
		tBindMoney =  tpProperty->GetBindMoney();
		tMoney	   =  tpLifeSkillTable->mStudyMoney[0] - tpProperty->GetBindMoney();		
	}
	
	if ( tBindMoney > 0 )
	{
		if ( PlayerChangeMoney( pPlayer, tBindMoney, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByUpLifeSkill(pPlayer, CYuanBao::em_bind_money, tBindMoney, tpMsg->lifeskilltype(), 1);	
		}
	}
	
	if ( tMoney > 0 )
	{
		if (PlayerChangeMoney( pPlayer, tMoney, true, false ) == SUCCESS)
		{
			LogEventLostMoneyByUpLifeSkill( pPlayer, CYuanBao::em_unbind_money, tMoney, tpMsg->lifeskilltype(), 1);
		}
	}
		
	CLifeSkill *tpSkill = tpPlayerLifeSkill->GetLifeSkillByKind( tStudySkillKind );
	LK_ASSERT( tpSkill != NULL, return )			
	
	tpSkill->InitialLifeSkill( tpMsg->lifeskilltype(), tStudySkillKind );
	OnPlayerAddTitleEvent( pPlayer, tpSkill->GetCurrentTitleID() );
	SendResponseInitializeLifeSkill( pPlayer, SUCCESS, tpMsg->lifeskilltype(), tStudySkillKind, tpSkill->GetSpecializedDegree(), tpSkill->GetLifeSkillLevel() );
	LogLifeSkillAction( pPlayer->GetCharID(), tpSkill, EM_LIFESKILLACTION_INITIAL, 0 );
}

// 处理玩家进阶生活技能的请求
void CPropertyModule::OnMessageLevelUpLifeSkillRequest( CEntityPlayer* pPlayer, CMessage* pMessage )	
{  
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageLevelUPLifeSkillRequest *tpMsg = ( CMessageLevelUPLifeSkillRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	// npc类型检查
//	CEntity *tpEntity = ( CEntity * )CSceneLogic::GetSingleton().GetEntity( tpMsg->entityid() );	
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		tpMsg->entityid( ) ) );
	LK_ASSERT( tpEntity != NULL, return )
	if ( !tpEntity->IsFunNpc() )
	{
		return;
	}

	// npc服务功能检查
	CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
	CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
	LK_ASSERT( tpTmpNpc != NULL, return  )	
	if ( tpTmpNpc->mLifeSkillService != (int)tpMsg->lifeskilltype() )
	{
		return;
	}
	
	if ( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) )
	{
		return;		
	}
	
	// 技能升级	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	CLifeSkill *tpLifeSkill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpMsg->lifeskilltype() );
	LK_ASSERT( tpLifeSkill != NULL, return )
	int tBindMoney = pPlayer->GetBindMoney();
	int tMoney		= pPlayer->GetMoney();
	int tRet = tpLifeSkill->LevelUpLifeSkill( pPlayer->GetLevel(), tBindMoney, tMoney );
	if ( tRet != SUCCESS )
	{
		SendResponseLevelUPLifeSkill( pPlayer, tRet, tpMsg->lifeskilltype(), tpLifeSkill->GetSpecializedDegree(), tpLifeSkill->GetLifeSkillLevel() );
		return;
	}
	
	OnPlayerAddTitleEvent( pPlayer, tpLifeSkill->GetCurrentTitleID() );
	
	// 发送操作成功的消息
	SendResponseLevelUPLifeSkill( pPlayer, SUCCESS, tpMsg->lifeskilltype(), tpLifeSkill->GetSpecializedDegree(), tpLifeSkill->GetLifeSkillLevel() );
	
	LogEventPlayerLifeSkillLevelUp(pPlayer, tpLifeSkill);
	
	LogLifeSkillAction( pPlayer->GetCharID(), tpLifeSkill, EM_LIFESKILLACTION_LEVELUP, 0 );

	// 扣除学习金钱	
	if ( tBindMoney > 0 )
	{
		if (PlayerChangeMoney( pPlayer, tBindMoney, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByUpLifeSkill(pPlayer, CYuanBao::em_bind_money, tBindMoney, 
					tpMsg->lifeskilltype(), tpLifeSkill->GetLifeSkillLevel());
		}
	}
	
	if ( tMoney > 0 )
	{
		if (PlayerChangeMoney( pPlayer, tMoney, true, false ) == SUCCESS)
		{
			LogEventLostMoneyByUpLifeSkill(pPlayer, CYuanBao::em_unbind_money, tMoney, 
					tpMsg->lifeskilltype(), tpLifeSkill->GetLifeSkillLevel());
		}
	}	
}

// 处理玩家学习新技能配方的请求
void CPropertyModule::OnMessageStudyComposeRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{  
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
		CMessageStudyComposeRequest *tpMsg = ( CMessageStudyComposeRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )

		CPropertyPlayer *tpProperty = ( CPropertyPlayer * )	pPlayer->GetProperty();
	CLifeSkill *tpLifeSkill =  tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpMsg->lifeskilltype() );
	if ( tpLifeSkill == NULL )
	{
		return;
	}

	// 如果是npc处学习的话得判断服务和距离
	if ( tpMsg->studyway() == COMPOSEGETWAY_BYNPC )
	{
		
		CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
			tpMsg->entityid( ) ) );
		LK_ASSERT( tpEntity != NULL, return )
		if ( !tpEntity->IsFunNpc() )
		{
			return;
		}

		// npc服务功能检查
		CPropertyNPC * tpNpcProperty = ( CPropertyNPC * )tpEntity->GetProperty(); 
		CTemplateNpc *tpTmpNpc = ( CTemplateNpc * )CDataStatic::SearchTpl( tpNpcProperty->GetPropertyTempID() );
		LK_ASSERT( tpTmpNpc != NULL, return  )	
		if ( tpTmpNpc->mLifeSkillService != (int)tpMsg->lifeskilltype() )
		{
			return;
		}

		if ( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD ) )
		{
			return;
		}
		int	tPlayerAP		= 100;
		unsigned int tPlayerMoney	= ( unsigned int )tpProperty->GetBindMoney() + ( unsigned int )tpProperty->GetMoney();	 
		int tRet = tpLifeSkill->StudyCompose( tpMsg->composeid(), COMPOSEGETWAY_BYNPC, tPlayerAP, tPlayerMoney );
		if ( tRet == SUCCESS )
		{
			if (PlayerChangeMoney( pPlayer, tPlayerMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByStudyCompose(pPlayer, CYuanBao::em_bind_money, tPlayerMoney,tpMsg->lifeskilltype());
			}
		}

		SendResponseStudyCompose( pPlayer, tRet, tpLifeSkill->GetSpecializedDegree(), tpMsg->composeid(), tpMsg->lifeskilltype(), tpMsg->studyway() );
		LogLifeSkillAction( pPlayer->GetCharID(), tpLifeSkill, EM_LIFESKILLACTION_STUDYCOMPOSE, tpMsg->composeid() );
		return;
	}

	if ( tpMsg->studyway() != COMPOSEGETWAY_BYCREAT )
	{
		return;
	}			

	// 添加材料		
	int tOldBagIndex = -1;
	for ( int i = 0; i < tpMsg->matierialindex_size(); ++i )
	{
		if ( (int)tpMsg->matierialindex( i ) < 0 )
		{
			continue;
		}
				
		CItemObject *tpItemObj = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->matierialindex( i ) );
		LK_ASSERT( tpItemObj != NULL, return )
		CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
		if ( tpTplItem == NULL )
		{
			return;
		}
		if ( tpTplItem->mItemType != CTplItem::ITEM_PRODUCE && tpTplItem->mItemType != CTplItem::ITEM_PHYSIC )
		{			
			SendResponseStudyCompose( pPlayer, ERROR_LIFESKILL_ITEMCANNOTCREATCOMPOSE, tpLifeSkill->GetSpecializedDegree(), 0, tpMsg->lifeskilltype(), tpMsg->studyway() );		
			return;
		}

		int tRet = tpProperty->GetPlayerLifeSkill()->AddMaterial( tpMsg->matierialindex( i ), i, tpItemObj->GetItemID(), tOldBagIndex );
		if ( tRet == -1 )
		{
			return;
		}
	}		
	
	// 创造配方
	int tComposeID = 0;
	int tRet = tpProperty->GetPlayerLifeSkill()->CreatComPose(  tpMsg->lifeskilltype(), tpMsg->value(), tComposeID, tpMsg->skillkind() );
	if ( tRet == -1 )
	{
		return;
	}	

	if ( tRet != ERROR_LIFESKILL_COMPOSEHASEXIST )
	{	
		int tIndexList[MATERIALINDEXNUM] = { 0 };
		int tNum = MATERIALINDEXNUM;
		tpProperty->GetPlayerLifeSkill()->GetMaterialList( tIndexList, tNum );		
		for ( int i = 0; i < tNum; ++i )
		{
			if ( tIndexList[i] != -1 )
			{
				PlayerRemoveItem( pPlayer, tIndexList[i], 1, false );
				tpProperty->GetPlayerLifeSkill()->TakeMaterial( i, tIndexList[i] );			
			}	
		}	 		
	}
	
	if ( tRet == SUCCESS )
	{
		LogLifeSkillAction( pPlayer->GetCharID(), tpLifeSkill, EM_LIFESKILLACTION_CREATCOMPOSE, tComposeID );	
	}		
	SendResponseStudyCompose( pPlayer, tRet, tpLifeSkill->GetSpecializedDegree(), tComposeID, tpMsg->lifeskilltype(), tpMsg->studyway() );			
}

// 处理玩家给装备附魔的请求
void CPropertyModule::OnMessageSetMagicStoneRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{  
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	CMessageSetMagicStoneRequest *tpMsg  = ( CMessageSetMagicStoneRequest * ) pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return ) 
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
		
	
	CItemObject *tpMagicStone = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->magicstoneindex() );
	if ( tpMagicStone == NULL )
	{
		return;
	}  	
	
	CTplItem *tpMagicItem = ( CTplItem * )CDataStatic::SearchTpl( tpMagicStone->GetItemID() );
	if ( tpMagicItem == NULL )
	{
		return;
	}
	
	if ( tpMagicItem->mItemType != ITEM_MAGICSTONE )
	{
		return;
	}
	
	
	CItemObject *tpEquipment  = NULL;
	if ( tpMsg->equipslot() == SLOT_BAGGAGE )
	{
		tpEquipment = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->equipindex() );
	}
	else if( tpMsg->equipslot() == SLOT_EQUIPMENT )
	{
		tpEquipment = tpProperty->GetEquipment()->GetItemObjPtr( tpMsg->equipindex() );
	}
	 
	if ( tpEquipment == NULL )
	{
		return;
	}
	
	CTplItem *tpTplEquip = ( CTplItem * )CDataStatic::SearchTpl( tpEquipment->GetItemID() );
	if ( tpTplEquip == NULL )
	{
		return;
	}		   
	
	if ( !tpTplEquip->IsEquipable() )
	{
		return;	
	}
	
	if ( ( tpEquipment->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tpEquipment->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		return;
	}
		

	int nFrom = (( CItemEquipment * ) tpEquipment)->GetMagicStoneNum();
	int nFromID = (( CItemEquipment * ) tpEquipment)->GetMagicStoneID();

	int tRet = ( ( CItemEquipment * )tpEquipment )->SetMagicStone( tpMagicStone->GetItemID() );
	if ( tRet == -1 )
	{
		return;
	}
	int tAttribute =  ( ( CItemEquipment * )tpEquipment )->GetMagicAttribute();
	SendResponseSetMagicStone( pPlayer, tRet, tpMsg->equipindex(), tAttribute, tpMagicStone->GetItemID(), ( ( CItemEquipment * )tpEquipment )->GetMagicStoneNum(), tpMsg->equipslot() );		
	
	if ( tRet == SUCCESS || tRet == ERROR_LIFESKILL_SETMAGICFAILED )
	{
		uint64_t ullGUID = tpMagicStone->GetGUID();
		int nItemID = tpMagicStone->GetItemID();
		if ( PlayerRemoveItem( pPlayer, tpMsg->magicstoneindex(), 1) == 0)
		{
			LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);
		}
		
		// 如果是身上的装备附魔，则刷新玩家属性
		if ( tpMsg->equipslot() == SLOT_EQUIPMENT )
		{
			RefreshPlayerProperty( pPlayer );		
		}	

		// 记录装备附魔日志
		int nTo = (( CItemEquipment * ) tpEquipment)->GetMagicStoneNum();
		int nToID = (( CItemEquipment * ) tpEquipment)->GetMagicStoneID();

		LogEventItemDianAction(pPlayer, tpEquipment->GetItemID(), tpEquipment->GetGUID(), 
				nFromID, nFrom, nToID, nTo, tpEquipment->GetBindStatus());
	}	
}

// 处理玩家分解装备的请求
void CPropertyModule::OnMessageDecompoundEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{  
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	CMessageDecompoundEquipRequest *tpMsg = ( CMessageDecompoundEquipRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )	
	
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	
	// 检查有没有密码保护
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	
	int tDecompoundEquipIndex = -1;
	if ( tpMsg->has_equipindex() )
	{
		tDecompoundEquipIndex = tpMsg->equipindex();
	}
	else
	{
		tDecompoundEquipIndex = tpProperty->GetDecompoundEquipIndex();
		tpProperty->SetDecompoundEquipIndex( -1 );
	}
	
	CLifeSkill *tpLifeSkill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( LIFESKILL_GOLDMAKE );
	if ( tpLifeSkill == NULL )
	{
		SendResponseDecompoundEquip( pPlayer, ERROR_LIFESKILL_DECOMPOUNDWITHOUTGOLDMAKE, tDecompoundEquipIndex );		
		return;
	}
		
	CItemObject *tpItemObj = ( CItemObject * )tpProperty->GetBaggage()->GetItemObjPtr( tDecompoundEquipIndex );
	if ( tpItemObj == NULL )
	{			
		return;
	}
	
	// 判断是否手动绑定
	if ( tpItemObj->GetBindStatus() & ITEM_BINDSTATUS_BYITEM )
	{
		return;
	}	
	
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	if ( tpTplItem == NULL )
	{			
		return;
	}
	
	
	if ( !tpTplItem->IsEquipable() )
	{
		SendResponseDecompoundEquip( pPlayer, ERROR_LIFESKILL_ITEMCANOTDECOMPOUND, tDecompoundEquipIndex );		
		return;
	}	
	CTemplateEquipment *tpTplEquipment = ( CTemplateEquipment * )tpTplItem;
		
	int tIDList[10]		= { 0 };
	int tNumList[10]	= { 0 };
	int tNum	= 0;	
	int tDegreeObtained = 0;
	int tRet = CDataStatic::GetCompoundIDList( tpLifeSkill->GetSpecializedDegree(), tpTplEquipment->mLevelRequire, tpTplEquipment->mShowColour, tIDList, tNumList, tNum, tDegreeObtained );	
	
	if ( tRet == -1 )
	{
		SendResponseDecompoundEquip( pPlayer, ERROR_LIFESKILL_EQUIPNOTCOMPONEDE, tDecompoundEquipIndex );		
		return;
	}
		
	if ( tRet == DECOMPOUND_DEGREENOTENOUGH )
	{	 
		SendResponseDecompoundEquip( pPlayer, ERROR_LIFESKILL_DECOMPOUNDWITHOUTENGOUGHDEGREE, tDecompoundEquipIndex );		
		return;
	}			
		
	/*int tCheckIDList[10] = { 0 };
	int tCheckNumList[10] = { 0 };
	memcpy( tCheckIDList, tIDList, sizeof( tCheckIDList  ) );
	memcpy( tCheckNumList, tNumList, sizeof( tCheckNumList ) );*/
	CItemBoxToolkit tItemBoxTooKit( tpProperty->GetBaggage() );
	if ( tItemBoxTooKit.GetLeftPileNum( -1 ) < tNum )
	{
		SendResponseDecompoundEquip( pPlayer, ERROR_LIFESKILL_DECOMPOUNDWITHOUTSPACE, tDecompoundEquipIndex );		
		return;
	}  
	
	if ( tDegreeObtained > 0 )
	{
		tpLifeSkill->AddSpecializedDegree( tDegreeObtained, CLifeSkill::DEGREEADDTYPE_USECOMPOSE );
		SendNotifyLifeSkillAttribute( pPlayer, tpLifeSkill->GetLifeSkillType(), tpLifeSkill->GetSpecializedDegree() );
	}
		
	uint64_t guid = tpItemObj->GetGUID();
	int nItemID = tpItemObj->GetItemID();
	int nItemNum = tpItemObj->GetItemNum();
	if ( PlayerRemoveItem( pPlayer, tDecompoundEquipIndex, tpItemObj->GetItemNum()) == 0)	
	{
		LogEventLostItemByDecompound( pPlayer, guid, nItemID, nItemNum );
	}
	
	for ( int i = 0; i < tNum; ++i )
	{
		if ( tNumList[i] > 0 )
		{
			CItemObject* pInsItemPile = PlayerInsertItem( pPlayer, tIDList[i], tNumList[i], false );
			if ( pInsItemPile)
			{
				LogEventGetItemByDeCompound( pPlayer, 
						pInsItemPile->GetGUID(), tIDList[i], tNumList[i], tpTplItem->mTempID, guid);		
			}
		}		
	}
	
	SendResponseDecompoundEquip( pPlayer, SUCCESS, tDecompoundEquipIndex );	
}

// 放置需要研究的材料
void CPropertyModule::OnMessageAddMaterialRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageAddMaterialRequest *tpMsg = ( CMessageAddMaterialRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )	pPlayer->GetProperty();	
	int tOldBagIndex = -1;
	CItemObject *tpItemObj = tpProperty->GetBaggage()->GetItemObjPtr(  tpMsg->materialindex() );
	LK_ASSERT( tpItemObj != NULL, return )
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	if ( tpTplItem == NULL )
	{
		return;
	}
	if ( tpTplItem->mItemType != CTplItem::ITEM_PRODUCE && tpTplItem->mItemType != CTplItem::ITEM_PHYSIC )
	{
		SendResponseAddMaterial( pPlayer, ERROR_LIFESKILL_ITEMCANNOTCREATCOMPOSE, tpMsg->materialindex(), tpMsg->posindex() );
		return;
	}
	
	tpProperty->GetPlayerLifeSkill()->AddMaterial( tpMsg->materialindex(), tpMsg->posindex(), tpItemObj->GetItemID(), tOldBagIndex );
	tpProperty->GetBaggage()->Lock( tpMsg->materialindex(), LOCKTYPE_LIFESKILL );
	SendLockItemNotice( pPlayer, tpMsg->materialindex(), LOCKTYPE_LIFESKILL );
	if ( tOldBagIndex >= 0 )
	{
		tpProperty->GetBaggage()->Lock( tpMsg->materialindex(), LOCKTYPE_NONE );
		SendLockItemNotice( pPlayer, tOldBagIndex, LOCKTYPE_NONE );
	}
	SendResponseAddMaterial( pPlayer, SUCCESS, tpMsg->materialindex(), tpMsg->posindex() );
}

// 取下研究材料
void CPropertyModule::OnMessageTakeMaterialRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{ 
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageTakeMaterialRequest *tpMsg = ( CMessageTakeMaterialRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int tBagIndex = -1;
	tpProperty->GetPlayerLifeSkill()->TakeMaterial( tpMsg->posindex(), tBagIndex );
	if ( tBagIndex >= 0 )
	{
		tpProperty->GetBaggage()->Lock( tBagIndex, LOCKTYPE_NONE );
		SendLockItemNotice( pPlayer, tBagIndex, LOCKTYPE_NONE );
	}		
	SendResponseTakeMaterial( pPlayer, SUCCESS, tpMsg->posindex() );			
}

// 遗忘生活技能
void CPropertyModule::OnMessageForgetLifeSkill( CEntityPlayer* pPlayer, CMessage* pMessage )
{	   
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )		
	CMessageForgetSkillRequest *tpMsg = ( CMessageForgetSkillRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	
	// 是否处于密码保护状态
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	
	
	CLifeSkill *tpLifeSkill = tpProperty->GetPlayerLifeSkill()->GetLifeSkillByType( tpMsg->lifeskilltype() );
	LK_ASSERT( tpLifeSkill != NULL, return )
	LogLifeSkillAction( pPlayer->GetCharID(), tpLifeSkill, EM_LIFESKILLACTION_FORGETLIFESKILL, 0 );
	int tRet = tpLifeSkill->ForgetLifeSkill();	 	
	SendResponseForgetLifeSkill( pPlayer, tRet, tpMsg->lifeskilltype() );	 	
}


// 处理玩家选择称号请求
void CPropertyModule::OnMessageSelectTitleRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return ;
	}

	CMessageSelectTitleRequest* tpReq = ( CMessageSelectTitleRequest* ) pMessage->msgpara();

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	if ( tpProperty->GetCurrentTitle() == (int)tpReq->titleid() )
	{
		return ;
	}

	CMessage tMessage;
	CMessageUpdateCurrentTitleNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_UPDATECURRENTTITLE );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_charid( pPlayer->GetCharID() );
	tPara.set_titleid( tpReq->titleid() );

	// 如果id是0,取消当前称号
	if ( tpReq->titleid() == 0 )
	{
		tpProperty->RemoveTitleSkill( tpProperty->GetCurrentTitle() );
		tpProperty->Refresh();
		pPlayer->NotifyPropertyRefresh();
		tpProperty->SetCurrentTitle( 0 );
		CMapModule::GetSingleton().MessageBroadCast( pPlayer, &tMessage, false, true );
		return ;
	}
	
	bool bHasThisTitle = false;
	bHasThisTitle = tpProperty->HasTitle( tpReq->titleid() );

	if ( bHasThisTitle )
	{		
		CTitle* tpTitle = CDataStatic::GetTitle( tpReq->titleid() );
		if ( tpTitle == NULL )
			return ;

		int tOldTitle = tpProperty->GetCurrentTitle();
		if ( tOldTitle > 0 )
		{
			tpProperty->RemoveTitleSkill( tOldTitle );
		}
		if ( tpTitle->mType == CTplTitleManager::TITLETYPE_SWORN )
		{
			if ( pPlayer->GetSwornID() > 0 )
			{
				CSwornTeam *tpSwornTeam = CFriendModule::GetSingleton().GetSwornTeam( pPlayer->GetSwornID() );
				if ( tpSwornTeam != NULL )
				{
					tPara.set_titlename( tpSwornTeam->GetSwornName() );
				}
			}
		}
		CMapModule::GetSingleton().MessageBroadCast( pPlayer, &tMessage, false, true );

		// update current title
		tpProperty->SetCurrentTitle( tpReq->titleid() );

		CTemplateSkill* tpSkill = ( CTemplateSkill* ) CDataStatic::SearchTpl( tpTitle->mAddProperty );
		if ( tpSkill != NULL )
		{
			tpProperty->mTitleSkill.InsertSkill( tpSkill->mSkillID, 1 );
		}
		RefreshPlayerProperty(pPlayer);
	}
	else
	{
		SendProErrorNotice( pPlayer, ERROR_PROPERTY_TITLENOTEXIST );
	}	
	return ;
}


void CPropertyModule::OnMessageProcessMultiBuffRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessageMultiBuffRequest* pRequestMsg = (CMessageMultiBuffRequest*) pMessage->msgpara();

	int nEventID = pRequestMsg->eventid();

	CTemplateMultiBuffConfig* pMutiBuffConfig = (CTemplateMultiBuffConfig*)CDataStatic::GetTemp( TEMP_MULTIBUFF );
	if( pMutiBuffConfig == NULL )
	{
		return ;
	}

	unsigned int i = 0;
	for(  i = 0; i < ARRAY_CNT(pMutiBuffConfig->mEvent); i++ )
	{
		if( nEventID == pMutiBuffConfig->mEvent[i].mEventID )
		{

			break;
		}
	}

	// 没有找到envent id 索引
	if( i >= ARRAY_CNT(pMutiBuffConfig->mEvent) )
	{
		return ;
	}

	// 必须是一个队伍
	int nTeamID = 0;
	std::map< int,CEntityPlayer* > tEventList;
	CTeamEventBuff tTeamEventBuff;
	tTeamEventBuff.mBuffID = pMutiBuffConfig->mEvent[ i ].mBuffID;
	tTeamEventBuff.mLastRefreshTime = time(NULL);
	tTeamEventBuff.mForceRefresh = ( pRequestMsg->needrefresh() == 1 ) ? true : false;
	std::vector< CEntityPlayer* > tPlayerList;
	
	for( int k = 0; k < pRequestMsg->buffeventlist_size(); k++ )
	{
		PBEntityBuffEvent* pEvent = pRequestMsg->mutable_buffeventlist( k );
		CEntityPlayer* pPlayer = CSceneLogic::GetSingletonPtr()->GetPlayerByCharID( pEvent->charid() );

		if( pPlayer == NULL )
		{
			return ;
		}

		if( nTeamID == 0 )
		{
			nTeamID = CTeamModule::GetSingletonPtr()->InTeam( pPlayer->GetCharID() );;
		}
		else if( nTeamID != CTeamModule::GetSingletonPtr()->InTeam( pPlayer->GetCharID() ) )
		{
			return ;
		}

		if ( pEvent->param1() != 0 )
		{
			tEventList.insert( std::pair<int,CEntityPlayer*>( (int)(pEvent->param1()), pPlayer ) );
			tPlayerList.push_back( pPlayer );
		}
		CTeamEventBuff::CPlayerTeamEvent mTeamEvent(pPlayer->GetCharID());
		tTeamEventBuff.mBeneficiary.push_back( mTeamEvent );		
	}

	switch( nEventID )
	{
	case CTemplateMultiBuffConfig::EVENT_SHITU:  // 师徒四人
		{
			if( tEventList.size() < 3 )
			{
				return ;
			}

			CEntityPlayer* pPlayer = NULL;
			int nBuffID = 0;

			std::map< int,CEntityPlayer* >::iterator it = tEventList.begin();
			for( ; it != tEventList.end(); ++it )
			{
				nBuffID = it->first;
				pPlayer = it->second;

				if( pPlayer->HasBuff( nBuffID ) != true )
				{
					return;
				}

			}

			CTeamModule::GetSingletonPtr()->AddTeamEventBuff( pPlayer, tTeamEventBuff );

			break;
		}
	case CTemplateMultiBuffConfig::EVENT_4METIRE_AWARD:
	case CTemplateMultiBuffConfig::EVENT_5METIRE_AWARD:
	case CTemplateMultiBuffConfig::EVENT_6METIRE_AWARD:
		{
			if( tEventList.size() < 4 )
			{
				return ;
			}

			CEntityPlayer* pPlayer = NULL;
			int nMetier = 0;

			std::map< int,CEntityPlayer* >::iterator it = tEventList.begin();
			for( ; it != tEventList.end(); ++it )
			{
				nMetier = it->first;
				pPlayer = it->second;

				if( pPlayer->GetMetier() != nMetier )
				{
					return;
				}
			}

			CTeamModule::GetSingletonPtr()->AddTeamEventBuff( pPlayer, tTeamEventBuff );

			break;
		}
        //add by yucx 20100716 特殊副本加成
	case CTemplateMultiBuffConfig::EVENT_4METIRE_AWARD_FB:
	case CTemplateMultiBuffConfig::EVENT_5METIRE_AWARD_FB:
	case CTemplateMultiBuffConfig::EVENT_6METIRE_AWARD_FB:
		{
			if( tEventList.size() < 4 )
			{
				return ;
			}

			CEntityPlayer* pPlayer = NULL;
			int nMetier = 0;

			std::map< int,CEntityPlayer* >::iterator it = tEventList.begin();
			for( ; it != tEventList.end(); ++it )
			{

				nMetier = it->first;
				pPlayer = it->second;

				if( pPlayer->GetMetier() != nMetier )
				{
					return;
				}

                CPropertyPlayer *tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
                CPlayerRepetion *tpRepetion = tpPro->GetRepetion( );

                bool inSRepetion = false;
                for(int j = 0; j < (int)ARRAY_CNT( pMutiBuffConfig->mEvent[i].mRepetionIndex ); j++ ) 
                {

                    if( tpRepetion ->GetInRepetionIndex() == pMutiBuffConfig->mEvent[i].mRepetionIndex[j] )
                    {
                        inSRepetion = true;  
                    }
                }

                if( inSRepetion == false)
                {
                    return ;
                }

			}

			CTeamModule::GetSingletonPtr()->AddTeamEventBuff( pPlayer, tTeamEventBuff );

			break;
		}
	case CTemplateMultiBuffConfig::EVENT_4SAMEBUFF_AWARD:
	case CTemplateMultiBuffConfig::EVENT_5SAMEBUFF_AWARD:
	case CTemplateMultiBuffConfig::EVENT_6SAMEBUFF_AWARD:
		{
			if( tEventList.size() != 1 )
			{
				return ;
			}
			CEntityPlayer* pPlayer = NULL;			

			std::map< int,CEntityPlayer* >::iterator it = tEventList.begin();
			int nBuffID = it->first;

			std::vector< CEntityPlayer* >::iterator it1 = tPlayerList.begin();
			for( ; it1 != tPlayerList.end(); ++it1 )
			{
				pPlayer = *it1;
				if( pPlayer->HasBuff( nBuffID ) != true )
				{
					return;
				}
			}
			int tIndex = -1;
			for ( int j = 0; j < MAX_EVENTPARAM; ++j )
			{
				if ( pMutiBuffConfig->mEventParam[ i ][ j ] == nBuffID )
				{
					tIndex = j;
				}
			}
			if ( tIndex >= 0 )
			{
				tTeamEventBuff.mBuffID = pMutiBuffConfig->mEventBuff[ i ][ tIndex ];
				CTeamModule::GetSingletonPtr()->AddTeamEventBuff( pPlayer, tTeamEventBuff );
			}
			break;
		}
	default:
		{
			LOG_ERROR( "pro", "[%s:%d] invalid event id %d", __FUNCTION__, __LINE__, nEventID );
			break;
		}
	
	}

}




// 发送增加凹槽放入回应
void CPropertyModule::SendPushAddSlotResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHADDSLOT );

	CMessagePushAddSlotResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送增加凹槽拿出回应
void CPropertyModule::SendPopAddSlotResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPADDSLOT );

	CMessagePopAddSlotResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送增加凹槽拿出回应
void CPropertyModule::SendAddSlotResponse( CEntityPlayer* pPlayer, int vResult, int vSlot )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_ADDSLOT );

	CMessageAddSlotResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_slot( vSlot );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送摘除宝石放入回应
void CPropertyModule::SendPushRemoveJewelResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHREMOVEJEWEL );

	CMessagePushRemoveJewelResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}
// 发送摘除宝石拿出回应
void CPropertyModule::SendPopRemoveJewelResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPREMOVEJEWEL );

	CMessagePopRemoveJewelResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送摘除宝石回应
void CPropertyModule::SendRemoveJewelResponse( CEntityPlayer* pPlayer, int vResult )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_REMOVEJEWEL );

	CMessageRemoveJewelResponse tMessage;
	tMessage.set_result( vResult );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送鉴定装备放入回应
void CPropertyModule::SendPushJudgeResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHJUDGE );

	CMessagePushJudgeResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}
// 发送鉴定装备拿出回应
void CPropertyModule::SendPopJudgeResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPJUDGE );

	CMessagePopJudgeResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送鉴定装备回应
void CPropertyModule::SendJudgeResponse( CEntityPlayer* pPlayer, int vResult, int vProperty1, int vProperty2, int vProperty3 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_JUDGE );

	CMessageJudgeResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_property1( vProperty1 );
	tMessage.set_property2( vProperty2 );
	tMessage.set_property3( vProperty3 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送转化抗性放入回应
void CPropertyModule::SendPushChangeResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHCHANGE );

	CMessagePushChangeResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}
// 发送转化抗性拿出回应
void CPropertyModule::SendPopChangeResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPCHANGE );

	CMessagePopChangeResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送转化抗性回应
void CPropertyModule::SendChangeResponse( CEntityPlayer* pPlayer, int vResult, int vType )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_CHANGE );

	CMessageChangeResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_type( vType );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送宝石合成放入回应
void CPropertyModule::SendPushJewComResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHJEWCOM );

	CMessagePushJewComResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}
// 发送宝石合成拿出回应
void CPropertyModule::SendPopJewComResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPJEWCOM );

	CMessagePopJewComResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送宝石合成回应
void CPropertyModule::SendJewComResponse( CEntityPlayer* pPlayer, int vResult )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_JEWCOM );

	CMessageJewComResponse tMessage;
	tMessage.set_result( vResult );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送增加凹槽放入回应
void CPropertyModule::SendPushMultiComResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHMULTI );

	CMessagePushMultiResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送增加凹槽拿出回应
void CPropertyModule::SendPopMultiComResponse( CEntityPlayer* pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_POPMULTI );

	CMessagePopMultiResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_index1( vIndex1 );
	tMessage.set_index2( vIndex2 );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}


// 发送复杂合成回应
void CPropertyModule::SendMultiComResponse( CEntityPlayer* pPlayer, int vComposeID, int vResult, int nIndex /* = -1 */ )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_MULTICOM );

	CMessageMultiComResponse tMessage;
	tMessage.set_composeid( vComposeID );
	tMessage.set_result( vResult );
	tMessage.set_equipindex( nIndex );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送放入卡片回应
void CPropertyModule::SendPushCardResponse( CEntityPlayer* pPlayer, int vResult, int vItemID )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_PUSHCARD );

	CMessagePushCardResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_itemid( vItemID );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送获得修为值通知
void CPropertyModule::SendTalentChangeNotify( CEntityPlayer* pPlayer, int vTalentExp, int vTalentPoint, int vTalentChange, int vTalentLevel )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	pPlayer->AddFunResult( 0, FUNC_TALENT, RESULT_NORMAL, false, vTalentExp, vTalentPoint, vTalentChange, vTalentLevel );

	/*CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIYFY_TALENTCHANGE );

	CMessageTalentChangeNotify tMessage;
	tMessage.set_talentexp( vTalentExp );
	tMessage.set_talentpoint( vTalentPoint );
	tMessage.set_talentchange( vTalentChange );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );*/
}

// 发送点击造化点回应
void CPropertyModule::SendClickTalentPointResponse( CEntityPlayer* pPlayer, int vResult, int vRow, int vCol, int vTalentExp, int vTalentPoint, int vTalentStep )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_CLICKTALENTPOINT );

	CMessageClickTalentPointResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_row( vRow );
	tMessage.set_col( vCol );
	tMessage.set_talentexp( vTalentExp );
	tMessage.set_talentpoint( vTalentPoint );
	tMessage.set_talentstep( vTalentStep );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送造化进阶回应
void CPropertyModule::SendIncreaseTalentResponse( CEntityPlayer* pPlayer, int vResult, int vTalentExp, int vTalentPoint, int vTalentStep )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_RESPONSE_INCREASESTAGE );

	CMessageIncreaseTalentResponse tMessage;
	tMessage.set_result( vResult );
	tMessage.set_talentexp( vTalentExp );
	tMessage.set_talentpoint( vTalentPoint );
	tMessage.set_talentstep( vTalentStep );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 发送初始化生活技能的回应
void CPropertyModule::SendResponseInitializeLifeSkill( CEntityPlayer *pPlayer, int nErrcode, int nLifeSkillType, int nLifeSkillKind, int nDegreeValue, int nSkillLevel )
{ 
	LK_ASSERT( pPlayer != NULL, return )		
	CMessage tMsgHead;
	CMessageInitialLifeSkillResponse tMsgInitialLifeSkill;
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_INITIALLIFESKILL );
	tMsgHead.set_msgpara( (int)&tMsgInitialLifeSkill );
	
	tMsgInitialLifeSkill.set_errcode( nErrcode );
	tMsgInitialLifeSkill.set_lifeskillkind( nLifeSkillKind );
	tMsgInitialLifeSkill.set_lifeskilllevel( nSkillLevel );
	tMsgInitialLifeSkill.set_lifeskilltype( nLifeSkillType );
	tMsgInitialLifeSkill.set_specializedegree( nDegreeValue );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 发送生活技能进阶的回应消息
void CPropertyModule::SendResponseLevelUPLifeSkill( CEntityPlayer *pPlayer, int nErrcode, int nLifeSkillType, int nSpecializeDegree, int nLifeSkillLevel )
{ 
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage tMsgHead;
	CMessageLevelUPLifeSkillResponse tMsgLevelUpLifeSkill;
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_LEVELUPLIFESKILL );
	tMsgHead.set_msgpara( (int)&tMsgLevelUpLifeSkill );
	
	tMsgLevelUpLifeSkill.set_errcode( nErrcode );
	tMsgLevelUpLifeSkill.set_lifeskilllevel( nLifeSkillLevel );
	tMsgLevelUpLifeSkill.set_lifeskilltype( nLifeSkillType );
	tMsgLevelUpLifeSkill.set_specializedegree( nSpecializeDegree );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 发送学习新技能配方的回应消息
void CPropertyModule::SendResponseStudyCompose( CEntityPlayer *pPlayer, int nErrcode, int nSpecializeDegree, int nComposeID, int nLifeSkillType, int nStudyWay )
{
	CMessage tMsgHead;
	CMessageStudyComposeResponse tMsgStudyCompose;
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_STUDYCOMPOSE );	
	tMsgHead.set_msgpara( ( int )&tMsgStudyCompose );
	
	tMsgStudyCompose.set_errcode( nErrcode );
	tMsgStudyCompose.set_specializedegree( nSpecializeDegree );
	tMsgStudyCompose.set_composeid( nComposeID );
	tMsgStudyCompose.set_lifeskilltype( nLifeSkillType );
	tMsgStudyCompose.set_studyway( nStudyWay );  
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 发送附魔的回应消息
void CPropertyModule::SendResponseSetMagicStone( CEntityPlayer *pPlayer, int nErrcode, int nEquipIndex, int nAttribute, int nStoneID, int nMagicNum /* = 0 */, int nSlotType /* = SLOT_BAGGAGE */ )
{  
	LK_ASSERT( pPlayer != NULL, return )		
	CMessage tMsg;
	CMessageSetMagicStoneResponse tMsgSetMagic;
	
	tMsg.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_SETMAGICSTONE );
	tMsg.set_msgpara( (int)&tMsgSetMagic );
	
	tMsgSetMagic.set_errcode( nErrcode );
	tMsgSetMagic.set_equipindex( nEquipIndex );
	tMsgSetMagic.set_magicnum( nMagicNum );	
	tMsgSetMagic.set_attributeid( nAttribute );
	tMsgSetMagic.set_magicstoneid( nStoneID );
	tMsgSetMagic.set_equipslot( nSlotType );
		
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsg );
}

// 发送装备分解的回应消息
void CPropertyModule::SendResponseDecompoundEquip( CEntityPlayer *pPlayer, int nErrcode, int nEquipIndex )
{
	CMessage tMsgHead;
	CMessageDecompoundEquipResponse tMsgDecompound;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_DECOMPOUNDEQUIP );
	tMsgHead.set_msgpara( (int)&tMsgDecompound );
	
	tMsgDecompound.set_errcode( nErrcode );
	tMsgDecompound.set_equipindex( nEquipIndex );
																					
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 发送放置材料的消息回应
void CPropertyModule::SendResponseAddMaterial( CEntityPlayer *pPlayer, int nErrcode, int nBagIndex, int nPosIndex )
{
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageAddMaterialResponse tMsgAddMaterial;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDMATERIAL );
	tMsgHead.set_msgpara( (int)&tMsgAddMaterial );
	
	tMsgAddMaterial.set_errcode( nErrcode );
	tMsgAddMaterial.set_materialindex( nBagIndex );
	tMsgAddMaterial.set_posindex( nPosIndex );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 取下研究材料
void CPropertyModule::SendResponseTakeMaterial( CEntityPlayer* pPlayer, int nErrcode, int nPosIndex )
{ 
	LK_ASSERT( pPlayer != NULL, return )				
	CMessage tMsgHead;
	CMessageTakeMaterialResponse tMsgTakeMaterial;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_TAKEMATERIAL );
	tMsgHead.set_msgpara( (int)&tMsgTakeMaterial );
	
	tMsgTakeMaterial.set_errcode( nErrcode );
	tMsgTakeMaterial.set_posindex( nPosIndex );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 发送生活技能属性改变的通知
void CPropertyModule::SendNotifyLifeSkillAttribute( CEntityPlayer* pPlayer, int nLifeSkillType, int nSpecializeDegree )
{		
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsg;
	CMessageLifeSkillAttributeNotify tMsgLifeSkill;
	
	tMsg.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_LIFESKILLATTRIBUTE );
	tMsg.set_msgpara( (int)&tMsgLifeSkill );
	
	tMsgLifeSkill.set_lifeskilltype( nLifeSkillType );
	tMsgLifeSkill.set_specializedegree( nSpecializeDegree );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsg );
}

// 发送遗忘生活技能的消息回应
void CPropertyModule::SendResponseForgetLifeSkill( CEntityPlayer *pPlayer, int nErrcode, int nLifeSkillType )
{ 
	LK_ASSERT( pPlayer != NULL, return )		
	CMessage tMsg;
	CMessageForgetSkillResponse tMsgForgetSkill;
	tMsg.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_FORGETLIFESKILL );
	tMsg.set_msgpara( (int)&tMsgForgetSkill );
	
	tMsgForgetSkill.set_errcode( nErrcode );
	tMsgForgetSkill.set_lifeskilltype( nLifeSkillType );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsg );
}

// 发送放置待分解装备的回应消息
void CPropertyModule::SendResponseAddDecompoundEquipRequest( CEntityPlayer *pPlayer, int nErrcode, int nEquipIndex )
{
	
}

// 发送取下待分解装备的回应消息
void CPropertyModule::SendResponseTakerDecompoundEquipResponse( CEntityPlayer *pPlayer, int nErrcode, int nEquipIndex )
{
	
}

void CPropertyModule::OnMessageListActivityMenu( CEntityPlayer* pPlayer, CMessage* pMessage) 
{
	LK_ASSERT(pPlayer != NULL && pMessage != NULL && pMessage->msgpara() != 0, return);
	
	CMessageActivityListRequest tFactMsg;	
	tFactMsg.set_roleid(pPlayer->GetCharID());

	CMessage tMsg;
	tMsg.set_msgpara((uint32_t) &tFactMsg);
	pbmsg_sethead(&tMsg, ID_S2E_ACTIVITYLIST_REQUEST, 0, 0, 0, 0, 0, 0);
	CSceneLogic::GetSingletonPtr()->Send2Gate( &tMsg );
}

void CPropertyModule::OnMessageListActivityItem(CEntityPlayer* tpPlayer, CMessage* tpMessage)
{
	LK_ASSERT(tpPlayer != NULL && tpMessage != NULL && tpMessage->msgpara() != 0, return);

	CMessageListActivityItemRequest* tpClickMenu = (CMessageListActivityItemRequest*) tpMessage->msgpara();
	
	CMessageUserItemListRequest tFactMsg;	
	tFactMsg.set_menuid(tpClickMenu->menuid());
	tFactMsg.set_roleid(tpPlayer->GetCharID());
	tFactMsg.set_accountid(tpPlayer->GetAccountID());	
	tFactMsg.set_rolelevel(tpPlayer->GetLevel());
	tFactMsg.set_rolemetier(tpPlayer->GetMetier());

	CMessage tMsg;
	tMsg.set_msgpara((uint32_t) &tFactMsg);
	pbmsg_sethead(&tMsg, ID_S2E_USERITEMLIST_REQUEST, 0, 0, 0, 0, 0, 0);
	CSceneLogic::GetSingletonPtr()->Send2Gate( &tMsg );

	/*
	CMessageUserItemListResponse tResultMsg;
	tResultMsg.set_roleid(tpPlayer->GetCharID());
	tResultMsg.set_activityid(1509073001);

	tResultMsg.set_money(100);
	tResultMsg.set_silveryb(200);

	PBActivityItem* ppbActivityItem = tResultMsg.add_items();
	ppbActivityItem->set_itemid(36009);
	ppbActivityItem->set_itemcode("i-36009");
	ppbActivityItem->set_number(5);

	tMsg.mutable_msghead()->set_messageid( ID_E2S_USERITEMLIST_RESPONSE );
	tMsg.set_msgpara( (int)&tResultMsg );
	CGMModule::GetSingletonPtr()->OnGmMessageUserItemListResponse(&tMsg);
	*/
}

void CPropertyModule::OnMessageMinusActivityItem(CEntityPlayer* tpPlayer, CMessage* tpMessage)
{
	/*
	LK_ASSERT(tpPlayer != NULL && tpMessage != NULL && tpMessage->msgpara() != 0, return);

	CMessageMinusActivityItemRequest* tpClickItem = (CMessageMinusActivityItemRequest*) tpMessage->msgpara();

	CMessageUserItemMinusRequest tFactMsg;
	//tFactMsg.set_activityid(tpClickItem->menuid());
	tFactMsg.set_roleid(tpPlayer->GetCharID());
	tFactMsg.set_accountid(tpPlayer->GetAccountID());	

	char szItemCode[32+1];
	//snprintf(szItemCode, 32, "%d", tpClickItem->itemid());
	//tFactMsg.set_itemcode(szItemCode);

	CMessage tMsg;
	tMsg.set_msgpara((uint32_t) &tFactMsg);
	pbmsg_sethead(&tMsg, ID_S2E_USERITEMMINUS_REQUEST, 0, 0, 0, 0, 0, 0);
	CSceneLogic::GetSingletonPtr()->Send2Gate( &tMsg );
	*/	
		
	CGMModule::GetSingletonPtr()->OnMessageMinusActivityItem(tpPlayer, tpMessage);
}

void CPropertyModule::CreateHierogram( CTplHierogram* pTpl, CWTPoint* pPos, CMapObject* tpMapObj )
{
	int tEntityID = 0;
	LK_ASSERT( tpMapObj != NULL, return );

	CPedalCreator tPedal;

	tPedal.mPedalType	= PEDAL_HIEROGRAM;
	tPedal.mTempID		= pTpl->mTempID;
	tPedal.mSrcRect		= CWTRect( *pPos, *pPos );
	tPedal.mLineID		= tpMapObj->GetLineID( );
	tPedal.mMapID		= tpMapObj->GetMapID( );

	tEntityID = tpMapObj->CreateNpc( &tPedal );
}

void CPropertyModule::ProcessPKValueOnDie( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity )
{
	if ( pDesEntity == NULL )
	{
		return ;
	}
	
	// if entity die, process business of drop item
	// when process dropping item, source entity is able to be null.
	// because dead entity may kill by himself
	if ( pDesEntity->IsPlayer() && IS_GLOBAL_SCENESERVER( pDesEntity->GetLineID() ) == false )
	{
		DropItemOnPkDie( (CEntityPlayer*) pDesEntity );

		if( ( (CEntityPlayer*) pDesEntity )->IsHandle( UN_HANDLE_PROCESS_FOE_DIE ) == false )
		{
			return;
		}
		
		// if entity in yellow status, clear yellow status
		/*CPropertyPlayer* tpDieProperty = ( CPropertyPlayer* )pDesEntity->GetProperty();
		if ( tpDieProperty->GetYellowTimer() != INVALID_OBJ_ID )
		{
			CEntityPlayer* tpDesPlayer = ( CEntityPlayer* ) pDesEntity;
			
			tpDesPlayer->GetTimerReciver()->ClearTimer( tpDieProperty->GetYellowTimer() );
			tpDieProperty->SetYellowTimer( INVALID_OBJ_ID );
			
			if ( tpDesPlayer->GetPKMode() != PKMODE_ALL )
				SendYellowStateNotice( tpDesPlayer, false );
			
			return ;
		}*/
	}	

	if ( pSrcEntity == NULL )
	{
		return ;
	}	

	CEntityPlayer* tpSrcPlayer = NULL;
	CEntityPlayer* tpDesPlayer = NULL;

	if ( pSrcEntity->IsPlayer() )
	{
		tpSrcPlayer = ( CEntityPlayer* ) pSrcEntity;
	}
	else if ( pSrcEntity->IsPet() )
	{
		tpSrcPlayer = ( CEntityPlayer* ) pSrcEntity->GetOwner();
	}
	
	if ( tpSrcPlayer == NULL )
	{
		return ;
	}
	
	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) tpSrcPlayer->GetProperty();

	if ( pDesEntity->IsOgre() )
	{
		CProperty* tpProperty = ( CProperty* ) pDesEntity->GetProperty();
		CTemplateOgre* tpOgre = ( CTemplateOgre* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
		if ( tpOgre == NULL )
		{
			return ;
		}
		int tDisLevel = abs( tpSrcPlayer->GetLevel() - tpOgre->mLevel );
		if ( tDisLevel <= (int)CSceneCfgManager::GetSingleton().GetProperty_cfg()->mJusticelevellimit )
		{
			tpSrcProperty->IncreasePKValue( tpOgre->mJusticeValue );
			SendPKValueMessage( tpSrcPlayer, tpSrcProperty->GetPKValue() );
		}
	}
	else if ( pDesEntity->IsPet() )
	{
		//tpDesPlayer = ( CEntityPlayer* ) pDesEntity->GetOwner();
		return ;
	}
	else if ( pDesEntity->IsPlayer() )
	{
		tpDesPlayer = ( CEntityPlayer* ) pDesEntity;
	}
	
	if ( tpDesPlayer == NULL )
	{
		return ;
	}

	if ( tpSrcPlayer->GetEntityID() == tpDesPlayer->GetEntityID() )
	{
		return ;
	}
	
	if( tpSrcPlayer->IsHandle( UN_HANDLE_PROCESS_FOE_DIE ) == false )
	{
		return;
	}

	if ( tpSrcPlayer->GetNationality() == tpDesPlayer->GetNationality() )
	{
		// 杀了本国人
		tpSrcProperty->SetKillSameNationNum( tpSrcProperty->GetKillSameNationNum()+1 );
	}

	CFriendModule::GetSingleton().OnPlayerBeKilled( tpSrcPlayer, tpDesPlayer );

	CPropertyPlayer* tpDesProperty = ( CPropertyPlayer* ) tpDesPlayer->GetProperty();

	// need not to process pk value between of diff nation
	if ( tpSrcPlayer->GetNationality() != tpDesPlayer->GetNationality() )
	{
		return ;
	}			

	// if des entity is in yellow status, pk value not change
	if ( tpDesProperty->GetYellowStatus() )
	{
		return ;
	}		

	// sb国王天子随便杀人
	if ( tpSrcPlayer->GetCountryID() == tpDesPlayer->GetCountryID() 
		&& CWorldModule::GetSingleton().IsKing( tpSrcPlayer->GetCharID(), tpSrcPlayer->GetNationality(), tpSrcPlayer->GetCountryID() ) == true )
	{
		return;
	}

	if ( CWorldModule::GetSingleton().IsKing( tpSrcPlayer->GetCharID(), tpSrcPlayer->GetNationality(), COUNTRY_CHANGAN ) == true )
	{
		return;
	}

	CTplPKValueTable* tpTplTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTplTable == NULL )
	{
		return ;
	}		

	if ( tpDesProperty->IsWhitePKStatus()  )
	{
		int tIndex = 0, tPkValue = 0;
		int tDisLevel = tpSrcPlayer->GetLevel() - tpDesPlayer->GetLevel();
		
		if( tDisLevel <= 0 ) 
			tPkValue = tpTplTable->mBasePKValue;
		else
		{
			tIndex = tDisLevel / 10;
			if ( tIndex < PRODUCE_LEVEL && tIndex >= 0 )
				tPkValue = tpTplTable->mPKValueLevel[ tIndex ] + tpTplTable->mBasePKValue;
			else 
				tPkValue = tpTplTable->mBasePKValue;
		}

		tpSrcProperty->IncreasePKValue( 0 - tPkValue );
		SendPKValueMessage( tpSrcPlayer, tpSrcProperty->GetPKValue() );			
	}
	return ;
}

void CPropertyModule::ProcessPKValueOnAttack( CEntityCharacter* pSrcEntity, CEntityCharacter* pDesEntity )
{
	if ( pSrcEntity == NULL || pDesEntity == NULL )
	{
		return ;
	}	

	CEntityPlayer* tpSrcPlayer = NULL;
	CEntityPlayer* tpDesPlayer = NULL;

	if ( pSrcEntity->IsPlayer() )
	{
		tpSrcPlayer = ( CEntityPlayer* ) pSrcEntity;
	}	
	else if ( pSrcEntity->IsPet() )
	{
		tpSrcPlayer = ( CEntityPlayer* ) pSrcEntity->GetOwner();
	}
	
	if ( pDesEntity->IsPlayer() )
	{
		tpDesPlayer = ( CEntityPlayer* ) pDesEntity;
	}
	else if ( pDesEntity->IsPet() )
	{
		tpDesPlayer = ( CEntityPlayer* ) pDesEntity->GetOwner();
	}	
	
	if ( tpSrcPlayer == NULL || tpDesPlayer == NULL )
	{
		return ;
	}	

	if ( tpSrcPlayer->GetNationality() != tpDesPlayer->GetNationality() )
	{
		if ( tpSrcPlayer->GetNationality() == CSceneLogic::GetSingleton().GetLineID() )
		{
			if ( tpSrcPlayer->GetProtectStatus() == true )
			{
				CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( tpSrcPlayer->GetMapID() );
				if ( tpMapTpl != NULL && tpSrcPlayer->GetLevel() < tpMapTpl->mProtectLevel )
				{
					tpSrcPlayer->SetProtectStatus( false );
					tpSrcPlayer->InitFunResult( );
					tpSrcPlayer->AddFunResult( tpSrcPlayer->GetEntityID(), FUNC_CHANGEPROTECT, RESULT_NONE, true, tpSrcPlayer->GetProtectStatus() );
					ResultListSend( );
					int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY, 0, 0, 0};
					tpSrcPlayer->GetTimerReciver()->SetTimer( tpSrcPlayer->get_id(), TIMER_NATION_PROTECT, PROTECT_TIME, 1, nTimerOtherInfo );
				}				
			}	
			else
			{
				tpSrcPlayer->GetTimerReciver()->ClearTimer( TIMER_NATION_PROTECT );
				int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY, 0, 0, 0};
				tpSrcPlayer->GetTimerReciver()->SetTimer( tpSrcPlayer->get_id(), TIMER_NATION_PROTECT, PROTECT_TIME, 1, nTimerOtherInfo );
			}
		}
		return ;
	}

	if ( tpSrcPlayer->GetEntityID() == tpDesPlayer->GetEntityID() )
	{
		return ;
	}

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) tpSrcPlayer->GetProperty();
	CPropertyPlayer* tpDesProperty = ( CPropertyPlayer* ) tpDesPlayer->GetProperty();

	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		return ;
	}

	if( tpSrcPlayer->IsHandle( UN_HANDLE_PROCESS_FOR_ATTACK ) == false )
	{
		return;
	}

	if ( tpSrcProperty->IsRedPKStatus() == false && tpDesProperty->IsWhitePKStatus() && tpSrcPlayer->GetNationality() == tpDesPlayer->GetNationality() )
	{
		tpSrcPlayer->GetTimerReciver()->ClearTimer( tpSrcProperty->GetYellowTimer() );
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = {MESSAGE_PROPERTY,0,0,0};
		int tTimerID = tpSrcPlayer->GetTimerReciver()->SetTimer( tpSrcPlayer->get_id(), TIMER_YELLOWNAME, tpTable->mYellowTime * 1000, 1, nTimerOtherInfo );
		tpSrcProperty->SetYellowTimer( tTimerID );
		if ( tpSrcPlayer->GetPKMode() != PKMODE_ALL && tpSrcPlayer->GetPKMode() != PKMODE_CORPS )
			SendYellowStateNotice( tpSrcPlayer, true );		
	}
		
	return ;	
}

// 红名PK死亡，损失经验 [11/23/2009 Macro]
void CPropertyModule::DecExpOnPkDie(CEntityPlayer *pPlayer)
{
	if ( pPlayer == NULL )
	{
		return ;
	}

	CTemplateLevelExp* tpLevelExp = (CTemplateLevelExp*) CDataStatic::GetTemp( TEMP_LEVELEXP );
	if ( tpLevelExp == NULL )
	{
		return ;
	}

	CTplPKValueTable* tpPKTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpPKTable == NULL )
	{
		LOG_ERROR( "pro", "get template point failed.[%s:%d]", __LK_FILE__, __LINE__ );
		return ;
	}

	// 升级到下一级所需经验
	int tTotalExp = tpLevelExp->mLevelExp[ pPlayer->GetLevel() ];
	int tDisExp = 0;	// 经验差

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	EPKStatus tPkStatus = tpProperty->GetTplPKState();

	switch ( tPkStatus )
	{
		// 浅红色
	case PKSTATUS_ROSINESS:
		{
			tDisExp = tTotalExp * tpPKTable->mDecExpRate[ 0 ];
			break;
		}
		// 红色
	case PKSTATUS_RED:
		{
			tDisExp = tTotalExp * tpPKTable->mDecExpRate[ 1 ];
			break;
		}
		// 深红色
	case PKSTATUS_CARMINE:
		{
			tDisExp = tTotalExp * tpPKTable->mDecExpRate[ 2 ];
			break;
		}
		// 邪恶上限
	case PKSTATUS_PKTOPLIMIT:
		{
			tDisExp = tTotalExp * tpPKTable->mDecExpRate[ 3 ];
			break;
		}
	default:
		break;
	}

	int tTopLimit = 0;
	tTopLimit = tpPKTable->mTopLimitDecExp[ pPlayer->GetLevel() ];
	if ( tTopLimit <= 0 )
	{
		return ;
	}

	tDisExp = std::min( tDisExp, tTopLimit );
	
	//TODO: 现在不支持对人物减少经验
	// 减经验
	return ;
}

//************************************
// Method:    RefreshPkValue
// FullName:  CPropertyModule::RefreshPkValue
// Access:    public 
// Returns:   void
// Qualifier: 在线更新个人pk值, made by 高宏
// Parameter: CEntityPlayer * npPlayer
// Parameter: int nTickOffset  毫秒数
//************************************
void CPropertyModule::RefreshPkValue( CEntityPlayer* npPlayer, int nTickOffset )
{	
	if ( npPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();

	// pk值已经是正值，就不需要再刷新
	if ( tpProperty->GetPKValue() >= 0 )
	{
		return ;
	}

	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		return ;
	}	

	tpProperty->IncreasePKValue( std::max( 1, (int)(tpTable->mDecValue/(60*60)) * (nTickOffset/1000) ) );
	SendPKValueMessage( npPlayer, tpProperty->GetPKValue() );		

	// confirm you are in the prison map
	if ( npPlayer->GetMapID() == tpTable->mMapID )
	{
		// 一次增 N ms
		tpProperty->IncPrisonTime( nTickOffset );

		// 兼容上版本total prison time
		if ( tpProperty->GetPrisonTime() > tpProperty->GetTotalPrisonTime() 
			&& tpProperty->GetTotalPrisonTime() >= 0 )
		{
			bool bTeleRes = false;
			bTeleRes = CMapModule::GetSingleton().Teleport( npPlayer->GetLineID(), tpTable->mFreeMapID, tpTable->mFreePosX, tpTable->mFreePosY, npPlayer );
			if ( bTeleRes )
			{
				tpProperty->SetPKValue( 0 );
				SendPKValueMessage( npPlayer, 0 );
				tpProperty->SetPrisonTime( 0 );
				tpProperty->SetTotalPrisonTime( 0 );
			}
		}
	}

	return ;
}

void CPropertyModule::RefreshApValue(CEntityPlayer *vpPlayer)
{
	if ( vpPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();

	CTplApConfig* tpConfig = ( CTplApConfig* ) CDataStatic::GetTemp( TEMP_APCONFIG );
	if ( tpConfig == NULL )
	{
		return ;
	}

	if ( vpPlayer->IsAlive() == false )
	{
		return ;
	}

	// 先自动回复活力
	for ( int i = 0; i < MAX_METIER; i ++ )
	{
		if ( tpConfig->mMetierAp[ i ].mMetier != vpPlayer->GetMetier() && vpPlayer->GetMetier() != 0 )
			continue;
		if ( tpProperty->GetCurAP() == ( unsigned int )tpProperty->GetMaxAP() )
			break;
		vpPlayer->CureAP( tpConfig->mMetierAp[ i ].mAp, vpPlayer->GetEntityID() );
		break;
	}

	// 如果是会员，不扣活力值
	if ( tpProperty->IsVip() )
	{
		return ;
	}

	// 活力值是否够挂机
	if ( tpProperty->GetAutoPlayFlag() )
	{
		int tDecValue = tpConfig->mConsumeHook / 20;
		if ( (int)tpProperty->GetCurAP() < tDecValue )
		{
			CMessage tMessage;
			CMessageOperateAutoHookResponse tPara;
			tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_AUTOHOOK );
			tMessage.set_msgpara( (long) &tPara );
			tPara.set_action( (int)false );
			tPara.set_rtncode( SUCCESS );
			CSceneLogic::GetSingleton().Send2Player( vpPlayer, &tMessage );

			tpProperty->SetAutoPlayFlag( false );
		}
		else
		{
			int tAp = tpProperty->GetCurAP();
			tAp = std::max( 0, ( tAp - tDecValue ) );
			tpProperty->SetCurAP( tAp );
		}
	}

	if ( vpPlayer->CanFly() )
	{
		CTplItemHorse *tplHorse = (CTplItemHorse*)CDataStatic::SearchTpl( tpProperty->GetHorseTempID( ) );
		if ( tplHorse != NULL )
		{
			int tAp = tpProperty->GetCurAP();
			tAp = std::max( 0, ( tAp - tplHorse->mDeltaAP ) );
			tpProperty->SetCurAP( tAp );
			if ( (int)(tpProperty->GetCurAP()) < tplHorse->mDeltaAP )
			{
				// 活力没了不下马
				//tpProperty->OffHorse( tplHorse->mSpeedBuff );
			}
		}		
	}
}

void CPropertyModule::SendPKValueMessage(CEntityPlayer *pPlayer,int nValue)
{
	if ( pPlayer == NULL )
	{
		return ;
	}	

	// 瞎他妈写
	/*if ( nValue == 0 )
	{
		return ;
	}*/
	
	pPlayer->AddFunResult( 0, FUNC_PKVALUE, RESULT_NORMAL, true, nValue );
	ResultListSend( );
	

	// 向网关发送数据
	CCommandSendPlayerDirtyDataToGate tSendToGate( pPlayer->GetEntityID() );
	tSendToGate.OnEventTrigger( CCommandSendPlayerDirtyDataToGate::DIRTYDATA_RED );
	return ;
}

void CPropertyModule::SendYellowStateNotice(CEntityPlayer *pPlayer, bool bOpen)
{
	if ( pPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	tpProperty->SetYellowStatus( bOpen );
	
	CMessage tMessage;
	CMessageYellowStateNotify tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_YELLOWSTATE );
	tPara.set_entityid( pPlayer->GetEntityID() );
	tPara.set_state( (int) bOpen );
	tMessage.set_msgpara( (long) &tPara );

	CMapModule::GetSingleton().MessageBroadCast( pPlayer, &tMessage, false, true );
	return ;
}

//***********************************
// FunctionName : DropItemOnPkDie 
// Description  : 
// Input Params : 
// Output Params: 
// Return Types : 
// Modified Time: [6/24/2009]
//***********************************

int CPropertyModule::DropItemOnPkDie(CEntityPlayer *pPlayer)
{
	if ( pPlayer == NULL )
	{
		return -1;
	}

	if( pPlayer->IsHandle( UN_HANDLE_DROP_FOE_DIE ) == false )
	{
		return SUCCESS;
	}
	
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	// 非红名状态不处理 [12/7/2009 Macro]
	if ( tpProperty->IsRedPKStatus() == false )
	{
		return -1;
	}

	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		LOG_ERROR( "pro", "pk config template error.[%s:%d]", __LK_FILE__, __LINE__ );
		return -1;
	}

	EPKStatus tPkStatus = tpProperty->GetTplPKState();
	
	int tIndex = 0;
	for ( ; tIndex < (int) ARRAY_CNT( tpTable->mDrop ); tIndex ++ )
	{
		if ( (EPKStatus)tpTable->mDrop[ tIndex ].mState == tPkStatus )
		{
			// 遍历确认红名阶段
			break;
		}				
	}

	int tRandom = RAND( SERVER_PERCENT_INT * 2 );
	
	if ( tRandom < SERVER_PERCENT_INT )
	{	
		// 处理掉道具
		if ( tRandom < tpTable->mDrop[ tIndex ].mEquipDropRate )
		{
			DropEquip( pPlayer );
		}
		if ( tRandom < tpTable->mDrop[ tIndex ].mBagDropRate1 )
		{
			if ( tRandom < tpTable->mDrop[ tIndex ].mBagDropRate2 )
			{
				DropItem( pPlayer, 2 );
			}
			else
			{
				DropItem( pPlayer, 1 );
			}
		}
	}
	else
	{
		// 处理传进监狱
		tRandom -= SERVER_PERCENT_INT;
		
		if ( tRandom < tpTable->mDrop[ tIndex ].mGoPrisonRate )
		{
			bool bTeleRes = false;
			int tPrisonTime = tpProperty->GetPrisonTime( );
			int tTotalPrisonTime = tpProperty->GetTotalPrisonTime( );
			// set prison time as zero, begin to increase the time
			tpProperty->SetPrisonTime( 0 );
			tpProperty->SetTotalPrisonTime( tpTable->mDrop[ tIndex ].mPrisonTime );
			bTeleRes = CMapModule::GetSingleton().Teleport( pPlayer->GetNationality(), tpTable->mMapID, tpTable->mPosX, tpTable->mPosY, pPlayer );
			if ( bTeleRes )
			{
				SendPrisonTimeNotice( pPlayer,  tpTable->mDrop[ tIndex ].mPrisonTime );
			}
			else
			{
				tpProperty->SetPrisonTime( tPrisonTime );
				tpProperty->SetTotalPrisonTime( tTotalPrisonTime );
			}
			CTemplateBuff *tplBuff = (CTemplateBuff*)CDataStatic::SearchTpl( tpTable->mPrisonBuffID );
			if (tplBuff !=NULL )
			{
				pPlayer->EntityInsertBuff( pPlayer, tplBuff );
			}
			
		}		
	}
	
	return SUCCESS;
}

//***********************************
// FunctionName : DropEquip 
// Description  : drop equip on entity
// Input Params : entity pointer
// Output Params: 
// Return Types : process result
// Modified Time: [6/24/2009]
//***********************************
int CPropertyModule::DropEquip(CEntityPlayer *pPlayer)
{
	if ( pPlayer == NULL )
	{
		return -1;
	}
	
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	CEquipment* tpEquips = tpProperty->GetEquipment();
	if ( tpEquips == NULL )
	{
		return -1;
	}
		
	unsigned int tIndex = 0, tEquipIndex = 0;
	int tEquipArray[ MAXEQUIPMENTINDEX ] = { 0 };
	for ( int i = 0; i < MAXEQUIPMENTINDEX && tEquipIndex < (int) ARRAY_CNT( tEquipArray ); i ++ )
	{
		CItemEquipment* tpEquipItem = ( CItemEquipment* )tpEquips->GetItemObjPtr( i );
		if ( tpEquipItem == NULL )
		{
			continue;
		}
		
		if ( tpEquipItem->GetLockStatus() != LOCKTYPE_NONE )
		{
			continue;
		}

		if ( tpEquipItem->GetBindStatus() != ITEM_BINDSTATUS_FREE  )
		{
			continue;
		}		
		
		// record all equips' index beyond in required scope
		tEquipArray[ tEquipIndex ++ ] = i; 
	}

	if ( tEquipIndex == 0 )
	{
		// no equip to be dropped
		return SUCCESS;
	}
		
	bool bCanDrop = false;
	int tReleaseIndex = tpProperty->GetBaggage()->mReleaseIndex;
	for ( int j = 0; j < tReleaseIndex; j ++ )
	{
		CItemObject* tpObj = tpProperty->GetBaggage()->GetItemObjPtr( j );
		if ( tpObj == NULL )
		{
			tIndex = j;
			bCanDrop = true;
			break;
		}			
	}
	
	// TODO:包裹背包的检索

	if ( bCanDrop )
	{
		unsigned short tPart = tEquipArray[ RAND( tEquipIndex ) ];
		UnEquipItem( pPlayer, tPart, tIndex );
		PlayerThrowItem( pPlayer, tIndex, 1 );
	}	

	return SUCCESS;
}

//***********************************
// FunctionName : DropItem 
// Description  : drop item on entity
// Input Params : 
// Output Params: 
// Return Types : int
// Modified Time: [6/24/2009]
//***********************************

int CPropertyModule::DropItem(CEntityPlayer *pPlayer, int vNum)
{
	if ( pPlayer == NULL || vNum == 0 )
	{
		return -1;
	}
	
	int tDropNum = 0;
	int tItemArray[ BAGGAGE_BASE ] = { 0 };
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	for ( int i = 0; i < (int)tpProperty->GetBaggage()->mReleaseIndex && 
		tDropNum < (int)ARRAY_CNT( tItemArray ); i ++ )
	{
		CItemObject* tpObj = tpProperty->GetBaggage()->GetItemObjPtr( i );
		if ( tpObj == NULL )
		{
			continue;
		}

		if ( tpObj->GetLockStatus() != LOCKTYPE_NONE )
		{
			continue;
		}		 
		
		if ( tpObj->GetBindStatus() != ITEM_BINDSTATUS_FREE )
		{
			continue;
		}
		
		tItemArray[ tDropNum ++ ] = i;	
	}	

	if ( tDropNum == 0 )
	{
		// no item to be dropped
		return SUCCESS;
	}	

	int tArrIdx = RAND( tDropNum );
	int tIndex = tItemArray[ tArrIdx ];
	CItemObject* tpItem = tpProperty->GetBaggage()->GetItemObjPtr( tIndex );
	if ( tpItem == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_ITEM_DATANOTEXIST );
		return -1;
	}
	PlayerThrowItem( pPlayer, tIndex, tpItem->GetItemNum() );	

	// maintain array of item index
	tItemArray[ tArrIdx ] = tItemArray[ tDropNum - 1 ];
	
	if ( vNum == 2 && tDropNum > 1 )
	{
		// pick up another item to drop it randomly
		int tConIndex = tItemArray[ RAND( tDropNum - 1 ) ];
		CItemObject* tpAnotherItem = tpProperty->GetBaggage()->GetItemObjPtr( tConIndex );
		if ( tpAnotherItem == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_ITEM_DATANOTEXIST );
			return -1;
		}
		PlayerThrowItem( pPlayer, tConIndex, tpAnotherItem->GetItemNum() );
	}	

	return SUCCESS;
}

//***********************************
// FunctionName : OnUseItemCall
// Description  : 使用召唤物品
// Input Params : 玩家pEntity,道具tpItem,包裹索引vIndex
// Output Params: 
// Return Types : 
// Modified Time: [6/26/2009]
//***********************************

int CPropertyModule::OnUseItemCall(CEntity *pEntity, CTplItem *tpItem, int vIndex)
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}

	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}

	CEntityPlayer* tpPlayer = ( CEntityPlayer* ) pEntity;
	CTplItemCall* tpCall    = ( CTplItemCall* ) tpItem;

	if ( tpCall->mLmtMapID != 0 ) // 开启使用区域检查
	{
		if ( tpPlayer->GetMapID() != tpCall->mLmtMapID )
		{
			//SendProErrorNotice( tpPlayer, ERROR_OUTOFRANGE );
			return ERROR_OUTOFRANGE;
		}
		else if ( (!(tpCall->mLmtX == -1 && tpCall->mLmtY == -1)) && (!( tpPlayer->GetPosX() >= tpCall->mLmtX - tpCall->mLmtWide/2 && tpPlayer->GetPosX() <= tpCall->mLmtX + tpCall->mLmtWide/2 
			&& tpPlayer->GetPosY() >= tpCall->mLmtY - tpCall->mLmtHeight/2 && tpPlayer->GetPosY() <= tpCall->mLmtY + tpCall->mLmtHeight/2 ) ) )
		{
			//SendProErrorNotice( tpPlayer, ERROR_OUTOFRANGE );
			return ERROR_OUTOFRANGE;
		}
	}

	CWTPoint tPos;
	if ( tpCall->mX == -1 || tpCall->mY == -1 ) // 在身边刷
	{
		tPos = tpPlayer->GetPos();
	}
	else
	{
		tPos.mX = tpCall->mX;
		tPos.mY = tpCall->mY;
	}

	CTemplateNpc* tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( tpCall->mCallNpcID );
	LK_ASSERT( tpNpc != NULL, return -1 );
	CreateNpc( tpPlayer, tpCall->mCallNpcID, ENTITYTYPE_FUNCNPC, tPos, 1000*tpNpc->mLifeTime, true, false, tpCall->mMapID, 1 );

	if ( tpCall->mIsDestroy == 1 )
	{
		uint64_t ullGUID = 0;
		if ( PlayerRemoveItem( tpPlayer, vIndex, 1, &ullGUID, true) == 0)
		{
			LogEventLostItemByUse(tpPlayer, ullGUID, tpCall->mTempID, 1);
		}
	}
	return 0;
}


//***********************************
// FunctionName : OnUseItemSkill
// Description  : 使用技能类物品
// Input Params : 玩家pEntity,道具tpItem,包裹索引vIndex
// Output Params: 
// Return Types : 
// Modified Time: [6/26/2009]
//***********************************

int CPropertyModule::OnUseItemSkill(CEntity *pEntity, CTplItem *tpItem, int vIndex)
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return -1;
	}

	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}

	CEntityPlayer* tpPlayer  = ( CEntityPlayer* ) pEntity;
	CTplItemSkill* tpTplItem = ( CTplItemSkill* ) tpItem;

	switch( tpTplItem->mOprType )
	{
	case TYPE_ADDBUFF2SENDNPC:
		{
			CEntityNpc* pEntityNpc = CTaskModule::GetSingleton().GetCurSendNpc(tpPlayer);
			if ( pEntityNpc == NULL )
			{
				SendProErrorNotice( tpPlayer, ERROR_NOSENDNPC );
				return ERROR_NOSENDNPC;
			}
			else
			{
				if ( InsertBuff( pEntityNpc, tpTplItem->mBuffID ) )
				{
					uint64_t ullGUID = 0;
					if (PlayerRemoveItem( tpPlayer, vIndex, 1, &ullGUID) == 0) 
					{
						LogEventLostItemByUse(tpPlayer, ullGUID, tpItem->mTempID, 1);
					}
				}
			}
			break;
		}
	case TYPE_REMOVEBUFF2SENDNPC:
		{
			CEntityNpc* pEntityNpc = CTaskModule::GetSingleton().GetCurSendNpc(tpPlayer);
			if ( pEntityNpc == NULL )
			{
				SendProErrorNotice( tpPlayer, ERROR_NOSENDNPC );
				return ERROR_NOSENDNPC;
			}
			else
			{
				int tRet = RemoveBuff( pEntityNpc, tpTplItem->mBuffID );
				if ( tRet == SUCCESS )
				{
					uint64_t ullGUID = 0;
					if (PlayerRemoveItem( tpPlayer, vIndex, 1, &ullGUID) == 0)
					{
						LogEventLostItemByUse(tpPlayer, ullGUID, tpItem->mTempID, 1); 
					}
				}
				else
				{
					SendProErrorNotice( tpPlayer, tRet );
					return tRet;
				}
			}
			break;
		}
	}

	return 0;
}

// 每周一0点要处理的事情(不在线 则在下次上线的时候自动处理)
int CPropertyModule::WeeklyDispose( CEntityPlayer* pPlayer, bool bIsOnline )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	if (!bIsOnline)
	{
		if ( !IsANewWeek((time_t)pProperty->GetLastWeeklyDisposTime(), time(0)) )
			return -1;
	}
	pProperty->SetDiploid( LK_ZERO );
	pProperty->SetLastRefreshTime( (int) time(NULL) );
	pProperty->GetRepetion( )->CleanWeekRepetion( );

	// (因为涉及到排行榜 只有新上线的才清除 否则由活动模块清除) 已经移到活动模块
	//if (!bIsOnline)
	//{
	//	if ( pProperty->GetLastWeekIncCharm() == 0 ) // 加判断是为了防止重复设置
	//	{
	//		pProperty->SetLastWeekIncCharm(pProperty->GetWeekIncCharm());
	//	}
	//	pProperty->SetWeekIncCharm(0);
	//}

	// 清空当周领取
	pProperty->ClearAwardTimes(EALT_Weekly);

	// 清空每日声望
	pProperty->mWizard.SetCombatToday( 0 );
	pProperty->mWizard.SetRepeToday( 0 );
	pProperty->mWizard.SetCommonToday( 0 );

	//pProperty->SetLastWeeklyDisposTime(time(0));(外面赋值过了)
	return 0;
}

// 新一天来的时候 处理(不在线 则在下次上线的时候自动处理)
int CPropertyModule::DaylyDispose( CEntityPlayer* pPlayer, bool bIsOnline )
{
	CPropertyPlayer* tpProPlayer = (CPropertyPlayer*) pPlayer->GetProperty();

	if (!bIsOnline)
	{
		if ( !IsANewDay((time_t)tpProPlayer->GetLastDaylyDisposTime(), time(0)) )
			return -1;
	}
	
	CTemplateBeginner* tpBeginner = ( CTemplateBeginner* ) CDataStatic::GetBeginner();
	if ( tpBeginner != NULL )
	{
		if ( IsANewDay((time_t)tpProPlayer->GetLastRefreshAPTime(), time(0)) )
		{
			tpProPlayer->SetCurAP( ( unsigned int )tpProPlayer->GetMaxAP() );
			//tpProPlayer->SetLastRefreshAPTime( time( NULL ) );
		}		
	}
	// 清空当天的杀敌数
	tpProPlayer->SetTodayKillEnemyNumIn(0);
	tpProPlayer->SetTodayKillEnemyNumOut(0);

	// 清空今日功勋
	tpProPlayer->SetTodayHonor(0);
	tpProPlayer->SetTodayWar(0);
	tpProPlayer->SetWarKill(0);
	tpProPlayer->SetExpHonor(0);
	tpProPlayer->SetItemHonor(0);

	// 清空今日投票
	tpProPlayer->SetHasVoted(0);

	// 清空今日领取
	tpProPlayer->ClearAwardTimes();
	//tpProPlayer->SetLastDaylyDisposTime(time(0));(外面赋值过了)

	// 重新缓存今日指引信息
	int tAchiveID = CAchieveModule::GetSingleton().GetAchieveDataUnit(pPlayer->GetCharID());
	CAchieveDataUnit* tpAchive = (CAchieveDataUnit*)CSceneObjManager::GetSingleton().GetObject(tAchiveID);
	if (tpAchive != NULL)
	{
		tpProPlayer->GetGuideData()->mAchiveBak = tpAchive->GetTotalPoint();
	}
	tpProPlayer->GetGuideData()->mExpBak = tpProPlayer->GetExp();
	tpProPlayer->GetGuideData()->mHonorBak = tpProPlayer->GetHonor();
	tpProPlayer->GetGuideData()->mKillBak = tpProPlayer->GetKillNumIn()+tpProPlayer->GetKillNumOut();
	tpProPlayer->GetGuideData()->mLevelBak = pPlayer->GetLevel();

	// 清空送花次数数据
	unsigned int tKey = CPersonalTimesMgr::MakeKey(TIMESMGR_USEFLOWER, 0);
	tpProPlayer->GetTimesMgr()->SetTimes( tKey, 0 );
	//tKey = CPersonalTimesMgr::MakeKey(TIMESMGR_USEGIFT, 0);
	//tpProPlayer->GetTimesMgr()->SetTimes( tKey, 0 );

	CTemplateCountTable *tpCountTable = (CTemplateCountTable*)CDataStatic::GetTemp( TEMP_COUNT );
	if ( tpCountTable != NULL )
	{
		for( int i = 1; i < MAX_COUNT_NUM; ++i )
		{
			if ( tpCountTable->mCountData[i].mCountType == 0 )
			{
				break;
			}
			if ( tpCountTable->mCountData[i].mClearType == 1 ) // 暂时写死 以后用枚举
			{
				tKey = CPersonalTimesMgr::MakeKey(tpCountTable->mCountData[i].mCountType, 0);
				tpProPlayer->GetTimesMgr()->SetTimes( tKey, 0 );
			}
		}
	}


	// 副本处理	
	CRepetionModule::GetSingletonPtr( )->CleanRepetion( tpProPlayer );

	// 清除活动状态 目前只有在线送好礼会清除
	for ( ACTIVITYINFO_TYPE::iterator it = tpProPlayer->mActivityInfo.mStates.begin(); it != tpProPlayer->mActivityInfo.mStates.end(); ++it )
	{
		if ( it->first == HELPID_ONLINEGIFT )
		{
			tpProPlayer->mActivityInfo.mStates.erase(it->first);
			break;
		}
	}	

	// 处理绝对过期时间物品
	CheckItemInvilidDate( pPlayer, bIsOnline );

	return 0;
}

// 法宝：增加法宝经验接口
// 传入：玩家指针 经验
// 返回：0 成功
int CPropertyModule::OnMagicWeaponObtainExp( CEntityPlayer* pPlayer, int nExp, bool bIsPile /*= false*/ )
{
	LK_ASSERT( pPlayer != NULL, return -1 );
	if ( nExp <= 0 )
		return -2;
	// 先获得当前是不是装备法宝了
	CPropertyPlayer* pPro = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemMagicWeapon* tpMW = (CItemMagicWeapon*)pPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
	if ( tpMW == NULL )
		return -3;

	bool tLevelUp = false;

	if ( tpMW->GetMWLevel() >= MAX_MAGICWEAPON_GRADE || tpMW->GetMWLevel() >= pPlayer->GetLevel()
		|| tpMW->GetMWLevel() >= MAGICWEAPON_MAX_GRADE )
		return -4;

	tpMW->SetExp( tpMW->GetExp( ) + nExp );

	// 升的级数
	int tUpLevel = 0;
	CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl( tpMW->GetItemID() );
	LK_ASSERT( tpItemMW!=NULL, return -1 );
	CTplMagicWeaponProIncTable* tpLevelExp = (CTplMagicWeaponProIncTable*)CDataStatic::SearchTpl(tpItemMW->mLevelTableID);
	LK_ASSERT( tpLevelExp != NULL, return -1 );

	while ( tpMW->GetExp( ) >= tpLevelExp->mValues[ tpMW->GetMWLevel( ) ].mLevelExp
		&& tpMW->GetMWLevel( ) < MAX_MAGICWEAPON_GRADE )
	{
		tpMW->SetExp( tpMW->GetExp( ) - tpLevelExp->mValues[ tpMW->GetMWLevel( ) ].mLevelExp );
		tpMW->LevelUp();
		// 激活新技能框 返回数量
		int tNextActIndex = -1;
		int tActNum = tpMW->OnActiveNewSkillBox( tNextActIndex );
		if ( tActNum > 0 )
		{
			CMessageActiveSkillBoxNotify msg;
			for( int i = 0; i < tActNum; ++i )
			{
				msg.add_index( tNextActIndex+i );
			}
			CMessage   tMessage;
			tMessage.set_msgpara((uint32_t) &msg);
			tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_ACTIVESKILLBOX);
			CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		}
		// 升级领悟新技能
		unsigned char tIndexs[SKILL_BOX_LMT] = {-1};
		int tLearnNum = tpMW->OnSelfLearnSkill( tIndexs );
		if ( tLearnNum > 0 ) //领悟到新技能了 还要刷新属性~~
		{
			for ( int i = 0; i < tLearnNum; ++i )
			{
				CMessageInsertSkillNotify msg;
				int tSkillID = 0;
				int tSkillLevel = 0;
				int tActedNum = 0;
				int tBookID = 0;

				tpMW->GetSkillBaseInfo( tIndexs[i], tSkillID, tSkillLevel, tActedNum, tBookID );

				// 设置消息
				msg.set_index(tIndexs[i]);
				msg.set_skillid( tSkillID );
				msg.set_curlevel(tSkillLevel);
				msg.set_reason(GETSKILL_LEARN); 
				msg.set_actednum(tActedNum);
				msg.set_bookid( tBookID );
				msg.set_bagindex(-1);

				CMessage   tMessage;
				tMessage.set_msgpara((uint32_t) &msg);
				tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_INSERTSKILL);
				CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
			}
		}

		tLevelUp = true; 
		tUpLevel++;
		//tpMW->SetExp( 0 ); // 一次只能升1级！
		if (!bIsPile) // 非吃丹的 一次只能升一级
		{
			tpMW->SetExp( 0 );
			break;
		}
	}

	if ( tLevelUp == true ) // 升级了  要刷新全部属性
	{
		// 法宝属性已刷新 通知客户端
		NotifyRefreshMagicWeaponProperty( pPlayer, -1 );
		// 刷新人
		RefreshPlayerProperty( pPlayer );
		// 通知
		SendProErrorNotice( pPlayer, ERROR_MW_LEVELUP );
	}
	else
	{
		NotifyRefreshMagicWeaponProperty( pPlayer, MAGIC_WEAPON_EXP, -1 );
	}

	// 如果是用丹升级的 则单独通知客户端
	if (bIsPile)
	{
		CMessageMWObtainExpNotify msg;
		msg.set_expval(nExp);
		CMessage   tMessage;
		tMessage.set_msgpara((uint32_t) &msg);
		tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_MWOBTAINEXP);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
	}

	// 记录日志
	LogEventGetMWExpByDefault(pPlayer, tpMW, nExp);

	return 0;
}

// 通知刷新法宝属性数值
void CPropertyModule::NotifyRefreshMagicWeaponProperty( CEntityPlayer* pPlayer, int nBagIndex )
{
	LK_ASSERT( pPlayer != NULL, return  );

	// 先获得当前是不是装备法宝了
	CPropertyPlayer* pPro = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemMagicWeapon* tpMW = NULL;
	if ( nBagIndex == -1 )
		tpMW = (CItemMagicWeapon*)pPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
	else
		tpMW = (CItemMagicWeapon*)pPro->GetBaggage()->GetItemObjPtr( nBagIndex );

	if ( tpMW == NULL )
		return ;

	CMessageMagicWeaponRefreshValueNotify msg;
	msg.set_mwlevel( tpMW->GetMWLevel() );
	msg.set_exp( tpMW->GetExp() );
	msg.set_mp( tpMW->GetMp() );
	msg.set_hp( tpMW->GetHp() );
	msg.set_curkeenpoints( tpMW->GetKeenpoints() );
	msg.set_curcalmpoints( tpMW->GetCalmpoints() );
	msg.set_curmagicpoints( tpMW->GetMagicpoints() );
	msg.set_curbierpoints( tpMW->GetBierpoints() );
	msg.set_curimmortalpoints( tpMW->GetImmortalpoints() );
	msg.set_leftpoints( tpMW->GetLeftPoints() );
	msg.set_prospir( tpMW->GetProSpir() );
	msg.set_processval( tpMW->GetProcessVal() );
	msg.set_leftskillpoints( tpMW->GetLeftSkillPoints() );
	msg.set_incmp( tpMW->GetIncMp() );
	msg.set_inchp( tpMW->GetIncHp() );
	msg.set_probase( tpMW->GetProBase() );
	msg.set_proup( tpMW->GetProUp() );
	msg.set_proeff( tpMW->GetProEff() );
	msg.set_maxmp( tpMW->GetMaxMp() );
	msg.set_maxhp( tpMW->GetMaxHp() );
	msg.set_index( nBagIndex );
	msg.set_nextactboxindex( tpMW->GetNextActBoxIndex() );
	msg.set_printedql( tpMW->GetCurQL() );

	CMessage   tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_REFRESHVALUE);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 通知刷新法宝属性数值 带类型 不是都发 遵循enMagicWeaponValueTyle
// 注意 这里不能刷印记的器灵ID
void CPropertyModule::NotifyRefreshMagicWeaponProperty( CEntityPlayer* pPlayer, int nType, int nBagIndex )
{
	LK_ASSERT( pPlayer != NULL, return  );

	// 先获得当前是不是装备法宝了
	CPropertyPlayer* pPro = (CPropertyPlayer*)pPlayer->GetProperty();

	CItemMagicWeapon* tpMW = NULL;
	if ( nBagIndex == -1 )
		tpMW = (CItemMagicWeapon*)pPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
	else
		tpMW = (CItemMagicWeapon*)pPro->GetBaggage()->GetItemObjPtr( nBagIndex );

	if ( tpMW == NULL )
		return ;

	CMessageMagicWeaponRefreshValueNotify msg;	
	if ( (nType&MAGIC_WEAPON_LEVEL) == MAGIC_WEAPON_LEVEL )
		msg.set_mwlevel( tpMW->GetMWLevel() );
	if ( (nType&MAGIC_WEAPON_EXP) == MAGIC_WEAPON_EXP )
		msg.set_exp( tpMW->GetExp() );
	if ( (nType&MAGIC_WEAPON_MP) == MAGIC_WEAPON_MP )
		msg.set_mp( tpMW->GetMp() );
	if ( (nType&MAGIC_WEAPON_HP) == MAGIC_WEAPON_HP )
		msg.set_hp( tpMW->GetHp() );
	if ( (nType&MAGIC_WEAPON_KEENPOINTS) == MAGIC_WEAPON_KEENPOINTS )
		msg.set_curkeenpoints( tpMW->GetKeenpoints() );
	if ( (nType&MAGIC_WEAPON_CALMPOINTS) == MAGIC_WEAPON_CALMPOINTS )
		msg.set_curcalmpoints( tpMW->GetCalmpoints() );
	if ( (nType&MAGIC_WEAPON_MAGICPOINTS) == MAGIC_WEAPON_MAGICPOINTS )
		msg.set_curmagicpoints( tpMW->GetMagicpoints() );
	if ( (nType&MAGIC_WEAPON_BIERPOINTS) == MAGIC_WEAPON_BIERPOINTS )
		msg.set_curbierpoints( tpMW->GetBierpoints() );
	if ( (nType&MAGIC_WEAPON_IMMORTALPOINTS ) == MAGIC_WEAPON_IMMORTALPOINTS )
		msg.set_curimmortalpoints( tpMW->GetImmortalpoints() );
	if ( (nType&MAGIC_WEAPON_LEFTPOINTS) == MAGIC_WEAPON_LEFTPOINTS )
		msg.set_leftpoints( tpMW->GetLeftPoints() );
	if ( (nType&MAGIC_WEAPON_PROSPIR) == MAGIC_WEAPON_PROSPIR )
		msg.set_prospir( tpMW->GetProSpir() );
	if ( (nType&MAGIC_WEAPON_LEFTSKILLPOINTS) == MAGIC_WEAPON_LEFTSKILLPOINTS )
		msg.set_leftskillpoints( tpMW->GetLeftSkillPoints() );
	if ( (nType&MAGIC_WEAPON_MP_INC) == MAGIC_WEAPON_MP_INC )
		msg.set_incmp( tpMW->GetIncMp() );
	if ( (nType&MAGIC_WEAPON_HP_INC) == MAGIC_WEAPON_HP_INC )
		msg.set_inchp( tpMW->GetIncHp() );
	if ( (nType&MAGIC_WEAPON_PROBASE) == MAGIC_WEAPON_PROBASE )
		msg.set_probase( tpMW->GetProBase() );
	if ( (nType&MAGIC_WEAPON_PROUP) == MAGIC_WEAPON_PROUP )
		msg.set_proup( tpMW->GetProUp() );
	if ( (nType&MAGIC_WEAPON_PROEFF) == MAGIC_WEAPON_PROEFF )
		msg.set_proeff( tpMW->GetProEff() );
	if ( (nType&MAGIC_WEAPON_PROCESSVAL) == MAGIC_WEAPON_PROCESSVAL )
		msg.set_processval( tpMW->GetProcessVal() );
	if ( (nType&MAGIC_WEAPON_MAXMP) == MAGIC_WEAPON_MAXMP )
		msg.set_maxmp( tpMW->GetMaxMp() );
	if ( (nType&MAGIC_WEAPON_MAXHP) == MAGIC_WEAPON_MAXHP )
		msg.set_maxhp( tpMW->GetMaxHp() );

	msg.set_index( nBagIndex );
	msg.set_nextactboxindex( tpMW->GetNextActBoxIndex() );

	CMessage   tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_REFRESHVALUE);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 恢复法宝MP timer
void CPropertyModule::OnTimeOutMessageMagicWeaponIncMp( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CItemMagicWeapon* pTimerOwner = (CItemMagicWeapon*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	// 得到佩戴者
	CEntityPlayer* pPlayer = (CEntityPlayer*)CSceneLogic::GetSingleton().GetEntity( pTimerOwner->GetOwner() );
	if( pPlayer == NULL )
		return ;

	if ( pTimerOwner->OnTimerIncMp() == 0 )
		return;

	NotifyRefreshMagicWeaponProperty( pPlayer, MAGIC_WEAPON_MP, -1 );
	return ;
}


// 扣减法宝HP timer
void CPropertyModule::OnTimeOutMessageMagicWeaponDecHp( CMessage* pMsg )
{
	if ( pMsg == NULL )
		return;

	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CItemMagicWeapon* pTimerOwner = (CItemMagicWeapon*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	// 得到佩戴者
	CEntityPlayer* pPlayer = (CEntityPlayer*)CSceneLogic::GetSingleton().GetEntity( pTimerOwner->GetOwner() );
	if( pPlayer == NULL )
	{
		//LOG_ERROR( "pro", "[%s:%d] can't find mw's owner %d", __FUNCTION__, __LINE__, pTimerOwner->GetOwner()  );
		return ;
	}

	if ( pTimerOwner->OnTimerDecHp() == 0 )
		return;

	NotifyRefreshMagicWeaponProperty( pPlayer, MAGIC_WEAPON_HP, -1 );

	// 如果扣减完以后变成0了 那么刷新人物属性！
	if ( pTimerOwner->GetHp() <= 0 )
	{
		RefreshPlayerProperty(pPlayer);
	}
	return ;
}

//***************************************
// Function Name: FireTitleEvent
// Input Param	: vType		- 称号类型		(CTplTitleManager::ETitleType)	
// Input Param	: vScope	- 称号获取的范围(CTplTitleManager::ECndisnScope)
// Input Param	: vParam	- 称号获取的条件(CTplTitleManager::ERankLevel)
//***************************************

int CPropertyModule::FireTitleEvent( CEntityPlayer* vpPlayer, int vType, int vScope, int vParam )
{
	if ( vpPlayer == NULL ) return -1;

	int tTitleID = 0;
	CTitle* tpTitle = CDataStatic::GetTitle(vType, vScope, vParam, tTitleID );

	if ( tpTitle == NULL )
	{
		return -1;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();

	if ( tpProperty->HasTitle( tTitleID ) == true )
	{
		return -1;
	}

	switch ( tpTitle->mType )
	{
		// 完成任务统计
	case CTplTitleManager::STATISTIC_TASK:
		{
			// 遍历玩家身上的所有称号，如果任务统计类的比当前激活的称号等级低的
			// 删除原来的低等级称号
			int tLowTitle = tpProperty->GetLowLevelTitle( tTitleID );
			if ( tLowTitle > 0 )
			{
				SendNotifyClientUpdateTitle( vpPlayer, TITLE_DELETE, tLowTitle );
			}
		}
	}

	tpProperty->AddTitle( tTitleID );
	SendNotifyClientUpdateTitle( vpPlayer, TITLE_ADD, tTitleID );
	return 0;
}

//********************************************
// Function : OnPlayerAddTitleEvent
// Describe : 跨模块调用，玩家增加称号
// Input	: nTitleID 称号ID 
// return   : void
//********************************************

int CPropertyModule::OnPlayerAddTitleEvent(CEntityPlayer *vpPlayer, int nTitleID, int nValidTime)
{
	if ( vpPlayer == NULL || nTitleID == 0 )
	{
		return -1;
	}

	CTitle *tpTitle = CDataStatic::GetTitle( nTitleID );
	if ( tpTitle == NULL )
	{	
		return -1;
	}

	// 如果是阵营称号 则转换为新称号
	//if ( tpTitle->mType == CTplTitleManager::TITLETYPE_CAMP )
	//{
	//	nTitleID += vpPlayer->GetNationality();
	//	tpTitle = CDataStatic::GetTitle( nTitleID );
	//	if ( tpTitle == NULL )
	//	{	
	//		LOG_ERROR("pro", "error title: %d", nTitleID );
	//		return -1;
	//	}
	//}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();
	if ( tpProperty->HasTitle( nTitleID ) )
	{
		SendProErrorNotice( vpPlayer, ERROR_PROPERTY_TITLEHASEXIST );
		return -1;
	}	

	if ( tpProperty->AddTitle( nTitleID, nValidTime ) <= 0 )
		return -1;

	SendNotifyClientUpdateTitle( vpPlayer, TITLE_ADD, nTitleID );
	
	const char *pTitleName = NULL;
	switch ( tpTitle->mType )
	{
		case CTplTitleManager::TITLETYPE_SWORN :
		{
			CSwornTeam * tpSwornTeam = CFriendModule::GetSingleton().GetSwornTeam( vpPlayer->GetSwornID() );
			if ( tpSwornTeam != NULL )
			{
				pTitleName = tpSwornTeam->GetSwornName();
			}
			break;
		}
	}	
	if ( nTitleID != tpProperty->GetCurrentTitle() )
	{	
		if ( tpTitle->mIsReplace == 1 )
		{
			// 删除旧称号
			tpProperty->RemoveTitleSkill( tpProperty->GetCurrentTitle() );
			tpProperty->Refresh();			
			tpProperty->SetCurrentTitle( nTitleID );
			
			// 添加新称号
			CTemplateSkill* tpSkill = ( CTemplateSkill* ) CDataStatic::SearchTpl( tpTitle->mAddProperty );
			if ( tpSkill != NULL )
			{
				tpProperty->mTitleSkill.InsertSkill( tpSkill->mSkillID, 1 );
				tpProperty->Refresh();						
			}						
			vpPlayer->NotifyPropertyRefresh();	
			SendNotifyUpdateCurrentTitle( vpPlayer, nTitleID, pTitleName );
		}
	}
		

	return SUCCESS;
}

int CPropertyModule::InsertTitleSkill( CEntityPlayer* vpPlayer, int* vTitleList, int vNum )
{
	/*if ( vpPlayer == NULL ) return -1;

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();

	for ( int i = 0; i < vNum; i ++ )
	{
		CTitle* tpTitle = CDataStatic::GetTitle( vTitleList[ i ] );
		if ( tpTitle == NULL )
			continue;

		CTemplateSkill* tpSkill = ( CTemplateSkill* ) CDataStatic::SearchTpl( tpTitle->mAddProperty );
		if ( tpSkill == NULL )
			continue;

		tpProperty->mTitleSkill.InsertSkill( tpSkill->mSkillID, 1 );
	}*/
	return 0;
}

// 通知客户端 更新称号 [12/5/2009 Macro]
void CPropertyModule::SendNotifyClientUpdateTitle(CEntityPlayer *vpPlayer, int vType, int vTitleID)
{
	if ( vpPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) vpPlayer->GetProperty();

	CMessage tMessage;
	CMessageUpdateTitleNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_UPDATETITLE );
	tPara.set_type( vType );
	tPara.set_isbatch( (int) false );
	tPara.set_titleid( vTitleID );
	tPara.set_time( tpProperty->GetTitleTime( vTitleID ) );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( vpPlayer, &tMessage );

	// 技能
	//CTitle* tpTitle = CDataStatic::GetTitle( vTitleID );
	//if ( tpTitle == NULL )
	//{
	//	return ;
	//}
	//CTemplateSkill* tpSkill = ( CTemplateSkill* ) CDataStatic::SearchTpl( tpTitle->mAddProperty );
	//if ( tpSkill == NULL )
	//{
	//	return ;
	//}

	if ( vType == TITLE_DELETE )
	{
		//tpProperty->mTitleSkill.RemoveSkill( tpSkill->mSkillID );
		// 刷新属性
		RefreshPlayerProperty(vpPlayer);
	}

	return ;
}

// 删除玩家的一个称号 [1/28/2010 Macro]
int CPropertyModule::OnPlayerDelTitleEvent( CEntityPlayer* npPlayer, int nTitleID )
{
	if ( npPlayer == NULL || nTitleID == 0 )
	{
		return -1;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();
	if ( tpProperty->HasTitle( nTitleID ) == false )
	{
		SendProErrorNotice( npPlayer, ERROR_PROPERTY_TITLENOTEXIST );
		return -1;
	}

	tpProperty->RemoveTitle( nTitleID );		
	SendNotifyClientUpdateTitle( npPlayer, TITLE_DELETE, nTitleID );
	
	if ( tpProperty->GetCurrentTitle() == nTitleID )
	{				
		CMessage tMessage;
		CMessageUpdateCurrentTitleNotice tPara;
		tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_UPDATECURRENTTITLE );
		tMessage.set_msgpara( (long) &tPara );
		tPara.set_charid( npPlayer->GetCharID() );
		tPara.set_titleid( 0 );				
		
		tpProperty->RemoveTitleSkill( tpProperty->GetCurrentTitle() );
		tpProperty->Refresh();
		npPlayer->NotifyPropertyRefresh();
		tpProperty->SetCurrentTitle( 0 );	
		CMapModule::GetSingleton().MessageBroadCast( npPlayer, &tMessage, false, true );		
	}
	return SUCCESS;
}

// 通知客户端 更新当前称号 [12/5/2009 Macro]
void CPropertyModule::SendNotifyUpdateCurrentTitle( CEntityPlayer *vpPlayer, int vTitleID, const char *pTitleName )
{
	if ( vpPlayer == NULL || vTitleID < 0 )
	{
		return ;
	}

	CMessage tMessage;
	CMessageUpdateCurrentTitleNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_UPDATECURRENTTITLE );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_charid( vpPlayer->GetCharID() );
	tPara.set_titleid( vTitleID );
	if ( pTitleName != NULL )
	{
		tPara.set_titlename( pTitleName );
	}

	CMapModule::GetSingleton().MessageBroadCast( vpPlayer, &tMessage, false, true );
	return ;
}

void CPropertyModule::FireActivityDiploid( CEntityPlayer* pPlayer, int nRate, int nBeginTime /* = 0 */, int nEndTime /* = 0 */ )
{
	if ( pPlayer == NULL ) return ;

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	
	CMessage tMessage;
	CMessageActivityDiploidNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_ACTIVITYDIPLOID );
	tPara.set_type( nRate );
	tPara.set_begintime( nBeginTime );
	tPara.set_endtime( nEndTime );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );

	tpProperty->SetActivityState( nRate );

	return ;
}

void CPropertyModule::FireActivityDiploid( CEntityPlayer* pPlayer, int nRate, bool bAllInScene, int nBeginTime, int nEndTime )
{
	CMessage tMessage;
	CMessageActivityDiploidNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTICE_ACTIVITYDIPLOID );
	tPara.set_type(  nRate );
	tPara.set_begintime( nBeginTime );
	tPara.set_endtime( nEndTime );
	tMessage.set_msgpara( (long) &tPara );

	if ( bAllInScene )
	{
		CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp;
		for( CSceneObjManagerImp::ObjMng_EntityPlayer::iterator tPlayerIt = pSceneneObjManagerImp->mEntityPlayerPool.begin( ); 
			tPlayerIt != pSceneneObjManagerImp->mEntityPlayerPool.end( ); 
			tPlayerIt++ 
			)
		{
			CEntityPlayer* tpEntity = &( *tPlayerIt );
			CSceneLogic::GetSingleton().Send2Player( tpEntity, &tMessage );

			if ( nRate > 0 )
			{
				// 开启活动双倍
				tpEntity->OpenActiveDoubleTime(nRate);
			}
			else
			{
				// 关闭活动双倍
				tpEntity->CloseActiveDoubleTime();
			}
		}
	}
	else
	{	
		if ( pPlayer == NULL ) return ;
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );

		if ( nRate > 0 )
		{
			// 开启活动双倍
			pPlayer->OpenActiveDoubleTime(nRate);
		}
		else
		{
			// 关闭活动双倍
			pPlayer->CloseActiveDoubleTime();
		}
	}
	return ;
}

// 玩家请求给法宝加点
void CPropertyModule::OnMessageMWAddPotential( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageAddPotentialRequest* tpMessage = ( CMessageAddPotentialRequest* )pMessage->msgpara( );
	if ( tpMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CPropertyPlayer* tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemMagicWeapon* tpObjMW = (CItemMagicWeapon*)tpProperty->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);

	if ( tpObjMW == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageAddPotentialResponse msg;
	CMessage   tMessage;

	int tRet = tpObjMW->OnAddPotential( tpMessage->keenpoints(), tpMessage->calmpoints(), tpMessage->magicpoints()
		, tpMessage->bierpoints(), tpMessage->immortalpoints() );

	msg.set_result(tRet);
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_ADDPOTENTIAL);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );

	if ( tRet == 0 )
	{
		// 法宝属性已刷新 通知客户端
		NotifyRefreshMagicWeaponProperty( pPlayer, -1 );
		// 刷新人
		RefreshPlayerProperty( pPlayer );
		msg.set_result( 0 );
	}
}

// 玩家请求改变额外分配经验比例
void CPropertyModule::OnMessageChangeExpScaleRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageChangeExpScaleRequest* tpMessage = ( CMessageChangeExpScaleRequest* )pMessage->msgpara( );
	CMessageAddPotentialResponse msg;
	CMessage   tMessage;

	if ( tpMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if ( tpMessage->percent() <= 100 )
	{
		CPropertyPlayer* tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
		tpProperty->SetAssignExpScl( tpMessage->percent() );
		msg.set_result(tpMessage->percent());
	}
	else
	{
		msg.set_result(ERROR_MW_ERRPERCENT);
	}
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_CHANGEEXPSCALE);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 法宝技能加点请求
void CPropertyModule::OnMessageMWAddSkillPoints( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageMWAddSkillPointsRequest* tpMessage = ( CMessageMWAddSkillPointsRequest* )pMessage->msgpara( );

	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemMagicWeapon* pObj = (CItemMagicWeapon*)pProperty->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
	if ( pObj == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTEQUIP );
		return;
	}

	int tRet = pObj->OnClickSP( tpMessage->index() );
	if ( tRet == 0 )
	{
		CMessageMWAddSkillPointsResponse msg;
		msg.set_index(tpMessage->index());
		CMessage tMessage;
		tMessage.set_msgpara((uint32_t) &msg);
		tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_MWADDSKILLPOINTS);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );

		// 法宝属性已刷新 通知客户端
		NotifyRefreshMagicWeaponProperty( pPlayer, -1 );
		// 刷新人
		RefreshPlayerProperty( pPlayer );
	}
	else
	{
		SendProErrorNotice( pPlayer, tRet );
		return;
	}
}

// 法宝技能框鉴定请求
void CPropertyModule::OnMessageMWJudgeSkill( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageMWJudgeSkillRequest* tpMessage = ( CMessageMWJudgeSkillRequest* )pMessage->msgpara( );
	CMessage   tMessage;
	// 发给客户端新加技能
	CMessageInsertSkillNotify msg;

	if ( tpMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}
	// NPC距离合法性检查
	CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		tpMessage->npcentityid( ) ) );
	if( pNpc == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
		return ;
	}
	if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
		return;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mMWSkillJudgeService == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemMagicWeapon* pObj = (CItemMagicWeapon*)pProperty->GetBaggage()->GetItemObjPtr( pProperty->GetBaggage()->GetMWLockIndex() );
	LK_ASSERT( pObj, return );

	if ( (pObj->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (pObj->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
		return;
	}

	// 检查钱
	LK_ASSERT( tpMessage->index()>=0 && tpMessage->index()<SKILL_BOX_LMT, return );
	CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl( pObj->GetItemID() );
	LK_ASSERT( tpItemMW!=NULL, return  );
	CTplMagicWeaponSkillBoxProTable* tpSkillTable = (CTplMagicWeaponSkillBoxProTable*)CDataStatic::SearchTpl(tpItemMW->mSkillBoxTableID);
	LK_ASSERT( tpSkillTable != NULL, return );
	if ( pProperty->GetMoney()+pProperty->GetBindMoney() < tpSkillTable->mValues[tpMessage->index()].mSkillBoxActMoney )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_JUDGENOMONEY );
		return;
	}
	
	// 调用法宝接口 鉴定
	msg.set_bagindex(pProperty->GetBaggage()->GetMWLockIndex());

	bool bFirst = false;
	pObj->OnStartMagicWeapon( pPlayer, false );  // 先启动 为了鉴定里面用
	int tRet = pObj->OnJudgeNewSkill( tpMessage->index(), bFirst, &msg );
	pObj->OnEndMagicWeapon( pPlayer );
	if ( tRet == 0 )
	{
		if ( !bFirst )
		{
			// 鉴定成功　扣钱
			if (PlayerChangeMoney( pPlayer,tpSkillTable->mValues[tpMessage->index()].mSkillBoxActMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByJudgeFabao( pPlayer, CYuanBao::em_bind_money, 
						tpSkillTable->mValues[tpMessage->index()].mSkillBoxActMoney, pObj->GetItemID(), pObj->GetGUID());
			}
		}

		// 新加技能
		tMessage.set_msgpara((uint32_t) &msg);
		tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_INSERTSKILL);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );

		// 刷新属性
		NotifyRefreshMagicWeaponProperty( pPlayer, pProperty->GetBaggage()->GetMWLockIndex() );
	}
	else
	{
		SendProErrorNotice( pPlayer, tRet );
	}
}


// 鉴定 放法宝 请求
void CPropertyModule::OnMessageLockMWInBagRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	LK_ASSERT( pProperty, return );

	CMessageLockMWInBagRequest* tpMsg = ( CMessageLockMWInBagRequest* )pMessage->msgpara( );

	CItemObject* pObj = pProperty->GetBaggage()->GetItemObjPtr(tpMsg->itemindex());
	LK_ASSERT( pObj, return );

	int nBagIndex = -1;
	int tLockType = -1;
	if ( tpMsg->locktype() == MWLOCK_SKILLJUDGE || tpMsg->locktype() == MWLOCK_PROJUDGE )
	{
		// 看看是不是法宝
		if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
			return;
		}
		nBagIndex = pProperty->GetBaggage()->GetMWLockIndex();
		tLockType = LOCKTYPE_MAGICWEAPON;
		pProperty->GetBaggage()->SetMWLockIndex(tpMsg->itemindex());
	}
	else if ( tpMsg->locktype() == MWLOCK_PROJUDGE_STONE )
	{
		CTplItem	*tpItem = ( CTplItem* ) CDataStatic::SearchTpl(  pObj->GetItemID()  );	
		LK_ASSERT( tpItem!=NULL, return );

		if ( tpItem->mItemType != CTplItem::ITEM_FUNCITEM || ((CTplFuncItem*)tpItem)->mFuncCode != FUNCCODE_JUDGEMWPRO )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NOTMWSTONE );
			return;
		}
		nBagIndex = pProperty->GetBaggage()->GetMWStoneLockIndex();
		tLockType = LOCKTYPE_MAGICWEAPON_STONE;
		pProperty->GetBaggage()->SetMWStoneLockIndex(tpMsg->itemindex());
	}

	bool ret;
	if (nBagIndex != -1 && nBagIndex != (int)tpMsg->itemindex()) // 已经有了 先解锁
	{
		CPropertyModule::GetSingleton().LockBaggage( pPlayer->GetEntityID(), nBagIndex, LOCKTYPE_NONE, ret );
	}

	CPropertyModule::GetSingleton().LockBaggage( pPlayer->GetEntityID(), tpMsg->itemindex(), tLockType, ret );

	CMessageLockMWInBagResponse msg;
	msg.set_itemindex(tpMsg->itemindex());
	msg.set_locktype( tpMsg->locktype() );
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_MWLOCKBAG);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 取下法宝请求
void CPropertyModule::OnMessagePlayerTakeOffMW( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	LK_ASSERT( pProperty, return );

	CMessageMWTakeOffItemRequest* tpMsg = ( CMessageMWTakeOffItemRequest* )pMessage->msgpara( );

	int nBagIndex = -1;
	if ( tpMsg->locktype() == MWLOCK_SKILLJUDGE || tpMsg->locktype() == MWLOCK_PROJUDGE )
	{
		nBagIndex = pProperty->GetBaggage()->GetMWLockIndex();
		pProperty->GetBaggage()->SetMWLockIndex( -1 );
	}
	else if ( tpMsg->locktype() == MWLOCK_PROJUDGE_STONE )
	{
		nBagIndex = pProperty->GetBaggage()->GetMWStoneLockIndex();
		pProperty->GetBaggage()->SetMWStoneLockIndex( -1 );
	}

	if (nBagIndex != -1 ) // 解锁
	{
		bool ret;
		CPropertyModule::GetSingleton().LockBaggage( pPlayer->GetEntityID(), nBagIndex, LOCKTYPE_NONE, ret );
	}
}

// 鉴定法宝属性
void CPropertyModule::OnMessagePlayerJudgeMWProperty( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	LK_ASSERT( pProperty, return );
	CMessageMWJudgePropertyRequest* tpMsg = ( CMessageMWJudgePropertyRequest* )pMessage->msgpara( );

	CItemMagicWeapon* tpMW = ( CItemMagicWeapon* )pProperty->GetBaggage()->GetItemObjPtr( tpMsg->mwindex() );
	if ( tpMW == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}
	if ( (tpMW->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (tpMW->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
		return;
	}
	// NPC距离合法性检查
	CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
		tpMsg->npcentityid( ) ) );
	if( pNpc == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
		return ;
	}
	if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
		return;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL  )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
		return;
	}

	// 检查钱
	CTemplateMagicWeapon* tpItemMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl( tpMW->GetItemID() );
	LK_ASSERT( tpItemMW!=NULL, return  );

	if ( pProperty->GetMoney()+pProperty->GetBindMoney() < tpItemMW->mProJudgeCost )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_JUDGENOMONEY );
		return;
	}

	CMessageMWJudgePropertyResponse msg;
	msg.set_bagindex(tpMsg->mwindex());
	if ( tpMW->GetProJudgeFlag() == 0 ) // 第一次鉴定
	{
		if ( tpNpc->mMWProJudgeService == 0 )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
			return;
		}
		if ( 0 != tpMW->OnJudgeProperty( 0, 0 ) )
			return; // 有问题的时候才不会成功 正常情况下都会成功 里面已经assert了
	}
	else	// 非第一次鉴定
	{
		if ( tpNpc->mMWSecondJudgeService == 0 )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
			return;
		}

		// 先检查物品
		CItemObject* pObj = pProperty->GetBaggage()->GetItemObjPtr(tpMsg->stoneindex());
		LK_ASSERT( pObj, return );

		CTplItem	*tpItem = ( CTplItem* ) CDataStatic::SearchTpl(  pObj->GetItemID()  );	
		LK_ASSERT( tpItem!=NULL, return );

		if ( tpItem->mItemType != CTplItem::ITEM_FUNCITEM || ((CTplFuncItem*)tpItem)->mFuncCode != FUNCCODE_JUDGEMWPRO )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NOTMWSTONE );
			return;
		}

		uint64_t ullGUID = pObj->GetGUID();
		int nItemID = pObj->GetItemID();

		// 检查OK  扣除物品
		if ( 0 == PlayerRemoveItem( pPlayer, tpMsg->stoneindex(), 1, false ) )
		{
			LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);

			if ( 0 != tpMW->OnJudgeProperty( ((CTplFuncItem*)tpItem)->mParams[0], ((CTplFuncItem*)tpItem)->mParams[1] ) )
				return; // 有问题的时候才不会成功 正常情况下都会成功 里面已经assert了
		}
		else
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NOTMWSTONE );
			return;
		}
	}

	// 能到这里 说明肯定鉴定成功了
	// 鉴定成功　扣钱
	if (PlayerChangeMoney( pPlayer, tpItemMW->mProJudgeCost, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByJudgeFabao(pPlayer, 
				CYuanBao::em_bind_money, tpItemMW->mProJudgeCost, tpMW->GetItemID(), tpMW->GetGUID());
	}

	msg.set_result(0);

	// 刷新法宝属性
	NotifyRefreshMagicWeaponProperty( pPlayer,  tpMsg->mwindex() );

	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_JUDGEPROPERTY);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 刷新人物属性 带广播
void CPropertyModule::RefreshPlayerProperty( CEntityPlayer* pPlayer )
{
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
	LK_ASSERT( tpPro!=NULL, return );
	tpPro->Refresh();
	pPlayer->NotifyPropertyRefresh( );

	// 把玩家MP和HP值的改变情况广播出去
	CMessage MessageHead;
	CMessageEntityRefreshNotice FreshMsg;
	CreateMessageEntityRefreshNotice( &MessageHead, &FreshMsg, pPlayer->GetEntityID(), tpPro->GetCurHP( ),  
		tpPro->GetCurMP( ), tpPro->GetMaxHP( ),  tpPro->GetMaxMP( ) );
	CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &MessageHead );
}

// 玩家使用技能书合成法宝技能请求
void CPropertyModule::OnMessageMWUseSkillBookRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		LOG_ERROR( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessageMWUseBookRequest* tpMessage = ( CMessageMWUseBookRequest* )pMessage->msgpara( );
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();

	CItemObject* pObj = (CItemObject*)pProperty->GetBaggage()->GetItemObjPtr( tpMessage->mwindex() );
	if ( pObj == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}

	// 看看是不是法宝
	if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}

	CItemMagicWeapon* tpObjMW = (CItemMagicWeapon*)pObj;

	CItemObject* tpItemObj = pProperty->GetBaggage()->GetItemObjPtr( tpMessage->bagindex() );
	LK_ASSERT( tpItemObj != NULL, return );

	CTplItem* tpTempItem = (CTplItem*)CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	LK_ASSERT( tpTempItem!=NULL, return );

	if ( tpTempItem->mItemType != ITEM_SKILLBOOK )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTSKILLBOOK );
		return;
	}

	CMessageInsertSkillNotify msg;
	CMessage tMessage;

	CTplItemSkillBook* tpItemBook = (CTplItemSkillBook*)CDataStatic::SearchTpl(tpItemObj->GetItemID());
	LK_ASSERT( tpItemBook != NULL, return );

	// 判断钱
	bool bEnough = false;
	switch(tpItemBook->mNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_NONE:
		{
			bEnough = true;
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			bEnough = (pProperty->GetBindMoney()+pProperty->GetMoney()>=tpItemBook->mNeedMoney);
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			bEnough = (pProperty->GetMoney()>=tpItemBook->mNeedMoney);
			break;
		}
	default:
		{

		}
	}
	if (!bEnough)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_USESKILLBOOK_NOMONEY );
		return ;
	}

	// 扣钱
	switch(tpItemBook->mNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, tpItemBook->mNeedMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByJudgeFabao( pPlayer, CYuanBao::em_bind_money, 
					tpItemBook->mNeedMoney, tpObjMW->GetItemID(), tpObjMW->GetGUID());
			}
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, tpItemBook->mNeedMoney, true, false ) == SUCCESS)
			{
				LogEventLostMoneyByJudgeFabao( pPlayer, CYuanBao::em_unbind_money, 
					tpItemBook->mNeedMoney, tpObjMW->GetItemID(), tpObjMW->GetGUID());
			}
			break;
		}
	default:
		{

		}
	}
	// 消耗书
	uint64_t ullGUID = tpItemObj->GetGUID();
	int nItemID = tpItemObj->GetItemID();
	// 扣除物品
	if ( PlayerRemoveItem( pPlayer, tpMessage->bagindex(), 1) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);
	}

	// 判断概率
	if ( RAND(10000) > tpItemBook->mSuccProb )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_USESKILLBOOK_FAILED );
		return ;
	}

	tpObjMW->OnStartMagicWeapon( pPlayer, false );  // 先启动 为了鉴定里面用
	int tRet = tpObjMW->OnUseSkillBook( tpMessage->boxindex(), tpItemObj->GetItemID(), &msg );
	tpObjMW->OnEndMagicWeapon( pPlayer );
	if (tRet == 0 )
	{
		// 新加技能
		tMessage.set_msgpara((uint32_t) &msg);
		tMessage.mutable_msghead()->set_messageid(ID_S2C_NOTIFY_INSERTSKILL);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );

		// 刷新属性
		NotifyRefreshMagicWeaponProperty( pPlayer, -1 );
		RefreshPlayerProperty( pPlayer );
		return;
	}

	SendProErrorNotice( pPlayer, tRet );
}

void CPropertyModule::OnMessageChangePKDrop( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessageChangePKDropMode* pMode = ( CMessageChangePKDropMode* )pMessage->msgpara( );
	if( pMode->isdrop( ) == true )
	{
		pPlayer->SetHandle( UN_HANDLE_DROP_FOE_DIE );
		pPlayer->SetHandle( UN_HANDLE_PROCESS_FOE_DIE );
		pPlayer->SetHandle( UN_HANDLE_PROCESS_FOR_ATTACK );
		pPlayer->SetHandle( UN_HANDLE_HONOR );
		pPlayer->SetHandle( UN_HANDLE_DURA );
	}
	else
	{
		pPlayer->SetUnHandle( UN_HANDLE_DROP_FOE_DIE );
		pPlayer->SetUnHandle( UN_HANDLE_PROCESS_FOE_DIE );
		pPlayer->SetUnHandle( UN_HANDLE_PROCESS_FOR_ATTACK );
		pPlayer->SetUnHandle( UN_HANDLE_HONOR );
		pPlayer->SetUnHandle( UN_HANDLE_DURA );
	}
}

void CPropertyModule::OnMessageAutoPlayerGameRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return ;
	}

	CMessageOperateAutoHookRequest* tpReq = ( CMessageOperateAutoHookRequest* ) pMessage->msgpara();
	
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	// open auto play flag
	int tAction = tpReq->action();
	if( tAction == (int) true )
	{
		tpProperty->SetAutoPlayFlag( true );
		CTplApConfig* tpConfig = ( CTplApConfig* ) CDataStatic::GetTemp( TEMP_APCONFIG );
		if ( tpConfig == NULL )
		{
			return ;
		}
		if ( tpProperty->IsVip() == false )
		{
			int tDecValue = tpConfig->mConsumeHook / 20;
			int tAp = tpProperty->GetCurAP();
			if ( tAp < tDecValue )
			{
				tpProperty->SetAutoPlayFlag( false );
				tAction = 0;
			}			
			tAp = std::max( 0, ( tAp - tDecValue ) );
			tpProperty->SetCurAP( tAp );
		}		
	}
	else
	{
		tpProperty->SetAutoPlayFlag( false );
	}

	CMessage tMessage;
	CMessageOperateAutoHookResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_AUTOHOOK );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_action( tAction );
	tPara.set_rtncode( SUCCESS );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

void CPropertyModule::OnMessageBuyPhysicRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return ;
	}

	CMessageBuyPhysicRequest* tpReq = ( CMessageBuyPhysicRequest* ) pMessage->msgpara();

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	//  not in auto play status, can't buy it
	if ( tpProperty->GetAutoPlayFlag() == false )
	{
		return ;
	}

	// 检查是否有密码保护
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{					
		SendProErrorNotice(pPlayer, tPwdCheckRet );
		return;
	}

	CTplApConfig* tpApConfig = (CTplApConfig*)CDataStatic::GetTemp( TEMP_APCONFIG );
	if ( tpApConfig == NULL )
	{
		return ;
	}

	int tItemID = 0;
	switch ( tpReq->type() )
	{
	case PHYSIC_RED:
		{
			if ( tpReq->index() >= 0 && tpReq->index() < ARRAY_CNT( tpApConfig->mRedPhysic ) )
				tItemID = tpApConfig->mRedPhysic[ tpReq->index() ];
			break;
		}
	case PHYSIC_BLUE:
		{
			if ( tpReq->index() >= 0 && tpReq->index() < ARRAY_CNT( tpApConfig->mBluePhysic ) )
				tItemID = tpApConfig->mBluePhysic[ tpReq->index() ];
			break;
		}
	case PHYSIC_AP:
		{
			// 客户端发送的索引对定心丸进行了绑定和非绑定区分
			// 服务器做相应处理
			tItemID = GetStoreItemID( tpApConfig->mApPhysic, ARRAY_CNT( tpApConfig->mApPhysic ), tpReq->buytype(), tpReq->index() );
			break;
		}
		// 法宝法力药 [3/2/2010 GaoHong]
	case PHYSIC_FB_HP:
		{
			if ( tpReq->index() >= 0 && tpReq->index() < ARRAY_CNT( tpApConfig->mFbHpPhysic ) )
				tItemID = tpApConfig->mFbHpPhysic[ tpReq->index() ];
			break;
		}
		// 法宝灵气药 [3/2/2010 GaoHong]
	case PHYSIC_FB_MP:
		{
			if ( tpReq->index() >= 0 && tpReq->index() < ARRAY_CNT( tpApConfig->mFbMpPhysic ) )
				tItemID = tpApConfig->mFbMpPhysic[ tpReq->index() ];
			break;
		}
		// 金刚钻 [3/4/2010 GaoHong]
	case PHYSIC_MEND:
		{
			// 客户端发送的索引对金刚钻进行了绑定和非绑定区分
			// 服务器做相应处理
			tItemID = GetStoreItemID( tpApConfig->mMendPhysic, ARRAY_CNT( tpApConfig->mMendPhysic ), tpReq->buytype(), tpReq->index() );
			break;
		}
	default:
		break;
	}

	if ( tItemID == 0 )
		return ;

	CTplItem* tpItem = (CTplItem*) CDataStatic::SearchTpl( tItemID );
	if ( tpItem == NULL )
	{
		LOG_ERROR( "pro", "[%s:%d] ITEM=%d not found", __FUNCTION__, __LINE__, tItemID );
		return;
	}

	if ( tpItem->mItemType != CTplItem::ITEM_PHYSIC )
	{
		// 检查是否是法宝药, 金刚钻
		if ( tpItem->mItemType == CTplItem::ITEM_FUNCITEM )
		{
			CTplFuncItem* tpFuncItem = (CTplFuncItem*) tpItem;
			if ( tpFuncItem->mFuncCode != FUNCCODE_RECVMWHP && 
				tpFuncItem->mFuncCode != FUNCCODE_RECVMWMP &&
				tpFuncItem->mFuncCode != FUNCCODE_REPAIR )
			{
				return ;
			}
		}
		else
		{
			LOG_ERROR( "pro", "[%s:%d] ITEM=%d is not physic", __FUNCTION__, __LINE__, tItemID );
			return ;
		}		
	}		

	int tNumber = tpReq->number();

	if ( tNumber <= 0 )
	{
		return ;
	}	 

	if ( tpProperty->GetBaggage()->Space( tItemID, tNumber ) == false )
	{
		SendProErrorNotice( pPlayer, ERROR_INSERTITEM_NOSPACE );
		return ;
	}

	// 元宝购买定心丸，金刚钻流程
	if ( tpReq->buytype() == EM_BIND_YB || tpReq->buytype() == EM_UNBIND_YB )
	{
		// 验证是否是定心丸,金刚钻
		if ( tpReq->type() != PHYSIC_AP && tpReq->type() != PHYSIC_MEND )
		{
			return ;
		}

		CMessage tMessage;
		CMessagePurchaseIbItemRequest tPara;
		tMessage.mutable_msghead()->set_messageid( ID_C2S_REQUEST_PURCHASEIBITEM );
		tMessage.set_msgpara( (long)&tPara );
		tPara.set_goodsid( tItemID );
		tPara.set_goodscount( tNumber );
		CIbStoreModule::GetSingleton().OnMessagePurchaseIbItemRequest( pPlayer, &tMessage );

		// 走完元宝购买流程直接返回！！！
		return ;
	}

	// check pk state of entity
	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		LOG_ERROR( "pro", "pk value config template error.[%s:%d]", __LK_FILE__, __LINE__ );
		return ;
	}	

	int tPurchasePrice = tpItem->mPricePurchase;
	EPKStatus tPkStatus = tpProperty->GetTplPKState();
	if ( tPkStatus == PKSTATUS_ROSINESS )
	{
		tPurchasePrice = (int) ( tpItem->mPricePurchase * (float) ( 1 + ( tpTable->mPriceChange[ 0 ] / SERVER_PERCENT_FLOAT ) ) );
	}
	else if ( tPkStatus == PKSTATUS_RED )
	{
		tPurchasePrice = (int) ( tpItem->mPricePurchase * (float) ( 1 + ( tpTable->mPriceChange[ 1 ] / SERVER_PERCENT_FLOAT ) ) );
	}
	else if ( tPkStatus == PKSTATUS_CARMINE )
	{
		tPurchasePrice = (int) ( tpItem->mPricePurchase * (float) ( 1 + ( tpTable->mPriceChange[ 2 ] / SERVER_PERCENT_FLOAT ) ) );
	}
	else if ( tPkStatus == PKSTATUS_PKTOPLIMIT )
	{
		LOG_INFO( "pro", "arrive top pk value, not able to purchase.[%s:%d]", __LK_FILE__, __LINE__ );
		return ;
	}

	if ( tpItem->mPurchaseBindMoney != LK_NOTBIND )
	{
		if ( tpProperty->IsMoneyEnough( true, ( tPurchasePrice * tNumber ) ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFMONEY );
			tNumber = ( tpProperty->GetBindMoney() + tpProperty->GetMoney() ) / tPurchasePrice;
		}		
	}
	else
	{
		if ( tpProperty->IsMoneyEnough( false, ( tPurchasePrice * tNumber ) ) == false )
		{
			SendProErrorNotice( pPlayer, ERROR_CLICKNPC_OUTOFMONEY );
			tNumber = tpProperty->GetMoney() / tPurchasePrice;
		}
	}


	CItemObject* pInsItemPile =  PlayerInsertItem( pPlayer, tItemID, tNumber);
	if ( pInsItemPile == NULL) return;

	//LOG
	LogEventGetItemByGuaJiShop(pPlayer, pInsItemPile->GetGUID(), tItemID, tNumber, 
		tpItem->mSaleBindMoney != LK_NOTBIND ? CYuanBao::em_bind_money : CYuanBao::em_unbind_money, tPurchasePrice, 0);

	// 如果添加道具成功，那么处理金币减少逻辑
	if ( tpItem->mPurchaseBindMoney != LK_NOTBIND )
	{
		// 绑定金钱足够买道具
		//PlayerChangeBindMoney( pPlayer, pProperty, tpItem->mPricePurchase * vNumber, true );
		if (PlayerChangeMoney( pPlayer, ( tPurchasePrice * tNumber ), true, true ) == SUCCESS)
		{
			LogEventLostMoneyByGuajiBuy(pPlayer, CYuanBao::em_bind_money, ( tPurchasePrice * tNumber ),
					tItemID, tNumber, pInsItemPile->GetGUID());
		}
	}	
	else
	{
		if (PlayerChangeMoney( pPlayer, ( tPurchasePrice * tNumber ), true, false ) == SUCCESS)
		{
			LogEventLostMoneyByGuajiBuy(pPlayer, CYuanBao::em_unbind_money, ( tPurchasePrice * tNumber ),
					tItemID, tNumber, pInsItemPile->GetGUID());
		}
	}

	return ;
}


// 放置待分解装备的请求消息
void CPropertyModule::OnMessageAddDecompoundEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{ 
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageAddEcompoundEquipRequest *tpMsg = ( CMessageAddEcompoundEquipRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )	pPlayer->GetProperty();
	CItemObject *tpItemObj = ( CItemObject * )tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->equipmentindex() );
	LK_ASSERT( tpItemObj != NULL, return )
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	
	if ( !tpTplItem->IsEquipable() )
	{
		return;
	}	
	
	if ( tpProperty->GetDecompoundEquipIndex() != -1 )
	{
		tpProperty->GetBaggage()->Lock( tpProperty->GetDecompoundEquipIndex(), LOCKTYPE_DECOMPOUND );
		SendLockItemNotice( pPlayer, tpProperty->GetDecompoundEquipIndex(), LOCKTYPE_DECOMPOUND );
	}
	
	tpProperty->SetDecompoundEquipIndex( tpMsg->equipmentindex() );	
	tpProperty->GetBaggage()->Lock( tpMsg->equipmentindex(), LOCKTYPE_DECOMPOUND );
	SendLockItemNotice( pPlayer, tpMsg->equipmentindex(), LOCKTYPE_DECOMPOUND );
	
	SendAddDecompoundEquipResponse( pPlayer, SUCCESS, tpMsg->equipmentindex() );
}

// 拿下待分解装备的请求消息
void CPropertyModule::OnMessageTakeDecompoundEquipRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{ 
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	CMessageTakeDecompoundEquipRequest *tpMsg = ( CMessageTakeDecompoundEquipRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	
	tpProperty->GetBaggage()->Lock( tpProperty->GetDecompoundEquipIndex(), LOCKTYPE_NONE );
	SendLockItemNotice( pPlayer, tpProperty->GetDecompoundEquipIndex(), LOCKTYPE_NONE );
	
	SendTakeDecompoundEquipResponse( pPlayer, SUCCESS, tpProperty->GetDecompoundEquipIndex() );
	tpProperty->SetDecompoundEquipIndex( -1 );
}

// 法宝 小洗 放法宝上来
void CPropertyModule::OnMessageMagicWeaponClearPointAddMWRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageMagicWeaponClearPointAddMWRequest *tpMsg = ( CMessageMagicWeaponClearPointAddMWRequest* )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

	CItemObject* pObj = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->mwbagindex());
	LK_ASSERT( pObj, return );

	// 看看是不是法宝
	if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}

	CItemMagicWeapon* tpMW = (CItemMagicWeapon*)pObj;
	CMessageMagicWeaponClearPointAddMWResponse msg;
	msg.set_newpoints( tpMW->GetThisLevelGotPoints() );
	msg.set_newskillpoints( tpMW->GetThisLevelGotSkillPoints() );
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_MAGICWEAPONCLEARPOINT_ADDMWRESPONSE);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 法宝洗点 处理
void CPropertyModule::OnMessageMagicWeaponClearPointRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageMagicWeaponClearPointRequest *tpMsg = ( CMessageMagicWeaponClearPointRequest* )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	// 最新改动 只有大洗才校验NPC
	if ( tpMsg->cleartype() == CLEARTYPE_BIG )
	{
		// 检查NPC服务 合法性
		CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( 
			tpMsg->npcentityid( ) ) );
		if( pNpc == NULL )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
			return ;
		}
		if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
			return;
		}
		CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
		if ( tpNpc == NULL || tpNpc->mMWClearPointService == 0 )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NPCINVALID );
			return;
		}
	}

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	CItemObject* pObj = NULL;

	// 如果是身上的
	int nPos = tpMsg->mwbagindex();
	if ( nPos == -1 )
	{
		pObj = tpProperty->GetEquipment()->GetItemObjPtr(EQUIPMENT_MAGICWEAPON);
		if (pObj == NULL)
		{
			SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
			return;
		}
	}
	else
	{
		pObj = tpProperty->GetBaggage()->GetItemObjPtr(nPos);
		if( pObj == NULL )
			return;
	}
	
	// 看看是不是法宝
	if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}
	CItemMagicWeapon* tpMW = (CItemMagicWeapon*)pObj;
	int tRet = -1;

	pObj = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->stonebagindex());
	LK_ASSERT( pObj, return );

	CTplItem	*tpItem = ( CTplItem* ) CDataStatic::SearchTpl( pObj->GetItemID()  );	
	LK_ASSERT ( tpItem != NULL, return );
	
	if ( tpItem->mItemType != CTplItem::ITEM_FUNCITEM )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_CLEAR_STONE_ERROR );
		return;
	}
	CTplFuncItem* tpTplFuncItem = (CTplFuncItem*)tpItem;
	
	if ( tpMsg->cleartype() == CLEARTYPE_BIG ) // 大洗
	{
		// 判断有没有手动绑定
		if ( (tpMW->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (tpMW->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
			return;
		}

		if ( tpTplFuncItem->mFuncCode != FUNCCODE_MW_WASH_BIG )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_CLEAR_TYPE_ERROR );
			return;
		}
		// 大洗！
		tRet = tpMW->ResetMagicWeapon( pPlayer );
	}
	else if ( tpMsg->cleartype() == CLEARTYPE_SMALL ) // 小洗
	{
		if ( tpTplFuncItem->mFuncCode != FUNCCODE_MW_WASH_SMALL )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_CLEAR_TYPE_ERROR );
			return;
		}
		tRet = tpMW->Return2LastLevel();
	}
	else
	{
		SendProErrorNotice( pPlayer, ERROR_MW_CLEAR_TYPE_ERROR );
		return;
	}

	if ( tRet != 0 ) // 失败
	{
		SendProErrorNotice( pPlayer, tRet );
		return;
	}

	uint64_t ullGUID = pObj->GetGUID();
	int nItemID = pObj->GetItemID();

	// 成功 扣物品
	int tRemoveRet = PlayerRemoveItem( pPlayer, tpMsg->stonebagindex(), 1);
	if ( 0 != tRemoveRet )
	{
		// 扣物品失败？
		LOG_ERROR("pro", "%s remove stone failed? ret=%d player=%s", __FUNCTION__, tRemoveRet, pPlayer->GetCharNameShow() );
		return ;
	}

	LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1); 
	CMessageMagicWeaponClearPointResponse msg;
	msg.set_result(0);
	msg.set_cleartype(tpMsg->cleartype());
	msg.set_mwbagindex(tpMsg->mwbagindex());
	PBItemObject* tpObj = msg.mutable_mwobj();
	tpMW->GetItemBinaryBuffer2( tpObj );
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_MAGICWEAPONCLEARPOINTRESPONSE);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
	//NotifyRefreshMagicWeaponProperty( pPlayer, tpMsg->mwbagindex() );
}

// 才华加点请求
void CPropertyModule::OnMessageAddWizardPointRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return ;
	}

	CMessageAddWizardPointRequest* tpReq = ( CMessageAddWizardPointRequest* ) pMessage->msgpara();

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	
	int tResult = tpProperty->mWizard.AddPoint( tpReq->type() );
	
	CMessage tMessage;
	CMessageAddWizardPointResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDWIZARDPOINT );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_result( tResult );
	tPara.set_type( tpReq->type() );
	tPara.set_increase( tpProperty->mWizard.GetWizardIncrease( tpReq->type() ) );
	tPara.set_commonleft( tpProperty->mWizard.GetWizardIncrease( WIZARD_COMMON ) );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

// 算命请求
void CPropertyModule::OnMessageGetTrendRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	if ( pPlayer == NULL || pMessage == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	CTemplateWizardTable *pTable = (CTemplateWizardTable*)CDataStatic::GetTemp( TEMP_WIZARD );
	if ( pTable == NULL )
	{
		return;
	}
	int tMoney = 0;
	if ( tpProperty->mWizard.GetTrend( ) != 0 )
	{
		tMoney = pTable->mMoney;
	}
	if ( PlayerChangeMoney( pPlayer, tMoney, true, true ) != SUCCESS )
	{
		SendGetTrendResponse( pPlayer, ERROR_GETTREND_NOMONEY, 0 );
		return;
	}
	int tRand = RAND(SERVER_PERCENT_INT);
	int tLowRan = 0, tHighRan = 0;
	if ( tRand < pTable->mKeepRand && tpProperty->mWizard.GetTrend( ) != 0 )
	{
		SendGetTrendResponse( pPlayer, SUCCESS, tpProperty->mWizard.mTrend );
		return;
	}
	else
	{
		tRand = RAND(SERVER_PERCENT_INT);
		for ( int t = 0; t < (int)ARRAY_CNT(pTable->mTrendRand); t ++ )
		{
			tLowRan		+= ( t == 0 ) ? 0 : pTable->mTrendRand[ t - 1 ];
			tHighRan	+= pTable->mTrendRand[ t ];
			if ( tRand >= tLowRan && tRand < tHighRan )
			{
				tpProperty->mWizard.SetTrend( pTable->mTrendResult[ t ] );
				break;
			}
		}
	}
	SendGetTrendResponse( pPlayer, SUCCESS, tpProperty->mWizard.GetTrend( ) );
}

// 发送算命结果
void CPropertyModule::SendGetTrendResponse( CEntityPlayer *pPlayer, int vResult, int vTrend )
{
	CMessage tMessage;
	CMessageGetTrendResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_GETTREND );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_result( vResult );
	tPara.set_trend( vTrend );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// 检查包裹里的东西 如果有当前地图不允许有的 就干掉
void CPropertyModule::CheckBagContent( CEntityPlayer *pPlayer )
{
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	CBaggage* tpBag = tpProperty->GetBaggage();

    CRepetionInfo *tpRepetionInfo =  CRepetionModule::GetSingleton().GetRepetionInfoByMapID(pPlayer->GetMapID());
    int tRepetionIndex = 0;
    if( tpRepetionInfo != NULL)
    {
         tRepetionIndex = tpRepetionInfo->GetRepetionIndex();
    }

	for ( unsigned int i = 0; i < BOX_LIMIT; ++i )
	{
		CItemObject* tpObj = tpBag->GetItemObjPtr(i);
		if ( tpObj != NULL && (tpObj->IsMapLimitedItem( pPlayer->GetMapID()) || tpObj->IsRepetionLimitedItem( tRepetionIndex ) ) )
		{
			CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpObj->GetItemID() );
			if ( tpTplItem == NULL )
			{
				LOG_ERROR( "pro", "can't find item %d in template1", tpObj->GetItemID() );
				continue;
			}
			// 干掉前判断是不是坐骑,是则处理下马逻辑
			if ( tpTplItem->mItemType == CTplItem::ITEM_HORSE )
			{
				if ( tpProperty->GetHorseTempID( ) == tpObj->GetItemID() )
				{
					CTplItemHorse* pTplHorse = (CTplItemHorse*)tpTplItem;
					tpProperty->OffHorse( pTplHorse->mSpeedBuff );
					SendRideHorseNotice( pPlayer, tpObj->GetItemID(), 0 );
				}
			}

			int nItemID = tpObj->GetItemID();
			uint64_t ullGUID = tpObj->GetGUID();
			int nItemNum = tpObj->GetItemNum();
			if (PlayerRemoveItem( pPlayer, i, nItemNum, &ullGUID) == 0)
			{
				LogEventLostItemByDestroyItem(pPlayer, ullGUID, nItemID, nItemNum) ;
			}
		}
	}

	// 检查身上装备的
	for ( unsigned int i = 0; i < EQUIPMENT_MAXPARTCOUNT; ++i )
	{
		CItemObject* tpObj = tpProperty->GetEquipment()->GetItemObjPtr(i);
		if ( tpObj != NULL && (tpObj->IsMapLimitedItem( pPlayer->GetMapID()) || tpObj->IsRepetionLimitedItem( tRepetionIndex ) ) )
		{
			// 非法持有 要干掉
			CSceneObjManager::GetSingletonPtr()->DestroyObject(tpObj->get_id());
			tpProperty->GetEquipment()->SetIndexNull(i);
		} 

		// 检查是否有该过期的东西
		if ( tpObj != NULL )
		{
			CTemplateEquipment* tpEquip = (CTemplateEquipment*) CDataStatic::SearchTpl( tpObj->GetItemID() );	
			LK_ASSERT( tpEquip!=NULL, continue );
			// 如果有 有效时间，而且是装备后开启 检查 如果还没有过期时间 则赋值&通知
			if ( tpEquip->mValidTime > 0 && tpEquip->mValidType == VALIDTYPE_EQUIP && tpObj->GetInvalidTime() == 0 )
			{
				SetItemValidTime( pPlayer, (CTplItem*)tpEquip, tpObj );
			}
		}
	}
	
	// TODO::检查包裹背包里面的物品
	//for ( int i = 0; i < tpProperty->GetBaggage()->GetKitBagIndex(); ++i )
	//{
	//	int tBeginIndex = 0;
	//	int tEndIndex	= 0;
	//	int tRet = tpProperty->GetBaggage()->GetKitBagIndexRange( BAGTYPE_KITBAG, i, tBeginIndex, tEndIndex );
	//	if ( tRet != SUCCESS )
	//	{
	//		continue;
	//	}
	//	for ( int K = tBeginIndex; K <= tEndIndex; ++K )
	//	{
	//		CItemObject* tpObj = tpProperty->GetBaggage()->GetItemObjPtr(K);
	//		if ( tpObj != NULL && tpObj->IsMapLimitedItem( pPlayer->GetMapID()) )	
	//		{
	//				
	//			// 非法持有 要干掉
	//			CSceneObjManager::GetSingletonPtr()->DestroyObject(tpObj->get_id());
	//			tpProperty->GetBaggage()->SetIndexNull(K);
	//		} 
	//	}
	//}
	//
}

void CPropertyModule::SendClientCtrlInfo(CEntityPlayer *pPlayer)
{
	CMessageClientRunTimeParamNotify msg;
	mClientCtrlData.FillMessage(&msg);
	CMessage tMessage;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_RUNTIMEPARAM );
	tMessage.set_msgpara( (long) &msg );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::OnMessageGetHelpRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageGetHelpDataRequest* tpReq = ( CMessageGetHelpDataRequest* ) pMessage->msgpara();
	LK_ASSERT( tpReq != NULL , return );

	CActivityModule::GetSingleton().SendHelpInfo2Client( pPlayer );
}


// 设置到期时间
void CPropertyModule::SetItemValidTime( CEntityPlayer* pPlayer, CTplItem* pTplItem, CItemObject* pItemObj)
{
	if (pTplItem==NULL || pItemObj==NULL)
		return;
	if (pItemObj->GetInvalidTime() != 0 )
		return;
	pItemObj->SetInvalidTime( time(0) + pTplItem->mValidTime*60 );
	//记录限时道具第一次使用时间

	LogEventStartUseTimeItem(pPlayer,pItemObj->GetGUID(),pItemObj->GetItemID(),1);

	StartItemValidTimer(pPlayer,pItemObj);
}

// 开始到期处理定时器
void CPropertyModule::StartItemValidTimer( CEntityPlayer* pPlayer, CItemObject* pItemObj)
{
	unsigned int tSecs = (pItemObj->GetInvalidTime() - time(0));
	if ( tSecs > 0 )
	{
		int nTimerOtherInfo[ TIMER_OTHER_INFO ] = { MESSAGE_PROPERTY, pItemObj->get_id(), 0, 0};
		pItemObj->SetValidTimerID(
			pPlayer->GetTimerReciver()->SetTimerBySec( pPlayer->GetEntityID(), TIMER_ITEM_DESTROY
			, tSecs, 2, nTimerOtherInfo ) );
	}
}

// 时间到 物品销毁
void CPropertyModule::OnTimeoutMessageDestroyItem(CMessage* pMsg)
{
	if ( pMsg == NULL )
	{
		return ;
	}
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntityPlayer* pTimerOwner = (CEntityPlayer*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	CItemObject* tpObj = (CItemObject*)CSceneObjManager::GetSingleton().GetObject(pTimerItem->mOtherInfo[1]);
	if ( tpObj != NULL )
	{
		// 判断是否真的到期了
		if ( tpObj->GetInvalidTime() <= ((unsigned int)time(0)+SEC_TIMER_ALLOW_MISTAKE) ) // 真到期了
		{
			OnPlayerItemOverTime(pTimerOwner, tpObj, POS_NULL, 1 ); // 未知位置
		}
		else
		{
			// 错误。。。
			LOG_ERROR("pro", "OVERTM:timer(%d) sec:%d mark:%d called:%d OBJ invtime:%d now:%d tempid:%d entityid:%d timer_iscleared:%d timer_miilsecs:%d Player(%d:%d)",
				pTimerItem->get_id(), pTimerItem->mSeconds, pTimerItem->mTimerMark, pTimerItem->mCalledNum, 
				tpObj->GetInvalidTime(), (unsigned int)time(0), tpObj->GetItemID(), tpObj->get_id(), 
				pTimerItem->mIsCleared, pTimerItem->mMillSeconds, pTimerOwner->GetCharID(), pTimerOwner->GetEntityID() );
			if ( pTimerItem->mCalledNum != 0 ) // 打印堆栈
				print_trace_fd("pro");
			pTimerOwner->GetTimerReciver()->ClearTimer(pTimerItem->get_id());
			return;
		}
	}
	else
	{
		LOG_ERROR("pro", "[%s:%s:%d] Can't find player %s's item(id=%d)", __LK_FILE__, __FUNCTION__, __LINE__, pTimerOwner->GetCharNameShow(), pTimerItem->mOtherInfo[1] );
		pTimerOwner->GetTimerReciver()->ClearTimer(pTimerItem->get_id());
	}
}

// 时间到 称号销毁
void CPropertyModule::OnTimeOutMessageTitleDisappear(CMessage* pMsg)
{
	if ( pMsg == NULL )
	{
		return ;
	}
	CTimerItem* pTimerItem = (CTimerItem*) pMsg->msgpara();
	CEntityPlayer* pTimerOwner = (CEntityPlayer*) CSceneObjManager::GetSingletonPtr()->GetObject( pTimerItem->mOwnerID );
	if( pTimerOwner == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] Can't find Entity %d", __LK_FILE__, __FUNCTION__, __LINE__, pTimerItem->mOwnerID );
		CTimerMng::GetSingletonPtr()->ClearTimer( pTimerItem->get_id() );
		return;
	}

	// 干掉称号
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pTimerOwner->GetProperty();
	tpProperty->RemoveTitle( pTimerItem->mOtherInfo[1] );
	if ( pTimerItem->mOtherInfo[1] == tpProperty->GetCurrentTitle() )
	{
		tpProperty->SetCurrentTitle( 0 );
		CPropertyModule::GetSingleton().SendNotifyUpdateCurrentTitle( pTimerOwner, 0 );
	}
	CPropertyModule::GetSingleton().SendNotifyClientUpdateTitle( pTimerOwner, TITLE_DELETE, pTimerItem->mOtherInfo[1] );

	// 干掉定时器
	pTimerOwner->GetTimerReciver()->ClearTimer(pTimerItem->get_id());

}
// 遍历包裹、仓库东西，看是不是有过期的 没有的 开启定时器<在发送数据之后调用的>
void CPropertyModule::CheckPlayerItems( CEntityPlayer* pPlayer )
{
	if ( pPlayer == NULL )
		return;
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();

	// 检查装备
	for ( unsigned int i = 0; i < EQUIP_LIMIT; ++i )
	{
		CItemObject* tpObj = tpPro->GetEquipment()->GetItemObjPtr(i);
		if ( tpObj == NULL )
			continue;

		if ( tpObj->GetInvalidTime() != 0 )
		{
			if ( tpObj->GetInvalidTime() <= (unsigned int)time(0) ) // 到期了
			{
				//tpPro->GetStorage()->RemoveItem(i);
				OnPlayerItemOverTime( pPlayer, tpObj, POS_EQUIPMENT, 0 );
			}
			else
			{
				StartItemValidTimer( pPlayer, tpObj );
			}
		}
	}

	// 检查包
	for ( unsigned int i = 0; i < BOX_LIMIT; ++i )
	{
		CItemObject* tpObj = tpPro->GetBaggage()->GetItemObjPtr(i);
		if ( tpObj == NULL )
			continue;

		if ( tpObj->GetInvalidTime() != 0 )
		{
			if ( tpObj->GetInvalidTime() <= (unsigned int)time(0) ) // 到期了
			{
				// tpPro->GetBaggage()->RemoveItem(i);
				OnPlayerItemOverTime( pPlayer, tpObj, POS_BAGGAGE, 0 );
			}
			else
			{
				StartItemValidTimer( pPlayer, tpObj );
			}
		}
	}
	
	// 检查仓库
	for ( unsigned int i = 0; i < tpPro->GetStorage()->mReleaseIndex && i < BOX_LIMIT; ++i )
	{
		CItemObject* tpObj = tpPro->GetStorage()->GetItemObjPtr(i);
		if ( tpObj == NULL )
			continue;

		if ( tpObj->GetInvalidTime() != 0 )
		{
			if ( tpObj->GetInvalidTime() <= (unsigned int)time(0) ) // 到期了
			{
				//tpPro->GetStorage()->RemoveItem(i);
				OnPlayerItemOverTime( pPlayer, tpObj, POS_STORAGE, 0 );
			}
			else
			{
				StartItemValidTimer( pPlayer, tpObj );
			}
		}
	}
	
	// 检查仓库背包
	for ( int i = 0; i < tpPro->GetStorage()->GetKitBagIndex(); ++i )
	{
		int tBeginIndex = -1;
		int tEndIndex	= -1;
		int tRet = tpPro->GetStorage()->GetKitBagIndexRange( BAGTYPE_KITBAG, i, tBeginIndex, tEndIndex );
		if ( tRet != SUCCESS )
		{
			continue;
		}
		
		for ( int j = tBeginIndex; j <= tEndIndex; ++j )
		{
			CItemObject* tpObj = tpPro->GetStorage()->GetItemObjPtr(j);
			if ( tpObj == NULL )
				continue;

			if ( tpObj->GetInvalidTime() != 0 )
			{
				if ( tpObj->GetInvalidTime() <= (unsigned int)time(0) ) // 到期了
				{				
					OnPlayerItemOverTime( pPlayer, tpObj, POS_STORAGE, 0 );
				}
				else
				{
					StartItemValidTimer( pPlayer, tpObj );
				}
			}
		}
	}
}

// 囚禁玩家 [12/14/2009 Macro]
// npPlayer :		囚犯对象, 
// nPrisonTime :	囚禁时间(毫秒)
// return : -1 失败, 0 成功
int CPropertyModule::OnEventCoopEntity(CEntityPlayer *npPlayer, int nPrisonTime)
{
	if ( npPlayer == NULL || nPrisonTime == 0 )
	{
		return -1;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();

	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		return -1;
	}

	// 已经在监狱
	if ( npPlayer->GetMapID() == tpTable->mMapID )
	{
		return -1;
	}

	bool bTeleRes = false;
	int tPrisonTime = tpProperty->GetPrisonTime( );
	int tTotalPrisonTime = tpProperty->GetTotalPrisonTime( );

	tpProperty->SetPrisonTime( 0 );
	tpProperty->SetTotalPrisonTime( nPrisonTime );

	bTeleRes = CMapModule::GetSingleton().Teleport( npPlayer->GetNationality(), tpTable->mMapID, tpTable->mPosX, tpTable->mPosY, npPlayer );
	
	if ( bTeleRes  )
	{
		SendPrisonTimeNotice( npPlayer, nPrisonTime );
	}
	else
	{
		tpProperty->SetPrisonTime( tPrisonTime );
		tpProperty->SetTotalPrisonTime( tTotalPrisonTime );
	}

	return SUCCESS;
}

// 监狱释放 [1/8/2010 Macro]
int CPropertyModule::OnEventUnCoopEntity(CEntityPlayer *npPlayer)
{
	if ( npPlayer == NULL )
	{
		return -1;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();

	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		return -1;
	}

	// 检查是否在监狱
	if ( npPlayer->GetMapID() != tpTable->mMapID )
	{
		return -1;
	}

	bool bTeleRes = false;
	bTeleRes = CMapModule::GetSingleton().Teleport( npPlayer->GetLineID(), tpTable->mFreeMapID, tpTable->mFreePosX, tpTable->mFreePosY, npPlayer );
	if ( bTeleRes )
	{
		tpProperty->SetPKValue( 0 );		
		tpProperty->SetPrisonTime( 0 );
		tpProperty->SetTotalPrisonTime( 0 );
		SendPKValueMessage( npPlayer, 0 );
	}

	return SUCCESS;
}

// 发送监狱囚禁时间倒计时 [12/14/2009 Macro]
void CPropertyModule::SendPrisonTimeNotice( CEntityPlayer* npPlayer, int nPrisonTime )
{
	if ( npPlayer == NULL )
	{
		return ;
	}

	// 囚禁时间单位： 毫秒

	CMessage tMessage;
	CMessageProPrisonTimeNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_PRISONTIME );
	tPara.set_time( nPrisonTime );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( npPlayer, &tMessage );
	
	return ;
}

// 给玩家发送监狱倒计时 [12/15/2009 Macro]
void CPropertyModule::OnEventNotifyPrisonTime(CEntityPlayer *npPlayer)
{
	if ( npPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();
	
	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		return ;
	}

	// 不在监狱
	if ( npPlayer->GetMapID() != tpTable->mMapID )
	{
		return ;
	}

	int tPrisonTime = std::max( 0, tpProperty->GetTotalPrisonTime() - tpProperty->GetPrisonTime() );
	if ( tPrisonTime > 0 )
	{
		SendPrisonTimeNotice( npPlayer, tPrisonTime );
	}

	return ;
}

void CPropertyModule::SendPickItemResponse( CEntityPlayer *pPlayer, int vEntityID )
{
	CMessage tMessage;
	CMessagePickItemNotify tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_PICKITEM );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_entityid( vEntityID );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// 刷新称号附加属性 [12/17/2009 Macro]
void CPropertyModule::RefreshTitleAddProperty( CEntityPlayer* npPlayer )
{
	if ( npPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();


	int tTitle = tpProperty->GetCurrentTitle();
	if ( tTitle == 0 )
	{
		return ;
	}

	CTitle* tpTitle = ( CTitle* ) CDataStatic::GetTitle( tTitle );
	if ( tpTitle == NULL )
	{
		return ;
	}
	
	CTemplateSkill* tpSkill = ( CTemplateSkill* ) CDataStatic::SearchTpl( tpTitle->mAddProperty );
	if ( tpSkill == NULL )
		return ;

	tpProperty->mTitleSkill.InsertSkill( tpSkill->mSkillID, 1 );

	tpProperty->Refresh();
	npPlayer->NotifyPropertyRefresh();

	return ;
}

void CPropertyModule::SendBindItemNotify( CEntityPlayer* pPlayer, int vIndex, int vStatus )
{
	CMessage tMessage;
	CMessageNotifyItemBinded tNotify;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_C2S_NOTIFY_ITEMHASBINDED );

	tNotify.set_itempos( SLOT_BAGGAGE );
	tNotify.set_itemindex( vIndex );
	tNotify.set_bindstatus( vStatus );

	tMessage.set_msgpara( (uint32)&tNotify );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// 玩家的限时物品到时间了处理
// 参数表：玩家，目标物品，物品所在位置
int CPropertyModule::OnPlayerItemOverTime( CEntityPlayer* pPlayer, CItemObject* pItemObj, EPosType posType, int nTimeoutType  )
{
	LK_ASSERT( pPlayer!=NULL, return -1 );
	LK_ASSERT( pItemObj!=NULL, return -1 );

	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
	int tIndex = -1;

	// 先停timer 防止等会物品变成野指针了
	if ( pItemObj->GetValidTimerID() != INVALID_OBJ_ID)
	{
		pPlayer->GetTimerReciver()->ClearTimer(pItemObj->GetValidTimerID());
		pItemObj->SetValidTimerID(INVALID_OBJ_ID);
	}

	// 查到物品具体位置
	if (posType == POS_NULL)
	{
		// 先查装备
		tIndex = tpPro->GetEquipment()->GetIndexByObjID(pItemObj->get_id());
		if (tIndex < 0)
		{
			// 检查包裹
			tIndex = tpPro->GetBaggage()->GetIndexByObjID(pItemObj->get_id());
			if (tIndex < 0)
			{
				// 检查仓库
				tIndex = tpPro->GetStorage()->GetIndexByObjID(pItemObj->get_id());
				if (tIndex < 0)
				{
					LOG_ERROR("pro", "no such obj?? player=%s objid=%d tempid=%d"
						, pPlayer->GetCharNameShow(), pItemObj->get_id(), pItemObj->GetItemID());
					return -2;
				}
				else
				{
					posType = POS_STORAGE;
				}
			}
			else
			{
				posType = POS_BAGGAGE;
			}
		}
		else
		{
			posType = POS_EQUIPMENT;
		}
	}

	// 检查物品类型
	CTplItem* tpItem = (CTplItem*)CDataStatic::SearchTpl(pItemObj->GetItemID());
	LK_ASSERT( tpItem != NULL, return -4 );

	// 根据物品类型来处理
	int tOprResult = -1; // 处理结果 TODO 以后用枚举
	switch( tpItem->mItemType )
	{
	case CTplItem::ITEM_TELESYMBOL: // 传送符 目前是让他消失
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_TELEPORT: // 也是传送符 目前是让他消失
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_PHYSIC: // 药品要消失
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_BOOK: // D类物品（技能书）要消失
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_FUNCITEM: // 功能性物品 干掉
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_HORSE: // 坐骑 先下马 再消失
		{
			if ( tpPro->GetHorseTempID( ) == pItemObj->GetItemID() )
			{
				CTplItemHorse* pTplHorse = (CTplItemHorse*)tpItem;
				tpPro->OffHorse( pTplHorse->mSpeedBuff );
				SendRideHorseNotice( pPlayer, pItemObj->GetItemID(), 0 );
			}
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_WEAPON:
	case CTplItem::ITEM_ARMOR:
	case CTplItem::ITEM_FASHION:
		{
			tOprResult = 1;
			break;
		}
	case CTplItem::ITEM_MAGICWEAPON: // 法宝 干掉
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_GIFTBAG: // 礼包类 干掉
		{
			tOprResult = 0;
			break;
		}
	case CTplItem::ITEM_SCROLL:
		{
			tOprResult = 0;
			break;
		}
	default:
		{
			// 不处理
			break;
		}
	}

	if (tOprResult != -1) // 要处理
	{
		switch(posType)
		{
		case POS_EQUIPMENT:
			{
				if (tIndex == -1)
				{
					tIndex = tpPro->GetEquipment()->GetIndexByObjID(pItemObj->get_id());
				}

				if (tOprResult == 0) // 删除
				{
					// 强制卸下
					unsigned int tIdx= (~0);
					CPropertyModule::UnEquipItem( pPlayer, tIndex, tIdx, true );
					if ( (int)tIdx != (~0) )
					{
						// 卸到包里了！！干掉！
						CItemObject* pDes=tpPro->GetBaggage()->GetItemObjPtr(tIdx);
						if ( pDes != NULL )
						{
							uint64_t tGuid = pDes->GetGUID();
							unsigned int tItemid = pDes->GetItemID();
							if ( 0==PlayerRemoveItem( pPlayer, tIdx, pDes->GetItemNum() ) )
							{
								LogEventLostItemByTimeOut( pPlayer, tGuid, tItemid, 1, posType, nTimeoutType );
							}
						}
						else
						{
							LOG_ERROR("pro", "no ovettm mw? idx %d", tIdx );
						}
					}
					else // 包裹满！直接干掉！
					{
						CItemObject* pDes=tpPro->GetEquipment()->GetItemObjPtr(tIndex);
						if ( pDes != NULL )
						{
							uint64_t tGuid = pDes->GetGUID();
							unsigned int tItemid = pDes->GetItemID();
							SendRemoveItemNotice(pPlayer, POS_EQUIPMENT, tIndex, 1);
							LogEventLostItemByTimeOut( pPlayer, tGuid, tItemid, 1, POS_EQUIPMENT, nTimeoutType );
						}
					}
				}
				else if ( tOprResult == 1 ) // 卸下
				{
					// 各种装备。。先刷属性 再通知客户端卸装
					tpPro->Refresh( );
					pPlayer->NotifyPropertyRefresh( );

					//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体
					CMessage tPlayerChange;
					CMessagePlayerChangeEquipNotice tMessage;
					bool vBool = false;
					CItemMagicWeapon* tpMW = (CItemMagicWeapon*)tpPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_MAGICWEAPON );
					int tMWID = 0;
					int tMWQLID = 0;
					if ( tpMW != NULL && tpMW->IsOvertimed() == false )
					{
						tMWID = tpMW->GetItemID();
						tMWQLID = tpMW->GetCurQL();
					}
					CItemEquipment* tpFashion = (CItemEquipment*)tpPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_FASHION );
					int tFashionID = 0;
					if ( tpFashion != NULL && tpFashion->IsOvertimed() == false )
					{
						tFashionID = tpFashion->GetItemID();
					}
					CItemEquipment* tpMarriageEquip = ( CItemEquipment * )tpPro->GetEquipment()->GetItemObjPtr( EQUIPMENT_MARRY );
					int tMarrageEquipID = 0;
					if ( tpMarriageEquip != NULL && tpMarriageEquip->IsOvertimed() == false )
					{
						tMarrageEquipID = tpMarriageEquip->GetItemID();
					}
					
					int tWeaponLevel = 0, tChestLevel = 0, tWeaponJewel = 0, tChestJewel = 0;
					tpPro->GetEquipment()->GetLightPoint( tWeaponLevel, tChestLevel, tWeaponJewel, tChestJewel );
					vBool = CreateMessagePlayerChangeEquipNotice(
						&tPlayerChange,
						&tMessage,
						pPlayer->GetEntityID(),
						tIndex,
						0,
						tpPro->GetCurHP( ),
						tpPro->GetCurMP( ),
						tpPro->GetMaxHP( ),
						tpPro->GetMaxMP( ),
						tWeaponLevel,tChestLevel,tWeaponJewel,tChestJewel,
						tMWID,
						tFashionID,
						tMarrageEquipID,
						tMWQLID
						);
					if ( vBool == true )
					{
						CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tPlayerChange, false, true );
					}

					// 通知自己 装备到期啦
					CMessageEquipmentOverdueNotify noti;
					noti.set_equipindex(tIndex);
					noti.set_pos_type(POS_EQUIPMENT);
					CMessage tMessage2;
					tMessage2.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_EQUIPOVERDUE );
					tMessage2.set_msgpara( (long) &noti );
					CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage2 ); 
				}
				break;
			}
		case POS_BAGGAGE:
			{
				if (tIndex == -1)
				{
					tIndex = tpPro->GetBaggage()->GetIndexByObjID(pItemObj->get_id());
				}

				if (tOprResult == 0) // 删除
				{
					uint64_t tGuid = pItemObj->GetGUID();
					unsigned int tItemid = pItemObj->GetItemID();
					if ( 0==PlayerRemoveItem( pPlayer, tIndex, pItemObj->GetItemNum() ) )
					{
						LogEventLostItemByTimeOut( pPlayer, tGuid, tItemid, 1, posType, nTimeoutType );
					}
				}
				else if ( tOprResult == 1 ) // 装备，要通知客户端
				{
					CMessageEquipmentOverdueNotify noti;
					noti.set_equipindex(tIndex);
					noti.set_pos_type(POS_BAGGAGE);
					CMessage tMessage2;
					tMessage2.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_EQUIPOVERDUE );
					tMessage2.set_msgpara( (long) &noti );
					CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage2 ); 
				}
				break;
			}
		case POS_STORAGE:
			{
				if (tIndex == -1)
				{
					tIndex = tpPro->GetStorage()->GetIndexByObjID(pItemObj->get_id());
				}

				if (tOprResult == 0) // 删除
				{
					uint64_t tGuid = pItemObj->GetGUID();
					unsigned int tItemid = pItemObj->GetItemID();
					PlayerThrowStorItem( pPlayer, tIndex, pItemObj->GetItemNum(), true );		
					LogEventLostItemByTimeOut( pPlayer, tGuid, tItemid, 1, posType, nTimeoutType );
				}
				break;
			}
		default:
			{
				break;
			}
		}
	}
	return 0;
}

// 检查玩家包裹里有没有绝对时间过期的东西
void CPropertyModule::CheckItemInvilidDate( CEntityPlayer* pPlayer, bool bIsNotify )
{
	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	int nYMD = GetYYYYMMDD( time(NULL) );

	CBaggage* tpBag = tpProperty->GetBaggage();
	for ( unsigned int i = 0; i < BOX_LIMIT; ++i )
	{
		CItemObject* tpObj = tpBag->GetItemObjPtr(i);
		if ( tpObj != NULL )
		{
			CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpObj->GetItemID() );
			if ( tpTplItem == NULL )
			{
				LOG_ERROR( "pro", "can't find item %d in template1x", tpObj->GetItemID() );
				continue;
			}

			// TODO 目前规则，只要是过了绝对时间，就干掉
			if ( tpTplItem->mInvilidDate != 0 && nYMD >= tpTplItem->mInvilidDate )
			{
				int nItemID = tpObj->GetItemID();
				uint64_t ullGUID = tpObj->GetGUID();
				int nItemNum = tpObj->GetItemNum();
				if (bIsNotify)
				{
					PlayerRemoveItem( pPlayer, i, nItemNum, &ullGUID) ;
				}
				else
				{
					tpBag->RemoveItem(i, nItemNum );
				}
				LogEventLostItemByTimeOut(pPlayer, ullGUID, nItemID, nItemNum, POS_BAGGAGE, 4) ;
			}
		}
	}

	// 检查仓库
	CStorage* tpStorage = tpProperty->GetStorage();
	for ( unsigned int i = 0; i < BOX_LIMIT; ++i )
	{
		CItemObject* tpObj = tpStorage->GetItemObjPtr(i);
		if ( tpObj != NULL )
		{
			CTplItem* tpTplItem = (CTplItem*) CDataStatic::SearchTpl( tpObj->GetItemID() );
			if ( tpTplItem == NULL )
			{
				LOG_ERROR( "pro", "can't find item %d in template3x", tpObj->GetItemID() );
				continue;
			}

			// TODO 目前规则，只要是过了绝对时间，就干掉
			if ( tpTplItem->mInvilidDate != 0 && nYMD >= tpTplItem->mInvilidDate )
			{
				uint64_t tGuid = tpObj->GetGUID();
				unsigned int tItemid = tpObj->GetItemID();
				int nItemNum = tpObj->GetItemNum();
				if (bIsNotify)
				{
					PlayerThrowStorItem( pPlayer, i, nItemNum, true );		
				}
				else
				{
					tpStorage->RemoveItem(i, nItemNum );
				}
				LogEventLostItemByTimeOut( pPlayer, tGuid, tItemid, nItemNum, POS_STORAGE, 4 );
			}
		}
	}
}

// 玩家请求传送道具的传送点列表
void CPropertyModule::OnMessageGetTeleList( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL, return );
	LK_ASSERT( pMessage != NULL, return );

	CMessageGetTeleListRequest *pMsg = ( CMessageGetTeleListRequest* )pMessage->msgpara( );

	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
	CMessage tMessage;
	CMessageGetTeleListResponse tPara;
	for ( int i = 0; i < TELE_LIST_SIZE; ++i )
	{
		ComplexPos* tpPos = tpPro->GetTelePos( i );
		if ( tpPos != NULL )
		{
			PBTelePostion* tpPBPos = tPara.add_telelist();
			tpPBPos->set_line( tpPos->mLineID );
			tpPBPos->set_map( tpPos->mMapID );
			tpPBPos->set_posx( tpPos->mPos.mX );
			tpPBPos->set_posy( tpPos->mPos.mY );
		}
		else
		{
			break;
		}
	}
	tPara.set_bagindex( pMsg->bagindex());

	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_GETTELELIST );
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// 玩家添加传送点
void CPropertyModule::OnMessageAddTelePoint( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL, return );
	LK_ASSERT( pMessage != NULL, return );
	
	if ( CDataStatic::IsWeddingHall( pPlayer->GetMapID() ) == true  )
	{
		SendProErrorNotice( pPlayer, EM_MARRIAGE_TELEPORT_INVALIDMAP );
		return;
	}	

	// 如果是阻挡 不让记录
	CWTPoint pos	= pPlayer->GetPos();
	if (CMapModule::GetSingleton().IsStaticBlock( pPlayer->GetLineID(), pPlayer->GetMapID(), pPlayer->GetMapIndex(), pos ) )
	{
		SendProErrorNotice( pPlayer, ERROR_CANT_ADD_TELEPOINT );
		return;
	}

	// 监狱，不让记录
	CTplPKValueTable* tpPKTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpPKTable == NULL )
	{
		LOG_ERROR( "pro", "get template point failed.[%s:%d]", __LK_FILE__, __LINE__ );
		return;
	}
	if (pPlayer->GetMapID() == tpPKTable->mMapID)
	{
		SendProErrorNotice( pPlayer, ERROR_CANT_ADD_TELEPOINT );
		return;
	}

	// 只有在本国和在中立区
	if ( pPlayer->GetLineID() == pPlayer->GetNationality() || IS_NEUTRAL_LINE_ID(pPlayer->GetLineID() ) )
	{
		CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
		ComplexPos now;
		now.mLineID = pPlayer->GetLineID();
		now.mMapID  = pPlayer->GetMapID();
		now.mPos	= pPlayer->GetPos();

		if ( tpPro->AddTelePos( now ) == 0 )
		{
			CMessage tMessage;
			CMessageAddTelePointResponse tPara;
			PBTelePostion* tpPos = tPara.mutable_telepoint();

			tpPos->set_line(now.mLineID);
			tpPos->set_map( now.mMapID );
			tpPos->set_posx( now.mPos.mX );
			tpPos->set_posy( now.mPos.mY );

			tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDTELEPOINT );
			tMessage.set_msgpara( (long) &tPara );
			CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
			return;
		}
		else
		{
			SendProErrorNotice( pPlayer, ERROR_OVERMAX_TELE_LISTS );
			return;
		}
	}
	else
	{
		SendProErrorNotice( pPlayer, ERROR_CANT_ADD_TELEPOINT );
		return;
	}
}

// 玩家删除传送点
void CPropertyModule::OnMessageDelTelePoint( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL, return );
	LK_ASSERT( pMessage != NULL, return );

	CMessageDelTelePointRequest *pMsg = ( CMessageDelTelePointRequest* )pMessage->msgpara( );
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
	if ( 0 == tpPro->DelTelePos( pMsg->index() ) )
	{
		CMessage tMessage;
		CMessageDelTelePointResponse tPara;
		tPara.set_index(pMsg->index());
		tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_DELTELEPOINT );
		tMessage.set_msgpara( (long) &tPara );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	}
}

// 玩家使用传送道具 重游符
void CPropertyModule::OnMessageUseTeleItem( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL, return );
	LK_ASSERT( pMessage != NULL, return );
	CMessageUseTeleItemRequest *pMsg = ( CMessageUseTeleItemRequest* )pMessage->msgpara( );
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
	
	// 检查读秒时间
	if ( tpPro->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_TELEPORT, pPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progress time when use teleitem, roleid:%d", pPlayer->GetCharID() );
		return;
	}
	
	if ( CDataStatic::IsWeddingHall( pPlayer->GetMapID() ) == true  )
	{
		SendProErrorNotice( pPlayer, EM_MARRIAGE_TELEPORT_INVALIDMAP );
		return;
	}		 

	// 不能传送，不让用
	if ( !tpPro->CanTeleport() )
		return;

	// 检查包裹的物品是否合法
	CItemObject* tpObj = (CItemObject*)tpPro->GetBaggage()->GetItemObjPtr(pMsg->bagindex());
	if ( tpObj == NULL )
		return;

	CTplItemTeleport* tpTplItem = (CTplItemTeleport*)CDataStatic::SearchTpl(tpObj->GetItemID());
	if ( tpTplItem == NULL)
		return;

	if ( tpTplItem->mMapID != TELE_LIST )
		return;

	// 如果是时间型的而且是首次使用开始计时
	if ( tpObj->GetInvalidTime() == 0 && tpTplItem->mValidTime > 0 && tpTplItem->mValidType == VALIDTYPE_USE )
	{
		SetItemValidTime( pPlayer, tpTplItem, tpObj );
		NotifyClientStartTimer( pPlayer, POS_BAGGAGE, pMsg->bagindex(), tpObj->GetInvalidTime() );
	}

	if ( ((tpObj->GetInvalidTime() != 0 )&&tpObj->GetInvalidTime() <= (unsigned int)time(0))
		|| ( (tpTplItem->mUseTimes>0)&&(tpObj->GetUsedTimes() >= tpTplItem->mUseTimes) ) )
	{
		SendProErrorNotice( pPlayer, ERROR_ITEM_INVALID );
		return;
	}

	// 检查当前地图能否使用
	CMapTpl* tpMapTpl = CMapTplManager::GetSingleton().GetMapTplByID( pPlayer->GetMapID() );
	if ( tpMapTpl == NULL )
	{
		LOG_FATAL("default", "can't find MAP! id=%d", pPlayer->GetMapID() );
		return;
	}

	if ( tpMapTpl->mTeleItem == false  )
	{
		SendProErrorNotice(pPlayer, ERROR_ITEM_NOTEVENT);
		return;
	}

	// 可以用了 先记录次数
	tpObj->SetUsedTimes( tpObj->GetUsedTimes()+1 );

	// 如果不是跨服 给客户端回复 使用成功
	ComplexPos* tpPos = tpPro->GetTelePos(pMsg->index());
	if ( tpPos == NULL )
	{
		return;
	}
	if ( pPlayer->GetLineID() == tpPos->mLineID )
	{
		SendUseItemResponse( pPlayer, 0, POS_BAGGAGE, pMsg->bagindex(), tpObj->GetItemID(), tpObj->GetUsedTimes() );
	}

	// 如果达到最大使用次数了 干掉
	if ((tpTplItem->mUseTimes>0) && (tpObj->GetUsedTimes() >= tpTplItem->mUseTimes))
	{
		uint64_t ullGUID = tpObj->GetGUID();
		int nItemID = tpObj->GetItemID();

		if (PlayerRemoveItem( pPlayer, pMsg->bagindex(), 1) == 0)
		{
			LogEventLostItemByUse( pPlayer, ullGUID, nItemID, 1);
		}
	}

	if ( tpPro != NULL )
	{
		CMapModule::GetSingleton().Teleport( tpPos->mLineID, tpPos->mMapID, tpPos->mPos.mX, tpPos->mPos.mY, pPlayer );
	}
}

// 使用会员道具 [1/6/2010 Macro]
int CPropertyModule::OnUseVipItem(CEntity *pEntity, CTplItem *tpItem, int vIndex)
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return ERROR_CANNUSEITEM;
	}

	CEntityPlayer*		tpPlayer = ( CEntityPlayer* ) pEntity;
	CPropertyPlayer*	tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();

	// 检查包裹的物品是否合法
	CItemVip* tpObj = dynamic_cast <CItemVip*> ( tpProperty->GetBaggage()->GetItemObjPtr(vIndex) );
	if ( tpObj == NULL )
	{
		return ERROR_CANNUSEITEM;
	}
	

	CTplItemVip* tpItemVip = ( CTplItemVip* ) tpItem;

	// 会员道具有效验证
	if ( tpItemVip->mVipTime <= 0 || tpItemVip->mVipLevel == CTplItemVip::emVipNone )
	{
		return ERROR_INVALIDVIP;
	}

	// 会员到期日期
	// 如果已经是会员，续费续时
	int tTime = 0;
	if ( tpProperty->IsVip() )
	{
		tTime = tpProperty->GetVipTime() +  tpItemVip->mVipTime * 3600;
	}
	else
	{
		tTime = time(NULL) +  tpItemVip->mVipTime * 3600;
	}

	tpProperty->OpenVip( tTime );
	SendVipFlagUpdateToGate( tpPlayer );

	// 可见范围通知，玩家开通会员功能
	SendVipNotice( tpPlayer, true );

	uint64_t ullGUID = tpObj->GetGUID();
	int nItemID = tpObj->GetItemID();
	// remove item
	if ( PlayerRemoveItem( tpPlayer, vIndex, 1) == 0)
	{
		LogEventLostItemByUse( tpPlayer, ullGUID, nItemID, 1);
	}

	return SUCCESS;	 
}

// 会员通知 [1/6/2010 Macro]
void CPropertyModule::SendVipNotice( CEntityPlayer* npPlayer, bool bFlag )
{
	if ( npPlayer == NULL )
	{
		return ;
	}

	CMessage tMessage;
	CMessageProVipNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_VIPNOTICE );
	tMessage.set_msgpara( (long) &tPara );

	tPara.set_charid( npPlayer->GetCharID() );
	tPara.set_status( (int) bFlag );
	tPara.set_time( ((CPropertyPlayer*)npPlayer->GetProperty())->GetVipTime() );

	CMapModule::GetSingleton().MessageBroadCast( npPlayer, &tMessage, false, true );
	return ;
}

// vip refresh [1/6/2010 Macro]
void CPropertyModule::RefreshVip( CEntityPlayer* npPlayer )
{
	if ( npPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer*	tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();

	if ( !tpProperty->IsVip() )
	{
		return ;
	}

	time_t tNow = time( NULL );

	if ( tNow >= tpProperty->GetVipTime() )
	{
		tpProperty->CloseVip();
		SendVipNotice( npPlayer, false );
		SendVipFlagUpdateToGate( npPlayer );
	}

	return ; 
}

// 洗点道具 [1/6/2010 Macro]
int CPropertyModule::OnUseCleanItem(CEntity *pEntity, CTplItem *tpItem, int vIndex)
{
	if ( pEntity == NULL || tpItem == NULL )
	{
		return ERROR_CANNUSEITEM;
	}

	CEntityPlayer*		tpPlayer = ( CEntityPlayer* ) pEntity;
	CPropertyPlayer*	tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{			
		return tPwdCheckRet;
	}		

	// 检查包裹的物品是否合法
	CItemClean* tpObj = dynamic_cast <CItemClean*> ( tpProperty->GetBaggage()->GetItemObjPtr(vIndex) );
	if ( tpObj == NULL )
	{
		return ERROR_CANNUSEITEM;
	}

	CTplItemClean* tpCleanItem = ( CTplItemClean* ) tpItem;


	// 不能使用低级洗点符
	if ( tpPlayer->GetLevel() > tpCleanItem->mCleanLevel )
	{
		return ERROR_LOWERCLEANITEM;
	}

	// 洗技能点
	if ( tpCleanItem->mCleanType == CTplItemClean::emTypeSkill )
	{
		if ( tpProperty->IsSPInit() )
		{
			return ERROR_SPINIT;
		}

		ResetAllSP( tpPlayer );
	}

	// 洗潜能点
	if ( tpCleanItem->mCleanType == CTplItemClean::emTypePotential )
	{
		if ( tpPlayer->GetLevel() < CLEAN_POTENTIAL_LIMIT_LEVEL )
		{
			return ERROR_LEVELLOWER;
		}

		if( tpProperty->IsPPInit() ) 
		{
			return ERROR_PPINIT;
		}

		ResetAllPP( tpPlayer );
	}

	if ( tpCleanItem->mCleanType == CTplItemClean::emTypeTalent )
	{
		int tRet = ResetAllTalent( tpPlayer, tpCleanItem->mStep );
		if ( tRet != ERROR_RESETTALENT_SUCCESS )
		{
			return tRet;
		}
	}

	uint64_t ullGUID = tpObj->GetGUID();
	int nItemID = tpObj->GetItemID();

	// remove item
	if ( PlayerRemoveItem( tpPlayer, vIndex, 1) == 0)
	{
		LogEventLostItemByUse( tpPlayer, ullGUID, nItemID, 1);
	}

	return SUCCESS;
}

// 使用家族军团特供物品
int CPropertyModule::OnUseLeagueBagItem( CEntity* pEntity, CTplItem* tpItem, int vIndex )
{ 
	LK_ASSERT( pEntity != NULL && tpItem != NULL, return -1 )	
	if ( pEntity->IsPlayer() == false )
	{
		return -1;
	}
	
	if ( tpItem->mItemType != CTplItem::ITEM_LEAGUEBAG )
	{
		return -1;
	}
	
	CEntityPlayer *tpPlayer = ( CEntityPlayer * )pEntity;
	CPropertyPlayer *tpPropety = ( CPropertyPlayer * )tpPlayer->GetProperty();
	CItemObject *tpItemObj = tpPropety->GetBaggage()->GetItemObjPtr( vIndex );
	if ( tpItemObj == NULL )
	{
		return -1;
	}
	
	CTplLeagueBag *tpLeagueBag = ( CTplLeagueBag * )tpItem;	
	
	// 距离判断
	if ( pEntity->GetMapID() != tpLeagueBag->mMapID )
	{
		return ERROR_WRONGPLACE;
	}	
	
	int tPosXLower = tpLeagueBag->mPosX - MAX_NPC_TALK_GIRD;
	int tPosXUpper = tpLeagueBag->mPosX + MAX_NPC_TALK_GIRD;
	int tPosYLower = tpLeagueBag->mPosY - MAX_NPC_TALK_GIRD;
	int tPosYUpper = tpLeagueBag->mPosY + MAX_NPC_TALK_GIRD;
	if ( pEntity->GetPosX() < tPosXLower || pEntity->GetPosX() > tPosXUpper )
	{
		return ERROR_WRONGPLACE;
	}
	
	if ( pEntity->GetPosY() < tPosYLower || pEntity->GetPosY() > tPosYUpper )
	{
		return ERROR_WRONGPLACE;
	}
	
	int tRet = SUCCESS;
	if ( tpLeagueBag->mLeagueBagType == CTplLeagueBag::LEAGUEBAG_FAMILY )	
	{
		tRet = CFamilyModule::GetSingleton().AddFamilyExchangeItem( tpPlayer, tpLeagueBag );	
	}
	else if( tpLeagueBag->mLeagueBagType == CTplLeagueBag::LEAGUEBAG_CORPS )
	{
		tRet = CCorpsModule::GetSingleton().AddCorpsExchangeItem( tpPlayer, tpLeagueBag );
	}
	else
	{
		return -1;	
	}
	
	if ( tRet == SUCCESS )
	{ 		
		uint64_t ullGUID = tpItemObj->GetGUID();
		int nItemID = tpItemObj->GetItemID();

		if ( PlayerRemoveItem( tpPlayer, vIndex, 1 ) == 0 )
		{
			LogEventLostItemByUse( tpPlayer, ullGUID, nItemID, 1 );
		}
	}
	return tRet;
}

// 玩家查询元宝数目
void CPropertyModule::OnMessageQueryGoldenYB( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT ( pPlayer != NULL && pMessage !=  NULL && pMessage->msgpara() != 0, return);
	CMessageQueryGoldenYBRequeset *pMsg = ( CMessageQueryGoldenYBRequeset* )pMessage->msgpara();

	if ( pMsg->entityid() == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_IBSTORE_DRAW_ISNOT_ACTIVE );
		return;
	}

	CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( pMsg->entityid( ) ) );
	if ( pNpc == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_IBSTORE_DRAW_ISNOT_ACTIVE );
		return;
	}

	if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", 
				pPlayer->GetCharNameShow(),  pMsg->entityid(), __FUNCTION__ );
		return;
	}

	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mActivityService == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_IBSTORE_DRAW_ISNOT_ACTIVE );
		return;
	}


	CMessage tMessage;
	CMessage4EQueryYuanBaoRequest tPara;

	tPara.set_roleid( pPlayer->GetCharID());

	tMessage.mutable_msghead()->set_messageid(ID_S2G_QUERYYUANBAO_REQUEST);
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Gate( &tMessage );
}

// 玩家提出领取元宝请求
void CPropertyModule::OnMessageDrawGoldenYB( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT ( pPlayer != NULL && pMessage !=  NULL && pMessage->msgpara() != 0, return);
	
	CMessageDrawGoldenYBRequest* prequest = (CMessageDrawGoldenYBRequest*) pMessage->msgpara();
	if (prequest->requiredgoldenyb() <= 0) return;
	
	// 安全密码检查
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int tCheckRet = tpProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tCheckRet != SUCCESS )
	{
		SendProErrorNotice( pPlayer, tCheckRet );
		return;
	}

	// 判断距离
	if ( prequest->entityid() == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_IBSTORE_DRAW_ISNOT_ACTIVE );
		return;
	}

	CEntityNpc* pNpc = dynamic_cast< CEntityNpc* >( CSceneObjManager::GetSingletonPtr( )->GetObject( prequest->entityid( ) ) );
	if ( pNpc == NULL )
	{
		SendProErrorNotice( pPlayer, ERROR_IBSTORE_DRAW_ISNOT_ACTIVE );
		return;
	}

	if( !pPlayer->IsWithinDistance( pNpc, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", 
				pPlayer->GetCharNameShow(),  prequest->entityid(), __FUNCTION__ );
		return;
	}

	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mActivityService == 0 )
	{
		SendProErrorNotice( pPlayer, ERROR_IBSTORE_DRAW_ISNOT_ACTIVE );
		return;
	}

	CMessage tMessage;
	CMessage4EDrawYuanBaoRequest tPara;

	tPara.set_roleid( pPlayer->GetCharID());

	tPara.mutable_draw()->set_unit(CYuanBao::em_golden_yuanbao);
	tPara.mutable_draw()->set_value(prequest->requiredgoldenyb());

	tMessage.mutable_msghead()->set_messageid(ID_S2G_DRAWYUANBAO_REQUEST);
	tMessage.set_msgpara( (long) &tPara );
	CSceneLogic::GetSingleton().Send2Gate( &tMessage );
}

void CPropertyModule::SendMultiTeleportNotify( CAsynTeleport vTeleport, char *vName )
{
	CSceneObjManagerImp* pSceneneObjManagerImp = CSceneObjManager::GetSingletonPtr()->mSceneObjManagerImp;
	for( CSceneObjManagerImp::ObjMng_EntityPlayer::iterator tPlayerIt = pSceneneObjManagerImp->mEntityPlayerPool.begin( ); 
		tPlayerIt != pSceneneObjManagerImp->mEntityPlayerPool.end( ); 
		++tPlayerIt 
		)
	{
		CEntityPlayer* tpSrcEntity = &( *tPlayerIt );

		if ( tpSrcEntity->GetCharID() == (unsigned int)vTeleport.mCharID )
			continue;
		if ( vTeleport.mDstChar.mNationID != WORLD_START && ((int)tpSrcEntity->GetNationality()) != vTeleport.mDstChar.mNationID )
			continue;
		if ( vTeleport.mDstChar.mCountryID != COUNTRY_NONE && tpSrcEntity->GetCountryID() != vTeleport.mDstChar.mCountryID )
			continue;
		if ( vTeleport.mDstChar.mCorpsID != 0 && tpSrcEntity->GetCorpsID() != vTeleport.mDstChar.mCorpsID )
			continue;
		if ( vTeleport.mDstChar.mFamilyID != 0 && tpSrcEntity->GetFamilyID() != vTeleport.mDstChar.mFamilyID )
			continue;
		if ( vTeleport.mDstChar.mKing != 0 && tpSrcEntity->GetKingID() == 0 )
			continue;		

		SendSingleTeleportNotify( tpSrcEntity->GetCharID(), vTeleport.mDestination, vName, vTeleport.mTokenID );
	}
}

void CPropertyModule::SendSingleTeleportNotify( int vCharID, ComplexPos vPos, char *vName, int vTokenID )
{
	CEntityPlayer *tpPlayer = CSceneLogic::GetSingleton().GetPlayerByCharID( vCharID );
	if ( tpPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_SUMMONPLAYER );

	CMessageSummonPlayerNotify tMessage;
	tMessage.set_lineid( vPos.mLineID );
	tMessage.set_mapid( vPos.mMapID );
	tMessage.set_posx( vPos.mPos.mX );
	tMessage.set_posy( vPos.mPos.mY );
	tMessage.set_srcname( vName );
	tMessage.set_tokenid( vTokenID );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( tpPlayer, &tTotalMessage );
}

// 开启内丹(直接噬炼)
void CPropertyModule::StartRedstone( CEntity *pEntity, int nOwnerID, int nRedstoneTmpID, bool bDestroyEntity /* = true */ )
{		
	LK_ASSERT( pEntity != NULL, return )
	if ( nOwnerID < 0 || nRedstoneTmpID <= 0 )
	{
		LOG_ERROR( "pro","wrong redstone OwernerID or TmpID, Owener ID:%d, TmpID:%d ", nOwnerID, nRedstoneTmpID );
		return;
	}
	
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( nRedstoneTmpID );
	if ( tpTplItem == NULL )
	{
		LOG_ERROR( "pro","Can not find Redstone TmpID by ID:%d", nRedstoneTmpID );
		return;
	}
	
	if ( tpTplItem->mItemType != CTplItem::ITEM_REDSTONE )
	{
		LOG_ERROR( "pro","Wrong Redstone TmpID , TmpID:%d, ItemType:%d", nRedstoneTmpID, tpTplItem->mItemType );		
		return;
	}	
	
	CTplRedStone *tpTplRedstone = ( CTplRedStone * )tpTplItem;
	if ( tpTplRedstone->mExpTime <= 0 )
	{
		LOG_ERROR( "pro","Redstone ExpTime Wrong, ExpTime:%d", tpTplRedstone->mExpTime );
		return;
	}
	
	CRedstoneController *tpRedstoneController = ( CRedstoneController * )CSceneObjManager::GetSingleton().CreateObject( OBJTYPE_REDSTONECONTROLLER );
	LK_ASSERT( tpRedstoneController != NULL, return )
	tpRedstoneController->SetEntityID( pEntity->GetEntityID() );
	tpRedstoneController->SetOwnerID( nOwnerID );
	tpRedstoneController->SetRedstoneTmpID( nRedstoneTmpID );
	tpRedstoneController->SetDestroyEntity( bDestroyEntity );	
	
	int OtherInfo[ 3 ]={0};
	OtherInfo[0]=MESSAGE_PROPERTY;
	OtherInfo[1]=tpTplRedstone->mExpTime;
	int tCount = tpTplRedstone->mMagicSustainTime / tpTplRedstone->mExpTime;	
	CTimerMng::GetSingleton().SetTimer( tpRedstoneController->get_id(),TIMER_REDSTONE_EXPMAGIC,
	( int )tpTplRedstone->mExpTime,2, OtherInfo, tCount );	
	
	// 立即分配一次经验
	int tLastNum = 0;
	RedStoneAllotExp( pEntity, nOwnerID, nRedstoneTmpID, 1, tLastNum );  			
	tpRedstoneController->SetLastNumber( tLastNum );
}

// ***********************************************************
//  Function:		OnMessageSetPwdProtectTimeRequest
//  Description:	设置密码安全时长的消息
//  Input:			CEntityPlayer*		pPlayer
//					CMessage*			pMessage
//  OutPut:			
//  Return:			
//  Others:
//  Date:	01/26/2010
// **********************************************************
void CPropertyModule::OnMessageSetPwdProtectTimeRequest( CEntityPlayer *pPlayer, CMessage *pMessage )
{  
	LK_ASSERT( pMessage != NULL && pPlayer != NULL, return )	
	CMessageSetPwdProtectTimeRequest *tpMsg = ( CMessageSetPwdProtectTimeRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	if ( tpProperty->GetRolePassword()->CheckProtectTime() == false )
	{
		SendResponseSetPwdProtectTime( pPlayer, ERR_PASSWORD_INPROTECTTIME, tpMsg->protecttime() );
		return;		
	}
		
	if ( tpMsg->protecttime() < 0 || tpMsg->protecttime() > MAX_PASSWORD_PROTECTIME )
	{
		SendResponseSetPwdProtectTime( pPlayer, ERR_PASSWORD_WRONGPROTECTTIME, tpMsg->protecttime() );
		return;
	}	
	
	tpProperty->GetRolePassword()->SetProtectTimeLength( tpMsg->protecttime() == 0 ? 1 : tpMsg->protecttime() );
	SendResponseSetPwdProtectTime( pPlayer, SUCCESS, tpMsg->protecttime() );
}

// ***********************************************************
//  Function:		SendResponseSetPwdProtectTime
//  Description:	发送设置安全密码安全时长的消息回应
//  OutPut:			
//  Return:			
//  Others:
//  Date:	01/26/2010
// **********************************************************
void CPropertyModule::SendResponseSetPwdProtectTime( CEntityPlayer *pPlayer, int nErrcode, int nTimeLength )
{
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageSetPwdProtectTimeResponse tMsgSetPwdProtectTime;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_SETPWDPROTECTTIME );
	tMsgHead.set_msgpara( (int)&tMsgSetPwdProtectTime );
	tMsgSetPwdProtectTime.set_errcode( nErrcode );
	tMsgSetPwdProtectTime.set_protecttime( nTimeLength );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// ***********************************************************
//  Function:		SendNotifyChangePasswordStatus
//  Description:	发送安全密码状态改变的通知
//  OutPut:			
//  Return:			
//  Others:
//  Date:	01/28/2010
// **********************************************************
void CPropertyModule::SendNotifyChangePasswordStatus( CEntityPlayer *pPlayer, int nPasswordStatus, const char *pPassword /* = NULL */ )
{
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageChangePasswordStatusNotify tMsgChangePasswordStatus;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2G_NOTIFY_CHANGEPASSWORDSTATUS );	
	tMsgHead.set_msgpara( (int)&tMsgChangePasswordStatus );
	
	tMsgChangePasswordStatus.set_roleid( pPlayer->GetCharID() );
	tMsgChangePasswordStatus.set_pwdstatus( nPasswordStatus );
	if ( pPassword != NULL )
	{
		tMsgChangePasswordStatus.set_password( pPassword );
	}
	CSceneLogic::GetSingleton().Send2Gate(  &tMsgHead );
}


// ***********************************************************
//  Function:		OnMessagePlayerUseFlowerRequest
//  Description:	处理客户端使用鲜花的请求
//  OutPut:			
//  Return:			
//  Others:
//  Date:	02/01/2010
// **********************************************************
void CPropertyModule::OnMessagePlayerUseFlowerRequest( CEntityPlayer *pPlayer, CMessage *pMessage )
{  
	LK_ASSERT( pMessage != NULL && pPlayer != NULL, return )	;
	CMessageUseFlowerRequest *tpMsg = ( CMessageUseFlowerRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );

	// 检查使用合法性
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pPlayer->GetProperty();
	CItemObject* tpObj = tpPro->GetBaggage()->GetItemObjPtr(tpMsg->bagindex());
	if ( tpObj == NULL )
		return;

	CTplItem *tpItem = (CTplItem *)CDataStatic::SearchTpl( tpObj->GetItemID() );
	if ( tpItem == NULL )
		return;		

	if ( tpItem->mItemType != CTplItem::ITEM_FUNCITEM )
		return;

	CTplFuncItem* tpFunc = (CTplFuncItem*)tpItem;
	if ( tpFunc->mFuncCode != FUNCCODE_XIANHUA )
		return;

	// 判断次数  ly 百花仙子以后 不再判断
	//int tKey = CPersonalTimesMgr::MakeKey(TIMESMGR_USEFLOWER, 0);
	//int nTimes = tpPro->GetTimesMgr()->GetTimes(tKey);

	//// 如果是限制次数
	//if ( CSceneCfgManager::GetSingleton().GetProperty_cfg()->mFlower_lmt_type == 0 )
	//{
	//	if ( nTimes >= MAX_USE_FLOWER_TIME_PERDAY )
	//	{
	//		SendProErrorNotice( pPlayer, ERROR_FLOWER_OVER_MAX_TIMES );
	//		return;
	//	}
	//}

	// 查查目标玩家在本服务器不
	CEntityPlayer* tpPlayer = CSceneLogic::GetSingleton().GetPlayerByName( tpMsg->desname().c_str() );
	if ( tpPlayer == NULL ) // 发路由消息
	{
		// 发送路由消息到邀请者所在的服务器处理
		CMessageS2SPlayerUseFlowerRequest msg;
		CMessage tMessage;
		msg.set_bagindex( tpMsg->bagindex() );
		msg.set_itemid( tpFunc->mTempID );
		CFriendModule::GetSingleton().MakeRouterMessageByName<CMessageS2SPlayerUseFlowerRequest>
			( pPlayer->GetCharName(), tpMsg->desname().c_str(), 0, 
			ID_S2S_REQUEST_USEFLOWER, msg, &tMessage );
		msg.mutable_router()->set_srccharid( pPlayer->GetCharID() );
		CSceneLogic::GetSingleton( ).Send2Player( tpMsg->desname().c_str(), &tMessage );
		return;
	}
	else // 直接使用
	{
		PlayerUseFlower( pPlayer->GetCharID(), pPlayer->GetCharName(), tpPlayer, tpFunc->mTempID, tpMsg->bagindex() );
	}
}

// ***********************************************************
//  Function:		PlayerUseFlower
//  Description:	处理玩家使用鲜花 负责给目标玩家加魅力、回应给SRC的场景服务器
//  OutPut:			
//  Return:			
//  Others:
//  Date:	02/01/2010
// **********************************************************
void CPropertyModule::PlayerUseFlower( int nSrcCharID, const char* pSrcName, CEntityPlayer* pDesPlayer, int nItemID, int nBagIndex )
{
	LK_ASSERT( pSrcName&&pDesPlayer, return );
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pDesPlayer->GetProperty();

	CTplItem *tpItem = (CTplItem *)CDataStatic::SearchTpl( nItemID );
	if ( tpItem == NULL )
		return;		

	if ( tpItem->mItemType != CTplItem::ITEM_FUNCITEM )
		return;

	CTplFuncItem* tpFunc = (CTplFuncItem*)tpItem;

	// 加魅力值
	tpPro->SetCharmValue( tpPro->GetCharmValue() + tpFunc->mParams[1] );
	tpPro->SetWeekIncCharm( tpPro->GetWeekIncCharm() + tpFunc->mParams[1] );

	// 通知des玩家 魅力值增加
	pDesPlayer->AddFunResult( 0, FUNC_CHARM, RESULT_NORMAL, false, tpPro->GetCharmValue(), 0, 0, 0 );

	// 增加亲密度
	if ( tpFunc->mParams[4] > 0 )
	{ 
		CFriendModule::GetSingleton().ChangeIntimacy( pDesPlayer->GetCharID(), nSrcCharID, ENTIMACY_CHANGE_TYPE_FLOWER, tpFunc->mParams[4] );
	}	

	// 广播 XX给XX送花
	CMessage tMessage;
	CMessageObtainFlowerNotify msg;
	msg.set_charid(pDesPlayer->GetCharID());
	msg.set_desname( pDesPlayer->GetCharName() );
	msg.set_srcname( pSrcName );
	msg.set_itemid( tpFunc->mTempID );
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_OBTAINFLOWER );
	CSceneLogic::GetSingleton( ).Send2Gate( &tMessage );

	// 回应使用者 使用成功
	CEntityPlayer* tpSrcPlayer = CSceneLogic::GetSingleton().GetPlayerByName( pSrcName );
	if ( tpSrcPlayer != NULL )
	{
		OnUseFlowerSuccess( tpSrcPlayer, nBagIndex );
		return;
	}
	else
	{
		// 发送路由消息到邀请者所在的服务器处理
		CMessageS2SPlayerUseFlowerResponse msg;
		CMessage tMessage;
		msg.set_bagindex( nBagIndex );
		msg.set_resultcode(1);

		CFriendModule::GetSingleton().MakeRouterMessageByName<CMessageS2SPlayerUseFlowerResponse>
			( pDesPlayer->GetCharName(), pSrcName, 0, 
			ID_S2S_RESPONSE_USEFLOWER, msg, &tMessage );
		CSceneLogic::GetSingleton( ).Send2Player( pSrcName, &tMessage );
		return;
	}
}

// 玩家使用鲜花成功 回应
void CPropertyModule::OnUseFlowerSuccess( CEntityPlayer* pSrcPlayer, int nBagIndex )
{
	LK_ASSERT( pSrcPlayer!=NULL, return );

	// 扣物品
	CPropertyPlayer* tpPro = (CPropertyPlayer*)pSrcPlayer->GetProperty();
	CItemObject* tpObj = tpPro->GetBaggage()->GetItemObjPtr(nBagIndex);
	if ( tpObj == NULL )
	{
		LOG_ERROR("pro", "player %s(%d)'s flower is null!!", pSrcPlayer->GetCharNameShow(), pSrcPlayer->GetCharID() );
		return;
	}

	CTplItem *tpItem = (CTplItem *)CDataStatic::SearchTpl( tpObj->GetItemID() );
	if ( tpItem == NULL )
		return;		

	if ( tpItem->mItemType != CTplItem::ITEM_FUNCITEM )
		return;

	CTplFuncItem* tpFunc = (CTplFuncItem*)tpItem;
	if ( tpFunc->mFuncCode != FUNCCODE_XIANHUA )
		return;

	int tKey = CPersonalTimesMgr::MakeKey(tpItem->mCountType, 0);
	int nTimes = tpPro->GetTimesMgr()->GetTimes(tKey);

	CTemplateCountTable *tpCountTable = (CTemplateCountTable*)CDataStatic::GetTemp( TEMP_COUNT );
	if ( tpCountTable == NULL || ( tpItem->mCountType >= (int) ARRAY_CNT(tpCountTable->mCountData) ) )
	{
		return;
	}

	bool bIsObtExp=false;
	int tTotalTimes=0;
	if ( tpPro->IsVip() ) 
	{
		if ( nTimes < tpCountTable->mCountData[ tpItem->mCountType ].mVipTime )
		{
			bIsObtExp = true;
		}		
		tTotalTimes=tpCountTable->mCountData[ tpItem->mCountType ].mVipTime;
	}
	else
	{
		if ( nTimes < tpCountTable->mCountData[ tpItem->mCountType ].mCountTime )
		{
			bIsObtExp = true;
		}
		tTotalTimes=tpCountTable->mCountData[ tpItem->mCountType ].mCountTime;
	}

	// 如果次数还没到 或者 不是限制加经验 则奖励经验
	// ly 百花之后 改为走表
	//if ( nTimes < MAX_USE_FLOWER_TIME_PERDAY || CSceneCfgManager::GetSingleton().GetProperty_cfg()->mFlower_lmt_type != 1 )
	if (bIsObtExp)
	{
		// 借用内丹的等级经验表
		CTemplateRedStoneExpTable* tpTable = (CTemplateRedStoneExpTable*)CDataStatic::SearchTpl(tpFunc->mParams[0]);
		if (tpTable == NULL)
		{
			LOG_ERROR("pro", "item %d 's table is null!!", tpFunc->mTempID );
		}
		else
		{
			int tCharID = pSrcPlayer->GetCharID();
			LK_ASSERT( pSrcPlayer->GetLevel()<TMP_MAX_GRADE, return );
			int tExp = tpTable->mExp[pSrcPlayer->GetLevel()];
			int nFinalExp = PlayerObtainExp( pSrcPlayer, tExp, EXPREASON_EXPITEM, &tCharID, 1 );

			if ( nFinalExp > 0)
			{
				LogEventGetExpByFlower(pSrcPlayer, tExp, nFinalExp);
			}
		}
	}

	// 干掉物品
	uint64_t ullGUID = tpObj->GetGUID();
	int nItemID = tpObj->GetItemID();

	if ( PlayerRemoveItem( pSrcPlayer, nBagIndex, 1 ) == 0)
	{
		LogEventLostItemByUse( pSrcPlayer, ullGUID, nItemID, 1 );
	}

	// 记录次数
	int tTickRet = tpPro->GetTimesMgr()->Tick(tKey);
	if ( tTickRet != 0 )
	{
		LOG_ERROR("default", "Tick %x FAILED! ret=%d", tKey, tTickRet );
	}	
	

	// 回应给使用者
	CMessageUseFlowerResponse msg;
	CMessage tMsgHead;

	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_USEFLOWER );
	tMsgHead.set_msgpara( (int)&msg );
	msg.set_resultcode(0);
	// 今日剩余次数
	tKey = CPersonalTimesMgr::MakeKey(TIMESMGR_USEFLOWER, 0);
	msg.set_todaylefttimes( std::max(0,tTotalTimes-tpPro->GetTimesMgr()->GetTimes(tKey)) );
	CSceneLogic::GetSingleton().Send2Player( pSrcPlayer, &tMsgHead );
}

void CPropertyModule::OnMessageS2SUseFlowerRequest( CMessage* pMessage )
{
	LK_ASSERT( pMessage != NULL , return );

	CMessageS2SPlayerUseFlowerRequest* tpMsg = (CMessageS2SPlayerUseFlowerRequest*) pMessage->msgpara( );
	LK_ASSERT( tpMsg != NULL, return );

	CMessageRouter* pRouter = tpMsg->mutable_router();
	LK_ASSERT( pRouter != NULL , return );

	if ( pRouter->sendback() == 1 ) // 打回消息
	{
		CEntityPlayer* tpSrcPlayer = CSceneLogic::GetSingleton().GetPlayerByName( pRouter->srcname().c_str());
		if ( tpSrcPlayer == NULL )
			return;

		if ( pRouter->routerreason() !=  CMessageRouter_EMRouterReason_REASON_SUCCESS )
		{
			SendProErrorNotice( tpSrcPlayer, ERROR_FLOWER_DES_INVILID );
			return;
		}
	}
	else
	{
		// 在获赠人的服务器
		CEntityPlayer* tpDesPlayer = CSceneLogic::GetSingleton().GetPlayerByName( pRouter->desname().c_str());
		if ( tpDesPlayer == NULL )
			return;
		PlayerUseFlower( pRouter->srccharid(), pRouter->srcname().c_str(), tpDesPlayer, tpMsg->itemid(), tpMsg->bagindex() );
		return;
	}
}

void CPropertyModule::OnMessageS2SUseFlowerResponse( CMessage* pMessage )
{
	LK_ASSERT( pMessage != NULL , return );

	CMessageS2SPlayerUseFlowerResponse* tpMsg = (CMessageS2SPlayerUseFlowerResponse*) pMessage->msgpara( );
	LK_ASSERT( tpMsg != NULL, return );

	CMessageRouter* pRouter = tpMsg->mutable_router();
	LK_ASSERT( pRouter != NULL , return );

	if ( pRouter->sendback() == 1 ) // 打回消息
	{
		return;
	}
	else
	{
		// 在用花人的服务器
		CEntityPlayer* tpPlayer = CSceneLogic::GetSingleton().GetPlayerByName( pRouter->desname().c_str());
		if ( tpPlayer == NULL )
			return;
		if ( tpMsg->resultcode() != 1 )
			return;
		OnUseFlowerSuccess( tpPlayer, tpMsg->bagindex() );
		return;
	}
}

// 发送会员状态更新到网关 [2/4/2010 Macro]
void CPropertyModule::SendVipFlagUpdateToGate( CEntityPlayer *npPlayer )
{
	if ( npPlayer == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();

	CMessage tMessage;
	CMessageSGProVipFlagNotice tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2G_NOTIFY_VIPFLAG );
	tMessage.set_msgpara( (long) &tPara );
	
	tPara.set_roleid( npPlayer->GetCharID() );
	tPara.set_vipflag( tpProperty->GetVipFlag() );

	CSceneLogic::GetSingleton().Send2Gate( &tMessage );

	// 好友通知
	CFriendModule::GetSingleton().SendAllFriendNotice( npPlayer );
	return ;
}

// 自动挂机购买的商城道具，做绑定非绑定处理 [3/4/2010 GaoHong]
int CPropertyModule::GetStoreItemID(int *npItemList, int nLen, int nType, int nIndex)
{
	if ( npItemList == NULL )
		return -1;
	
	int tBindItemList[ MAX_PHYSIC_NUM ] = { 0 };
	int tUnBindItemList[ MAX_PHYSIC_NUM ] = { 0 };
	int tBindNum = 0, tUnBindNum = 0, tItemID = 0;
	for ( int i = 0; i < nLen; i ++ )
	{
		CTplItem* tpItem = (CTplItem*) CDataStatic::SearchTpl( npItemList[ i ] );
		if ( tpItem == NULL )
			continue;

		if ( ( tpItem->mProcessType & CTplItem::PROCESSTYPE_BINDONPICK ) == CTplItem::PROCESSTYPE_BINDONPICK )
		{
			tBindItemList[ tBindNum ++ ] = tpItem->mTempID;
		}
		else
		{
			tUnBindItemList[ tUnBindNum ++ ] = tpItem->mTempID;
		}
	}
	if ( nType == EM_BIND_YB )
	{
		if ( nIndex >= 0 && nIndex < tBindNum )
			tItemID = tBindItemList[ nIndex ];
	}
	else
	{
		if ( nIndex >= 0 && nIndex < tUnBindNum )
			tItemID = tUnBindItemList[ nIndex ];
	}

	return tItemID;
}

// 远程修理装备 [3/5/2010 GaoHong]
void CPropertyModule::OnMessageRemoteMendAllEquip(CEntityPlayer *npPlayer, CMessage *npMessage)
{
	if ( npPlayer == NULL || npMessage == NULL )
	{
		return ;
	}

	CPropertyPlayer* tpProperty = ( CPropertyPlayer* ) npPlayer->GetProperty();

	// 检查是否是会员
	if ( tpProperty->IsVip() == false )
	{
		return ;
	}

	// 修理玩家身上所有装备
	this->MendAllEquipment( npPlayer );

	return ;
}

// 对物品进行普通绑定的消息请求
void CPropertyModule::OnMessageCommonBindRequest( CEntityPlayer *pPlayer, CMessage *pMessage )
{	
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )
	CMessageCommonBindRequest *tpMsg = ( CMessageCommonBindRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )
	
	CItemObject *tpItemObject  = NULL;
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	if ( tpMsg->itemslot() == SLOT_BAGGAGE )
	{
		tpItemObject = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->itemindex() );
	}
	
	else if( tpMsg->itemslot() == SLOT_EQUIPMENT )
	{
		tpItemObject = tpProperty->GetEquipment()->GetItemObjPtr( tpMsg->itemindex() );
	}
	
	if ( tpItemObject == NULL )
	{			
		return;
	}
	
	if ( tpItemObject->GetBindStatus() & ITEM_BINDSTATUS_BYITEM )
	{
		SendCommonBindResponse( pPlayer, ITEM_COMMONBIND_BINDBYITEM, tpMsg->itemindex(), tpMsg->itemslot() );			
		return;
	}
		
		
	if ( tpItemObject->GetBindStatus() & ITEM_BINDSTATUS_BINDED )
	{
		SendCommonBindResponse( pPlayer, ITEM_COMMONBIND_ITEMBINDED, tpMsg->itemindex(), tpMsg->itemslot() );			
		return;
	}
	
	CTplItem *tpTplItemNeedbind = ( CTplItem * )CDataStatic::SearchTpl( tpItemObject->GetItemID() );
	if( tpTplItemNeedbind == NULL )
	{
		return;
	}
	
	if ( tpTplItemNeedbind->mPileLimit > 1 )
	{
		SendCommonBindResponse( pPlayer, ITEM_COMMONBIND_PIPELIMIT, tpMsg->itemindex(), tpMsg->itemslot() );			
		return;
	}
	 
	
	CItemObject *tpBindStone = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->bindstoneindex() );
	if ( tpBindStone == NULL )
	{
		return;
	}
	
	if ( tpMsg->bindstoneindex() == tpMsg->itemindex() && tpMsg->itemslot() == SLOT_BAGGAGE )
	{
		return;
	}
	
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpBindStone->GetItemID() );	
	if ( tpTplItem == NULL )
	{
		LOG_ERROR( "pro","[%s,%d]wrong template item, tmpid:%d",__FUNCTION__, __LINE__, tpBindStone->GetItemID() );
		return;
	}
	
	if( tpTplItem->mItemType != CTplItem::ITEM_FUNCITEM ) 
	{
		SendCommonBindResponse( pPlayer, ITEM_COMMONBIND_WRONGBINDITEM, tpMsg->itemindex(), tpMsg->itemslot() );
		return;	
	}
	
	CTplFuncItem *tpFuncItem = ( CTplFuncItem * )tpTplItem;
	if ( tpFuncItem->mFuncCode != FUNCCODE_COMMONBIND )
	{
		SendCommonBindResponse( pPlayer, ITEM_COMMONBIND_WRONGBINDITEM, tpMsg->itemindex(), tpMsg->itemslot() );
		return;	
	}
	
	// 绑定物品
	int nFrom = tpItemObject->GetBindStatus();
	if ( !( tpItemObject->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
	{			
		SetEquipBindTime( tpItemObject );
	}	
	tpItemObject->SetBindStatus( tpItemObject->GetBindStatus() | ITEM_BINDSTATUS_BINDED );
	
	// 删除道具
	PlayerRemoveItem( pPlayer, tpMsg->bindstoneindex(), 1 );

	LogEventItemBindAction(pPlayer, tpItemObject->GetItemID(), tpItemObject->GetGUID(), 
				nFrom, tpItemObject->GetBindStatus(), tpBindStone->GetItemID(), tpItemObject->GetBindStatus());
	
	SendCommonBindResponse( pPlayer, SUCCESS, tpMsg->itemindex(), tpMsg->itemslot() );
}

// 发送普通绑定的回应消息
void CPropertyModule::SendCommonBindResponse( CEntityPlayer *pPlayer, int nErrcode, int nItemIndex, int nItemSlot )
{	
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageCommonBindResponse tMsgCommonBind;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_COMMONBIND );
	tMsgHead.set_msgpara( (int)&tMsgCommonBind );
	
	tMsgCommonBind.set_errcode( nErrcode );
	tMsgCommonBind.set_itemindex( nItemIndex );
	tMsgCommonBind.set_itemslot( nItemSlot );
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 客户端开始读秒的消息请求
void CPropertyModule::OnMessageStartProgressRequest( CEntityPlayer *pPlayer, CMessage *pMessage )
{ 
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CMessageStartProgressRequest *tpMsg =  ( CMessageStartProgressRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )	
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();		
	tpProperty->SetProgressFunc( tpMsg->functype() );	
	tpProperty->SetProgressStartTime( LINEKONG::GetTickCount() );	
	SendStartProgressResponse( pPlayer, SUCCESS );
}

// 客户端开始读秒的消息回应
void CPropertyModule::SendStartProgressResponse( CEntityPlayer *pPlayer, int nErrcode )
{
	LK_ASSERT( pPlayer != NULL, return )	
	CMessage tMsgHead;
	CMessageStartProgressResponse tMsgStartProgress;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_STARTPROGRESS );
	tMsgHead.set_msgpara( (int)&tMsgStartProgress );
	
	tMsgStartProgress.set_errcode( nErrcode );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

void CPropertyModule::SendUseItemNotify( CEntityPlayer *pPlayer, int vItemID )
{
	if ( pPlayer == NULL )
	{
		return;
	}
	CMessage tMessage;
	CMessagePlayerUseItemNotify tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_USEITEM );
	tPara.set_itemid(vItemID);
	tMessage.set_msgpara( (long) &tPara );

	CSeenPlayerContainer& rSeenPlayerContainer = pPlayer->GetSeenPlayersContainer();
	CSeenPlayerContainer::SeenPlayerVector::iterator it = rSeenPlayerContainer.mPlayers.begin();
	for ( ; it != rSeenPlayerContainer.mPlayers.end(); ++it)
	{
		CEntityPlayer* pTargetEntity = ( CEntityPlayer* ) CSceneObjManager::GetSingletonPtr()->GetObject( *it );
		if( pTargetEntity == NULL )
		{
			LOG_ERROR("pro", "in use FuncItem, NULL! entity=%d", *it );
			continue;
		}
		tPara.set_entityid(pPlayer->GetEntityID());
		CSceneLogic::GetSingleton().Send2Player( pTargetEntity, &tMessage );
	}
	tPara.set_entityid(pPlayer->GetEntityID());
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

// 发送使用黑狗丸的消息通知
void CPropertyModule::SendUseBlackPillsNotify( CEntityPlayer *pPlayer, int nOffLineTime, int nPillsLeftTime, int nPillsIndex, int nExp, int nOffLineTimeConsumed, int nBlackPillID, int nErrcode )
{
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageUseBlackPillsNotify tUseBlackPills;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_USEBLACKPILLS );
	tMsgHead.set_msgpara( (int)&tUseBlackPills );
	tUseBlackPills.set_offlinetime( nOffLineTime );
	tUseBlackPills.set_pilllefttime( nPillsLeftTime );
	tUseBlackPills.set_pillindex( nPillsIndex );
	tUseBlackPills.set_exp( nExp );
	tUseBlackPills.set_offlinetimeconsumed( nOffLineTimeConsumed );
	tUseBlackPills.set_blackpillsid( nBlackPillID );
	tUseBlackPills.set_errcode( nErrcode );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 重置装备属性请求
void CPropertyModule::OnMessageChangeEquipProRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageChangeEquipProRequest *tpMsg =  ( CMessageChangeEquipProRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpMsg->npcentityid(), __FUNCTION__ );
		return;
	}

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	if ( tpTplNpc->mRefreshService == 0 )
	{
		return;
	}

	int tIndex1 = tpMsg->equipindex();
	int tIndex2 = tpMsg->itemindex();
	if( ( !pProperty->GetBaggage( )->CheckIndexValid( tIndex1 ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( tIndex2 ) ) )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( tIndex1 );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( tIndex2 );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}	

	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}		   	

	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID());
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}

	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && 
		tpItem1->mItemType != CTplItem::ITEM_ARMOR &&
		tpItem1->mItemType != CTplItem::ITEM_FASHION ) 
		|| ( tpItem2->mItemType != CTplItem::ITEM_REFRESH ) )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}	

	CTemplateEquipment *tpEquip = (CTemplateEquipment*)tpItem1;	
	CItemEquipment *tEquip = (CItemEquipment*)tItem1;
	CTplItemRefresh *tplRefresh = (CTplItemRefresh*)tpItem2;
	if ( tplRefresh->mColor != tpEquip->mShowColour || tplRefresh->mLevel < tpEquip->mShowLevel )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}

	if ( tpEquip->mEquipType >= (int)ARRAY_CNT(tplRefresh->mLimitPos) || tplRefresh->mLimitPos[ tpEquip->mEquipType ] == 0 )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}

	if ( tpEquip->mCanChange == 0 )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}

	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tpEquip->mChangeCharge )
	{
		SendChangeEquipProResponse( pPlayer, ERROR_CHANGEEQUIPERROR, 0, 0 );
		return;
	}

	// 记录重置之前的属性
	int nFrom1 = tEquip->GetProperty(0);
	int nFrom2 = tEquip->GetProperty(1);
	
	tEquip->GetPropertyFromTpl( tEquip->GetItemID(), false );

	// 记录装备的重置前后的属性,目前只记录鉴定前后的两个属性
	LogEventItemProtertyAction (pPlayer, tEquip->GetItemID(), tEquip->GetGUID(), 
			nFrom1, nFrom2, tEquip->GetProperty(0), tEquip->GetProperty(1), tEquip->GetBindStatus());

	if (PlayerChangeMoney( pPlayer, tpEquip->mChangeCharge, true, true ) == SUCCESS)
	{
		LogEventLostMoneyByEquipPro(pPlayer, CYuanBao::em_bind_money, tpEquip->mChangeCharge, tEquip->GetItemID(), tEquip->GetGUID());
	}

	uint64_t ullGUIDOfItem1 = tItem1->GetGUID();
	uint64_t ullGUIDOfItem2 = tItem2->GetGUID();
	int nItem1ID = tItem1->GetItemID();
	int nItem2ID = tItem2->GetItemID();
	
	if ( PlayerRemoveItem( pPlayer, tIndex2, 1 ) == 0)
	{
		LogEventLostItemByEquipPro(pPlayer, ullGUIDOfItem2, nItem2ID, 1, nItem1ID, ullGUIDOfItem1);
	}	

	SendChangeEquipProResponse( pPlayer, SUCCESS, tIndex1, tIndex2 );
}

void CPropertyModule::SendChangeEquipProResponse( CEntityPlayer *pPlayer, int vResult, int vIndex1, int vIndex2 )
{
	LK_ASSERT( pPlayer != NULL, return );	
	CMessage tMsgHead;
	CMessageChangeEquipProResponse tResponse;

	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_CHANGEEQUIPPRO );
	tMsgHead.set_msgpara( (int)&tResponse );

	tResponse.set_result( vResult );
	tResponse.set_equipindex( vIndex1 );
	tResponse.set_itemindex( vIndex2 );
	CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( vIndex1 );
	if ( tItem1 != NULL )
	{
		CItemEquipment *tEquip = (CItemEquipment*)tItem1;
		for ( int i = 0; i < PROPERTYNUM; i++ )
		{
			tResponse.add_propertyid( tEquip->GetProperty( i ) );
		}
	}
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 使用绣花针的消息请求
void CPropertyModule::OnMessageUseKitbagNeedleRequest( CEntityPlayer *pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )			
	CMessageUseKitbagNeedleRequest *tpMsg = ( CMessageUseKitbagNeedleRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	
	CItemObject *tpItemObj = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->needleindex() );
	LK_ASSERT( tpItemObj != NULL, return )	
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return  )
	
	if( tpTplItem->mItemType != CTplItem::ITEM_FUNCITEM )
	{		 
		SendUseKitbagNeedleResponse( pPlayer, ERR_KITBAGNEEDLE_NOTNEEDLEITEM, tpMsg->kitbagslot(), tpMsg->kitbagindex(), tpMsg->needleindex(), 0, 0 );
		return;
	}	 	
	
	CTplFuncItem *tpTplFuncItem = ( CTplFuncItem * )tpTplItem;
	if ( tpTplFuncItem->mFuncCode == FUNCCODE_FASHIONNEEDLE )
	{
		UseFashionNeedle( pPlayer, tpMsg->needleindex(), tpMsg->kitbagindex(), tpMsg->kitbagslot() );
		return;
	}
	if ( tpTplFuncItem->mFuncCode != FUNCCODE_NEEDLE )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_KITBAGNEEDLE_NOTNEEDLEITEM, tpMsg->kitbagslot(), tpMsg->kitbagindex(), tpMsg->needleindex(), 0, 0 );
		return;
	}
	
	CItemObject *tpKitbag = NULL;
	if ( tpMsg->kitbagslot() == SLOT_BAGGAGE )
	{
		tpKitbag = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->kitbagindex() );	
	}
	else if( tpMsg->kitbagslot() == SLOT_STORAGE )
	{	
		tpKitbag = tpProperty->GetStorage()->GetItemObjPtr( tpMsg->kitbagindex() ); 	
	}
	else if ( tpMsg->kitbagslot() == SLOT_BAGGAGEKITBAG )
	{
		tpKitbag = tpProperty->GetBaggage()->GetKitBagItemByIndex( tpMsg->kitbagindex() );
	}
	else if( tpMsg->kitbagslot() == SLOT_STORKITBAG )
	{
		tpKitbag = tpProperty->GetStorage()->GetKitBagItemByIndex( tpMsg->kitbagindex() );
	}
	
	if ( tpKitbag == NULL )
	{
		return;
	}
	
	tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpKitbag->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	if( tpTplItem->mItemType != CTplItem::ITEM_KITBAG )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_KITBAGNEEDLE_NOTKITBAG, tpMsg->kitbagslot(), tpMsg->kitbagindex(), tpMsg->needleindex(), 0, 0 );
		return;
	}
	
	if ( tpKitbag->GetInvalidTime() >= ( unsigned int)time(NULL) || tpKitbag->GetInvalidTime() == 0 )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_KITBAGNEEDLE_KITBAGNOTEXPIRED, tpMsg->kitbagslot(), tpMsg->kitbagindex(), tpMsg->needleindex(), 0, 0 );
		return;
	}
	
	CTplKitBag *tpTplKibag = ( CTplKitBag * )tpTplItem;
	if ( tpTplKibag->mIndexNum > tpTplFuncItem->mParams[0] )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_KITBAGNEEDLE_NOTSUITABLENEEDLE, tpMsg->kitbagslot(), tpMsg->kitbagindex(), tpMsg->needleindex(), 0, 0 );
		return;
	}
	
	tpKitbag->SetInvalidTime( time(NULL) + tpTplFuncItem->mParams[1]*60 );

	LogEventStartUseTimeItem(pPlayer,tpKitbag->GetGUID(),tpKitbag->GetItemID(),1);

	SendUseKitbagNeedleResponse( pPlayer, SUCCESS, tpMsg->kitbagslot(), tpMsg->kitbagindex(), tpMsg->needleindex(), tpKitbag->GetInvalidTime(), tpTplFuncItem->mParams[1] );	
	PlayerRemoveItem( pPlayer, tpMsg->needleindex(), 1 );
}

// 发送使用绣花针的回应消息
void CPropertyModule::SendUseKitbagNeedleResponse( CEntityPlayer *pPlayer, int nErrcode, int nKitbagSlot, int nKitbagIndex, int nNeedleIndex, int nExpiredTime, int nTimeLength )
{	
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageUseKitbagNeedleResponse tMsgUseKitbagNeedle;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_USEKITBAGNEEDLE );				
	tMsgHead.set_msgpara( (int)&tMsgUseKitbagNeedle );
	
	tMsgUseKitbagNeedle.set_errcode( nErrcode );
	tMsgUseKitbagNeedle.set_expiredtime( nExpiredTime );
	tMsgUseKitbagNeedle.set_kitbagslot( nKitbagSlot );
	tMsgUseKitbagNeedle.set_kitbagindex( nKitbagIndex );
	tMsgUseKitbagNeedle.set_needleindex( nNeedleIndex );
	tMsgUseKitbagNeedle.set_timelength( nTimeLength );	
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

void CPropertyModule::OnMessageOpenStoneRequest(CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessageOpenStoneRequest* tpRequest = ( CMessageOpenStoneRequest* ) pMessage->msgpara();
	LK_ASSERT( pPlayer != NULL && tpRequest != NULL, return );

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();
	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpRequest->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpRequest->npcentityid(), __FUNCTION__ );
		return;
	}

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	if ( tpSrcProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_STONE, pPlayer->GetClientInfo()->mNetSpeed ) == false )
	{
		LOG_ERROR( "pro","wrong progresstime when open stone, roleid:%d", pPlayer->GetCharID() );
		return;
	}

	CTemplateBuff *tplBuff = (CTemplateBuff*)CDataStatic::SearchTpl( tpTplNpc->mStoneBuff );
	pPlayer->EntityInsertBuff( pPlayer, tplBuff );
	int pTime = tplBuff->mLastTime/1000;
	if (pTime >= 60)
	{
		LogEventGetBuffByItem(pPlayer,tplBuff->mTempID,pTime,tpTplNpc->mStoneBuff); 
	}
	

	if ( IS_BATTLE_LINE_ID( pPlayer->GetLineID() ) == true )
	{
		SendWarEventNotify( NOTICE_WAR_STONE_PICK, pPlayer->GetMapID(), pPlayer->GetPosX(), pPlayer->GetPosY(), 
			pPlayer->GetNationality(), 0, 0, tpProperty->GetPropertyTempID(), pPlayer->GetCharName() );
	}

	if ( tpTplNpc->mDisappear != 0 )
	{
		CSceneLogic::GetSingleton( ).DestroyEntity( tpEntity, 0 );
	}

	CMessage tMessage;
	CMessageOpenStoneResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_OPENSTONE );
	tMessage.set_msgpara( (long) &tPara );

	// 领取成功
	tPara.set_result( SUCCESS );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

// 安全保护密码重新锁定的请求
void CPropertyModule::OnMessageLockPasswordRequest( CEntityPlayer *pPlayer, CMessage *pMessage )
{	 
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return )	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	if ( tpProperty->GetRolePassword()->GetStatus() != EM_PASSWORD_PASSFREE )
	{
		SendLockPasswordResponse( pPlayer, ERR_PASSWORD_NOTFREE, tpProperty->GetRolePassword()->GetStatus() );
		return;
	}
	
	tpProperty->GetRolePassword()->SetStatus( EM_PASSWORD_PASSLOCKED );
	SendLockPasswordResponse( pPlayer, SUCCESS, tpProperty->GetRolePassword()->GetStatus() );
}

// 发送保护密码重新锁定的回应消息
void CPropertyModule::SendLockPasswordResponse( CEntityPlayer *pPlayer, int nErrcode, int nStatus )
{
	LK_ASSERT( pPlayer != NULL, return )
	CMessage tMsgHead;
	CMessageLockPasswordResponse tMsgLockPassword;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_LOCKPASSWORD );
	tMsgHead.set_msgpara( (int)&tMsgLockPassword );
	
	tMsgLockPassword.set_errcode( nErrcode );
	tMsgLockPassword.set_status( nStatus );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );	
}

// 检查结婚装备能否使用
int CPropertyModule::CheckMarriageEquipmentValid( CEntityPlayer *pPlayer, CTplItem *pTplItem, CItemObject *pItemObj, CEntity *pEntity )
{  
	if ( pPlayer == NULL || pTplItem == NULL || pItemObj == NULL || pEntity == NULL )
	{
		return SUCCESS;
	}
	
	if ( pTplItem->mItemType != CTplItem::ITEM_WEAPON  )
	{
		return SUCCESS;
	}
	
	CTemplateEquipment *tpTplEquipment = ( CTemplateEquipment * )pTplItem;
	if( tpTplEquipment->mEquipType != CTemplateEquipment::PART_MARRY )
	{
		return SUCCESS;
	}
	
	CItemEquipment *tpEquipment = ( CItemEquipment * )pItemObj;
	CEntityPlayer *tpSpouse = ( CEntityPlayer * )pEntity;

	// 判断是否是结拜信物
	if ( tpEquipment->IsSwornEquipment() == true )
	{
		if ( tpSpouse->GetSwornID() <= 0 )
		{
			return EM_SWORNEQUIPMENT_NOTINSWORNTEAM;
		}
		if ( tpSpouse->GetSwornID() != tpSpouse->GetSwornID() )
		{
			return EM_SWORNEQUIPMENT_NOTINSAMESWORNTEAM;
		}
		return SUCCESS;	
	}	

	// 结婚信物
	CMarriageInfo *tpMarriageInfo = CMarriageManager::GetSingleton().GetMarriageInfoByID( pPlayer->GetNationality(), pPlayer->GetMarriageID() );
	if ( tpMarriageInfo == NULL )
	{
		return EM_MARRIAGE_MARRIAGEEQUIP_NOTMARRIED;
	}

	if ( pEntity->IsPlayer() == false )
	{
		return EM_MARRIAGE_MARRIAGEEQUIP_NOTSPOUSE;
	}
	if ( tpSpouse->GetCharID() != tpMarriageInfo->GetBrideID() && tpSpouse->GetCharID() != tpMarriageInfo->GetGroomID() )
	{
		return EM_MARRIAGE_MARRIAGEEQUIP_NOTSPOUSE;
	}
	
	if ( tpEquipment->GetSpouseID() != (int)tpSpouse->GetCharID() )
	{
		return	EM_MARRIAGE_MARRIAGEEQUIP_NOTMARRIEDKEEPSAKE;
	}
	
	return SUCCESS;
}

void CPropertyModule::OnMessageLearnOgreSkillRequest(CEntityPlayer* pPlayer, CMessage* pMessage )
{
	CMessageLearnOgreSkillRequest* tpRequest = ( CMessageLearnOgreSkillRequest* ) pMessage->msgpara();
	LK_ASSERT( pPlayer != NULL && tpRequest != NULL, return );

	CPropertyPlayer* tpSrcProperty = ( CPropertyPlayer* ) pPlayer->GetProperty();

	int tCardID = tpRequest->cardid();

	if ( tpSrcProperty->mActiveCardList.find( tCardID ) == tpSrcProperty->mActiveCardList.end() )
	{
		return;
	}

	CTplItemCard* tplCard = ( CTplItemCard* ) CDataStatic::SearchTpl( tCardID );
	if ( tplCard == NULL )
	{
		LOG_ERROR( "pro", "temp %d not exist ", tCardID );
		return ;
	}

	CTemplateSkill *tpSkill1 = (CTemplateSkill *)CDataStatic::SearchTpl( tplCard->mSkillID1 );
	CTemplateSkill *tpSkill2 = (CTemplateSkill *)CDataStatic::SearchTpl( tplCard->mSkillID2 );
	if ( tpSkill1 == NULL || tpSkill2 == NULL )
	{
		return;
	}

	tpSrcProperty->GetSkillList().InsertSkill( tpSkill1->mSkillID, 1 );
	tpSrcProperty->GetSkillList().InsertSkill( tpSkill2->mSkillID, 1 );

	CMessage tMessage;
	CMessageLearnOgreSkillResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_LEARNOGRESKILL );
	tMessage.set_msgpara( (long) &tPara );

	tPara.set_result( SUCCESS );
	tPara.set_cardid( tCardID );
	tPara.set_index1( tpSrcProperty->GetSkillList().GetSkillIndexByID( tpSkill1->mSkillID ) );
	tPara.set_index2( tpSrcProperty->GetSkillList().GetSkillIndexByID( tpSkill2->mSkillID ) );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	return ;
}

void CPropertyModule::OnMessageQueryPedalRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageQueryPedalRequest *tpMsg =  ( CMessageQueryPedalRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	//CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpMsg->npcentityid(), __FUNCTION__ );
		return;
	}

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	if ( tpTplNpc->mPedalIndex <= 0 || tpTplNpc->mPedalIndex >= OGREINDEX )
	{
		return;
	}
	CPedalCreator *tpCreator = (CPedalCreator*)CCreatorManager::GetSingleton().GetCreator( tpTplNpc->mPedalIndex );
	if ( tpCreator == NULL )
	{
		return;
	}

	CMessage tMessage;
	CMessageQueryPedalResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_QUERYPEDAL );
	tMessage.set_msgpara( (long) &tPara );

	tPara.set_existtime( tpCreator->mExistTime );
	for ( unsigned int i = 0; i < ARRAY_CNT(tpCreator->mRandList); i++ )
	{
		if ( tpCreator->mRandList[ i ].mActive == true )
		{
			tPara.add_hour( tpCreator->mRandList[ i ].mHour );
		}
	}
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::SendGetItemNotify( CEntityPlayer *pPlayer, int vItemID, int vNum, int vType, int vSpecial, int vLevel )
{
	// 如果是开袋出的，要提示
	int nParam[4] = {0};
	nParam[0] = pPlayer->GetCharID();
	nParam[1] = vLevel;
	nParam[2] = vItemID;
	nParam[3] = vNum;
	int tCode = 0;
	int tGlobal = 0;
	if ( vType == MINEMAP_NOTICE )
	{
		tCode = NOTICE_MINEMAP;
		tGlobal = 1;
	}
	else if ( vType == COUNTRY_NOTICE )
	{
		tCode = NOTICE_GETITEM;
	}
	else if ( vType == WORLD_NOTICE )
	{
		tCode = NOTICE_GETITEM;
		tGlobal = 1;
	}
	else if ( vType == SPECIAL_NOTICE )
	{
		tCode = vSpecial;
		tGlobal = 1;
	}
	else
	{
		return;
	}
	if ( tGlobal == 1 )
	{
		CPropertyModule::GetSingleton().SendEventNotify( tCode, 1, nParam, 4, (char*)pPlayer->GetCharName(), NULL, pPlayer->GetRoleWorldID() );
		CPropertyModule::GetSingleton().SendEventNotify( tCode, 2, nParam, 4, (char*)pPlayer->GetCharName(), NULL, pPlayer->GetRoleWorldID() );
		CPropertyModule::GetSingleton().SendEventNotify( tCode, 3, nParam, 4, (char*)pPlayer->GetCharName(), NULL, pPlayer->GetRoleWorldID() );
		CPropertyModule::GetSingleton().SendEventNotify( tCode, 4, nParam, 4, (char*)pPlayer->GetCharName(), NULL, pPlayer->GetRoleWorldID() );
	}
	else
	{
		CPropertyModule::GetSingleton().SendEventNotify( tCode, pPlayer->GetNationality(), nParam, 4, (char*)pPlayer->GetCharName(), NULL, pPlayer->GetRoleWorldID() );
	}
}

// 中断玩家读条
void CPropertyModule::StopProgress( CEntityPlayer *pPlayer )
{	
	LK_ASSERT( pPlayer != NULL, return )	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	if(  tpProperty->GetProgressFunc() != CTemplateProgressConfig::PROGRESS_FUCTYPE_HORSE )
	{
		tpProperty->SetProgressStartTime( 0 );	
	}
}

int CPropertyModule::OnMessageUseSummonItemRequest( CEntityPlayer* pEntity, CMessage *pMessage )
{
	CMessageUseSummonItemRequest* tpRequest = ( CMessageUseSummonItemRequest* ) pMessage->msgpara();
	if ( pEntity == NULL || tpRequest == NULL )
	{
		return -1;
	}

	CItemObject *pItemObject = ((CPropertyPlayer*) pEntity->GetProperty())->GetBaggage( )->GetItemObjPtr( tpRequest->itemindex() );
	if ( pItemObject == NULL ) return -1;

	CTplItem *tpItem = (CTplItem*)CDataStatic::SearchTpl( pItemObject->GetItemID() );

	if ( tpItem->mItemType != ITEM_SUMMON )
	{
		return -1;
	}

	CEntityPlayer *tpDesPlayer = (CEntityPlayer*)CSceneLogic::GetSingleton().GetPlayerByName( tpRequest->charname().c_str() );
	if ( tpDesPlayer != NULL && pEntity->GetCharID() == tpDesPlayer->GetCharID() )
	{
		return -1;
	}
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pEntity->GetProperty();

	CMessage tSceneMessage;
	CMessageUseSummonItemResponse tPara;
	tSceneMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_USESUMMONITEM );
	tSceneMessage.set_msgpara( (long) &tPara );

	// 增加使用次数判断
	if ( tpItem->mCountType != 0 )
	{
		CTemplateCountTable *tpCountTable = (CTemplateCountTable*)CDataStatic::GetTemp( TEMP_COUNT );
		if ( tpCountTable == NULL || ( tpItem->mCountType >= (int) ARRAY_CNT(tpCountTable->mCountData) ) )
		{
			tPara.set_result( ERROR_ITEM_OVER_TIME );
			CSceneLogic::GetSingleton().Send2Player( pEntity, &tSceneMessage );
			return -1;
		}
		int tKey = CPersonalTimesMgr::MakeKey((enTimeMgrType)tpItem->mCountType, 0);
		int tTimes = pProperty->GetTimesMgr()->GetTimes(tKey);
		
		if ( pProperty->IsVip() ) 
		{
			if ( tTimes >= tpCountTable->mCountData[ tpItem->mCountType ].mVipTime )
			{
				tPara.set_result( ERROR_ITEM_OVER_TIME );
				CSceneLogic::GetSingleton().Send2Player( pEntity, &tSceneMessage );
				return -1;
			}		
		}
		else
		{
			if ( tTimes >= tpCountTable->mCountData[ tpItem->mCountType ].mCountTime )
			{
				tPara.set_result( ERROR_ITEM_OVER_TIME );
				CSceneLogic::GetSingleton().Send2Player( pEntity, &tSceneMessage );
				return -1;
			}
		}
	}

	CTplPKValueTable* tpTable = ( CTplPKValueTable* ) CDataStatic::GetTemp( TEMP_PKVALUE );
	if ( tpTable == NULL )
	{
		return -1;
	}
	if ( IS_REPETION_LINE_ID( pEntity->GetLineID() ) 
		|| pEntity->GetLineID() != pEntity->GetNationality()
		|| CDataStatic::IsWeddingHall( pEntity->GetMapID() ) == true 
		|| pEntity->HasStall() == true
		|| pEntity->GetMapID() == tpTable->mMapID )
	{
		tPara.set_result( ERROR_SUMMONWRONGPLACE );
		CSceneLogic::GetSingleton().Send2Player( pEntity, &tSceneMessage );
		return -1;
	}

	CTplItemSummon* tpSummon = ( CTplItemSummon* ) tpItem;

	CMessageTrySummonRequest tRequest;
	CMessage tGateMessage;

	tGateMessage.mutable_msghead()->set_messageid( ID_S2G_REQUEST_TRYSUMMON );
	tGateMessage.set_msgpara( (uint32)&tRequest );

	tRequest.set_charid( pEntity->GetCharID() );
	if ( tpRequest->has_charname() )
	{
		tRequest.set_charname( tpRequest->charname().c_str() );
	}
	tRequest.set_itemindex( tpRequest->itemindex() );
	tRequest.set_summontype( tpSummon->mSummonType );
	CSceneLogic::GetSingletonPtr()->Send2Gate( &tGateMessage );

	return SUCCESS;
}

void CPropertyModule::OnMessageGetStarRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageGetStarRequest *tpMsg =  ( CMessageGetStarRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpMsg->npcentityid(), __FUNCTION__ );
		return;
	}

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	int tEquipIndex = tpMsg->equipindex();
	int tItemIndex = tpMsg->itemindex();
	CMessage tMessage;
	CMessageGetStarResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_GETSTAR );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_equipindex( tEquipIndex );
	tPara.set_itemindex( tItemIndex );

	if ( tpTplNpc->mDirectService == 0 )
	{
		return;
	}	

	if( ( !pProperty->GetBaggage( )->CheckIndexValid( tEquipIndex ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( tItemIndex ) ) )
	{
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( tEquipIndex );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( tItemIndex );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		return;
	}	

	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		return;
	}		   	

	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID());
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		return;
	}
	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR && tpItem1->mItemType != CTplItem::ITEM_MAGICWEAPON ) || tpItem2->mItemType != CTplItem::ITEM_GETSTAR )
	{
		return;
	}	

	CTemplateDirectTable *tpTable = (CTemplateDirectTable*)CDataStatic::GetTemp( TEMP_DIRECT );
	if ( tpTable == NULL )
	{
		return;
	}
	CTemplateEquipment *tpEquip = (CTemplateEquipment*)tpItem1;	
	CItemEquipment *tEquip = (CItemEquipment*)tItem1;
	uint64_t ullGUIDOfItem1 = tItem1->GetGUID();
	//uint64_t ullGUIDOfItem2 = tItem2->GetGUID();
	
	if ( tEquip->GetLevel() < 0 || tEquip->GetLevel() > ITEMUPLIMIT )
	{
		return;
	}
	// 如果金钱不足
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tpEquip->mUpgCharge )
	{
		return;
	}

	CItemBoxToolkit tItemBoxTooKit( pProperty->GetBaggage() );
	if ( tItemBoxTooKit.GetLeftPileNum( -1 ) < (int)( ARRAY_CNT(tpTable->mLuckRate)+1 ) )
	{
		tPara.set_result( ERROR_INSERTITEM_NOSPACE );	
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return;
	}

	int tItemID = tpTable->mDirectID[ tpEquip->mShowLevel ][ tEquip->GetLevel() ];

	if ( tItemID != 0 )
	{
		if ( PlayerRemoveItem( pPlayer, tItemIndex, 1 ) == 0 )
		{
			int nPrevLevel = tEquip->GetLevel();			
			CItemObject* tpItemObject = CPropertyModule::GetSingleton().PlayerInsertItem(pPlayer, tItemID, 1,false);
			if ( tpItemObject)
			{
				LogEventGetItemByGetStar(pPlayer, tpItemObject->GetGUID(), tItemID, 1, tEquip->GetItemID(), ullGUIDOfItem1);
			}
			int tDropNum = 0;
			int tRand= RAND(SERVER_PERCENT_INT);
			int	tLowRan		= 0;
			int	tHighRan	= 0;				
			for ( unsigned int i = 0; i < ARRAY_CNT(tpTable->mLuckRate); i++ )
			{
				tLowRan		+= ( i == 0 ) ? 0 : tpTable->mLuckRate[ i - 1 ];
				tHighRan	+= tpTable->mLuckRate[ i ];
				if ( tRand >= tLowRan && tRand < tHighRan )
				{
					tDropNum = i + 1;
					break;
				}
			}

			CTplItem* pTplDropItem = (CTplItem*)CDataStatic::SearchTpl( tpTable->mLuckID[ tEquip->GetLevel() ] ); 
			if( pTplDropItem == NULL )
			{
				return;
			}

			// 对于不可堆叠的物品，分批插入
			if( pTplDropItem->mPileLimit == 1 )
			{
				for( int nDropIdx = 0; nDropIdx < tDropNum; nDropIdx++ )
				{
					tpItemObject = CPropertyModule::GetSingleton().PlayerInsertItem(pPlayer, pTplDropItem->mTempID, 1, false);
					if ( tpItemObject)
					{
						LogEventGetItemByGetStar(pPlayer, tpItemObject->GetGUID(), pTplDropItem->mTempID, 1, tEquip->GetItemID(), ullGUIDOfItem1);
					}
				}
			}
			else
			{
				tpItemObject = CPropertyModule::GetSingleton().PlayerInsertItem(pPlayer, pTplDropItem->mTempID, tDropNum, false);
				if ( tpItemObject)
				{
					LogEventGetItemByGetStar(pPlayer, tpItemObject->GetGUID(), pTplDropItem->mTempID, tDropNum, tEquip->GetItemID(), ullGUIDOfItem1);
				}
			}


			LogEventLostItemByGetStar(pPlayer, ullGUIDOfItem1, tpItem2->mTempID, 1, UPG_SUCCESS, tpItem1->mTempID, 0);
			if (PlayerChangeMoney( pPlayer, tpEquip->mUpgCharge, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByUpgradeEquip(pPlayer, CYuanBao::em_bind_money, tpEquip->mUpgCharge, tpItem1->mTempID, ullGUIDOfItem1);
			}
			tEquip->SetLevel( 0 );
			tPara.set_result( SUCCESS );
			LogEventItemLevelUpAction(pPlayer, tpItem1->mTempID, ullGUIDOfItem1, UPG_PROPERTY, UPG_SUCCESS, 
					0, nPrevLevel, tpItem2->mTempID, tItem1->GetBindStatus());
		}
	}
	else
	{
		tPara.set_result( ERROR_NOSTAR );
	}
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::OnMessageAddStarRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageAddStarRequest *tpMsg =  ( CMessageAddStarRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

	int tEquipIndex = tpMsg->equipindex();
	int tItemIndex = tpMsg->itemindex();
	CMessage tMessage;
	CMessageAddStarResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDSTAR );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_equipindex( tEquipIndex );
	tPara.set_itemindex( tItemIndex );

	if( ( !pProperty->GetBaggage( )->CheckIndexValid( tEquipIndex ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( tItemIndex ) ) )
	{
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( tEquipIndex );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( tItemIndex );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		return;
	}	

	if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
	{
		return;
	}		   	

	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID());
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		return;
	}
	// 如果第一件不是装备或者第二件不是升级道具或者第三件不是保底或者运气
	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR && tpItem1->mItemType != CTplItem::ITEM_MAGICWEAPON ) || tpItem2->mItemType != CTplItem::ITEM_DIRECT )
	{
		return;
	}

	CTemplateEquipment *tpEquip = (CTemplateEquipment*)tpItem1;	
	CItemEquipment *tEquip = (CItemEquipment*)tItem1;
	CTplItemDirect *tpDirect = (CTplItemDirect*)tpItem2;
	uint64_t ullGUIDOfItem1 = tItem1->GetGUID();
	//uint64_t ullGUIDOfItem2 = tItem2->GetGUID();

	if ( tpEquip->mShowLevel > tpDirect->mLevel )
	{
		tPara.set_result( ERROR_STARHIGHSTAR );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return;
	}

	if ( tEquip->GetLevel() >= tpDirect->mStar )
	{
		tPara.set_result( ERROR_STARHIGHSTAR );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return;
	}

	if ( ( tItem2->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED && ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
	{
		if ( !( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
		{				
			SetEquipBindTime( tItem1 );
		}	
		tItem1->SetBindStatus( tItem1->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, tEquipIndex, tItem1->GetBindStatus( ) );
	}

	if ( PlayerRemoveItem( pPlayer, tItemIndex, 1 ) == 0 )
	{
		int nPrevLevel = tEquip->GetLevel();
		LogEventLostItemByAddStar(pPlayer, ullGUIDOfItem1, tpItem2->mTempID, 1, UPG_SUCCESS, tpItem1->mTempID, 0);
		tEquip->SetLevel( tpDirect->mStar );
		tPara.set_result( SUCCESS );
		tPara.set_star( tpDirect->mStar );
		LogEventItemLevelUpAction(pPlayer, tpItem1->mTempID, ullGUIDOfItem1, UPG_PROPERTY, UPG_SUCCESS, 
					tEquip->GetLevel(), nPrevLevel, tpItem2->mTempID, tItem1->GetBindStatus());
		
	}
	else
	{
		return;
	}

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::SendPickItemNotify( CEntityPlayer *pPlayer, int vItemID )
{
	if ( pPlayer == NULL || vItemID == 0 )
		return;

	CMessagePlayerPickItemNotify tNotify;
	CMessage tMessage;

	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_PLAYERPICKITEM );
	tMessage.set_msgpara( (uint32)&tNotify );

	tNotify.set_playername( pPlayer->GetCharName() );
	tNotify.set_itemid( vItemID );

	CEntityPlayer* tTeamPlayerList[ TEAM_NUMBER ] = { NULL };
	int tNum = 0;
	CTeamModule::GetSingleton().OnGetMemberList( pPlayer, tTeamPlayerList, TEAM_NUMBER, tNum );
	for ( int i = 0; i < tNum; i ++ )
	{
		if ( tTeamPlayerList[ i ] != NULL && tTeamPlayerList[ i ] != pPlayer )
		{
			CSceneLogic::GetSingleton().Send2Player( tTeamPlayerList[ i ], &tMessage );
		}
	}
}

// 通知客户端 开始计时啦
void CPropertyModule::NotifyClientStartTimer(CEntityPlayer* pPlayer, EPosType vType, int nIndex, unsigned int tTime )
{
	CMessageItemStartTimerNotify tNotify;
	tNotify.set_item_index( nIndex );
	tNotify.set_overdue_time(tTime);
	tNotify.set_pos_type(vType);
	CMessage tMessage;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_STARTTIMER );
	tMessage.set_msgpara( (uint32)&tNotify );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}


void CPropertyModule::OnMessageAddExtraRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageAddExtraRequest *tpMsg =  ( CMessageAddExtraRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpMsg->npcentityid(), __FUNCTION__ );
		return;
	}

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	int tEquipIndex = tpMsg->equipindex();
	int tItemIndex = tpMsg->itemindex();
	CMessage tMessage;
	CMessageAddExtraResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_ADDEXTRA );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_equipindex( tEquipIndex );
	tPara.set_itemindex( tItemIndex );	

	if ( tpTplNpc->mExtraService == 0 )
	{
		return;
	}	

	if( ( !pProperty->GetBaggage( )->CheckIndexValid( tEquipIndex ) ) || ( !pProperty->GetBaggage()->CheckIndexValid( tItemIndex ) ) )
	{
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( tEquipIndex );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( tItemIndex );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		return;
	}	   	

	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID());
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		return;
	}
	if ( ( tpItem1->mItemType != CTplItem::ITEM_WEAPON && tpItem1->mItemType != CTplItem::ITEM_ARMOR ) || tpItem2->mItemType != CTplItem::ITEM_FUNCITEM )
	{
		return;
	}

	CTemplateEquipment *tpEquip = (CTemplateEquipment*)tpItem1;	
	CItemEquipment *tEquip = (CItemEquipment*)tItem1;
	CTplFuncItem *tplFuncItem = (CTplFuncItem*)tpItem2;
	uint64_t ullGUIDOfItem1 = tItem1->GetGUID();
	//uint64_t ullGUIDOfItem2 = tItem2->GetGUID();
	
	if ( tplFuncItem->mFuncCode != FUNCCODE_EXTRA )
	{
		return;
	}

	if ( tpEquip->mEquipType > CTemplateEquipment::PART_CLOAK )
	{
		tPara.set_result( ERROR_CANNOTEXTRA );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
		return;
	}

	// 如果金钱不足
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() + pProperty->GetBindMoney() );
	if ( tBaggageMoney < (unsigned int)tpEquip->mExtCharge )
	{
		return;
	}

	// 如果已经有的效果高
	if ( tEquip->GetExtraType() != CTemplateEquipment::EXTRA_NONE )
	{
		if ( tEquip->GetExtraType() == CTemplateEquipment::EXTRA_SECOND || tplFuncItem->mParams[ 0 ] == CTemplateEquipment::EXTRA_FIRST )
		{
			tPara.set_result( ERROR_CANNOTEXTRA );
			CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
			return;
		}
	}
	if ( PlayerRemoveItem( pPlayer, tItemIndex, 1 ) == 0 )
	{
		tEquip->SetExtraType( tplFuncItem->mParams[ 0 ] );
		LogEventLostItemByAddExtra(pPlayer, ullGUIDOfItem1, tpItem2->mTempID, 1, UPG_SUCCESS, tpItem1->mTempID, 0);
		if (PlayerChangeMoney( pPlayer, tpEquip->mExtCharge, true, true ) == SUCCESS)
		{
			LogEventLostMoneyByAddExtra(pPlayer, CYuanBao::em_bind_money, tpEquip->mExtCharge, tpItem1->mTempID, ullGUIDOfItem1);
		}
		tPara.set_extratype( tEquip->GetExtraType() );
		tPara.set_result( SUCCESS );
		// 耍流氓直接绑
		if ( ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == 0 )
		{
			if ( !( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BINDED ) )
			{					
				SetEquipBindTime( tItem1 );
			}	
			tItem1->SetBindStatus( tItem1->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
			SendBindItemNotify( pPlayer, tEquipIndex, tItem1->GetBindStatus( ) );
		}
	}
	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
	// 记录装备印鉴效果
	LogEventItemMarkAction(pPlayer, tEquip->GetItemID(), tEquip->GetGUID(), tpItem2->mTempID, tEquip->GetBindStatus());
}

void CPropertyModule::OnMessageWarOperateRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageWarOperateRequest *tpMsg =  ( CMessageWarOperateRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *pProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}
	CEntityNpc *tpNpc = (CEntityNpc*)tpEntity;

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpMsg->npcentityid(), __FUNCTION__ );
		return;
	}	

	CProperty* tpProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpProperty->GetPropertyTempID() );
		return ;
	}

	if ( tpTplNpc->mWarOpType == CTemplateNpc::WAR_OP_NONE )
	{
		return;
	}

	// 空中不能操作
	if ( pProperty->GetStateParam( STATE_FLY ).mInState == true )
	{
		return;
	}

	CMessage tGateMessage;
	CMessageWarChangeNotify tGatePara;
	tGateMessage.mutable_msghead()->set_messageid( ID_S2G_NOTIFY_WARCHANGE );
	tGateMessage.set_msgpara( (long) &tGatePara );
	tGatePara.set_mapid( pPlayer->GetMapID() );

	if ( tpTplNpc->mWarOpType == CTemplateNpc::WAR_OP_CHARACTER )
	{
		if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_JUDIAN, pPlayer->GetClientInfo()->mNetSpeed ) == false )
		{
			LOG_ERROR( "pro","wrong progresstime when war, roleid:%d", pPlayer->GetCharID() );
			return;
		}
		int tOldCamp = tpNpc->GetOwnCampID();
		if ( tOldCamp == pPlayer->GetNationality() )
			return;
		tpNpc->SetOwnCampID( pPlayer->GetNationality() );
		SendChangeOwnCampNotify( tpNpc );
		tGatePara.set_seedtype( CHANGE_ADD );
		tGatePara.set_worldid( pPlayer->GetNationality() );
		tGatePara.set_seedvalue( tpTplNpc->mWarValue );
		CSceneLogic::GetSingleton().Send2Gate( &tGateMessage );

		SendWarEventNotify( NOTICE_WAR_FLAG_OCCUPY, pPlayer->GetMapID(), pPlayer->GetPosX(), pPlayer->GetPosY(), 
			tOldCamp, pPlayer->GetNationality(), tpTplNpc->mWarValue, tpProperty->GetPropertyTempID(), pPlayer->GetCharName() );

		ObtainWarHonor( pPlayer, tpTplNpc->mWarHonor, false );

		if ( tOldCamp != 0 )
		{
			tGatePara.set_seedtype( CHANGE_DEL );
			tGatePara.set_worldid( tOldCamp );
			CSceneLogic::GetSingleton().Send2Gate( &tGateMessage );
		}
	}

	if ( tpTplNpc->mWarOpType == CTemplateNpc::WAR_OP_STONE )
	{
		if ( pProperty->CheckProgressTime( CTemplateProgressConfig::PROGRESS_FUCTYPE_INSTONE, pPlayer->GetClientInfo()->mNetSpeed ) == false )
		{
			LOG_ERROR( "pro","wrong progresstime when war, roleid:%d", pPlayer->GetCharID() );
			return;
		}

		CPropertyPlayer *tpPropertyPlayer = (CPropertyPlayer*)pPlayer->GetProperty();
		if ( tpPropertyPlayer->GetStateParam( STATE_STONE ).mInState == false )
		{
			return;
		}		
		int tBuffID = tpPropertyPlayer->GetStateParam( STATE_STONE ).mIndex;
		// 要单走一套删除流程,先干掉状态,再删BUFF
		int tNpcID = tpPropertyPlayer->GetStateParam( STATE_STONE ).mParames1;
		SendWarEventNotify( NOTICE_WAR_STONE_GIVE, pPlayer->GetMapID(),	pPlayer->GetPosX(), pPlayer->GetPosY(), 
			pPlayer->GetNationality(), 0, 0, tNpcID, pPlayer->GetCharName() );
		CTemplateNpc * tplNpc = (CTemplateNpc*)CDataStatic::SearchTpl( tNpcID );
		if ( tplNpc != NULL && tplNpc->mTownX != 0 && tplNpc->mTownY != 0 )
		{
			CWTPoint tPoint( 0, 0 );
			CPropertyModule::GetSingleton().CreateNpc( pPlayer, tNpcID, ENTITYTYPE_FUNCNPC, tPoint, tplNpc->mTeleTime * 1000 );
			//SendWarEventNotify( NOTICE_WAR_STONE_CREATE, pPlayer->GetMapID(), tplNpc->mTownX, tplNpc->mTownY, 
			//	pPlayer->GetNationality(), 0, 0, tNpcID, pPlayer->GetCharName() );
		}		
		tpPropertyPlayer->DetachState( STATE_STONE, 0, BUFF, 0, 0 );
		pPlayer->EntityRemoveBuff( tBuffID );
		LogEventLostBuffByStateStone(pPlayer,tBuffID );

		tGatePara.set_worldid( pPlayer->GetNationality() );
		tGatePara.set_sourcetype( CHANGE_ADD );
		tGatePara.set_sourcevalue( tplNpc->mWarValue );
		CSceneLogic::GetSingleton().Send2Gate( &tGateMessage );

		ObtainWarHonor( pPlayer, tpTplNpc->mWarHonor, false );
	}

	CMessage tSceneMessage;
	CMessageWarOperateResponse tScenePara;
	tSceneMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_WAROPERATE );
	tSceneMessage.set_msgpara( (long) &tScenePara );

	// 领取成功
	tScenePara.set_result( SUCCESS );
	tScenePara.set_optype( tpMsg->optype() );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tSceneMessage );
	return ;
}

void CPropertyModule::SendChangeOwnCampNotify( CEntityNpc *tpNpc )
{
	if ( tpNpc == NULL )
		return;
	CMessage tMessage;
	CMessageChangeOwnCampNotify tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_CHANGEOWNCAMP );
	tMessage.set_msgpara( (long) &tPara );

	tPara.set_npcentityid( tpNpc->GetEntityID() );
	tPara.set_campid( tpNpc->GetOwnCampID() );
	tPara.set_posx( tpNpc->GetPosX() );
	tPara.set_posy( tpNpc->GetPosY() );
	tPara.set_tempid( tpNpc->GetNpcID() );

	CSceneLogic::GetSingleton().SendSceneMessage( &tMessage, -1, tpNpc->GetMapID() );
}

void CPropertyModule::SendWarEventNotify( int vEventID, int vMapID, int vPosX, int vPosY, int vSrcCampID, int vDesCampID, int vValue, int vTempID, const char *vName )
{

	if ( IS_BATTLE_LINE_ID( CSceneLogic::GetSingleton().GetLineID() ) == false )
		return;

	CMessage tMessage;
	CMessageEventNotify tNotify;

	CMessageHead* tpHead = tMessage.mutable_msghead();
	LK_ASSERT( tpHead != NULL, return );

	tpHead->set_messageid( ID_S2C_NOTIFY_EVENT );

	tNotify.set_eventid( vEventID );

	tNotify.add_intparam( vPosX );
	tNotify.add_intparam( vPosY );
	tNotify.add_intparam( vTempID );
	tNotify.add_intparam( vSrcCampID );
	tNotify.add_intparam( vDesCampID );
	if ( vValue != 0 )
		tNotify.add_intparam( vValue );	
	
	if ( vName != NULL )
	{
		tNotify.add_stringparam( vName );
	}

	tMessage.set_msgpara( (uint32)&tNotify );
		
	CSceneLogic::GetSingleton().SendSceneMessage( &tMessage, -1, vMapID );

	CTemplateWorldBattleConfig *tpConfig = (CTemplateWorldBattleConfig*)CDataStatic::GetTemp( TEMP_BATTLECONFIG );
	if ( tpConfig != NULL && vTempID == tpConfig->mFlagBonus )
	{		
		// 特殊处理灵石..
		if ( vEventID == NOTICE_WAR_STONE_PICK )
		{
			int tEntityID = 0;
			if ( vName != NULL )
			{
				CEntityPlayer *tpPlayer = CSceneLogic::GetSingletonPtr()->GetPlayerByName( vName );
				tEntityID = tpPlayer != NULL ? tpPlayer->GetEntityID() : 0;
			}
			CWorldModule::GetSingleton().SetStoneInfo( vMapID, 0, 0, 0, tEntityID );
		}
		if ( vEventID == NOTICE_WAR_STONE_CREATE || vEventID == NOTICE_WAR_STONE_THROW )
		{
			CWorldModule::GetSingleton().SetStoneInfo( vMapID, vTempID, vPosX, vPosY, 0 );
		}
	}	
}

void CPropertyModule::ObtainWarHonor( CEntityPlayer *pPlayer, int vValue, bool vSelf )
{
	if ( pPlayer == NULL )
		return;

	if ( IS_BATTLE_LINE_ID( CSceneLogic::GetSingleton().GetLineID() ) == false )
		return;

	CTemplateWorldBattleConfig *tpConfig = (CTemplateWorldBattleConfig*)CDataStatic::GetTemp( TEMP_BATTLECONFIG );
	if ( tpConfig == NULL )
		return;

	CMessage tSceneMessage;
	CMessageWarHonorNotify tSceneNotify;
	tSceneMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_WARHONOR );
	tSceneMessage.set_msgpara( (uint32)&tSceneNotify );

	CMessage tGateMessage;
	CMessageObtainWarHonorNotify tGateNotify;
	tGateMessage.mutable_msghead()->set_messageid( ID_S2G_NOTIFY_OBTAINWARHONOR );
	tGateMessage.set_msgpara( (uint32)&tGateNotify );

	CPropertyPlayer *tpProperty = NULL;

	tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	int tOldHonor = tpProperty->GetTodayWar();
	int tNewHonor = tpProperty->GetTodayWar() + vValue;
	if ( tNewHonor > tpConfig->mMaxWarHonor )
		tNewHonor = tpConfig->mMaxWarHonor;
	tpProperty->SetTotalWar( tpProperty->GetTotalWar() + tNewHonor- tOldHonor );
	tpProperty->SetTodayWar( tpProperty->GetTodayWar() + tNewHonor- tOldHonor );
	tpProperty->SetFreeWar( tpProperty->GetFreeWar() + tNewHonor- tOldHonor );
	
	tSceneNotify.set_totalhonor( tpProperty->GetTotalWar() );
	tSceneNotify.set_warhonor( tpProperty->GetTodayWar() );
	tSceneNotify.set_freehonor( tpProperty->GetFreeWar() );
	CSceneLogic::GetSingletonPtr()->Send2Player( pPlayer, &tSceneMessage );
	WarHonorData *pHonorData = tGateNotify.add_warhonor();
	pHonorData->set_charid( pPlayer->GetCharID() );
	pHonorData->set_warhonor( tpProperty->GetTodayWar() );
	pHonorData->set_warkill( tpProperty->GetWarKill() );

	// 发给自己
	if( vSelf == true )
	{
		CSceneLogic::GetSingleton().Send2Gate( &tGateMessage );
		return;
	}

	CEntity* pTargetEntity = NULL;
	CSeenPlayerContainer& rSeenPlayerContainer = pPlayer->GetSeenPlayersContainer();

	CSeenPlayerContainer::SeenPlayerVector::iterator it = rSeenPlayerContainer.mPlayers.begin();
	for ( ; it != rSeenPlayerContainer.mPlayers.end(); )
	{
		pTargetEntity = ( CEntity* ) CSceneObjManager::GetSingletonPtr()->GetObject( *it );
		if( pTargetEntity == NULL )
		{
			rSeenPlayerContainer.mPlayers.erase( it++ );
			continue;
		}

		++it;

		if( pTargetEntity->IsPlayer() == false )
		{
			continue;
		}

		if( pTargetEntity == pPlayer )
		{
			continue;
		}
		
		CEntityPlayer *tpTargetPlayer = (CEntityPlayer*)pTargetEntity;

		if ( tpTargetPlayer->GetNationality() != pPlayer->GetNationality() )
		{
			continue;
		}

		tpProperty = (CPropertyPlayer*)tpTargetPlayer->GetProperty();
		int tOldHonor = tpProperty->GetTodayWar();
		int tNewHonor = tpProperty->GetTodayWar() + vValue;
		if ( tNewHonor > tpConfig->mMaxWarHonor )
			tNewHonor = tpConfig->mMaxWarHonor;
		tpProperty->SetTotalWar( tpProperty->GetTotalWar() + tNewHonor- tOldHonor );
		tpProperty->SetTodayWar( tpProperty->GetTodayWar() + tNewHonor- tOldHonor );
		tpProperty->SetFreeWar( tpProperty->GetFreeWar() + tNewHonor- tOldHonor );
		
		tSceneNotify.set_totalhonor( tpProperty->GetTotalWar() );
		tSceneNotify.set_warhonor( tpProperty->GetTodayWar() );
		tSceneNotify.set_freehonor( tpProperty->GetFreeWar() );
		CSceneLogic::GetSingletonPtr()->Send2Player( tpTargetPlayer, &tSceneMessage );

		WarHonorData *pHonorData = tGateNotify.add_warhonor();
		pHonorData->set_charid( pPlayer->GetCharID() );
		pHonorData->set_warhonor( tpProperty->GetTodayWar() );
		pHonorData->set_warkill( tpProperty->GetWarKill() );
	}	
	CSceneLogic::GetSingleton().Send2Gate( &tGateMessage );
}

// 记录装备普通绑定的时间
void CPropertyModule::SetEquipBindTime( CItemObject *pItem )
{	
	LK_ASSERT( pItem != NULL, return )
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( pItem->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	if ( tpTplItem->IsEquipable() == false )
	{
		return;
	}
	
	CItemEquipment *tpEquipMent = ( CItemEquipment * )pItem;
	if ( tpEquipMent->GetBindTime() == 0 )
	{
		tpEquipMent->SetBindTime( time(NULL) );
	}	
}

void CPropertyModule::SendPlayerTransformNotify( CEntityPlayer *pPlayer )
{
	if ( pPlayer == NULL )
		return;
	CMessage tMessage;
	CMessagePlayerTransformNotify tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_PLAYERTRANSFORM );
	tMessage.set_msgpara( (long) &tPara );

	tPara.set_entityid( pPlayer->GetEntityID() );
	PBTransform *tpTran = tPara.mutable_transform();
	CPropertyPlayer *tpProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	CBuffList *tpBuff = tpProperty->GetBuffList( );
	tpBuff->GetTransform( tpTran );
	CMapModule::GetSingleton().MessageBroadCast( pPlayer, &tMessage, false, true );
}

void CPropertyModule::OnMessageLearnFangCunSkillRequest( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageLearnFangCunSkillRequest *tpMsg =  ( CMessageLearnFangCunSkillRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();	
	CSkillList& tpSkill = tpProperty->GetSkillList( );

	CEntity* tpEntity = dynamic_cast< CEntity* >( CSceneObjManager::GetSingletonPtr( )->GetObject( tpMsg->npcentityid( ) ) );
	if ( tpEntity == NULL )
	{
		return ;
	}

	if ( tpEntity->IsNpc() == false )
	{
		return;
	}

	if( !pPlayer->IsWithinDistance( tpEntity, MAX_NPC_TALK_GIRD) ) // 在合法距离之内才判断
	{
		LOG_ERROR("pro", "player %s not near npc %d! func=%s", pPlayer->GetCharNameShow(), tpMsg->npcentityid(), __FUNCTION__ );
		return;
	}

	CProperty* tpNPCProperty = ( CProperty* ) tpEntity->GetProperty();	
	CTemplateNpc* tpTplNpc = ( CTemplateNpc* ) CDataStatic::SearchTpl( tpNPCProperty->GetPropertyTempID() );
	if ( tpTplNpc == NULL )
	{
		LOG_ERROR( "pro", "npc %d not exist ", tpNPCProperty->GetPropertyTempID() );
		return ;
	}

	int	tSkillStage	= tpMsg->skillstage();
	int tSkillIndex = tpMsg->skillindex();
	int tItemIndex = tpMsg->itemindex();		

	if ( tpTplNpc->mFangCunService == 0 )
	{
		return;
	}	

	CTemplateFangCunTree *tpSkillTree = (CTemplateFangCunTree*)CDataStatic::GetTemp( TEMP_FANGCUNTREE );
	if ( tpSkillTree == NULL )
	{
		return;
	}
	if ( tSkillStage < 0 || tSkillStage >= (int)ARRAY_ROW(tpSkillTree->mNode)
		|| tSkillIndex < 0 || tSkillIndex >= (int)ARRAY_COL(tpSkillTree->mNode) )
	{
		return;
	}
	CFangCunTreeNode *tpNode = &( tpSkillTree->mNode[ tSkillStage ][ tSkillIndex ] );

	uint64_t ullGUID = 0;
	if ( tpNode->mNeedBook != 0 )
	{
		if( !tpProperty->GetBaggage()->CheckIndexValid( tItemIndex ) )
		{
			return;
		}
		CItemObject *tItem = tpProperty->GetBaggage( )->GetItemObjPtr( tItemIndex );
		if ( tItem == NULL )
		{
			return;
		}

		// 如果没有技能书
		if ( tItem->GetItemID() != (unsigned int)tpNode->mNeedBook )
		{
			SendLearnFangCunSkillResponse( pPlayer, ERROR_FANGCUN_NOITEM, 0, 0, 0 );
			return;
		}
		ullGUID = tItem->GetGUID();
	}	
	
	CSkillObject *tpSkillObj = NULL;
	tpSkillObj = tpSkill.GetSkillObjectByID( tpNode->mSkillID );
	// 如果已经学过
	if ( tpSkillObj != NULL )
	{
		SendLearnFangCunSkillResponse( pPlayer, ERROR_FANGCUN_HASLEARN, 0, 0, 0 );
		return;
	}
	// 检查已学技能
	for ( int i = 0; i < (int)ARRAY_CNT(tpNode->mNeedSkillID); i++ )
	{
		if ( tpNode->mNeedSkillID[ i ] == 0 )
			break;
		tpSkillObj = tpSkill.GetSkillObjectByID( tpNode->mNeedSkillID[ i ] );
		if ( tpSkillObj == NULL )
		{
			SendLearnFangCunSkillResponse( pPlayer, ERROR_FANGCUN_NOPRESKILL, 0, 0, 0 );
			return;
		}
	}	

	if ( pPlayer->GetLevel() < tpNode->mLevel )
	{
		SendLearnFangCunSkillResponse( pPlayer, ERROR_FANGCUN_LOWLEVEL, 0, 0, 0 );
		return;
	}
	//学习方寸山技能 检查 消耗金钱
	CTemplateSkill* tpSkillTpl = NULL;
	// 技能找不到有几种情况,1技能还未学习,2技能找不到
	tpSkillTpl = (CTemplateSkill*) CDataStatic::SearchSkill(tpNode->mSkillID, tpNode->mMaxLevel );
	if (tpSkillTpl)
	{
		CPropertyPlayer* pSrcProperty = (CPropertyPlayer*)pPlayer->GetProperty();
		if (pSrcProperty )
		{
			if (pSrcProperty->IsMoneyEnough( true, tpSkillTpl->mStudyGold ) == false )
			{
				SendProErrorNotice( pPlayer, ERROR_CLICKSP_NEEDMONEY );
				return ;
			}	
			if(PlayerChangeMoney( pPlayer, tpSkillTpl->mStudyGold , true, true )==SUCCESS)
			{
				LogEventLostMoneyByStudySkill(pPlayer, CYuanBao::em_bind_money, tpSkillTpl->mStudyGold);
			}
		}
	}
	tpSkill.InsertSkill( tpNode->mSkillID, tpNode->mMaxLevel );
	int tObjIndex = tpSkill.GetSkillIndexByID( tpNode->mSkillID );

	
	if (PlayerRemoveItem( pPlayer, tItemIndex, 1) == 0)
	{
		LogEventLostItemByFangCun( pPlayer, ullGUID, tpNode->mNeedBook, 1);
	}
	
	SendLearnFangCunSkillResponse( pPlayer, SUCCESS, tpNode->mSkillID, tItemIndex, tObjIndex );
}

void CPropertyModule::SendLearnFangCunSkillResponse( CEntityPlayer* pPlayer, int vResult, int vSkillID, int vItemIndex, int vObjIndex )
{
	CMessage tMessage;
	CMessageLearnFangCunSkillResponse tPara;
	tMessage.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_LEARNFANGCUNSKILL );
	tMessage.set_msgpara( (long) &tPara );
	tPara.set_result( vResult );
	tPara.set_skillid( vSkillID );
	tPara.set_itemindex( vItemIndex );
	tPara.set_objindex( vObjIndex );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::OnMessageHonorToItemRequest( CEntityPlayer* pPlayer, CMessage* pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );	
	CMessageHonorToItemRequest *tpMsg =  ( CMessageHonorToItemRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer *pProperty = (CPropertyPlayer*)pPlayer->GetProperty( );
	CEntityNpc *pNpc = (CEntityNpc*)CSceneObjManager::GetSingletonPtr()->GetObject( pProperty->GetTalkNpcEntityID( ) );
	if( pNpc == NULL )
	{
		LOG_ERROR( "pro", "[%s:%s:%d] can't find obj %d", __LK_FILE__, __FUNCTION__, __LINE__,  pProperty->GetTalkNpcEntityID( ) );
		return ;
	}
	CTemplateNpc *tpNpc = (CTemplateNpc*)CDataStatic::SearchTpl( pNpc->GetNpcID( ) );
	if ( tpNpc == NULL || tpNpc->mHonorService == 0 )
	{
		return;
	}

	int tItemID = tpMsg->itemid();
	int tItemNum = tpMsg->itemnum();
	CTemplateHonorToExp *tpHonor = (CTemplateHonorToExp*)CDataStatic::GetTemp( TEMP_HONORTOEXP );
	if ( tpHonor == NULL )
		return;
	if ( tItemID != tpHonor->mItemID )
		return;
	int tItemHonor = tItemNum * tpHonor->mItemHonor;
	if ( pProperty->GetHonor() < tItemHonor )
		return;
	if ( pProperty->GetItemHonor() + tItemHonor > tpHonor->mItemLimit )
		return;
	if ( pProperty->GetBaggage()->Space( tItemID, tItemNum ) == false )
	{
		SendProErrorNotice( pPlayer, ERROR_INSERTITEM_NOSPACE );
		return;
	}

	pPlayer->InitFunResult( );
	ResultListSend( );
	CItemObject* pInsItemPile = CPropertyModule::GetSingleton().PlayerInsertItem( pPlayer, tItemID, tItemNum ); 
	if ( pInsItemPile != NULL)
	{
		LogEventGetItemByHonor( pPlayer, pInsItemPile->GetGUID(), tItemID, tItemNum, tpHonor->mTempID );
		pProperty->SetHonor( pProperty->GetHonor( ) - tItemHonor );
		pProperty->SetItemHonor( pProperty->GetItemHonor() + tItemHonor );
		SendObtainHonorNotice( pPlayer, -1 * tItemHonor );			
	}
}

void CPropertyModule::OnPlayerLevelUp( CEntityPlayer *pPlayer, int vUpLevel )
{
	if ( pPlayer == NULL )
		return;

	CPropertyPlayer *pProperty = (CPropertyPlayer*)pPlayer->GetProperty( );

	pPlayer->AddFunResult( 0, FUNC_LEVELUP,	RESULT_NORMAL, true, pPlayer->GetLevel(), pProperty->GetCurHP( ), pProperty->GetMaxHP( ), pProperty->GetCurMP( ), pProperty->GetMaxMP( ) );
			
	// 升级则刷新属性
	pPlayer->NotifyPropertyRefresh( );

	LogEventPlayerExpLevelUp(pPlayer, vUpLevel);

	// 通知任务模块
	CTaskModule::GetSingleton().FireEvent( pPlayer, EVENT_LEVELCHANGE, 0 );

	// 通知活动模板
	CActivityModule::GetSingleton().OnPlayerLevelUp( pPlayer);

	// 玩家信息改变通知网关(如果需要的话)
	CCommandSendPlayerDirtyDataToGate tSendToGate( pPlayer->GetEntityID() );
	tSendToGate.OnEventTrigger( CCommandSendPlayerDirtyDataToGate::DIRTYDATA_LEVEL );
	
	// 通知活动模块
	CActivityModule::GetSingleton().OnEventInvestQuestion( INVEST_TYPE_LEVEL, pPlayer->GetLevel(), pPlayer );

	// 通知好友升级的消息
	CFriendModule::GetSingleton().FriendLevelUp( pPlayer, vUpLevel );

	// 如果有前辈，给他发邮件
	CTemplateMatrixTable *tpTable = (CTemplateMatrixTable*)CDataStatic::GetTemp( TEMP_MATRIXTABLE );	
	if ( tpTable != NULL )
	{
		bool tHasMaster = false;
		int tLevel = 0;
		for ( int j = 0; j < MAX_MASTER_NUM; j++ )
		{
			if ( pProperty->GetMasterID( j ) != 0 )
			{						  
				for ( int i = 0; i < MAX_MATRIX_LEVEL; i++ )
				{
					if ( pPlayer->GetLevel() == tpTable->mLevel[ i ] )
					{
						int tItemNum[ MAX_MASTER_AWARD_NUM ] = { 0 };
						for ( int n = 0; n < MAX_MASTER_AWARD_NUM; n++ )
						{
							int tPercent = pProperty->GetMasterPercent( j );
							if ( tPercent == 0 )
								tPercent = tpTable->mAlterDefault;
							tItemNum[ n ] = tPercent * tpTable->mMasterItemNum[ i ][ n ] / tpTable->mAlterAll;
						}
						char *tpName = (char*)pPlayer->GetCharName();			
						int tPos = 1;
						int tNum = 1;
						CMailModule::GetSingleton().SendSysMailBySysID( tpTable->mMailID[ i ], NULL,pProperty->GetMasterID( j ), tpTable->mMasterItemID[ i ],
							tItemNum, MAX_MASTER_AWARD_NUM, pPlayer->GetNationality(), 0, &tpName, &tPos, tNum, pPlayer->GetCharID() );
						tHasMaster = true;
						tLevel = i;
					}
				}
			}
		}
		if ( tHasMaster )
		{
			int tPlayerLevel = pPlayer->GetLevel();
			char pNum[10] = { 0 };
			sprintf( pNum, "%d", tPlayerLevel );			
			char *pParam[1]	= { NULL };
			int pParamPos[1] = { 0 };
			pParam[0] = (char*)pNum;
			pParamPos[0] = 1;
			CMailModule::GetSingleton().SendSysMailBySysID( tpTable->mSlaveMailID, NULL,pPlayer->GetCharID(), tpTable->mSlaveItemID[ tLevel ],
							tpTable->mSlaveItemNum[ tLevel ], MAX_MASTER_AWARD_NUM, pPlayer->GetNationality(), 0, pParam, pParamPos, 1, pPlayer->GetCharID() );
		}
	}

	// 升级影响人物活力上限值
	pProperty->RefreshMaxAP();
}

// 处理修炼经验丹的函数
void CPropertyModule::AddExpToExpContainer( CEntityPlayer *pPlayer, int nExp )
{
	LK_ASSERT( pPlayer != NULL , return )
	
	if ( nExp <= 0 )
	{
		return;
	}	
	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	int nIndex = -1;
	int nNum = 0;
	int tRet = tpProperty->GetBaggage()->HasItemOfCertainType( CTplItem::ITEM_EXPCONTAINER,  nNum, nIndex );
	if ( tRet != SUCCESS || nIndex < 0 )
	{
		return;	
	}
	
	CItemObject *tpItemObj = tpProperty->GetBaggage()->GetItemObjPtr( nIndex );		
	LK_ASSERT( tpItemObj != NULL, return )	
	
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItemObj->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	
	if ( tpTplItem->mItemType != CTplItem::ITEM_EXPCONTAINER )
	{
		return;
	}
	
	CTplItemExpContainer *tpTplExpContainer = ( CTplItemExpContainer * )tpTplItem;
	CItemExpContainer *tpItemExpContainer = ( CItemExpContainer * )tpItemObj;
	
	unsigned long long tExp = tpItemExpContainer->GetExp() + nExp*( tpTplExpContainer->mOgreExpRate/SERVER_PERCENT_FLOAT );
	if ( tExp >= tpTplExpContainer->mMaxExp )
	{
		SendExpContainerNotify( pPlayer, tpTplExpContainer->mMaxExp, tpTplExpContainer->mMaxExp - tpItemExpContainer->GetExp(), nIndex, tpTplExpContainer->mExpPillsID );	
		PlayerRemoveItem( pPlayer, nIndex, 1 );
		PlayerInsertItem( pPlayer, tpTplExpContainer->mExpPillsID, 1, false );		
		return;
	}
	if ( tExp > tpItemExpContainer->GetExp() )
	{
		SendExpContainerNotify( pPlayer, tExp, tExp - tpItemExpContainer->GetExp(), nIndex, 0 );	
		tpItemExpContainer->SetExp( tExp );		
	}  	
}

// 发送修炼经验丹经验改变的通知
void CPropertyModule::SendExpContainerNotify( CEntityPlayer *pPlayer, unsigned long long nExp, int nExpAdded, int nIndex, int nExpPillsID )
{
	 CMessage tMsgHead;
	 CMessageExpContainerNotify tMsgExpNotify;
	 
	 tMsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_EXPCONTAINER );
	 tMsgHead.set_msgpara( (int)& tMsgExpNotify );
	 tMsgExpNotify.set_currentexp( nExp );
	 tMsgExpNotify.set_expadded( nExpAdded );
	 tMsgExpNotify.set_exppillsid( nExpPillsID );
	 tMsgExpNotify.set_index( nIndex );
	 
	 CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 使用经验丹
int CPropertyModule::OnUseExpPills(CEntity *pEntity, CTplItem *tpItem, int vIndex)
{
	 LK_ASSERT( pEntity != NULL && tpItem != NULL, return -1 )
	 if ( tpItem->mItemType != CTplItem::ITEM_EXPPILLS )
	 {
		return 0;
	 }
	 
	 CTplItemExpPills *tpTplExpPills = ( CTplItemExpPills * )tpItem;
	 CEntityPlayer *pPlayer = ( CEntityPlayer * )pEntity;
	 if ( pPlayer->GetLevel() >= MAX_GRADE )
	 {
		SendProErrorNotice( pPlayer, ERROR_EXPPILLS_MAXLEVEL );
		return 0;
	 }
	 
	 if ( pPlayer->GetLevel() < tpTplExpPills->mLevelLimit )
	 {
		SendProErrorNotice( pPlayer, ERROR_EXPPILLS_LEVELLOW );
		return 0;
	 }
	 
	int tCharID = pPlayer->GetCharID();
	PlayerObtainExp2( pPlayer, tpTplExpPills->mExp, 0, EXPREASON_EXPITEM, &tCharID, 1 );	
	LogEventGetExpByExpPill(pPlayer, tpTplExpPills->mExp, tpTplExpPills->mTempID );
					 
	PlayerRemoveItem( pPlayer, vIndex, 1 );	
	uint64_t tGuID = 0;
	LogEventLostItemByUse( pPlayer, tGuID, tpTplExpPills->mTempID, 1  );	
	return 0;
}

//发送元宝更新消息
void CPropertyModule::SendUpdateYuanbaoNotice( CEntity* pPlayer, const int vAmount, const int vType )
{
	if ( pPlayer == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	if ( vAmount == LK_ZERO )
	{
		return ;
	}	

	CMessage tTotalMessage;

	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		LOG_DEBUG( "pro", "[ %s : %d ] [ %s ]", __LK_FILE__, __LINE__, __FUNCTION__ );
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTICE_YUANBAOUPDATE );

	CMessageUpdateYuanBaoNotice tMessage;
	tMessage.set_moneytype(vType);
	tMessage.set_amount( vAmount );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

// 使用时装绣花针
void CPropertyModule::UseFashionNeedle( CEntityPlayer *pPlayer, int nNeedleIndex, int nFashionIndex, int nFashionslot )
{
	LK_ASSERT( pPlayer != NULL , return )
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * ) pPlayer->GetProperty();
	CItemObject *tpItem = tpProperty->GetBaggage()->GetItemObjPtr( nNeedleIndex ); 
	LK_ASSERT( tpItem != NULL, return )
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItem->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	
	if ( tpTplItem->mItemType != CTplItem::ITEM_FUNCITEM )
	{
		return;
	}
	
	CTplFuncItem *tpTplFuncItem = ( CTplFuncItem * )tpTplItem;
	if ( tpTplFuncItem->mFuncCode != FUNCCODE_FASHIONNEEDLE )
	{
		return;
	}	
	
	tpItem = NULL;
	if ( nFashionslot == SLOT_EQUIPMENT )
	{
		tpItem = tpProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_FASHION );
	}
	else if ( nFashionslot == SLOT_BAGGAGE )
	{
		tpItem = tpProperty->GetBaggage()->GetItemObjPtr( nFashionIndex );
	}
	else if( nFashionslot == SLOT_STORAGE )
	{	
		tpItem = tpProperty->GetStorage()->GetItemObjPtr( nFashionIndex ); 	
	}
	
	if ( tpItem == NULL )
	{
		return;
	}
	
	tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItem->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	
	if ( tpTplItem->mItemType != CTplItem::ITEM_FASHION )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_FASHIONNEEDLE_NOTFASHION, nFashionslot, nFashionIndex, nNeedleIndex, 0, 0 );		
		return;
	}
	
	CTemplateEquipment *tpTplEquip = ( CTemplateEquipment * )tpTplItem;
	if ( tpTplEquip->mEquipType != CTemplateEquipment::PART_FASHION )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_FASHIONNEEDLE_NOTFASHION, nFashionslot, nFashionIndex, nNeedleIndex, 0, 0 );
		return;
	}
	
	if ( ( ( 1 << ( tpTplEquip->mShowColour - 1 ) ) & tpTplFuncItem->mParams[0] ) == 0 )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_FASHIONNEEDLE_WRONGCOLOR, nFashionslot, nFashionIndex, nNeedleIndex, 0, 0 );
		return;
	}			
	
	CItemEquipment *tpEquip = ( CItemEquipment * )tpItem;
	if ( tpEquip->IsOvertimed()  == false )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_FASHIONNEEDLE_FASHIONNOTEXPIRED, nFashionslot, nFashionIndex, nNeedleIndex, 0, 0 );
		return;
	}

	// 绣花针不能修补时装时效小于自己修补时长的时装
	if ( tpTplEquip->mValidTime < tpTplFuncItem->mParams[1] )
	{
		SendUseKitbagNeedleResponse( pPlayer, ERR_FASHIONNEEDLE_WRONGCOLOR, nFashionslot, nFashionIndex, nNeedleIndex, 0, 0 );
		return;	
	}
	
	int tExpiredTime = time( NULL ) + tpTplFuncItem->mParams[1]*60;
	tpEquip->SetInvalidTime( tExpiredTime );
	SendUseKitbagNeedleResponse( pPlayer, SUCCESS, nFashionslot, nFashionIndex, nNeedleIndex, tExpiredTime, tpTplFuncItem->mParams[1] );	
	LogEventLostItemByUse( pPlayer, tpItem->GetGUID(), tpItem->GetItemID(), 1 );				
	PlayerRemoveItem( pPlayer, nNeedleIndex, 1 );
		
	
	if ( nFashionslot == SLOT_EQUIPMENT )
	{
		CMessage        MsgHead; 		
		tpProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
		CMessageEntityRefreshNotice FreshMsg;
		CreateMessageEntityRefreshNotice( &MsgHead, &FreshMsg, pPlayer->GetEntityID(), tpProperty->GetCurHP( ), tpProperty->GetCurMP( ), tpProperty->GetMaxHP( ),  tpProperty->GetMaxMP( ) );
		CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &MsgHead );
		
		CMessage tPlayerChange;
		CMessagePlayerChangeEquipNotice tMessage;	
		CItemEquipment* tpFashion = (CItemEquipment*)tpProperty->GetEquipment()->GetItemObjPtr( EQUIPMENT_FASHION );
		int tFashionID = 0;
		if ( tpFashion != NULL && tpFashion->IsOvertimed() == false )
		{
			tFashionID = tpFashion->GetItemID();
		}
		int tMWID = 0,	tMarriageEquipID = 0;
		int tWeaponLevel = 0, tChestLevel = 0, tWeaponJewel = 0, tChestJewel = 0;
		int vPart = EQUIPMENT_FASHION;
		tpProperty->GetEquipment()->GetLightPoint( tWeaponLevel, tChestLevel, tWeaponJewel, tChestJewel );
		CreateMessagePlayerChangeEquipNotice(
			&tPlayerChange,
			&tMessage,
			pPlayer->GetEntityID(),
			vPart,
			tFashionID,
			tpProperty->GetCurHP( ),
			tpProperty->GetCurMP( ),
			tpProperty->GetMaxHP( ),
			tpProperty->GetMaxMP( ),
			tWeaponLevel,tChestLevel,tWeaponJewel,tChestJewel,
			tMWID,
			tFashionID,
			tMarriageEquipID,
			0
			);		
		//// 把消息发送给所有看到源和目标还有牵连到的实体的所有实体		
		CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tPlayerChange, false, false );
	}
}

// 宝石雕琢
void CPropertyModule::OnMessageJewelCarveRequest( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageJewelCarveRequest *tpMsg =  ( CMessageJewelCarveRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	
	// 检查是否有密码保护
	int tPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if ( tPwdCheckRet != SUCCESS )
	{
		CPropertyModule::GetSingleton().SendProErrorNotice( pPlayer, tPwdCheckRet );
		return;
	}	

	int tJewelIndex = tpMsg->jewelindex();
	int tCardIndex = tpMsg->cardindex();
	int tJewelPos = tpMsg->jewelpos();
		
	// 防止缓冲区溢出
	// TODO:包括背包索引的检查
	if ( (!pProperty->GetBaggage()->CheckIndexValid( tJewelIndex )) || ( !pProperty->GetBaggage()->CheckIndexValid( tCardIndex ) ) )	
	{
		return;
	}
	CItemObject *tItem1 = pProperty->GetBaggage( )->GetItemObjPtr( tJewelIndex );
	CItemObject *tItem2 = pProperty->GetBaggage( )->GetItemObjPtr( tCardIndex );
	if ( tItem1 == NULL || tItem2 == NULL )
	{
		return;
	}
	
	CTplItem *tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tItem1->GetItemID() );
	CTplItem *tpItem2 = (CTplItem*)CDataStatic::SearchTpl( tItem2->GetItemID() );
	if ( tpItem1 == NULL || tpItem2 == NULL )
	{
		return;
	}

	CMessage tMsgHead;
	CMessageJewelCarveResponse tMsgResponse;	 
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_JEWELCARVE );
	tMsgHead.set_msgpara( (int)& tMsgResponse );
	tMsgResponse.set_jewelindex( tJewelIndex );
	tMsgResponse.set_cardindex( tCardIndex );
	tMsgResponse.set_jewelpos( tJewelPos );

	int tJewelTplID = 0;
	int tEquipID = 0;
	if ( tpItem1->mItemType == CTplItem::ITEM_JEWEL )
	{
		tJewelTplID = tItem1->GetItemID();
	}
	else if ( tpItem1->mItemType == CTplItem::ITEM_WEAPON || tpItem1->mItemType == CTplItem::ITEM_ARMOR )
	{
		if ( tJewelPos < 0 || tJewelPos >= JEWELNUM )
		{
			return;
		}
		CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
		tJewelTplID = tpEquip->GetSlotValue( tJewelPos );
		tEquipID = tItem1->GetItemID();

		if ( ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || ( tItem1->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND ) )
		{
			tMsgResponse.set_result( ERROR_CARVE_BINDED );
			CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
			return;
		}
	}

	tpItem1 = (CTplItem*)CDataStatic::SearchTpl( tJewelTplID );

	if ( tpItem1 == NULL )
	{
		return;
	}

	// 如果第一件不是宝石
	if ( tpItem1->mItemType != CTplItem::ITEM_JEWEL )
	{
		return;
	}		
	
	//CItemJewel *tpJewel = (CItemJewel*)tItem1;
	CTplItemJewel *tplJewel = (CTplItemJewel*)tpItem1;

	// 如果无法雕琢
	if ( tplJewel->mCanCarve == 0 )
	{
		tMsgResponse.set_result( ERROR_CARVE_CANNOT );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
		return;
	}
	// 如果符类型不对
	//if ( tplJewel->mCardID != tItem2->GetItemID() )
	if ( tItem2->IsSameItemGroup( tplJewel->mCardID, BIND_ALL ) == false )
	{
		tMsgResponse.set_result( ERROR_CARVE_NOCARD );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
		return;
	}
	
	unsigned int tBaggageMoney = ( unsigned int )( pProperty->GetMoney() );
	if ( tBaggageMoney < (unsigned int)tplJewel->mCarveCharge )
	{
		tMsgResponse.set_result( ERROR_CARVE_NOMONEY );
		CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
		return;
	}

	// 如果是宝石,检查包裹空格
	if ( tEquipID == 0 )
	{
		CItemBoxToolkit tItemBoxTooKit( pProperty->GetBaggage() );
		if ( tItemBoxTooKit.GetLeftPileNum( -1 ) <= 0 )
		{
			tMsgResponse.set_result( ERROR_CARVE_NOSPACE );
			CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
			return;
		}
	}

	int tCarveJewelID = 0;
	int tLow = 0;
	int tHigh = 0;
	int tRand = RAND(SERVER_PERCENT_INT);
	for (unsigned int i = 0; i < ARRAY_CNT(tplJewel->mCarveJewelID) && i < ARRAY_CNT(tplJewel->mCarveRand); i++ )
	{
		tLow += ( i == 0 ) ? 0 : tplJewel->mCarveRand[ i - 1 ];
		tHigh += tplJewel->mCarveRand[ i ];
		if ( tRand >= tLow && tRand <= tHigh )
		{
			tCarveJewelID = tplJewel->mCarveJewelID[ i ];
			break;
		}
	}
	if ( tCarveJewelID == 0 )
	{
		tCarveJewelID = tJewelTplID;
	}

	if (PlayerChangeMoney( pPlayer, tplJewel->mCarveCharge, true, false ) == SUCCESS)
	{
		LogEventLostMoneyByCarve(pPlayer, CYuanBao::em_unbind_money, tplJewel->mCarveCharge);
	}

	bool tBind = false;
	if ( ( tItem2->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED
		|| ( tItem1->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
	{	
		tBind = true;
	}

	// 如果是宝石,插入新的并删除旧的
	if ( tEquipID == 0 )
	{
		CItemObject * pInsItemPile = PlayerInsertItem( pPlayer, tCarveJewelID, 1, false, 0, NULL, tBind );		
		if ( pInsItemPile != NULL )
		{
			LogEventGetItemByCarve( pPlayer, pInsItemPile->GetGUID(), tCarveJewelID, 1, tItem1->GetItemID() );
		}
		uint64_t ullGUID1 = tItem1->GetGUID();
		int nItem1ID = tItem1->GetItemID();
		if( PlayerRemoveItem( pPlayer, tJewelIndex, 1 ) == 0)
		{
			LogEventLostItemByCarve(pPlayer, ullGUID1, nItem1ID, 1, tJewelPos, tJewelTplID, tCarveJewelID);
		}
	}	
	// 如果是装备,修改
	else 
	{
		CItemEquipment *tpEquip = (CItemEquipment*)tItem1;
		tpEquip->SetSlotValue( tJewelPos, tCarveJewelID );
		tMsgResponse.set_equipjewel( tCarveJewelID );
		if ( tBind )
		{
			tpEquip->SetBindStatus( tpEquip->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
			SendBindItemNotify( pPlayer, tJewelIndex, tpEquip->GetBindStatus( ) );
		}
	}

	uint64_t ullGUID2 = tItem2->GetGUID();
	int nItem2ID = tItem2->GetItemID();
	if( PlayerRemoveItem( pPlayer, tCardIndex, 1 ) == 0)
	{
		LogEventLostItemByCarve(pPlayer, ullGUID2, nItem2ID, 1, tJewelPos, tJewelTplID, tCarveJewelID);
	}

	tMsgResponse.set_result( SUCCESS );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );

	return;
}

// 客户端放数字烟花
void CPropertyModule::OnMessageStartDigitalFireworks( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pPlayer != NULL, return )	
	CMessageStartDigitalFireworksRequest *tpMsg = ( CMessageStartDigitalFireworksRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return )	
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	CItemObject *tpItem = tpProperty->GetBaggage()->GetItemObjPtr( tpMsg->itemindex() );
	LK_ASSERT( tpItem != NULL, return )
	
	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpItem->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return )
	if ( tpTplItem->mItemType != CTplItem::ITEM_FUNCITEM )
	{	
		SendResponseStartDigitalFireworks( pPlayer, ERROR_DIGITALFIREWORKS_WRONGITEM );
		return;
	}
	
	CTplFuncItem *tpTplFuncItem = ( CTplFuncItem * )tpTplItem;
	if ( tpTplFuncItem->mFuncCode != FUNCCODE_DIGITALFIREWORKS )
	{
		SendResponseStartDigitalFireworks( pPlayer, ERROR_DIGITALFIREWORKS_WRONGITEM );
		return;
	}
	
	if ( tpMsg->styleid() != (unsigned int)tpTplFuncItem->mParams[1] )
	{
		SendResponseStartDigitalFireworks( pPlayer, ERROR_DIGITALFIREWORKS_WRONGTYPE );		
		return;
	}
	
	if ( tpMsg->digitalwords_size() > tpTplFuncItem->mParams[0] )
	{
		SendResponseStartDigitalFireworks( pPlayer, ERROR_DIGITALFIREWORKS_TO0MUCHWORDS );		
		return;
	}
	
	// 添加一种新的buff
	InsertBuff( pPlayer, tpTplFuncItem->mParams[3] );
	
	CMessage tMsgHead;
	CMessageStartDigitalFireworksNotify tMsgStartDigitalFireWorks;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_STARTDIGITALFIREWORKS );
	tMsgHead.set_msgpara( (int)&tMsgStartDigitalFireWorks );
	
	tMsgStartDigitalFireWorks.set_entityid( pPlayer->GetEntityID() );
	tMsgStartDigitalFireWorks.set_posx( pPlayer->GetPosX() );
	tMsgStartDigitalFireWorks.set_posy( pPlayer->GetPosY() );
	tMsgStartDigitalFireWorks.set_styleid( tpMsg->styleid() );
	
	for ( int i = 0; i < tpMsg->digitalwords_size(); ++i )
	{
		tMsgStartDigitalFireWorks.add_digitalwords()->CopyFrom( *tpMsg->mutable_digitalwords( i ) );	
	}	
	CMapModule::GetSingleton().MessageBroadCast( pPlayer, &tMsgHead, false, true );	
	PlayerRemoveItem( pPlayer, tpMsg->itemindex(), 1 );
}

// 客户端播放数字烟花的回应消息
void CPropertyModule::SendResponseStartDigitalFireworks( CEntityPlayer *pPlayer, int nErrcode )
{	
	LK_ASSERT( pPlayer != NULL, return )		
	CMessage tMsgHead;
	CMessageStartDigitalFireworksResponse tMsgStartDigitalFireworks;
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_STARTDIGITALFIREWORKS );
	tMsgHead.set_msgpara( (int)&tMsgStartDigitalFireworks );
	
	tMsgStartDigitalFireworks.set_errcode( nErrcode );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

void CPropertyModule::LogRoleDamage( CEntityPlayer* pSrcPlayer, CEntityPlayer* pDesPlayer, int vSkillID, int vRealDamage, int vResultType )
{
	if ( pSrcPlayer == NULL || pDesPlayer == NULL )
		return;
	if ( pSrcPlayer->GetLevel() < EM_MIN_LEVEL || pDesPlayer->GetLevel() < EM_MIN_LEVEL )
		return;

	CMessage tMsgHead;
	CMessageLogRoleDamage tRoleDamage;
	
	tMsgHead.mutable_msghead()->set_messageid( ID_S2L_ROLE_DAMAGE );		
	tMsgHead.set_msgpara( (int)&tRoleDamage );	

	CPropertyPlayer* pSrcProperty = (CPropertyPlayer*) pSrcPlayer->GetProperty();
	CPropertyPlayer* pDesProperty = (CPropertyPlayer*) pDesPlayer->GetProperty();
	
	tRoleDamage.set_srccharid( pSrcPlayer->GetCharID() );
	tRoleDamage.set_descharid( pDesPlayer->GetCharID() );
	tRoleDamage.set_optime( time(NULL) );
	tRoleDamage.set_skillid( vSkillID );
	tRoleDamage.set_calcdamage( vResultType );
	tRoleDamage.set_realdamage( vRealDamage );	
	tRoleDamage.set_srcpatt( pSrcProperty->GetPAttackMax() );
	tRoleDamage.set_srcmatt( pSrcProperty->GetMAttackMax() );
	tRoleDamage.set_despdef( pDesProperty->GetPDefence() );
	tRoleDamage.set_desmdef( pDesProperty->GetMDefence() );
	tRoleDamage.set_despimu( pDesProperty->GetDecPerPDamage() );
	tRoleDamage.set_desmimu( pDesProperty->GetDecPerMDamage() );
	tRoleDamage.set_srcdhit( pSrcProperty->GetDeathValue() );
	tRoleDamage.set_desddef( pDesProperty->GetDeathDefense() );
	tRoleDamage.set_srctitle( pSrcProperty->GetCurrentTitle() );
	tRoleDamage.set_destitle( pDesProperty->GetCurrentTitle() );
	
	char tSrcRes[ 40 ] = { 0 };
	char tDesRes[ 40 ] = { 0 };
	snprintf( tSrcRes, sizeof(tSrcRes)-1, "%d %d %d %d %d %d", 
		pSrcProperty->GetResAtt( RES_TYPE1 ), pSrcProperty->GetResAtt( RES_TYPE2 ), 
		pSrcProperty->GetResAtt( RES_TYPE3 ), pSrcProperty->GetResAtt( RES_TYPE4 ),
		pSrcProperty->GetResAtt( RES_TYPE5 ), pSrcProperty->GetResAtt( RES_TYPE6 ) );
	snprintf( tDesRes, sizeof(tDesRes)-1, "%d %d %d %d %d %d", 
		pDesProperty->GetResDef( RES_TYPE1 ), pDesProperty->GetResDef( RES_TYPE2 ), 
		pDesProperty->GetResDef( RES_TYPE3 ), pDesProperty->GetResDef( RES_TYPE4 ),
		pDesProperty->GetResDef( RES_TYPE5 ), pDesProperty->GetResDef( RES_TYPE6 ) );
	tRoleDamage.set_srcres( tSrcRes );
	tRoleDamage.set_desres( tDesRes );

	char tSrcBuff[ 200 ] = { 0 };
	char tDesBuff[ 200 ] = { 0 };
	for ( unsigned int i = 0; i < pSrcProperty->GetBuffList()->mBuffNumber; i++ )
	{
		char tBuff[ 7 ] = { 0 };
		snprintf( tBuff, sizeof(tBuff)-1, "%d ", pSrcProperty->GetBuffList()->mBuffList[ i ].mBuffID );
		strcat( tSrcBuff, tBuff );
		strcat( tSrcBuff, " " );
	}
	for ( unsigned int i = 0; i < pDesProperty->GetBuffList()->mBuffNumber; i++ )
	{
		char tBuff[ 7 ] = { 0 };
		snprintf( tBuff, sizeof(tBuff)-1, "%d ", pDesProperty->GetBuffList()->mBuffList[ i ].mBuffID );
		strcat( tDesBuff, tBuff );
		strcat( tDesBuff, " " );
	}
	tRoleDamage.set_srcbuff( tSrcBuff );
	tRoleDamage.set_desbuff( tDesBuff );

    CSceneLogic::GetSingleton().Send2Log( &tMsgHead, tMsgHead.mutable_msghead()->messageid(), 0 );
}

// 发送装备宝石升级消息
void CPropertyModule::SendUpgAndJewNotice( CEntityPlayer *pPlayer, int vType, int vLevel, CItemObject *pObject )
{
	if ( pPlayer == NULL || pObject == NULL )
		return;
	CMessage tMsgHead;
	CMessageUpgAndJewNotify tMsgNotify;
	 
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_NOTICE_UPGANDJEW );
	tMsgHead.set_msgpara( (int)& tMsgNotify );
	tMsgNotify.set_playername( pPlayer->GetCharName() );
	tMsgNotify.set_type( vType );
	PBItemObject *tpPBObject = tMsgNotify.mutable_iteminfo();

	if ( vType == UPG_NOTICE )
	{
		switch( vLevel )
		{
		case NOTICE_UPG_FIRST:
			{
				pObject->GetItemBinaryBuffer2( tpPBObject, 1 );
				CMapModule::GetSingletonPtr()->MessageBroadCast( pPlayer, &tMsgHead, false, true );
				break;
			}
		case NOTICE_UPG_SECOND:
			{
				pObject->GetItemBinaryBuffer2( tpPBObject, 1 );
				CSceneLogic::GetSingleton().SendCountryMessage( &tMsgHead, pPlayer->GetNationality() );
				break;
			}
		case NOTICE_UPG_THIRD:
			{
				pObject->GetItemBinaryBuffer2( tpPBObject, 1 );
				CSceneLogic::GetSingleton().SendWorldMessage( &tMsgHead );
				break;
			}
		default:
			break;
		}
		
	}
	if ( vType == JEW_NOTICE )
	{
		switch( vLevel )
		{
			case NOTICE_JEW_FIRST:
			{
				pObject->GetItemBinaryBuffer2( tpPBObject, 1 );
				CSceneLogic::GetSingleton().SendWorldMessage( &tMsgHead );
				break;
			}
			default:
				break;
		}
	}
}

void CPropertyModule::OnMessageQueryBossRequest( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageQueryBossRequest *tpMsg =  ( CMessageQueryBossRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CMessage tMsgHead;
	CMessageQueryBossResponse tMsgResponse;	 
	tMsgHead.mutable_msghead()->set_messageid( ID_S2C_RESPONSE_QUERYBOSS );
	tMsgHead.set_msgpara( (int)& tMsgResponse );

	time_t tval;
	struct tm *now;        
	time(&tval);
	now = localtime(&tval);	

	CCreatorManager::NotifyList::iterator tBeginIter = CCreatorManager::GetSingletonPtr()->mNotifyList.begin();
	CCreatorManager::NotifyList::iterator tEndIter = CCreatorManager::GetSingletonPtr()->mNotifyList.end();
	for ( ; tBeginIter != tEndIter; ++tBeginIter)
	{
		COgreCreator *pCreator = (COgreCreator *) CSceneObjManager::GetSingletonPtr()->GetObject( *tBeginIter );
		if ( pCreator == NULL )
			continue;	
		PBBoss *tpBoss = tMsgResponse.add_bossdata();
		CEntityOgre *tpOgre = (CEntityOgre*) CSceneObjManager::GetSingletonPtr()->GetObject( pCreator->mHasOgre );
		if ( tpOgre != NULL && tpOgre->mHasCreated == true )
		{
			CPropertyCharacter* pProperty = (CPropertyCharacter*)tpOgre->GetProperty();
			tpBoss->set_tempid( tpOgre->GetNpcID() );
			tpBoss->set_mapid( tpOgre->GetMapID() );
			tpBoss->set_posx( tpOgre->GetPosX() );
			tpBoss->set_posy( tpOgre->GetPosY() );
			tpBoss->set_hp( pProperty->GetCurHP() );
		}
		else
		{
			tpBoss->set_tempid( pCreator->mRefresh1[ 0 ].mOgreID );	
			tpBoss->set_mapid( pCreator->mMapID );
			tpBoss->set_posx( pCreator->mPosition.mX );
			tpBoss->set_posy( pCreator->mPosition.mY );
			tpBoss->set_hp( 0 );
		}
		
		tpBoss->set_configtime( pCreator->GetRightTime( now ) );
		tpBoss->set_nexttime( pCreator->mNextRefreshTime );
	}

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsgHead );
}

// 处理法宝分解消息
void CPropertyModule::OnMessageDecomposeMW( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageDecomposeMWRequest *tpMsg =  ( CMessageDecomposeMWRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

	CItemObject* pObj = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->itemindex());
	LK_ASSERT( pObj, return );

	// 看看是不是法宝
	if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}

	if ( (pObj->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (pObj->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
		return;
	}

	CMessageDecomposeMWResponse msg;
	msg.set_itemindex(tpMsg->itemindex());
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_DECOMPOSEMW);

	// 查分解表	
	// 组装物品数组
	int tItemIds[20]={0};
	int tItemNums[20]={0};
	CTemplateMagicWeapon* pMagicWeaponTpl = (CTemplateMagicWeapon*)CDataStatic::SearchTpl(pObj->GetItemID());
	if (NULL == pMagicWeaponTpl)
	{
		return;
	}
	CMagicWeaponDecomposeTable* pMWDecomposeTable = (CMagicWeaponDecomposeTable*)CDataStatic::SearchTpl(pMagicWeaponTpl->mDecomposeTabID);
	if (NULL == pMWDecomposeTable)
	{
		return; // 无法分解，客户端已判断
	}

	// 检查钱
	bool bEnough = false;
	switch(pMWDecomposeTable->mNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_NONE:
		{
			bEnough = true;
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			bEnough = (tpProperty->GetBindMoney()+tpProperty->GetMoney()>=pMWDecomposeTable->mNeedMoney);
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			bEnough = (tpProperty->GetMoney()>=pMWDecomposeTable->mNeedMoney);
			break;
		}
	default:
		{

		}
	}

	if (!bEnough)
	{
		msg.set_retcode(ERROR_MW_DECPOM_LESSMONEY);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	unsigned int i = 0;
	for ( ; i < ARRAY_CNT(pMWDecomposeTable->mItems); ++i )
	{
		if ( pMWDecomposeTable->mItems[i].mTempID == 0 )
			break;
		tItemIds[i] = pMWDecomposeTable->mItems[i].mTempID;
		tItemNums[i] = pMWDecomposeTable->mItems[i].mNumMax;
	}
	// 检查包满（无视概率）
	if (!tpProperty->TestBaggageSpace( tItemIds, tItemNums, i ))
	{
		msg.set_retcode(ERROR_MW_DECPOM_BAGFUL);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

//	bool bBind = (pObj->GetBindStatus()!=ITEM_BINDSTATUS_FREE ); 【都非绑】
	bool bBind=false;
	// 生成物品，进包
	for ( unsigned int i = 0; i < ARRAY_CNT(pMWDecomposeTable->mItems); ++i )
	{
		if ( pMWDecomposeTable->mItems[i].mTempID == 0 )
			break;
		// 先随机得不得
		if ( RAND(10000) < pMWDecomposeTable->mItems[i].mProb ) // 获得
		{
			int nNum = pMWDecomposeTable->mItems[i].mNumMin+RAND(pMWDecomposeTable->mItems[i].mNumMax-pMWDecomposeTable->mItems[i].mNumMin);
			CItemObject *pInsItemPile = PlayerInsertItem( pPlayer, pMWDecomposeTable->mItems[i].mTempID, nNum, false, 0, NULL, bBind );
			if ( pInsItemPile != NULL)
			{
				LogEventGetItemByDeCompound( pPlayer, 
					pInsItemPile->GetGUID(), pMWDecomposeTable->mItems[i].mTempID, nNum, 
					pObj->GetItemID(), pObj->GetGUID() ); 
			}
		}
	}

	// 扣钱
	switch(pMWDecomposeTable->mNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, pMWDecomposeTable->mNeedMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByDecompos(pPlayer, CYuanBao::em_bind_money, pMWDecomposeTable->mNeedMoney);
			}
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, pMWDecomposeTable->mNeedMoney, true, false ) == SUCCESS)
			{
				LogEventLostMoneyByDecompos(pPlayer, CYuanBao::em_unbind_money, pMWDecomposeTable->mNeedMoney);
			}
			break;
		}
	default:
		{

		}
	}

	// 扣法宝
	uint64_t guid = pObj->GetGUID();
	int nItemID = pObj->GetItemID();
	int nItemNum = pObj->GetItemNum();
	if ( PlayerRemoveItem( pPlayer, tpMsg->itemindex(), pObj->GetItemNum()) == 0)	
	{
		LogEventLostItemByDecompound( pPlayer, guid, nItemID, nItemNum );
	}

	// 回复消息
	msg.set_retcode(0);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 处理法宝印记消息
void CPropertyModule::OnMessageMWQLPrintRequest( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageMWQLPrintRequest *tpMsg =  ( CMessageMWQLPrintRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

	CItemObject* pObj = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->mwindex());
	LK_ASSERT( pObj, return );
	bool bBind = (pObj->GetBindStatus()!=ITEM_BINDSTATUS_FREE );

	CItemObject* pObjQL = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->qlindex());
	LK_ASSERT( pObjQL, return );
	if (!bBind)
		bBind = (pObjQL->GetBindStatus()!=ITEM_BINDSTATUS_FREE );

	if (tpProperty->GetBaggage()->CheckIndexValid( tpMsg->mwindex(), true ) == false)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_MWCANTIN_INVALIDBAG );
		return;
	}

	if (tpProperty->GetBaggage()->CheckIndexValid( tpMsg->qlindex(), true ) == false)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_CANTIN_INVALIDBAG );
		return;
	}

	if ( (int)tpMsg->itemindex() != -1 && tpProperty->GetBaggage()->CheckIndexValid( tpMsg->itemindex(), true ) == false)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_CANTIN_INVALIDBAG );
		return;
	}

	//CItemObject* pObjItem = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->itemindex());

	// 看看是不是法宝
	if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}

	// 如果是法宝，检查有没有被手动绑定
	if ( (pObj->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (pObj->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
		return;
	}

	// 检查放上来的是不是器灵
	if ( !CheckItemType( pObjQL->GetItemID(), CTplItem::ITEM_FUNCITEM) )
	{
		return;
	}
	CTplFuncItem* tpItemQL = (CTplFuncItem*)CDataStatic::SearchTpl( pObjQL->GetItemID() );
	LK_ASSERT( tpItemQL, return );

	if( tpItemQL->mFuncCode != FUNCCODE_QILING )
		return;

	CMessageMWQLPrintResponse msg;
	msg.set_mwindex(tpMsg->mwindex());
	msg.set_qlid(pObjQL->GetItemID());
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_MWQLPNT);

	// 检查品级
	CTemplateMagicWeapon* tplMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl(pObj->GetItemID());
	LK_ASSERT( tplMW, return );
	if ( tpItemQL->mParams[QLIDX_LEVEL] < tplMW->mLvByNum )
	{
		msg.set_retcode(ERROR_MW_PRINT_ERRPIN);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 检查钱
	if ( tpProperty->GetMoney() < tpItemQL->mParams[QLIDX_MONEY] )
	{
		msg.set_retcode(ERROR_MW_PRINT_LESSMONEY);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 扣钱
	if (PlayerChangeMoney( pPlayer, tpItemQL->mParams[QLIDX_MONEY] , true, false ) == SUCCESS)
	{
		LogEventLostMoneyByMWPrint(pPlayer, CYuanBao::em_unbind_money, tpItemQL->mParams[QLIDX_MONEY]);
	}

	// 计算概率
	int nProb=tpItemQL->mParams[QLIDX_PROP];

	// 如果有石头，概率加成
	CItemObject* pObjItem = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->itemindex());
	if (pObjItem != NULL)
	{
		//if (!bBind)
		//	bBind = (pObjItem->GetBindStatus()!=ITEM_BINDSTATUS_FREE );
		// 检查放上来的是不是幸运符
		if ( !CheckItemType( pObjItem->GetItemID(), CTplItem::ITEM_FUNCITEM) )
		{
			return;
		}
		CTplFuncItem* tpItem = (CTplFuncItem*)CDataStatic::SearchTpl( pObjItem->GetItemID() );
		if (tpItem == NULL)
			return;
		if ( tpItem->mFuncCode != FUNCCODE_MWPRNTLUCKY)
			return;

		// 检查品级
		if ( tpItem->mParams[1] != tpItemQL->mParams[QLIDX_LEVEL] )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_PRINT_PIN_ERR );
			return;
		}
		nProb += tpItem->mParams[0];

		uint64_t ullGUID = pObjItem->GetGUID();
		int nTplID = pObjItem->GetItemID();
		// 扣物品
		if( PlayerRemoveItem( pPlayer, tpMsg->itemindex(), 1 ) == 0 )
		{
			LogEventLostItemByCompose( pPlayer, ullGUID, nTplID, 1, pObjItem->GetItemID(), 1, pObjItem->GetGUID());
		}
	}

	// 扣器灵
	uint64_t ullGUID = pObjQL->GetGUID();
	int nTplID = pObjQL->GetItemID();
	if( PlayerRemoveItem( pPlayer, tpMsg->qlindex(), 1 ) == 0 )
	{
		LogEventLostItemByCompose( pPlayer, ullGUID, nTplID, 1, pObj->GetItemID(), 1, pObj->GetGUID());
	}

	if ( RAND(10000) > nProb )
	{
		msg.set_retcode(ERROR_MW_PRINT_FAILED);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 概率校验成功，走法宝内部
	CItemMagicWeapon* pObjMW=(CItemMagicWeapon*)pObj;
	int nRet = pObjMW->OnPrintQilin(pObjQL->GetItemID());

	// 如果要绑定 则绑定法宝
	if (bBind)
	{
		pObjMW->SetBindStatus( pObjMW->GetBindStatus( ) | ITEM_BINDSTATUS_BINDED );
		SendBindItemNotify( pPlayer, tpMsg->mwindex(), pObjMW->GetBindStatus( ) );
	}

	// 给客户端刷新法宝常规属性
	if (nRet == 0)
	{
		// 刷新法宝属性
		NotifyRefreshMagicWeaponProperty( pPlayer,  tpMsg->mwindex() );
	}

	// 回复消息
	msg.set_retcode(nRet);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

// 处理法宝飞升消息
void CPropertyModule::OnMessageMWQuickUpRequest( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageQuickUpRequest *tpMsg =  ( CMessageQuickUpRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

	CItemObject* pObj = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->mwindex());
	if (pObj == NULL)
		return;

	bool	bBind = (pObj->GetBindStatus()!=ITEM_BINDSTATUS_FREE );

	CItemObject* pObjItem = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->itemindex());
	if (pObjItem == NULL)
		return;

	if (!bBind)
		bBind = (pObjItem->GetBindStatus()!=ITEM_BINDSTATUS_FREE );

	if (tpProperty->GetBaggage()->CheckIndexValid( tpMsg->mwindex(), true ) == false)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_MWCANTIN_INVALIDBAG );
		return;
	}

	if (tpProperty->GetBaggage()->CheckIndexValid( tpMsg->itemindex(), true ) == false)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_CANTIN_INVALIDBAG );
		return;
	}

	if ( tpMsg->uptype() == MWUp_Level&& tpProperty->GetBaggage()->CheckIndexValid( tpMsg->mwindexex(), true ) == false)
	{
		SendProErrorNotice( pPlayer, ERROR_MW_MWCANTIN_INVALIDBAG );
		return;
	}

	// 看看是不是法宝
	if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_NOTMW );
		return;
	}

	// 检查有没有被手动绑定
	if ( (pObj->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (pObj->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
		return;
	}

	CTemplateMagicWeapon* tplMW = (CTemplateMagicWeapon*)CDataStatic::SearchTpl(pObj->GetItemID());
	LK_ASSERT( tplMW, return );

	int nTabID = 0;
	if (tpMsg->uptype() == MWUp_Color) // 如果是飞升
	{
		nTabID = tplMW->mQuickUpTabID;
	}
	else if(tpMsg->uptype() == MWUp_Level) // 如果是升品
	{
		nTabID = tplMW->mUpLevelTabID;
	}
	CMagicWeaponQuickUpTable* tpQuickTable = (CMagicWeaponQuickUpTable*)CDataStatic::SearchTpl(nTabID);
	if (tpQuickTable == NULL)
		return; // 不能升级

	CMessageQuickUpResponse msg;
	msg.set_mwindex(tpMsg->mwindex());
	msg.set_uptype(tpMsg->uptype());
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_QUICKUP);
	// 检查等级
	CItemMagicWeapon* pObjMW=(CItemMagicWeapon*)pObj;
	if ( pObjMW->GetMWLevel() < tpQuickTable->mNeedLevel )
	{
		msg.set_retcode( ERROR_MW_QUICKUP_LEVELLESS );
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 检查钱
	bool bEnough = false;
	switch(tpQuickTable->mNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_NONE:
		{
			bEnough = true;
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			bEnough = (tpProperty->GetBindMoney()+tpProperty->GetMoney()>=tpQuickTable->mNeedMoney);
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			bEnough = (tpProperty->GetMoney()>=tpQuickTable->mNeedMoney);
			break;
		}
	default:
		{

		}
	}

	if (!bEnough)
	{
		msg.set_retcode(ERROR_MW_QUICKUP_LESSMONEY);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	if ( !CheckItemType( pObjItem->GetItemID(), CTplItem::ITEM_FUNCITEM ) )
	{
		SendProErrorNotice( pPlayer, ERROR_MW_QUICKUP_LESSITEM );
		return;
	}

	CTplItem* tpTplItem = (CTplItem*)CDataStatic::SearchTpl(pObjItem->GetItemID());
	LK_ASSERT(tpTplItem != NULL, return );

	// 检查物品
	if ( (pObjItem->GetItemID() != (unsigned int)tpQuickTable->mNeedItem && tpTplItem->mCommonID != tpQuickTable->mNeedItem)
		|| pObjItem->GetItemNum() < (unsigned int)tpQuickTable->mNeedItemNum )
	{
		msg.set_retcode(ERROR_MW_QUICKUP_LESSITEM);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 如果是升品，检查副法宝
	if (tpMsg->uptype() == MWUp_Level)
	{
		CItemObject* pObjEx=(CItemObject*)tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->mwindexex());
		if (pObjEx == NULL)
			return;
		if ( (pObjEx->GetBindStatus() & ITEM_BINDSTATUS_BYITEM ) || (pObjEx->GetBindStatus() & ITEM_BINDSTATUS_FREEBIND) )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_BIND_BYITEM );
			return;
		}
		if (!bBind)
			bBind = (pObjEx->GetBindStatus()!=ITEM_BINDSTATUS_FREE );

		if ( !CheckItemType( pObjEx->GetItemID(), CTplItem::ITEM_MAGICWEAPON ) )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_UPLEVEL_ERROR2NDMW );
			return;
		}

		CItemMagicWeapon* pObjMWEx=(CItemMagicWeapon*)pObjEx;
		// 检查等级
		if ( (pObjMW->GetMWLevel() - pObjMWEx->GetMWLevel() ) > tpQuickTable->mLeastLeve )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_UPLEVEL_ERROR2NDMW );
			return;
		}

		// 检查颜色
		CTemplateMagicWeapon* tplMWEx = (CTemplateMagicWeapon*)CDataStatic::SearchTpl(pObjMWEx->GetItemID());
		LK_ASSERT( tplMWEx, return );

		// 副法宝的颜色最多只能比主法宝低一档
		if (tplMWEx->mShowColour < tplMW->mShowColour-1 )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_UPLEVEL_ERROR2NDMW );
			return;
		}

		// 检查品级(不低于)
		if ( tplMWEx->mLvByNum > tplMW->mLvByNum )
		{
			SendProErrorNotice( pPlayer, ERROR_MW_UPLEVEL_ERROR2NDMW );
			return;
		}
	}

	// 扣钱
	switch(tpQuickTable->mNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, tpQuickTable->mNeedMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByUpgradeEquip(pPlayer, CYuanBao::em_bind_money, tpQuickTable->mNeedMoney, pObj->GetItemID(), pObj->GetGUID());
			}
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, tpQuickTable->mNeedMoney, true, false ) == SUCCESS)
			{
				LogEventLostMoneyByUpgradeEquip(pPlayer, CYuanBao::em_unbind_money, tpQuickTable->mNeedMoney, pObj->GetItemID(), pObj->GetGUID());
			}
			break;
		}
	default:
		{

		}
	}

	// 扣物品
	uint64_t ullGUID = pObjItem->GetGUID();
	int nTplID = pObjItem->GetItemID();
	if( PlayerRemoveItem( pPlayer, tpMsg->itemindex(), tpQuickTable->mNeedItemNum ) == 0 )
	{
		LogEventLostItemByMWQuickUp( pPlayer, ullGUID, nTplID, tpQuickTable->mNeedItemNum);
	}
	else
	{
		msg.set_retcode(ERROR_MW_QUICKUP_LESSITEM);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 计算成功否
	if ( RAND(10000)<tpQuickTable->mSuccessProb )
	{
		// 如果是升品，扣除副法宝
		if (tpMsg->uptype() == MWUp_Level)
		{
			CItemObject* pObjEx=(CItemObject*)tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->mwindexex());
			uint64_t ullGUID = pObjEx->GetGUID();
			int nTplID = pObjEx->GetItemID();
			if( PlayerRemoveItem( pPlayer, tpMsg->mwindexex(), 1 ) == 0 )
			{
				LogEventLostItemByMWQuickUp( pPlayer, ullGUID, nTplID, 1);
			}
			else
			{
				return;
			}
		}
	
		// 成功，扣法宝，发新法宝
		uint64_t ullGUID = pObj->GetGUID();
		int nTplID = pObj->GetItemID();
		if( PlayerRemoveItem( pPlayer, tpMsg->mwindex(), 1 ) == 0 )
		{
			LogEventLostItemByMWQuickUp( pPlayer, ullGUID, nTplID, 1);
		}
		else
		{
			return;
		}
		CItemObject *pInsItemPile = PlayerInsertItem( pPlayer, tpQuickTable->mNewMWID, 1, false, 0, NULL, bBind);
		if ( pInsItemPile != NULL)
		{
			LogEventGetItemByMWQuickUp( pPlayer, 
				pInsItemPile->GetGUID(), tpQuickTable->mNewMWID, 1,  nTplID );
		}
		msg.set_retcode(0);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 回复消息
	msg.set_retcode(ERROR_MW_QUICKUP_FAILED);
	CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
}

void CPropertyModule::OnMessageQilinComposeRequest( CEntityPlayer* pPlayer, CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageQilinComposeRequest *tpMsg =  ( CMessageQilinComposeRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();

	CMessageQilinComposeResponse msg;
	CMessage tMessage;
	tMessage.set_msgpara((uint32_t) &msg);
	tMessage.mutable_msghead()->set_messageid(ID_S2C_RESPONSE_QLCOMPOSE);

	// 遍历放上来的器灵
	int nNeedMoneyType=0;
	int nNeedMoney=0;
	int nPinJi = -1;
	int nTotalProb = 0;
	// 最新修改：如果器灵不够 不让合成
	if ( tpMsg->qlindex_size() < MAX_MW_QL_COMPOSE_NUM )
	{
		msg.set_retcode(ERROR_MW_QL_LESS);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}
	
	bool bBind = false;
	std::map<int, int> tIdProbs; // 每个ID最终产生的概率 
	for (int i = 0; i < tpMsg->qlindex_size() && i < MAX_MW_QL_COMPOSE_NUM; ++i )
	{
		if (tpProperty->GetBaggage()->CheckIndexValid( tpMsg->qlindex(i), true ) == false)
		{
			SendProErrorNotice( pPlayer, ERROR_MW_CANTIN_INVALIDBAG );
			return;
		}

		CItemObject* pObj = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->qlindex(i));
		if (pObj == NULL)
			return;

		if (!bBind)
			bBind = (pObj->GetBindStatus()!=ITEM_BINDSTATUS_FREE );

		if ( !CheckItemType( pObj->GetItemID(), CTplItem::ITEM_FUNCITEM ) )
			return;

		CTplFuncItem* tpTplQl = (CTplFuncItem*)CDataStatic::SearchTpl(pObj->GetItemID());
		if (tpTplQl == NULL)
			return;

		if (tpTplQl->mFuncCode != FUNCCODE_QILING)
			return;

		if (nPinJi == -1)
			nPinJi = tpTplQl->mParams[QLIDX_LEVEL];

		if (nPinJi != tpTplQl->mParams[QLIDX_LEVEL]) // 品级不符
			return;

		if ( tpTplQl->mParams[QLIDX_COMPOS_MONEY] > nNeedMoney )
		{
			nNeedMoney = tpTplQl->mParams[QLIDX_COMPOS_MONEY];
			nNeedMoneyType = tpTplQl->mParams[QLIDX_COMPOS_MONEY_TYPE];
		}
		
		std::map<int, int>::iterator itFind = tIdProbs.find(tpTplQl->mParams[QLIDX_COMPOS_ID]);
		if ( itFind == tIdProbs.end() ) // 没找到
		{
			tIdProbs.insert(std::pair<int,int>(tpTplQl->mParams[QLIDX_COMPOS_ID], tpTplQl->mParams[QLIDX_COMPOS_PROB]));
		}
		else
		{
			itFind->second += tpTplQl->mParams[QLIDX_COMPOS_PROB];
		}
		nTotalProb += tpTplQl->mParams[QLIDX_COMPOS_PROB];
	}

	// 检查钱
	bool bEnough = false;
	switch(nNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_NONE:
		{
			bEnough = true;
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			bEnough = (tpProperty->GetBindMoney()+tpProperty->GetMoney()>=nNeedMoney);
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			bEnough = (tpProperty->GetMoney()>=nNeedMoney);
			break;
		}
	default:
		{

		}
	}

	if (!bEnough)
	{
		msg.set_retcode(ERROR_MW_QUICKUP_LESSMONEY);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
		return;
	}

	// 扣钱
	switch(nNeedMoneyType)
	{
	case MW_DECOMPOS_MONEY_TYPE_BINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, nNeedMoney, true, true ) == SUCCESS)
			{
				LogEventLostMoneyByMWQLCompose(pPlayer, CYuanBao::em_bind_money, nNeedMoney);
			}
			break;
		}
	case MW_DECOMPOS_MONEY_TYPE_NOTBINDMONEY:
		{
			if (PlayerChangeMoney( pPlayer, nNeedMoney, true, false ) == SUCCESS)
			{
				LogEventLostMoneyByMWQLCompose(pPlayer, CYuanBao::em_unbind_money, nNeedMoney);
			}
			break;
		}
	default:
		{

		}
	}

	// 扣物品
	for (int i = 0; i < tpMsg->qlindex_size() && i < MAX_MW_QL_COMPOSE_NUM; ++i )
	{
		CItemObject* pObjItem = tpProperty->GetBaggage()->GetItemObjPtr(tpMsg->qlindex(i));
		uint64_t ullGUID = pObjItem->GetGUID();
		int nTplID = pObjItem->GetItemID();
		if( PlayerRemoveItem( pPlayer, tpMsg->qlindex(i), 1 ) == 0 )
		{
			LogEventLostItemByMWQLCompose( pPlayer, ullGUID, nTplID, 1);
		}
	}

	// 随机 决定物品
	int nRandNum = RAND(nTotalProb)+1;
	int nGetItemID = 0;
	for ( std::map<int, int>::iterator it = tIdProbs.begin(); it != tIdProbs.end(); ++it )
	{
		nRandNum -= it->second;
		if ( nRandNum <= 0 )
		{
			nGetItemID = it->first;
			break;
		}
	}

	// 发物品
	if (nGetItemID != 0)
	{
		CItemObject *pInsItemPile = PlayerInsertItem( pPlayer, nGetItemID, 1, false, 0, NULL, bBind );
		if ( pInsItemPile != NULL)
		{
			LogEventGetItemByMWQLCompose( pPlayer, 	pInsItemPile->GetGUID(), nGetItemID, 1 );
		}
		msg.set_retcode(0);
		CSceneLogic::GetSingleton( ).Send2Player( pPlayer, &tMessage );
	}
}

void CPropertyModule:: OnMessageBagLockRequest( CEntityPlayer *pPlayer,  CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageBaggageLockedRequest *tpMsg =  ( CMessageBaggageLockedRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CMessage tMsg;
	CMessageBaggageLockedResponse tMsgResponse;
	tMsgResponse.set_bagtype(tpMsg->bagtype());
	tMsgResponse.set_kitbagindex(tpMsg->kitbagindex());
	tMsgResponse.set_locked(tpMsg->locked());

	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();
	

	if (tpMsg->bagtype() == SLOT_BAGGAGE)
	{
		tpProperty->GetBaggage()->mKitLocked[tpMsg->kitbagindex()] = tpMsg->locked();
	}

	else if (tpMsg->bagtype() == SLOT_STORAGE)
	{
		tpProperty->GetStorage()->mKitLocked[tpMsg->kitbagindex()] = tpMsg->locked();
	}

	else
	{

	}
	tMsg.mutable_msghead()->set_messageid( ID_S2C_NOTIFY_BAGGAGELOCKEN );
	tMsg.set_msgpara( (int)& tMsgResponse );
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsg );
}

void CPropertyModule:: OnMessageQueryAroundPlayerRequest( CEntityPlayer *pPlayer,  CMessage *pMessage )
{
	LK_ASSERT( pPlayer != NULL && pMessage != NULL, return );
	CMessageQueryAroundPlayerRequest *tpMsg =  ( CMessageQueryAroundPlayerRequest * )pMessage->msgpara();
	LK_ASSERT( tpMsg != NULL, return );	

	CMessage tMsg;
	CMessageQueryAroundPlayerResponse tMsgResponse;	 
	tMsg.mutable_msghead()->set_messageid( ID_S2C_QUERY_AROUND_PLAYER );
	tMsg.set_msgpara( (int)& tMsgResponse );

	//if( IS_REPETION_LINE_ID( pPlayer->GetLineID( ) ) == true )
	//{
	//	tMsgResponse.set_inrepetion( 1 );
	//}else{
			
	tMsgResponse.set_queryrange( tpMsg->queryrange());

	int tQueryNum = 0;
	if(tpMsg->queryrange() == 1)
	{		

		CSeenPlayerContainer& rSeenPlayerContainer = pPlayer->GetSeenPlayersContainer();

		CSeenPlayerContainer::SeenPlayerVector::iterator it = rSeenPlayerContainer.mPlayers.begin();

		
		for ( ; it != rSeenPlayerContainer.mPlayers.end() && tQueryNum < QUERY_PLAYER_NUMBER ; ++it)
		{
			CEntityPlayer* pTargetEntity = ( CEntityPlayer* ) CSceneObjManager::GetSingletonPtr()->GetObject( *it );
			if( pTargetEntity != NULL && pTargetEntity->get_id() != pPlayer->get_id() 
				&& pTargetEntity->GetNationality( ) == pPlayer->GetNationality( ))
			{
				AroundPlayer *tpAroundPlayer = tMsgResponse.add_playerdata();
				tpAroundPlayer->set_mapid( pTargetEntity->GetMapID( ) );
				tpAroundPlayer->set_level( pTargetEntity->GetLevel( ) );
				tpAroundPlayer->set_sex( pTargetEntity->GetSex( ) - 1 );
				tpAroundPlayer->set_charname( pTargetEntity->GetCharName( ) );
				int TeamID = CTeamModule::GetSingleton().InTeam( pTargetEntity->GetCharID() );;
				if( TeamID != INVALID_OBJ_ID )
				{
					tpAroundPlayer->set_haveteam( TeamID );
				}
				int tpMemberList[ TEAMNUM ] = { 0 };
				int tRtn = 0, tCount = 0;
				tRtn = CTeamModule::GetSingleton( ).OnGetMemberList( pTargetEntity->GetCharID( ), tpMemberList, ARRAY_CNT( tpMemberList ), tCount );

				if( tRtn < 0 )
				{
					tCount = 1;
				}
				tpAroundPlayer->set_teamnum( tCount );
				tpAroundPlayer->set_metierid( pTargetEntity->GetMetier( ) );
				tpAroundPlayer->set_charid( pTargetEntity->GetCharID( ));
				tpAroundPlayer->set_entityid( pTargetEntity->GetEntityID( ));
				++tQueryNum ;

			}

			continue;

		}
	}else{

	}
	//}else if( tpMsg->queryrange() == 2)
	//{
	//
	//	CMapObject* tpMapObj = pPlayer->GetMapObject( );
	//	LK_ASSERT( tpMapObj != NULL, return );

	//	for( unsigned int i = 0 ; tQueryNum < QUERY_PLAYER_NUMBER && i < tpMapObj->mPlayers.size() ; i++)
	//	{

	//		//	CSeenPlayerContainer::SeenPlayerVector::iterator tpIt = find( rSeenPlayerContainer.mPlayers.begin(), rSeenPlayerContainer.mPlayers.end(),tpMapObj->mPlayers[ i ]);


	//		CEntityPlayer* pMapTargetEntity = ( CEntityPlayer* ) CSceneObjManager::GetSingletonPtr()->GetObject( tpMapObj->mPlayers[ i ] );
	//		if( pMapTargetEntity != NULL && pMapTargetEntity->get_id() != pPlayer->get_id() 
	//			&&pMapTargetEntity->GetNationality( ) == pPlayer->GetNationality( ))
	//		{
	//			AroundPlayer *tpAroundPlayer = tMsgResponse.add_playerdata();
	//			tpAroundPlayer->set_mapid( pMapTargetEntity->GetMapID( ) );
	//			tpAroundPlayer->set_level( pMapTargetEntity->GetLevel( ) );
	//			tpAroundPlayer->set_sex( pMapTargetEntity->GetSex( ) - 1);
	//			tpAroundPlayer->set_charname( pMapTargetEntity->GetCharName( ) );
	//			int TeamID = CTeamModule::GetSingleton().InTeam( pMapTargetEntity->GetCharID() );
	//			if( TeamID != INVALID_OBJ_ID )
	//			{
	//				tpAroundPlayer->set_haveteam( TeamID );
	//			}
	//			int tpMemberList[ TEAMNUM ] = { 0 };
	//			int tRtn = 0, tCount = 0;
	//			tRtn = CTeamModule::GetSingleton( ).OnGetMemberList( pMapTargetEntity->GetCharID( ), tpMemberList, ARRAY_CNT( tpMemberList ), tCount );

	//			if( tRtn < 0 )
	//			{
	//				tCount = 1;
	//			}
	//			tpAroundPlayer->set_teamnum( tCount );
	//			tpAroundPlayer->set_metierid( pMapTargetEntity->GetMetier( ) );
	//			tpAroundPlayer->set_charid( pMapTargetEntity->GetCharID( ));
	//			tpAroundPlayer->set_entityid( pMapTargetEntity->GetEntityID( ));
	//			tQueryNum++;
	//		}

	//	}
	//}

	LOG_NOTICE( "pro", "[ %s : %d ] [ %s ], query player num is %d", __LK_FILE__, __LINE__, __FUNCTION__, tQueryNum );

	
	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tMsg );

}


// 增加玩家包裹的使用时间
// int nSlotType种类,  int nIndex位置, int nIndexNum 各自生活,int nAddTime 加上的时间
bool CPropertyModule::AddBagInvalidTime( CEntityPlayer *pPlayer, int nSlotType, int nIndex, int nIndexNum,int nAddTime )
{
	LK_ASSERT( pPlayer != NULL , return false)			
	CPropertyPlayer *tpProperty = ( CPropertyPlayer * )pPlayer->GetProperty();


	CItemObject *tpKitbag = NULL;
	if(	nSlotType == SLOT_BAGGAGE )
	{
		tpKitbag = tpProperty->GetBaggage()->GetItemObjPtr( nIndex );	

	}else if( nSlotType == SLOT_STORAGE )
	{	
		tpKitbag = tpProperty->GetStorage()->GetItemObjPtr( nIndex ); 

	}else if( nSlotType == SLOT_BAGGAGEKITBAG )
	{
		tpKitbag = tpProperty->GetBaggage()->GetKitBagItemByIndex( nIndex );

	}else if( nSlotType == SLOT_STORKITBAG )
	{
		tpKitbag = tpProperty->GetStorage()->GetKitBagItemByIndex( nIndex );
	}

	if ( tpKitbag == NULL )
	{
		return false;
	}

	CTplItem *tpTplItem = ( CTplItem * )CDataStatic::SearchTpl( tpKitbag->GetItemID() );
	LK_ASSERT( tpTplItem != NULL, return false )
	if( tpTplItem->mItemType != CTplItem::ITEM_KITBAG ) return false;
	if ( tpKitbag->GetInvalidTime() == 0 )//如果是永久包裹
	{
		return false;
	}

	CTplKitBag *tpTplKibag = ( CTplKitBag * )tpTplItem;
	if ( tpTplKibag->mIndexNum != nIndexNum )
	{
		return false;
	}
	
	if( tpKitbag->GetInvalidTime() <= ( unsigned int)time(NULL) ){
		tpKitbag->SetInvalidTime( time(NULL) + nAddTime );
	}else{
		tpKitbag->SetInvalidTime( tpKitbag->GetInvalidTime() + nAddTime );
	}
	return true;
}


// 添加vip时间 , 暂时功能付费使用

bool CPropertyModule::AddVIPTime( CEntity *pEntity, int tAddTime )
{
	if ( pEntity == NULL || tAddTime <= 0 )
	{
		return false;
	}

	CEntityPlayer*		tpPlayer = ( CEntityPlayer* ) pEntity;
	CPropertyPlayer*	tpProperty = ( CPropertyPlayer* ) tpPlayer->GetProperty();


	// 会员到期日期
	// 如果已经是会员，续费续时
	int tTime = 0;
	if ( tpProperty->IsVip() )
	{
		tTime = tpProperty->GetVipTime() +  tAddTime;
	}
	else
	{
		tTime = time(NULL) +  tAddTime;
	}

	tpProperty->OpenVip( tTime );
	SendVipFlagUpdateToGate( tpPlayer );

	// 可见范围通知，玩家开通会员功能
	SendVipNotice( tpPlayer, true );

	return true;	 
}

void CPropertyModule::LoadClientCtrlConfigCallback(const char *pcConfigPath)
{
	CPropertyModule::GetSingleton().mClientCtrlData.LoadFromXml(pcConfigPath);
}

void CPropertyModule::ChangeCombatFame( CEntityPlayer *pPlayer, int vDeltaFame )
{
	if ( pPlayer == NULL || vDeltaFame == 0 )
		return;
	CPropertyPlayer *tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	int tDelta = 0;
	if ( vDeltaFame > 0 )
	{
		tDelta = tpProperty->mWizard.AddCombatFame( vDeltaFame );
		LogEventGetMoneyByCombatFame( pPlayer, tDelta );
	}
	else
	{		
		tDelta = tpProperty->mWizard.DelCombatFame( -1 * vDeltaFame );
		LogEventLostMoneyByCombatFame( pPlayer, tDelta );
	}
	SendSyncFameNotify( pPlayer, tDelta, 0, 0 );
}

void CPropertyModule::ChangeRepeFame( CEntityPlayer *pPlayer, int vDeltaFame )
{
	if ( pPlayer == NULL || vDeltaFame == 0 )
		return;
	CPropertyPlayer *tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	int tDelta = 0;
	if ( vDeltaFame > 0 )
	{
		tDelta = tpProperty->mWizard.AddRepeFame( vDeltaFame );
		LogEventGetMoneyByRepeFame( pPlayer, tDelta );
	}
	else
	{
		tDelta = tpProperty->mWizard.DelRepeFame( -1 * vDeltaFame );
		LogEventLostMoneyByRepeFame( pPlayer, tDelta );
	}
	SendSyncFameNotify( pPlayer, 0, tDelta, 0 );
}

void CPropertyModule::ChangeCommonFame( CEntityPlayer *pPlayer, int vDeltaFame )
{
	if ( pPlayer == NULL || vDeltaFame == 0 )
		return;
	CPropertyPlayer *tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	int tDelta = 0;
	if ( vDeltaFame > 0 )
	{
		tDelta = tpProperty->mWizard.AddCommonFame( vDeltaFame );
		LogEventGetMoneyByCommonFame( pPlayer, tDelta );
	}
	else
	{
		tDelta = tpProperty->mWizard.DelCommonFame( -1 * vDeltaFame );
		LogEventLostMoneyByCommonFame( pPlayer, tDelta );
	}
	SendSyncFameNotify( pPlayer, 0, 0, tDelta );
}

void CPropertyModule::SendSyncFameNotify( CEntityPlayer *pPlayer, int vCombatDelta, int vRepeDelta, int vCommonDelta )
{
	if ( pPlayer == NULL )
		return;
	CPropertyPlayer *tpProperty = (CPropertyPlayer*) pPlayer->GetProperty();

	CMessage tTotalMessage;
	CMessageHead* tpHead = NULL;
	tpHead = tTotalMessage.mutable_msghead();
	if ( tpHead == NULL )
	{
		return;
	}

	tpHead->set_messageid( ID_S2C_NOTIFY_SYNCFAME );

	CMessageSyncFameNotify tMessage;
	tMessage.set_combatfame( tpProperty->mWizard.GetCombatFame() );
	tMessage.set_repefame( tpProperty->mWizard.GetRepeFame() );
	tMessage.set_commonfame( tpProperty->mWizard.GetCommonFame() );
	tMessage.set_combatdelta( vCombatDelta );
	tMessage.set_repedelta( vRepeDelta );
	tMessage.set_commondelta( vCommonDelta );
	tMessage.set_combattoday( tpProperty->mWizard.GetCombatToday() );
	tMessage.set_repetoday( tpProperty->mWizard.GetRepeToday() );
	tMessage.set_commontoday( tpProperty->mWizard.GetCommonToday() );

	tTotalMessage.set_msgpara( (long)&tMessage );

	CSceneLogic::GetSingleton().Send2Player( pPlayer, &tTotalMessage );
}

void CPropertyModule::OnMessageSpiritOpenRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	if (pPlayer == NULL || pMessage == NULL)
	{
		return;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}

	// 安全密码检查
	int nPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if (nPwdCheckRet != SUCCESS)
	{
		SendProErrorNotice(pPlayer, nPwdCheckRet);
		return;
	}	

	CMessageSpiritOpenRequest* pMsg = (CMessageSpiritOpenRequest*)pMessage->msgpara();
	if (pMsg == NULL)
	{
		return;
	}

	int nPositionIndex = pMsg->positionindex();
	int nTypeIndex = pMsg->spirittype();
	int nSlotIndex = pMsg->slotindex();
	CSpiritInfo& rSpiritInfo = pProperty->GetSpiritInfo();
	int nResult = SUCCESS;

	CTplCastingSpiritTable* pCastingSpiritTable = (CTplCastingSpiritTable*)CDataStatic::GetTemp(TEMP_CASTING_SPIRIT_TABLE);
	if (pCastingSpiritTable == NULL)
	{
		return;
	}

	if (nPositionIndex < 0 || nPositionIndex >= MAX_CASTINGSPIRIT_POSITION)
	{
		return;
	}

	if (pCastingSpiritTable->m_anIsOpen[nPositionIndex] == 0)
	{
		return;
	}

	int nOpenStatus = rSpiritInfo.GetSlotOpenStatus(nPositionIndex, nTypeIndex, nSlotIndex);
	if (nOpenStatus == 1)
	{
		SendProErrorNotice(pPlayer, SPIRIT_OPEN_SLOT_ALREADY_OPEN);
		return;
	}

	// 前置孔开启状态检查
	if (nSlotIndex > 0)
	{
		int nPreSlotIndex = nSlotIndex - 1;
		nOpenStatus = rSpiritInfo.GetSlotOpenStatus(nPositionIndex, nTypeIndex, nPreSlotIndex);
		if (nOpenStatus != 1)
		{
			SendProErrorNotice(pPlayer, SPIRIT_OPEN_PRESLOT_NOTOPEN);
			return;
		}
	}

	if (nSlotIndex < 0 || nSlotIndex > MAX_CASTINGSPIRIT_SLOT)
	{
		return;
	}

	// 启灵道具检查
	int nItemID = pCastingSpiritTable->m_anSpiritItem[nSlotIndex];
	int nItemNum = pCastingSpiritTable->m_anSpiritItemNum[nSlotIndex];
	
	int nNumCheckResult = 0;
	HasItem(pPlayer->GetEntityID(), nItemID, nItemNum, nNumCheckResult, 0);
	if (nNumCheckResult != 1)
	{
		SendProErrorNotice(pPlayer, SPIRIT_OPEN_LACK_ITEM);
		return;
	}

	// 开孔操作
	bool bBind = false;
	uint64_t ullGUID = 0;
	// 先消耗绑定物品
	int nUsedNum = nItemNum - PlayerRemoveItemByID(pPlayer, nItemID, nItemNum, bBind, &ullGUID, BIND_YES);
	if (nUsedNum > 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID, nItemID, nUsedNum);
	}
	
	// 再消耗非绑定物品
	if (nItemNum > nUsedNum)
	{
		int nUnbindedNum = nItemNum - nUsedNum;
		if (PlayerRemoveItemByID(pPlayer, nItemID, nUnbindedNum, bBind, &ullGUID, BIND_NO) == 0)
		{
			LogEventLostItemByUse(pPlayer, ullGUID, nItemID, nUnbindedNum);
		}
	}
	rSpiritInfo.SetSlotOpenStatus(nPositionIndex, nTypeIndex, nSlotIndex, 1);
	// 记录铸灵信息
	int nTotalGrade = rSpiritInfo.GetScore();
	int nOpenedSlotCount = 0;
	int nCastedSlotCount = 0;
	rSpiritInfo.GetSlotInfo(nOpenedSlotCount, nCastedSlotCount);
	LogEventSpiritInfo(pPlayer, nItemID, ullGUID, nTotalGrade, nCastedSlotCount, nOpenedSlotCount);

	CMessage Msg;
	CMessageSpiritOpenResponse MsgPara;
	CMessageHead* pMsgHead = Msg.mutable_msghead();
	if (pMsgHead == NULL)
	{
		return;
	}

	pMsgHead->set_messageid(ID_S2C_RESPONSE_SPIRIT_OPEN);
	MsgPara.set_result(nResult);
	Msg.set_msgpara((uint32)&MsgPara);
	CSceneLogic::GetSingleton().Send2Player(pPlayer, &Msg);
	if (nResult == SUCCESS)
	{
		SendSpiritInfo(pPlayer);
	}
}

void CPropertyModule::OnMessageSpiritCastingRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	if (pPlayer == NULL || pMessage == NULL)
	{
		return;
	}

	CMessageSpiritCastingRequest* pMsg = (CMessageSpiritCastingRequest*)pMessage->msgpara();
	if (pMsg == NULL)
	{
		return;
	}

	// 安全密码检查
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}

	int nPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if (nPwdCheckRet != SUCCESS)
	{
		SendProErrorNotice(pPlayer, nPwdCheckRet);
		return;
	}	

	CMessage Msg;
	CMessageSpiritCastingResponse MsgPara;
	CMessageHead* pMsgHead = Msg.mutable_msghead();
	if (pMsgHead == NULL)
	{
		return;
	}

	int nPositionIndex = pMsg->positionindex();
	int nTypeIndex = pMsg->spirittype();
	
	int nResult = SPIRIT_CASTING_ERROR;
	int nSize = pMsg->itemindex_size();
	int nSlotSize = pMsg->slotindex_size();
	for (int i = 0; i < nSize && i < nSlotSize; i++)
	{
		int	nItemIndex = pMsg->itemindex(i);
		int	nSlotIndex = pMsg->slotindex(i);
		int nRet = PlayerSpiritCasting(pPlayer, nPositionIndex, nTypeIndex, nSlotIndex, nItemIndex);
		if (nRet == SUCCESS)
		{
			nResult = SUCCESS;
			MsgPara.add_itemindex(nItemIndex);
		}
	}

	pMsgHead->set_messageid(ID_S2C_RESPONSE_SPIRIT_CASTING);
	MsgPara.set_result(nResult);	
	Msg.set_msgpara((uint32)&MsgPara);
	CSceneLogic::GetSingleton().Send2Player(pPlayer, &Msg);
	if (nResult == SUCCESS)
	{
		SendSpiritInfo(pPlayer);
		// 刷新属性
		pProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
	}
}

void CPropertyModule::OnMessageSpiritUpgradeRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	if (pPlayer == NULL)
	{
		return;
	}

	if (pMessage == NULL)
	{
		return;
	}

	// 安全密码检查
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}

	int nPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if (nPwdCheckRet != SUCCESS)
	{
		SendProErrorNotice(pPlayer, nPwdCheckRet);
		return;
	}

	CMessageSpiritUpgradeRequest* pMsgPara = (CMessageSpiritUpgradeRequest*)pMessage->msgpara();
	if (pMsgPara == NULL)
	{
		return;
	}

	int anSpiritItemIndex[MAX_SPIRITUPGRADE_ITEMNUM];
	int nUpgradeItemIndex = -1;
	nUpgradeItemIndex = pMsgPara->upgradeitemindex();
	int nSize = pMsgPara->spirititemindex_size();
	// 初始化索引为-1；
	for (int i = 0; i < ARRAY_CNT(anSpiritItemIndex); i++)
	{
		anSpiritItemIndex[i] = -1;
	}

	for (int i = 0; i < nSize && i < ARRAY_CNT(anSpiritItemIndex); i++)
	{
		anSpiritItemIndex[i] = pMsgPara->spirititemindex(i);
	}

	int nResult = PlayerSpiritUpgrade(pPlayer, anSpiritItemIndex, nUpgradeItemIndex);
	CMessage Msg;
	CMessageSpiritUpgradeResponse MsgPara;
	CMessageHead* pMsgHead = Msg.mutable_msghead();
	if (pMsgHead == NULL)
	{
		return;
	}

	pMsgHead->set_messageid(ID_S2C_RESPONSE_SPIRIT_UPGRADE);
	MsgPara.set_result(nResult);
	Msg.set_msgpara((uint32)&MsgPara);
	CSceneLogic::GetSingleton().Send2Player(pPlayer, &Msg);
}

int CPropertyModule::PlayerSpiritUpgrade(CEntityPlayer *pPlayer, int *apnSpiritIndex, int nUpgradeItemIndex)
{
	if (pPlayer == NULL)
	{
		return SPIRIT_UPGRADE_ERROR;
	}

	CItemObject *apItemObject[MAX_SPIRITUPGRADE_ITEMNUM] = { NULL };
	CTplItem *apItem[MAX_SPIRITUPGRADE_ITEMNUM] = { NULL };

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	bool bBind = false;
	int nSpiritNum = 0;
	
	// 决定产出结果的索引，默认第一个，如果有绑定的则取绑定的
	
	CTplSpiritItem*  pStandardItem = NULL;
	for ( int i = 0; i < MAX_SPIRITUPGRADE_ITEMNUM; i++ )
	{
		if ( apnSpiritIndex[ i ] == -1 )
		{
			continue;
		}

		apItemObject[ i ] = pProperty->GetBaggage( )->GetItemObjPtr( apnSpiritIndex[ i ] );
		if ( apItemObject[ i ] == NULL )
		{
			continue;
		}

		apItem[ i ] = (CTplItem*)CDataStatic::SearchTpl( apItemObject[ i ]->GetItemID() );
		if ( apItem[ i ] == NULL )
		{
			continue;
		}

		unsigned int unItemID = apItemObject[ i ]->GetItemID();
		// 取到聚灵的标准道具，以它为准
		if (pStandardItem == NULL)
		{
			pStandardItem = (CTplSpiritItem*)CDataStatic::SearchTpl(unItemID);
		}	
	}
	if (pStandardItem == NULL)
	{
		return SPIRIT_UPGRADE_LACK_ITEM;
	}		

	for ( int i = 0; i < MAX_SPIRITUPGRADE_ITEMNUM; i++ )
	{
		if ( apnSpiritIndex[ i ] == -1 )
			continue;
		
		if ( apItemObject[ i ] == NULL )
		{
			return SPIRIT_UPGRADE_LACK_ITEM;
		}

		if ( apItem[ i ] == NULL )
		{
			return SPIRIT_UPGRADE_LACK_ITEM;
		}	

		if ( apItem[ i ]->mItemType != CTplItem::ITEM_SPIRIT_CASTING)
		{
			return SPIRIT_UPGRADE_LACK_ITEM;
		}

		CTplSpiritItem* pTplSpiritItem = (CTplSpiritItem*)apItem[ i ];
	
		if (pTplSpiritItem->mCommonID != pStandardItem->mCommonID)
		{
			return SPIRIT_UPGRADE_LACK_ITEM;
		}

		if ( ( apItemObject[ i ]->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
		{
			bBind = true;
		}	

		for ( int j = 0; j < i; j++ )
		{
			if ( apnSpiritIndex[ j ] == apnSpiritIndex[ i ] )
			{
				return SPIRIT_UPGRADE_LACK_ITEM;
			}
		}		

		nSpiritNum += apItemObject[ i ]->GetItemNum();

		if (nSpiritNum >= MAX_SPIRITUPGRADE_ITEMNUM)
		{
			nSpiritNum = MAX_SPIRITUPGRADE_ITEMNUM;
			break;
		}
	}

	// 判断真灵总数是否足够
	if (nSpiritNum < MAX_SPIRITUPGRADE_ITEMNUM)
	{
		return SPIRIT_UPGRADE_LACK_ITEM;
	}

	int nNewGrade = 0;
	int nOldGrade = pStandardItem->m_nGrade - 1;
	nNewGrade = nOldGrade + 1;

	if (nNewGrade < 1 || nNewGrade >= MAX_SPIRITITEM_GRADE)
	{
		return SPIRIT_UPGARDE_GRADE_ERROR;
	}

	CTemplateCompose *tpCompose = (CTemplateCompose*)CDataStatic::SearchTpl(pStandardItem->mCompID);
	if ( tpCompose == NULL )
	{
		return SPIRIT_UPGRADE_ERROR;
	}

	CTplCastingSpiritTable* pSpiritCastingTable = (CTplCastingSpiritTable*)CDataStatic::GetTemp(TEMP_CASTING_SPIRIT_TABLE);
	if (pSpiritCastingTable == NULL)
	{
		return SPIRIT_UPGRADE_ERROR;
	}

	unsigned int unUpgradeMoney = (unsigned int)pSpiritCastingTable->m_anUpgradeMoney[nNewGrade];
	unsigned int unBaggageMoney = ( unsigned int )pProperty->GetMoney();
	if ( unBaggageMoney < unUpgradeMoney)
	{
		return SPIRIT_UPGARDE_LACK_MONEY;
	}

	int nComID = tpCompose->mItemID;
	int nComNum = tpCompose->mItemNum;

	CItemObject* pUpgradeItemObj = pProperty->GetBaggage( )->GetItemObjPtr(nUpgradeItemIndex);
	if (pUpgradeItemObj == NULL)
	{
		return SPIRIT_UPGARDE_LACK_UPGARDEIEM;
	}

	int nUpgradeItemID = pUpgradeItemObj->GetItemID();
	bool bHasItem = HasItemOnIndex(pPlayer->GetEntityID(), nUpgradeItemIndex, pSpiritCastingTable->m_nUpgradeItem, 1);
	if (!bHasItem)
	{
		return SPIRIT_UPGARDE_LACK_UPGARDEIEM;
	}

	if (!pProperty->GetBaggage()->Space(-1, nComNum))
	{
		return ERROR_INSERTITEM_NOSPACE;
	}

	if ( ( pUpgradeItemObj->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
	{
		bBind = true;
	}

	uint64_t ullGUID = pUpgradeItemObj->GetGUID();
	if ( PlayerRemoveItem( pPlayer, nUpgradeItemIndex, 1) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID, nUpgradeItemID, 1);
	}

	int nRemoveCount = 0;
	int nItemID = 0;
	for ( int i = 0; i < MAX_SPIRITUPGRADE_ITEMNUM; i++ )
	{
		if ( apItem[ i ] == NULL )
			continue; 

		ullGUID = apItemObject[i]->GetGUID();
		nItemID = apItemObject[ i ]->GetItemID();
		int nRemoveNum = 0;
		// 还没达到上限，就全扣掉
		if ( (int)apItemObject[ i ]->GetItemNum() + nRemoveCount <= nSpiritNum )
		{
			nRemoveNum = apItemObject[ i ]->GetItemNum();
		}
		else
		{
			nRemoveNum = nSpiritNum - nRemoveCount;
		}
		if ( PlayerRemoveItem( pPlayer, apnSpiritIndex[ i ], nRemoveNum ) == 0)
		{
			LogEventLostItemByCompose(pPlayer, ullGUID, nItemID, nRemoveNum, 0, 0, 0);
		}
		nRemoveCount += nRemoveNum;
		if ( nRemoveCount >= nSpiritNum )
			break;
	}

	if (PlayerChangeMoney( pPlayer, unUpgradeMoney, true, false ) != SUCCESS)
	{
		return SPIRIT_UPGARDE_LACK_MONEY;
	}

	CItemObject *pInsItemPile = PlayerInsertItem( pPlayer, nComID, nComNum, false, 0, NULL, bBind );
	if ( pInsItemPile == NULL)
	{
		return SPIRIT_UPGARDE_INSERTNEW_ERROR;	
	}
	else
	{
		LogEventGetItemByCompose(pPlayer, pInsItemPile->GetGUID(), nComID, nComNum, nItemID, nSpiritNum);
		LogEventLostMoneyBySpiritUpgrade(pPlayer, CYuanBao::em_unbind_money, unUpgradeMoney,
			pInsItemPile->GetItemID(), pInsItemPile->GetGUID());
	}	

	return SUCCESS;
}

void CPropertyModule::OnMessageSpiritDowngradeRequest(CEntityPlayer *pPlayer, CMessage *pMessage)
{
	if (pPlayer == NULL)
	{
		return;
	}

	if (pMessage == NULL)
	{
		return;
	}

	CMessageSpiritDowngradeRequest* pMsgPara = (CMessageSpiritDowngradeRequest*)pMessage->msgpara();
	if (pMsgPara == NULL)
	{
		return;
	}

	// 安全密码检查
	CPropertyPlayer* pProperty = (CPropertyPlayer*)pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}

	int nPwdCheckRet = pProperty->GetRolePassword()->CheckActionAllowed( EM_PASSWORD_ACTION_GAMEACTION );
	if (nPwdCheckRet != SUCCESS)
	{
		SendProErrorNotice(pPlayer, nPwdCheckRet);
		return;
	}

	int nPosition = pMsgPara->positionindex();
	int nType = pMsgPara->spirittype();
	int nSlot = pMsgPara->slotindex();
	int nItemIndex = pMsgPara->downgradeitemindex();
	int nResult = PlayerSpiritDowngrade(pPlayer, nPosition, nType, nSlot, nItemIndex);

	CMessage Msg;
	CMessageSpiritDowngradeResponse MsgPara;
	CMessageHead* pMsgHead = Msg.mutable_msghead();
	if (pMsgHead == NULL)
	{
		return;
	}

	MsgPara.set_result(nResult);
	pMsgHead->set_messageid(ID_S2C_RESPONSE_SPIRIT_DOWNGRADE);
	Msg.set_msgpara((uint32)&MsgPara);
	CSceneLogic::GetSingleton().Send2Player(pPlayer, &Msg);
	if (nResult == SUCCESS)
	{
		SendSpiritInfo(pPlayer);
		// 刷新属性
		pProperty->Refresh( );
		pPlayer->NotifyPropertyRefresh( );
	}
}

int CPropertyModule::PlayerSpiritDowngrade(CEntityPlayer *pPlayer, int nPosition, int nType, int nSlot, int nItemIndex)
{
	if (pPlayer == NULL)
	{
		return SPIRIT_DOWNGRADE_ERROR;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return SPIRIT_DOWNGRADE_ERROR;
	}

	CSpiritInfo& rSpiritInfo = pProperty->GetSpiritInfo();
	int nSpiritItem = rSpiritInfo.GetCastingItemID(nPosition, nType, nSlot);
	if (nSpiritItem <= 0)
	{
		return SPIRIT_DOWNGRADE_ERROR;
	}
	
	CItemObject* pDowngradeItem = pProperty->GetBaggage( )->GetItemObjPtr(nItemIndex);
	if (pDowngradeItem == NULL)
	{
		return SPIRIT_DOWNGARDE_LACK_DOWNGARDEIEM;
	}

	if (!pProperty->GetBaggage()->Space(-1, 1))
	{
		return ERROR_INSERTITEM_NOSPACE;
	}

	bool bBind = false;
	CTplCastingSpiritTable* pSpiritCastingTable = (CTplCastingSpiritTable*)CDataStatic::GetTemp(TEMP_CASTING_SPIRIT_TABLE);
	if (pSpiritCastingTable == NULL)
	{
		return SPIRIT_DOWNGRADE_ERROR;
	}

	CTplSpiritItem* pSpiritItem = (CTplSpiritItem*)CDataStatic::SearchTpl(nSpiritItem);
	if (pSpiritItem == NULL)
	{
		return SPIRIT_DOWNGRADE_ERROR;
	}

	int nGradeIndex = pSpiritItem->m_nGrade - 1;
	if (nGradeIndex < 0 || nGradeIndex >= MAX_SPIRITITEM_GRADE)
	{
		return SPIRIT_DOWNGRADE_ERROR;
	}

	unsigned int unDowngradeMoney = (unsigned int)pSpiritCastingTable->m_anDowngradeMoney[nGradeIndex];
	unsigned int unBaggageMoney = ( unsigned int )pProperty->GetMoney();
	if ( unBaggageMoney < unDowngradeMoney)
	{
		return SPIRIT_DOWNGARDE_LACK_MONEY;
	}

	// 判断是否是退灵珠
	int nDowngradeItemID = pDowngradeItem->GetItemID();
	bool bHasItem = HasItemOnIndex(pPlayer->GetEntityID(), nItemIndex, pSpiritCastingTable->m_nDowngradeItem, 1);
	if (!bHasItem)
	{
		return SPIRIT_DOWNGARDE_LACK_DOWNGARDEIEM;
	}

	if ( ( pDowngradeItem->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
	{
		bBind = true;
	}

	if (rSpiritInfo.GetBindStatus(nPosition, nType, nSlot) == 1)
	{
		bBind = true;
	}

	if (PlayerChangeMoney( pPlayer, unDowngradeMoney, true, false ) == SUCCESS)
	{
		LogEventLostMoneyBySpiritDowngrade(pPlayer, CYuanBao::em_unbind_money, unDowngradeMoney, nPosition, nType, nSlot);
	}
	else
	{
		return SPIRIT_UPGARDE_LACK_MONEY;
	}

	// 退灵操作
	rSpiritInfo.SetCastingItemID(nPosition, nType, nSlot, 0);
	rSpiritInfo.SetBindStatus(nPosition, nType, nSlot, 0);
	uint64_t ullGUID = pDowngradeItem->GetGUID();
	int nItemID = pDowngradeItem->GetItemID();
	if (PlayerRemoveItem(pPlayer, nItemIndex, 1) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);
	}

	// 退回灵珠
	CItemObject *pInsItemPile = PlayerInsertItem( pPlayer, nSpiritItem, 1, false, 0, NULL, bBind );
	if ( pInsItemPile == NULL)
	{
		return SPIRIT_DOWNGARDE_INSERTNEW_ERROR;	
	}
	else
	{
		LogEventGetItemBySpiritDowngrade(pPlayer, pInsItemPile->GetGUID(), nSpiritItem, 1, nPosition, nType, nSlot);
	}

	// 记录铸灵信息
	int nTotalGrade = rSpiritInfo.GetScore();
	int nOpenedSlotCount = 0;
	int nCastedSlotCount = 0;
	rSpiritInfo.GetSlotInfo(nOpenedSlotCount, nCastedSlotCount);
	LogEventSpiritInfo(pPlayer, nItemID, ullGUID, nTotalGrade, nCastedSlotCount, nOpenedSlotCount);

	return SUCCESS;
}

void CPropertyModule::OnMessageSpiritInfoRequest(CEntityPlayer* pPlayer, CMessage *pMessage)
{
	SendSpiritInfo(pPlayer);
}

void CPropertyModule::SendSpiritInfo(CEntityPlayer* pPlayer)
{
	if (pPlayer == NULL)
	{
		return;
	}

	CMessage Msg;
	CMessageSpiritInfoNotify MsgPara;
	CMessageHead* pMsgHead = Msg.mutable_msghead();
	if (pMsgHead == NULL)
	{
		return;
	}

	pMsgHead->set_messageid(ID_S2C_NOTIFY_SPIRIT_INFO);
	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return;
	}

	CSpiritInfo& rSpiritInfo = pProperty->GetSpiritInfo();
	for (int i = 0; i < MAX_CASTINGSPIRIT_TYPE; i++)
	{
		int nPoint = rSpiritInfo.GetEffectValue(i);
		MsgPara.add_point(nPoint);
	}
	int nScore = rSpiritInfo.GetScore();
	MsgPara.set_score(nScore);
	rSpiritInfo.CreateTlvPB(*MsgPara.mutable_spiritinfo());
	Msg.set_msgpara((uint32)&MsgPara);
	CSceneLogic::GetSingleton().Send2Player(pPlayer, &Msg);
}

int CPropertyModule::PlayerSpiritCasting(CEntityPlayer *pPlayer, int nPositionIndex, int nTypeIndex, int nSlotIndex, int nItemIndex)
{
	if (pPlayer == NULL)
	{
		return SPIRIT_CASTING_ERROR;
	}

	CPropertyPlayer* pProperty = (CPropertyPlayer*) pPlayer->GetProperty();
	if (pProperty == NULL)
	{
		return SPIRIT_CASTING_ERROR;
	}

	CSpiritInfo& rSpiritInfo = pProperty->GetSpiritInfo();
	CTplCastingSpiritTable* pCastingSpiritTable = (CTplCastingSpiritTable*)CDataStatic::GetTemp(TEMP_CASTING_SPIRIT_TABLE);
	if (pCastingSpiritTable == NULL)
	{
		return SPIRIT_CASTING_ERROR;
	}

	int nOpenStatus = rSpiritInfo.GetSlotOpenStatus(nPositionIndex, nTypeIndex, nSlotIndex);
	if (nOpenStatus == 0)
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_SLOT_NOTOPEN);
		return SPIRIT_CASTING_SLOT_NOTOPEN;
	}

	int nSpiritItem = rSpiritInfo.GetCastingItemID(nPositionIndex, nTypeIndex, nSlotIndex);
	if (nSpiritItem != 0)
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_ALREADY);
		return SPIRIT_CASTING_ALREADY;
	}

	CItemObject* pItemObject = (CItemObject*)pProperty->GetBaggage( )->GetItemObjPtr(nItemIndex);
	if (pItemObject == NULL || pItemObject->GetItemNum() < 1)
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_LACK_ITEM);
		return SPIRIT_CASTING_LACK_ITEM;
	}

	int nItemID = pItemObject->GetItemID();
	CTplItem* pTplItem = (CTplItem*)CDataStatic::SearchTpl(nItemID);
	if (pTplItem->mItemType != CTplItem::ITEM_SPIRIT_CASTING)
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_LACK_ITEM);
		return SPIRIT_CASTING_LACK_ITEM;
	}

	CTplSpiritItem* pSpiritItem = (CTplSpiritItem*)pTplItem;
	if (pSpiritItem == NULL)
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_LACK_ITEM);
		return SPIRIT_CASTING_LACK_ITEM;
	}

	if (pSpiritItem->m_nSpiritType != nTypeIndex)
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_TYPE_ERROR);
		return SPIRIT_CASTING_TYPE_ERROR;	
	}

	if (pSpiritItem->m_nLevelLimit > pPlayer->GetLevel())
	{
		SendProErrorNotice(pPlayer, SPIRIT_CASTING_PLAYER_LEVEL_LOW);
		return SPIRIT_CASTING_PLAYER_LEVEL_LOW;	
	}

	uint64_t ullGUID = 0;
	if (PlayerRemoveItem(pPlayer, nItemIndex, 1, &ullGUID) == 0)
	{
		LogEventLostItemByUse(pPlayer, ullGUID, nItemID, 1);
	}
	// 记录铸灵用的灵珠、绑定状态
	rSpiritInfo.SetCastingItemID(nPositionIndex, nTypeIndex, nSlotIndex, nItemID);
	if ( ( pItemObject->GetBindStatus( ) & ITEM_BINDSTATUS_BINDED ) == ITEM_BINDSTATUS_BINDED )
	{
		rSpiritInfo.SetBindStatus(nPositionIndex, nTypeIndex, nSlotIndex, 1);
	}
	else
	{
		rSpiritInfo.SetBindStatus(nPositionIndex, nTypeIndex, nSlotIndex, 0);
	}
	
	// 记录铸灵信息
	int nTotalGrade = rSpiritInfo.GetScore();
	int nOpenedSlotCount = 0;
	int nCastedSlotCount = 0;
	rSpiritInfo.GetSlotInfo(nOpenedSlotCount, nCastedSlotCount);
	LogEventSpiritInfo(pPlayer, nItemID, ullGUID, nTotalGrade, nCastedSlotCount, nOpenedSlotCount);

	return SUCCESS;
}